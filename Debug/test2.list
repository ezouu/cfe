
test2.elf:     file format elf32-littlearm

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .isr_vector   00000010  20000000  20000000  00001000  2**0
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  1 .text         0000444c  20000010  20000010  00001010  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  2 .init         00000004  2000445c  2000445c  0000545c  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  3 .fini         00000004  20004460  20004460  00005460  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  4 .rodata       00000600  20004464  20004464  00005464  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  5 .ARM.exidx    00000008  20004a64  20004a64  00005a64  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  6 .data         00000040  20004a6c  20004a6c  00005a6c  2**2
                  CONTENTS, ALLOC, LOAD, DATA
  7 .bss          00000270  20004ab0  20004ab0  00005aac  2**3
                  ALLOC
  8 ._user_heap_stack 00000600  20004d20  20004d20  00005aac  2**0
                  ALLOC
  9 .ARM.attributes 00000030  00000000  00000000  00005aac  2**0
                  CONTENTS, READONLY
 10 .comment      00000043  00000000  00000000  00005adc  2**0
                  CONTENTS, READONLY
 11 .debug_line   00005b90  00000000  00000000  00005b1f  2**0
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 12 .debug_line_str 00000051  00000000  00000000  0000b6af  2**0
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 13 .debug_info   00006852  00000000  00000000  0000b700  2**0
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 14 .debug_abbrev 00001fee  00000000  00000000  00011f52  2**0
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 15 .debug_aranges 00000788  00000000  00000000  00013f40  2**3
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 16 .debug_str    0000855a  00000000  00000000  000146c8  2**0
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 17 .debug_rnglists 00000581  00000000  00000000  0001cc22  2**0
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 18 .debug_macro  0000195f  00000000  00000000  0001d1a3  2**0
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 19 .debug_frame  00001cc8  00000000  00000000  0001eb04  2**2
                  CONTENTS, READONLY, DEBUGGING, OCTETS

Disassembly of section .text:

20000010 <__aeabi_uldivmod>:
20000010:	b953      	cbnz	r3, 20000028 <__aeabi_uldivmod+0x18>
20000012:	b94a      	cbnz	r2, 20000028 <__aeabi_uldivmod+0x18>
20000014:	2900      	cmp	r1, #0
20000016:	bf08      	it	eq
20000018:	2800      	cmpeq	r0, #0
2000001a:	bf1c      	itt	ne
2000001c:	f04f 31ff 	movne.w	r1, #4294967295	@ 0xffffffff
20000020:	f04f 30ff 	movne.w	r0, #4294967295	@ 0xffffffff
20000024:	f000 b96a 	b.w	200002fc <__aeabi_idiv0>
20000028:	f1ad 0c08 	sub.w	ip, sp, #8
2000002c:	e96d ce04 	strd	ip, lr, [sp, #-16]!
20000030:	f000 f806 	bl	20000040 <__udivmoddi4>
20000034:	f8dd e004 	ldr.w	lr, [sp, #4]
20000038:	e9dd 2302 	ldrd	r2, r3, [sp, #8]
2000003c:	b004      	add	sp, #16
2000003e:	4770      	bx	lr

20000040 <__udivmoddi4>:
20000040:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
20000044:	9d08      	ldr	r5, [sp, #32]
20000046:	460c      	mov	r4, r1
20000048:	2b00      	cmp	r3, #0
2000004a:	d14e      	bne.n	200000ea <__udivmoddi4+0xaa>
2000004c:	4694      	mov	ip, r2
2000004e:	458c      	cmp	ip, r1
20000050:	4686      	mov	lr, r0
20000052:	fab2 f282 	clz	r2, r2
20000056:	d962      	bls.n	2000011e <__udivmoddi4+0xde>
20000058:	b14a      	cbz	r2, 2000006e <__udivmoddi4+0x2e>
2000005a:	f1c2 0320 	rsb	r3, r2, #32
2000005e:	4091      	lsls	r1, r2
20000060:	fa20 f303 	lsr.w	r3, r0, r3
20000064:	fa0c fc02 	lsl.w	ip, ip, r2
20000068:	4319      	orrs	r1, r3
2000006a:	fa00 fe02 	lsl.w	lr, r0, r2
2000006e:	ea4f 471c 	mov.w	r7, ip, lsr #16
20000072:	fa1f f68c 	uxth.w	r6, ip
20000076:	fbb1 f4f7 	udiv	r4, r1, r7
2000007a:	ea4f 431e 	mov.w	r3, lr, lsr #16
2000007e:	fb07 1114 	mls	r1, r7, r4, r1
20000082:	ea43 4301 	orr.w	r3, r3, r1, lsl #16
20000086:	fb04 f106 	mul.w	r1, r4, r6
2000008a:	4299      	cmp	r1, r3
2000008c:	d90a      	bls.n	200000a4 <__udivmoddi4+0x64>
2000008e:	eb1c 0303 	adds.w	r3, ip, r3
20000092:	f104 30ff 	add.w	r0, r4, #4294967295	@ 0xffffffff
20000096:	f080 8112 	bcs.w	200002be <__udivmoddi4+0x27e>
2000009a:	4299      	cmp	r1, r3
2000009c:	f240 810f 	bls.w	200002be <__udivmoddi4+0x27e>
200000a0:	3c02      	subs	r4, #2
200000a2:	4463      	add	r3, ip
200000a4:	1a59      	subs	r1, r3, r1
200000a6:	fa1f f38e 	uxth.w	r3, lr
200000aa:	fbb1 f0f7 	udiv	r0, r1, r7
200000ae:	fb07 1110 	mls	r1, r7, r0, r1
200000b2:	ea43 4301 	orr.w	r3, r3, r1, lsl #16
200000b6:	fb00 f606 	mul.w	r6, r0, r6
200000ba:	429e      	cmp	r6, r3
200000bc:	d90a      	bls.n	200000d4 <__udivmoddi4+0x94>
200000be:	eb1c 0303 	adds.w	r3, ip, r3
200000c2:	f100 31ff 	add.w	r1, r0, #4294967295	@ 0xffffffff
200000c6:	f080 80fc 	bcs.w	200002c2 <__udivmoddi4+0x282>
200000ca:	429e      	cmp	r6, r3
200000cc:	f240 80f9 	bls.w	200002c2 <__udivmoddi4+0x282>
200000d0:	4463      	add	r3, ip
200000d2:	3802      	subs	r0, #2
200000d4:	1b9b      	subs	r3, r3, r6
200000d6:	ea40 4004 	orr.w	r0, r0, r4, lsl #16
200000da:	2100      	movs	r1, #0
200000dc:	b11d      	cbz	r5, 200000e6 <__udivmoddi4+0xa6>
200000de:	40d3      	lsrs	r3, r2
200000e0:	2200      	movs	r2, #0
200000e2:	e9c5 3200 	strd	r3, r2, [r5]
200000e6:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
200000ea:	428b      	cmp	r3, r1
200000ec:	d905      	bls.n	200000fa <__udivmoddi4+0xba>
200000ee:	b10d      	cbz	r5, 200000f4 <__udivmoddi4+0xb4>
200000f0:	e9c5 0100 	strd	r0, r1, [r5]
200000f4:	2100      	movs	r1, #0
200000f6:	4608      	mov	r0, r1
200000f8:	e7f5      	b.n	200000e6 <__udivmoddi4+0xa6>
200000fa:	fab3 f183 	clz	r1, r3
200000fe:	2900      	cmp	r1, #0
20000100:	d146      	bne.n	20000190 <__udivmoddi4+0x150>
20000102:	42a3      	cmp	r3, r4
20000104:	d302      	bcc.n	2000010c <__udivmoddi4+0xcc>
20000106:	4290      	cmp	r0, r2
20000108:	f0c0 80f0 	bcc.w	200002ec <__udivmoddi4+0x2ac>
2000010c:	1a86      	subs	r6, r0, r2
2000010e:	eb64 0303 	sbc.w	r3, r4, r3
20000112:	2001      	movs	r0, #1
20000114:	2d00      	cmp	r5, #0
20000116:	d0e6      	beq.n	200000e6 <__udivmoddi4+0xa6>
20000118:	e9c5 6300 	strd	r6, r3, [r5]
2000011c:	e7e3      	b.n	200000e6 <__udivmoddi4+0xa6>
2000011e:	2a00      	cmp	r2, #0
20000120:	f040 8090 	bne.w	20000244 <__udivmoddi4+0x204>
20000124:	eba1 040c 	sub.w	r4, r1, ip
20000128:	ea4f 481c 	mov.w	r8, ip, lsr #16
2000012c:	fa1f f78c 	uxth.w	r7, ip
20000130:	2101      	movs	r1, #1
20000132:	fbb4 f6f8 	udiv	r6, r4, r8
20000136:	ea4f 431e 	mov.w	r3, lr, lsr #16
2000013a:	fb08 4416 	mls	r4, r8, r6, r4
2000013e:	ea43 4304 	orr.w	r3, r3, r4, lsl #16
20000142:	fb07 f006 	mul.w	r0, r7, r6
20000146:	4298      	cmp	r0, r3
20000148:	d908      	bls.n	2000015c <__udivmoddi4+0x11c>
2000014a:	eb1c 0303 	adds.w	r3, ip, r3
2000014e:	f106 34ff 	add.w	r4, r6, #4294967295	@ 0xffffffff
20000152:	d202      	bcs.n	2000015a <__udivmoddi4+0x11a>
20000154:	4298      	cmp	r0, r3
20000156:	f200 80cd 	bhi.w	200002f4 <__udivmoddi4+0x2b4>
2000015a:	4626      	mov	r6, r4
2000015c:	1a1c      	subs	r4, r3, r0
2000015e:	fa1f f38e 	uxth.w	r3, lr
20000162:	fbb4 f0f8 	udiv	r0, r4, r8
20000166:	fb08 4410 	mls	r4, r8, r0, r4
2000016a:	ea43 4304 	orr.w	r3, r3, r4, lsl #16
2000016e:	fb00 f707 	mul.w	r7, r0, r7
20000172:	429f      	cmp	r7, r3
20000174:	d908      	bls.n	20000188 <__udivmoddi4+0x148>
20000176:	eb1c 0303 	adds.w	r3, ip, r3
2000017a:	f100 34ff 	add.w	r4, r0, #4294967295	@ 0xffffffff
2000017e:	d202      	bcs.n	20000186 <__udivmoddi4+0x146>
20000180:	429f      	cmp	r7, r3
20000182:	f200 80b0 	bhi.w	200002e6 <__udivmoddi4+0x2a6>
20000186:	4620      	mov	r0, r4
20000188:	1bdb      	subs	r3, r3, r7
2000018a:	ea40 4006 	orr.w	r0, r0, r6, lsl #16
2000018e:	e7a5      	b.n	200000dc <__udivmoddi4+0x9c>
20000190:	f1c1 0620 	rsb	r6, r1, #32
20000194:	408b      	lsls	r3, r1
20000196:	fa22 f706 	lsr.w	r7, r2, r6
2000019a:	431f      	orrs	r7, r3
2000019c:	fa20 fc06 	lsr.w	ip, r0, r6
200001a0:	fa04 f301 	lsl.w	r3, r4, r1
200001a4:	ea43 030c 	orr.w	r3, r3, ip
200001a8:	40f4      	lsrs	r4, r6
200001aa:	fa00 f801 	lsl.w	r8, r0, r1
200001ae:	0c38      	lsrs	r0, r7, #16
200001b0:	ea4f 4913 	mov.w	r9, r3, lsr #16
200001b4:	fbb4 fef0 	udiv	lr, r4, r0
200001b8:	fa1f fc87 	uxth.w	ip, r7
200001bc:	fb00 441e 	mls	r4, r0, lr, r4
200001c0:	ea49 4404 	orr.w	r4, r9, r4, lsl #16
200001c4:	fb0e f90c 	mul.w	r9, lr, ip
200001c8:	45a1      	cmp	r9, r4
200001ca:	fa02 f201 	lsl.w	r2, r2, r1
200001ce:	d90a      	bls.n	200001e6 <__udivmoddi4+0x1a6>
200001d0:	193c      	adds	r4, r7, r4
200001d2:	f10e 3aff 	add.w	sl, lr, #4294967295	@ 0xffffffff
200001d6:	f080 8084 	bcs.w	200002e2 <__udivmoddi4+0x2a2>
200001da:	45a1      	cmp	r9, r4
200001dc:	f240 8081 	bls.w	200002e2 <__udivmoddi4+0x2a2>
200001e0:	f1ae 0e02 	sub.w	lr, lr, #2
200001e4:	443c      	add	r4, r7
200001e6:	eba4 0409 	sub.w	r4, r4, r9
200001ea:	fa1f f983 	uxth.w	r9, r3
200001ee:	fbb4 f3f0 	udiv	r3, r4, r0
200001f2:	fb00 4413 	mls	r4, r0, r3, r4
200001f6:	ea49 4404 	orr.w	r4, r9, r4, lsl #16
200001fa:	fb03 fc0c 	mul.w	ip, r3, ip
200001fe:	45a4      	cmp	ip, r4
20000200:	d907      	bls.n	20000212 <__udivmoddi4+0x1d2>
20000202:	193c      	adds	r4, r7, r4
20000204:	f103 30ff 	add.w	r0, r3, #4294967295	@ 0xffffffff
20000208:	d267      	bcs.n	200002da <__udivmoddi4+0x29a>
2000020a:	45a4      	cmp	ip, r4
2000020c:	d965      	bls.n	200002da <__udivmoddi4+0x29a>
2000020e:	3b02      	subs	r3, #2
20000210:	443c      	add	r4, r7
20000212:	ea43 400e 	orr.w	r0, r3, lr, lsl #16
20000216:	fba0 9302 	umull	r9, r3, r0, r2
2000021a:	eba4 040c 	sub.w	r4, r4, ip
2000021e:	429c      	cmp	r4, r3
20000220:	46ce      	mov	lr, r9
20000222:	469c      	mov	ip, r3
20000224:	d351      	bcc.n	200002ca <__udivmoddi4+0x28a>
20000226:	d04e      	beq.n	200002c6 <__udivmoddi4+0x286>
20000228:	b155      	cbz	r5, 20000240 <__udivmoddi4+0x200>
2000022a:	ebb8 030e 	subs.w	r3, r8, lr
2000022e:	eb64 040c 	sbc.w	r4, r4, ip
20000232:	fa04 f606 	lsl.w	r6, r4, r6
20000236:	40cb      	lsrs	r3, r1
20000238:	431e      	orrs	r6, r3
2000023a:	40cc      	lsrs	r4, r1
2000023c:	e9c5 6400 	strd	r6, r4, [r5]
20000240:	2100      	movs	r1, #0
20000242:	e750      	b.n	200000e6 <__udivmoddi4+0xa6>
20000244:	f1c2 0320 	rsb	r3, r2, #32
20000248:	fa20 f103 	lsr.w	r1, r0, r3
2000024c:	fa0c fc02 	lsl.w	ip, ip, r2
20000250:	fa24 f303 	lsr.w	r3, r4, r3
20000254:	4094      	lsls	r4, r2
20000256:	430c      	orrs	r4, r1
20000258:	ea4f 481c 	mov.w	r8, ip, lsr #16
2000025c:	fa00 fe02 	lsl.w	lr, r0, r2
20000260:	fa1f f78c 	uxth.w	r7, ip
20000264:	fbb3 f0f8 	udiv	r0, r3, r8
20000268:	fb08 3110 	mls	r1, r8, r0, r3
2000026c:	0c23      	lsrs	r3, r4, #16
2000026e:	ea43 4301 	orr.w	r3, r3, r1, lsl #16
20000272:	fb00 f107 	mul.w	r1, r0, r7
20000276:	4299      	cmp	r1, r3
20000278:	d908      	bls.n	2000028c <__udivmoddi4+0x24c>
2000027a:	eb1c 0303 	adds.w	r3, ip, r3
2000027e:	f100 36ff 	add.w	r6, r0, #4294967295	@ 0xffffffff
20000282:	d22c      	bcs.n	200002de <__udivmoddi4+0x29e>
20000284:	4299      	cmp	r1, r3
20000286:	d92a      	bls.n	200002de <__udivmoddi4+0x29e>
20000288:	3802      	subs	r0, #2
2000028a:	4463      	add	r3, ip
2000028c:	1a5b      	subs	r3, r3, r1
2000028e:	b2a4      	uxth	r4, r4
20000290:	fbb3 f1f8 	udiv	r1, r3, r8
20000294:	fb08 3311 	mls	r3, r8, r1, r3
20000298:	ea44 4403 	orr.w	r4, r4, r3, lsl #16
2000029c:	fb01 f307 	mul.w	r3, r1, r7
200002a0:	42a3      	cmp	r3, r4
200002a2:	d908      	bls.n	200002b6 <__udivmoddi4+0x276>
200002a4:	eb1c 0404 	adds.w	r4, ip, r4
200002a8:	f101 36ff 	add.w	r6, r1, #4294967295	@ 0xffffffff
200002ac:	d213      	bcs.n	200002d6 <__udivmoddi4+0x296>
200002ae:	42a3      	cmp	r3, r4
200002b0:	d911      	bls.n	200002d6 <__udivmoddi4+0x296>
200002b2:	3902      	subs	r1, #2
200002b4:	4464      	add	r4, ip
200002b6:	1ae4      	subs	r4, r4, r3
200002b8:	ea41 4100 	orr.w	r1, r1, r0, lsl #16
200002bc:	e739      	b.n	20000132 <__udivmoddi4+0xf2>
200002be:	4604      	mov	r4, r0
200002c0:	e6f0      	b.n	200000a4 <__udivmoddi4+0x64>
200002c2:	4608      	mov	r0, r1
200002c4:	e706      	b.n	200000d4 <__udivmoddi4+0x94>
200002c6:	45c8      	cmp	r8, r9
200002c8:	d2ae      	bcs.n	20000228 <__udivmoddi4+0x1e8>
200002ca:	ebb9 0e02 	subs.w	lr, r9, r2
200002ce:	eb63 0c07 	sbc.w	ip, r3, r7
200002d2:	3801      	subs	r0, #1
200002d4:	e7a8      	b.n	20000228 <__udivmoddi4+0x1e8>
200002d6:	4631      	mov	r1, r6
200002d8:	e7ed      	b.n	200002b6 <__udivmoddi4+0x276>
200002da:	4603      	mov	r3, r0
200002dc:	e799      	b.n	20000212 <__udivmoddi4+0x1d2>
200002de:	4630      	mov	r0, r6
200002e0:	e7d4      	b.n	2000028c <__udivmoddi4+0x24c>
200002e2:	46d6      	mov	lr, sl
200002e4:	e77f      	b.n	200001e6 <__udivmoddi4+0x1a6>
200002e6:	4463      	add	r3, ip
200002e8:	3802      	subs	r0, #2
200002ea:	e74d      	b.n	20000188 <__udivmoddi4+0x148>
200002ec:	4606      	mov	r6, r0
200002ee:	4623      	mov	r3, r4
200002f0:	4608      	mov	r0, r1
200002f2:	e70f      	b.n	20000114 <__udivmoddi4+0xd4>
200002f4:	3e02      	subs	r6, #2
200002f6:	4463      	add	r3, ip
200002f8:	e730      	b.n	2000015c <__udivmoddi4+0x11c>
200002fa:	bf00      	nop

200002fc <__aeabi_idiv0>:
200002fc:	4770      	bx	lr
200002fe:	bf00      	nop

20000300 <Reset_Handler>:
   .section	.text.Reset_Handler
	.weak	Reset_Handler
	.type	Reset_Handler, %function
Reset_Handler:

 ldr   sp, =_estack    /* Set stack pointer */
20000300:	f8df d0e8 	ldr.w	sp, [pc, #232]	@ 200003ec <L__usart_tdr+0x4>

/* Zero fill the bss segment. */
  ldr r2, =_sbss
20000304:	4a3a      	ldr	r2, [pc, #232]	@ (200003f0 <L__usart_tdr+0x8>)
  ldr r4, =_ebss
20000306:	4c3b      	ldr	r4, [pc, #236]	@ (200003f4 <L__usart_tdr+0xc>)
  movs r3, #0
20000308:	2300      	movs	r3, #0

1:
  cmp r2, r4
2000030a:	42a2      	cmp	r2, r4
  beq 2f
2000030c:	d002      	beq.n	20000314 <Reset_Handler+0x14>

  str  r3, [r2]
2000030e:	6013      	str	r3, [r2, #0]
  adds r2, r2, #4
20000310:	3204      	adds	r2, #4
  b  1b
20000312:	e7fa      	b.n	2000030a <Reset_Handler+0xa>

2:

  /* enable gpio clk from bus */
  ldr   r0, L__rcc_ahb2enr
20000314:	f8df 00a4 	ldr.w	r0, [pc, #164]	@ 200003bc <L__rcc_ahb2enr>
  mov   r1, 0x2
20000318:	f04f 0102 	mov.w	r1, #2
  str   r1, [r0]
2000031c:	6001      	str	r1, [r0, #0]

  /* enable hsi 16M OSC */
  ldr   r0, L__rcc_cr
2000031e:	4826      	ldr	r0, [pc, #152]	@ (200003b8 <L__rcc_cr>)
  mov   r1, 0xf00
20000320:	f44f 6170 	mov.w	r1, #3840	@ 0xf00
  str   r1, [r0]
20000324:	6001      	str	r1, [r0, #0]

  /* choose uart clk source as hsi 16Mhz */
  ldr   r0, L__rcc_ccipr
20000326:	4826      	ldr	r0, [pc, #152]	@ (200003c0 <L__rcc_ccipr>)
  mov   r1, 0x2
20000328:	f04f 0102 	mov.w	r1, #2
  str   r1, [r0]
2000032c:	6001      	str	r1, [r0, #0]


  /* enable uart clk from bus */
  ldr   r0, L__rcc_apb2enr
2000032e:	4825      	ldr	r0, [pc, #148]	@ (200003c4 <L__rcc_apb2enr>)
  mov   r1, 0x4000
20000330:	f44f 4180 	mov.w	r1, #16384	@ 0x4000
  str   r1, [r0]
20000334:	6001      	str	r1, [r0, #0]


  /*gpio, set as alt */
  ldr   r0, L__gpio_moder
20000336:	4824      	ldr	r0, [pc, #144]	@ (200003c8 <L__gpio_moder>)
  mov   r1, 0xa000
20000338:	f44f 4120 	mov.w	r1, #40960	@ 0xa000
  str   r1, [r0]
2000033c:	6001      	str	r1, [r0, #0]

   /*gpio, set as alt 7 */
  ldr   r0, L__gpio_afrl
2000033e:	4823      	ldr	r0, [pc, #140]	@ (200003cc <L__gpio_afrl>)
  mov   r1, 0x77000000
20000340:	f04f 41ee 	mov.w	r1, #1996488704	@ 0x77000000
  str   r1, [r0]
20000344:	6001      	str	r1, [r0, #0]


    /*uart, control, enable */
  ldr   r0, L__usart_cr1
20000346:	4824      	ldr	r0, [pc, #144]	@ (200003d8 <L__usart_cr1>)
  mov   r1, 0xd
20000348:	f04f 010d 	mov.w	r1, #13
  str   r1, [r0]
2000034c:	6001      	str	r1, [r0, #0]

   /*uart, baudrate */
  ldr   r0, L__usart_brr
2000034e:	4824      	ldr	r0, [pc, #144]	@ (200003e0 <L__usart_brr>)
  mov   r1, 0x8b
20000350:	f04f 018b 	mov.w	r1, #139	@ 0x8b
  str   r1, [r0]
20000354:	6001      	str	r1, [r0, #0]

  ldr   r0, L__usart_isr
20000356:	4823      	ldr	r0, [pc, #140]	@ (200003e4 <L__usart_isr>)
1:
  ldr   r1, [r0]
20000358:	6801      	ldr	r1, [r0, #0]
  and   r1,  1<<7
2000035a:	f001 0180 	and.w	r1, r1, #128	@ 0x80
  cmp   r1,  1<<7
2000035e:	2980      	cmp	r1, #128	@ 0x80
  bne   1b
20000360:	d1fa      	bne.n	20000358 <Reset_Handler+0x58>


     /*uart, tx data */
  ldr   r0, L__usart_tdr
20000362:	4821      	ldr	r0, [pc, #132]	@ (200003e8 <L__usart_tdr>)
  mov   r1, 0x59
20000364:	f04f 0159 	mov.w	r1, #89	@ 0x59
  str   r1, [r0]
20000368:	6001      	str	r1, [r0, #0]



  ldr   r0, L__usart_isr
2000036a:	481e      	ldr	r0, [pc, #120]	@ (200003e4 <L__usart_isr>)
1:
  ldr   r1, [r0]
2000036c:	6801      	ldr	r1, [r0, #0]
  and   r1, 1<<7
2000036e:	f001 0180 	and.w	r1, r1, #128	@ 0x80
  cmp   r1, 1<<7
20000372:	2980      	cmp	r1, #128	@ 0x80
  bne   1b
20000374:	d1fa      	bne.n	2000036c <Reset_Handler+0x6c>

  ldr   r0, L__usart_tdr
20000376:	481c      	ldr	r0, [pc, #112]	@ (200003e8 <L__usart_tdr>)
  mov   r1, 0x58
20000378:	f04f 0158 	mov.w	r1, #88	@ 0x58
  str   r1, [r0]
2000037c:	6001      	str	r1, [r0, #0]
  mov r0, #1
2000037e:	f04f 0001 	mov.w	r0, #1
  mov r1, #2
20000382:	f04f 0102 	mov.w	r1, #2

20000386 <compute>:


compute:
  add r2, r1, r0
20000386:	eb01 0200 	add.w	r2, r1, r0
  mov r0, r2
2000038a:	4610      	mov	r0, r2
  add r1, r1, #1
2000038c:	f101 0101 	add.w	r1, r1, #1

  cmp r1, #101
20000390:	2965      	cmp	r1, #101	@ 0x65
  bne compute
20000392:	d1f8      	bne.n	20000386 <compute>

//mov  r2, 0x8800
//bl start


bl cfe_main
20000394:	f002 feda 	bl	2000314c <cfe_main>

20000398 <start>:

start:
    ldr   r1, [r0]
20000398:	6801      	ldr	r1, [r0, #0]
    ands  r1, r1, 1<<7
2000039a:	f011 0180 	ands.w	r1, r1, #128	@ 0x80
    beq   start
2000039e:	d0fb      	beq.n	20000398 <start>
    ldr   r0, L__usart_tdr
200003a0:	4811      	ldr	r0, [pc, #68]	@ (200003e8 <L__usart_tdr>)
    mov   r1, #48
200003a2:	f04f 0130 	mov.w	r1, #48	@ 0x30
    str   r1, [r0]
200003a6:	6001      	str	r1, [r0, #0]

200003a8 <stop>:


stop:
    ldr   r1, [r0]
200003a8:	6801      	ldr	r1, [r0, #0]
    ands  r1, r1, 1<<7
200003aa:	f011 0180 	ands.w	r1, r1, #128	@ 0x80
    beq   stop
200003ae:	d0fb      	beq.n	200003a8 <stop>
    ldr   r0, L__usart_tdr
200003b0:	480d      	ldr	r0, [pc, #52]	@ (200003e8 <L__usart_tdr>)
    mov   r1, #49
200003b2:	f04f 0131 	mov.w	r1, #49	@ 0x31
    str   r1, [r0]
200003b6:	6001      	str	r1, [r0, #0]

200003b8 <L__rcc_cr>:
200003b8:	40021000 	.word	0x40021000

200003bc <L__rcc_ahb2enr>:
200003bc:	4002104c 	.word	0x4002104c

200003c0 <L__rcc_ccipr>:
200003c0:	40021088 	.word	0x40021088

200003c4 <L__rcc_apb2enr>:
200003c4:	40021060 	.word	0x40021060

200003c8 <L__gpio_moder>:
200003c8:	48000400 	.word	0x48000400

200003cc <L__gpio_afrl>:
200003cc:	48000420 	.word	0x48000420

200003d0 <L__gpio_ospeedr>:
200003d0:	48000408 	.word	0x48000408

200003d4 <L__gpio_pupdr>:
200003d4:	4800040c 	.word	0x4800040c

200003d8 <L__usart_cr1>:
200003d8:	40013800 	.word	0x40013800

200003dc <L__usart_otyper>:
200003dc:	40013804 	.word	0x40013804

200003e0 <L__usart_brr>:
200003e0:	4001380c 	.word	0x4001380c

200003e4 <L__usart_isr>:
200003e4:	4001381c 	.word	0x4001381c

200003e8 <L__usart_tdr>:
200003e8:	40013828 	.word	0x40013828
 ldr   sp, =_estack    /* Set stack pointer */
200003ec:	20018000 	.word	0x20018000
  ldr r2, =_sbss
200003f0:	20004ab0 	.word	0x20004ab0
  ldr r4, =_ebss
200003f4:	20004d20 	.word	0x20004d20

200003f8 <__atox>:
    *  Return Value:
    *      number of digits placed in output buffer
    ********************************************************************* */
static int __atox(char *buf,unsigned int num,unsigned int radix,int width,
		     const char *digits)
{
200003f8:	b480      	push	{r7}
200003fa:	b08b      	sub	sp, #44	@ 0x2c
200003fc:	af00      	add	r7, sp, #0
200003fe:	60f8      	str	r0, [r7, #12]
20000400:	60b9      	str	r1, [r7, #8]
20000402:	607a      	str	r2, [r7, #4]
20000404:	603b      	str	r3, [r7, #0]
    char buffer[16];
    char *op;
    int retval;

    op = &buffer[0];
20000406:	f107 0310 	add.w	r3, r7, #16
2000040a:	627b      	str	r3, [r7, #36]	@ 0x24
    retval = 0;
2000040c:	2300      	movs	r3, #0
2000040e:	623b      	str	r3, [r7, #32]

    do {
	*op++ = digits[num % radix];
20000410:	68bb      	ldr	r3, [r7, #8]
20000412:	687a      	ldr	r2, [r7, #4]
20000414:	fbb3 f2f2 	udiv	r2, r3, r2
20000418:	6879      	ldr	r1, [r7, #4]
2000041a:	fb01 f202 	mul.w	r2, r1, r2
2000041e:	1a9b      	subs	r3, r3, r2
20000420:	6b3a      	ldr	r2, [r7, #48]	@ 0x30
20000422:	441a      	add	r2, r3
20000424:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
20000426:	1c59      	adds	r1, r3, #1
20000428:	6279      	str	r1, [r7, #36]	@ 0x24
2000042a:	7812      	ldrb	r2, [r2, #0]
2000042c:	701a      	strb	r2, [r3, #0]
	retval++;
2000042e:	6a3b      	ldr	r3, [r7, #32]
20000430:	3301      	adds	r3, #1
20000432:	623b      	str	r3, [r7, #32]
	num /= radix;
20000434:	68ba      	ldr	r2, [r7, #8]
20000436:	687b      	ldr	r3, [r7, #4]
20000438:	fbb2 f3f3 	udiv	r3, r2, r3
2000043c:	60bb      	str	r3, [r7, #8]
	} while (num != 0);
2000043e:	68bb      	ldr	r3, [r7, #8]
20000440:	2b00      	cmp	r3, #0
20000442:	d1e5      	bne.n	20000410 <__atox+0x18>

    if (width && (width > retval)) {
20000444:	683b      	ldr	r3, [r7, #0]
20000446:	2b00      	cmp	r3, #0
20000448:	d020      	beq.n	2000048c <__atox+0x94>
2000044a:	683a      	ldr	r2, [r7, #0]
2000044c:	6a3b      	ldr	r3, [r7, #32]
2000044e:	429a      	cmp	r2, r3
20000450:	dd1c      	ble.n	2000048c <__atox+0x94>
	width = width - retval;
20000452:	683a      	ldr	r2, [r7, #0]
20000454:	6a3b      	ldr	r3, [r7, #32]
20000456:	1ad3      	subs	r3, r2, r3
20000458:	603b      	str	r3, [r7, #0]
	while (width) {
2000045a:	e00a      	b.n	20000472 <__atox+0x7a>
	    *op++ = '0';
2000045c:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
2000045e:	1c5a      	adds	r2, r3, #1
20000460:	627a      	str	r2, [r7, #36]	@ 0x24
20000462:	2230      	movs	r2, #48	@ 0x30
20000464:	701a      	strb	r2, [r3, #0]
	    retval++;
20000466:	6a3b      	ldr	r3, [r7, #32]
20000468:	3301      	adds	r3, #1
2000046a:	623b      	str	r3, [r7, #32]
	    width--;
2000046c:	683b      	ldr	r3, [r7, #0]
2000046e:	3b01      	subs	r3, #1
20000470:	603b      	str	r3, [r7, #0]
	while (width) {
20000472:	683b      	ldr	r3, [r7, #0]
20000474:	2b00      	cmp	r3, #0
20000476:	d1f1      	bne.n	2000045c <__atox+0x64>
	    }
	}

    while (op != buffer) {
20000478:	e008      	b.n	2000048c <__atox+0x94>
	op--;
2000047a:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
2000047c:	3b01      	subs	r3, #1
2000047e:	627b      	str	r3, [r7, #36]	@ 0x24
	*buf++ = *op;
20000480:	68fb      	ldr	r3, [r7, #12]
20000482:	1c5a      	adds	r2, r3, #1
20000484:	60fa      	str	r2, [r7, #12]
20000486:	6a7a      	ldr	r2, [r7, #36]	@ 0x24
20000488:	7812      	ldrb	r2, [r2, #0]
2000048a:	701a      	strb	r2, [r3, #0]
    while (op != buffer) {
2000048c:	f107 0310 	add.w	r3, r7, #16
20000490:	6a7a      	ldr	r2, [r7, #36]	@ 0x24
20000492:	429a      	cmp	r2, r3
20000494:	d1f1      	bne.n	2000047a <__atox+0x82>
	}

    return retval;
20000496:	6a3b      	ldr	r3, [r7, #32]
}
20000498:	4618      	mov	r0, r3
2000049a:	372c      	adds	r7, #44	@ 0x2c
2000049c:	46bd      	mov	sp, r7
2000049e:	f85d 7b04 	ldr.w	r7, [sp], #4
200004a2:	4770      	bx	lr

200004a4 <__llatox>:
    *  Return Value:
    *      number of digits placed in output buffer
    ********************************************************************* */
static int __llatox(char *buf,unsigned long long num,unsigned int radix,
		    int width,const char *digits)
{
200004a4:	e92d 43b0 	stmdb	sp!, {r4, r5, r7, r8, r9, lr}
200004a8:	b08a      	sub	sp, #40	@ 0x28
200004aa:	af00      	add	r7, sp, #0
200004ac:	60f8      	str	r0, [r7, #12]
200004ae:	e9c7 2300 	strd	r2, r3, [r7]
    char buffer[16];
    char *op;
    int retval;

    op = &buffer[0];
200004b2:	f107 0310 	add.w	r3, r7, #16
200004b6:	627b      	str	r3, [r7, #36]	@ 0x24
    retval = 0;
200004b8:	2300      	movs	r3, #0
200004ba:	623b      	str	r3, [r7, #32]
	retval++;
	num >>= 4;
	} while (num != 0);
#else
    do {
	*op++ = digits[num % radix];
200004bc:	6c3b      	ldr	r3, [r7, #64]	@ 0x40
200004be:	2200      	movs	r2, #0
200004c0:	4698      	mov	r8, r3
200004c2:	4691      	mov	r9, r2
200004c4:	e9d7 0100 	ldrd	r0, r1, [r7]
200004c8:	4642      	mov	r2, r8
200004ca:	464b      	mov	r3, r9
200004cc:	f7ff fda0 	bl	20000010 <__aeabi_uldivmod>
200004d0:	6cbb      	ldr	r3, [r7, #72]	@ 0x48
200004d2:	441a      	add	r2, r3
200004d4:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
200004d6:	1c59      	adds	r1, r3, #1
200004d8:	6279      	str	r1, [r7, #36]	@ 0x24
200004da:	7812      	ldrb	r2, [r2, #0]
200004dc:	701a      	strb	r2, [r3, #0]
	retval++;
200004de:	6a3b      	ldr	r3, [r7, #32]
200004e0:	3301      	adds	r3, #1
200004e2:	623b      	str	r3, [r7, #32]
	num /= radix;
200004e4:	6c3b      	ldr	r3, [r7, #64]	@ 0x40
200004e6:	2200      	movs	r2, #0
200004e8:	461c      	mov	r4, r3
200004ea:	4615      	mov	r5, r2
200004ec:	4622      	mov	r2, r4
200004ee:	462b      	mov	r3, r5
200004f0:	e9d7 0100 	ldrd	r0, r1, [r7]
200004f4:	f7ff fd8c 	bl	20000010 <__aeabi_uldivmod>
200004f8:	4602      	mov	r2, r0
200004fa:	460b      	mov	r3, r1
200004fc:	e9c7 2300 	strd	r2, r3, [r7]
	} while (num != 0);
20000500:	e9d7 2300 	ldrd	r2, r3, [r7]
20000504:	4313      	orrs	r3, r2
20000506:	d1d9      	bne.n	200004bc <__llatox+0x18>
#endif

    if (width && (width > retval)) {
20000508:	6c7b      	ldr	r3, [r7, #68]	@ 0x44
2000050a:	2b00      	cmp	r3, #0
2000050c:	d020      	beq.n	20000550 <__llatox+0xac>
2000050e:	6c7a      	ldr	r2, [r7, #68]	@ 0x44
20000510:	6a3b      	ldr	r3, [r7, #32]
20000512:	429a      	cmp	r2, r3
20000514:	dd1c      	ble.n	20000550 <__llatox+0xac>
	width = width - retval;
20000516:	6c7a      	ldr	r2, [r7, #68]	@ 0x44
20000518:	6a3b      	ldr	r3, [r7, #32]
2000051a:	1ad3      	subs	r3, r2, r3
2000051c:	647b      	str	r3, [r7, #68]	@ 0x44
	while (width) {
2000051e:	e00a      	b.n	20000536 <__llatox+0x92>
	    *op++ = '0';
20000520:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
20000522:	1c5a      	adds	r2, r3, #1
20000524:	627a      	str	r2, [r7, #36]	@ 0x24
20000526:	2230      	movs	r2, #48	@ 0x30
20000528:	701a      	strb	r2, [r3, #0]
	    retval++;
2000052a:	6a3b      	ldr	r3, [r7, #32]
2000052c:	3301      	adds	r3, #1
2000052e:	623b      	str	r3, [r7, #32]
	    width--;
20000530:	6c7b      	ldr	r3, [r7, #68]	@ 0x44
20000532:	3b01      	subs	r3, #1
20000534:	647b      	str	r3, [r7, #68]	@ 0x44
	while (width) {
20000536:	6c7b      	ldr	r3, [r7, #68]	@ 0x44
20000538:	2b00      	cmp	r3, #0
2000053a:	d1f1      	bne.n	20000520 <__llatox+0x7c>
	    }
	}

    while (op != buffer) {
2000053c:	e008      	b.n	20000550 <__llatox+0xac>
	op--;
2000053e:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
20000540:	3b01      	subs	r3, #1
20000542:	627b      	str	r3, [r7, #36]	@ 0x24
	*buf++ = *op;
20000544:	68fb      	ldr	r3, [r7, #12]
20000546:	1c5a      	adds	r2, r3, #1
20000548:	60fa      	str	r2, [r7, #12]
2000054a:	6a7a      	ldr	r2, [r7, #36]	@ 0x24
2000054c:	7812      	ldrb	r2, [r2, #0]
2000054e:	701a      	strb	r2, [r3, #0]
    while (op != buffer) {
20000550:	f107 0310 	add.w	r3, r7, #16
20000554:	6a7a      	ldr	r2, [r7, #36]	@ 0x24
20000556:	429a      	cmp	r2, r3
20000558:	d1f1      	bne.n	2000053e <__llatox+0x9a>
	}

    return retval;
2000055a:	6a3b      	ldr	r3, [r7, #32]
}
2000055c:	4618      	mov	r0, r3
2000055e:	3728      	adds	r7, #40	@ 0x28
20000560:	46bd      	mov	sp, r7
20000562:	e8bd 83b0 	ldmia.w	sp!, {r4, r5, r7, r8, r9, pc}
	...

20000568 <xvsprintf>:
    *  Return Value:
    *      number of characters copied
    ********************************************************************* */
#define isdigit(x) (((x) >= '0') && ((x) <= '9'))
int xvsprintf(char *outbuf,const char *templat,va_list marker)
{
20000568:	b5b0      	push	{r4, r5, r7, lr}
2000056a:	b09a      	sub	sp, #104	@ 0x68
2000056c:	af04      	add	r7, sp, #16
2000056e:	60f8      	str	r0, [r7, #12]
20000570:	60b9      	str	r1, [r7, #8]
20000572:	607a      	str	r2, [r7, #4]
    long long ll;
    int leadingzero;
    int leadingnegsign;
    int islong;
    int width;
    int width2 = 0;
20000574:	2300      	movs	r3, #0
20000576:	62fb      	str	r3, [r7, #44]	@ 0x2c
    int hashash = 0;
20000578:	2300      	movs	r3, #0
2000057a:	62bb      	str	r3, [r7, #40]	@ 0x28

    optr = outbuf;
2000057c:	68fb      	ldr	r3, [r7, #12]
2000057e:	657b      	str	r3, [r7, #84]	@ 0x54
    iptr = templat;
20000580:	68bb      	ldr	r3, [r7, #8]
20000582:	653b      	str	r3, [r7, #80]	@ 0x50

    while (*iptr) {
20000584:	e326      	b.n	20000bd4 <xvsprintf+0x66c>
	if (*iptr != '%') {*optr++ = *iptr++; continue;}
20000586:	6d3b      	ldr	r3, [r7, #80]	@ 0x50
20000588:	781b      	ldrb	r3, [r3, #0]
2000058a:	2b25      	cmp	r3, #37	@ 0x25
2000058c:	d008      	beq.n	200005a0 <xvsprintf+0x38>
2000058e:	6d3a      	ldr	r2, [r7, #80]	@ 0x50
20000590:	1c53      	adds	r3, r2, #1
20000592:	653b      	str	r3, [r7, #80]	@ 0x50
20000594:	6d7b      	ldr	r3, [r7, #84]	@ 0x54
20000596:	1c59      	adds	r1, r3, #1
20000598:	6579      	str	r1, [r7, #84]	@ 0x54
2000059a:	7812      	ldrb	r2, [r2, #0]
2000059c:	701a      	strb	r2, [r3, #0]
2000059e:	e319      	b.n	20000bd4 <xvsprintf+0x66c>

	iptr++;
200005a0:	6d3b      	ldr	r3, [r7, #80]	@ 0x50
200005a2:	3301      	adds	r3, #1
200005a4:	653b      	str	r3, [r7, #80]	@ 0x50

	if (*iptr == '#') { hashash = 1; iptr++; }
200005a6:	6d3b      	ldr	r3, [r7, #80]	@ 0x50
200005a8:	781b      	ldrb	r3, [r3, #0]
200005aa:	2b23      	cmp	r3, #35	@ 0x23
200005ac:	d104      	bne.n	200005b8 <xvsprintf+0x50>
200005ae:	2301      	movs	r3, #1
200005b0:	62bb      	str	r3, [r7, #40]	@ 0x28
200005b2:	6d3b      	ldr	r3, [r7, #80]	@ 0x50
200005b4:	3301      	adds	r3, #1
200005b6:	653b      	str	r3, [r7, #80]	@ 0x50
	if (*iptr == '-') {
200005b8:	6d3b      	ldr	r3, [r7, #80]	@ 0x50
200005ba:	781b      	ldrb	r3, [r3, #0]
200005bc:	2b2d      	cmp	r3, #45	@ 0x2d
200005be:	d105      	bne.n	200005cc <xvsprintf+0x64>
	    leadingnegsign = 1;
200005c0:	2301      	movs	r3, #1
200005c2:	627b      	str	r3, [r7, #36]	@ 0x24
	    iptr++;
200005c4:	6d3b      	ldr	r3, [r7, #80]	@ 0x50
200005c6:	3301      	adds	r3, #1
200005c8:	653b      	str	r3, [r7, #80]	@ 0x50
200005ca:	e001      	b.n	200005d0 <xvsprintf+0x68>
	    }
	else leadingnegsign = 0;
200005cc:	2300      	movs	r3, #0
200005ce:	627b      	str	r3, [r7, #36]	@ 0x24

	if (*iptr == '0') leadingzero = 1;
200005d0:	6d3b      	ldr	r3, [r7, #80]	@ 0x50
200005d2:	781b      	ldrb	r3, [r3, #0]
200005d4:	2b30      	cmp	r3, #48	@ 0x30
200005d6:	d102      	bne.n	200005de <xvsprintf+0x76>
200005d8:	2301      	movs	r3, #1
200005da:	623b      	str	r3, [r7, #32]
200005dc:	e001      	b.n	200005e2 <xvsprintf+0x7a>
	else leadingzero = 0;
200005de:	2300      	movs	r3, #0
200005e0:	623b      	str	r3, [r7, #32]

	width = 0;
200005e2:	2300      	movs	r3, #0
200005e4:	633b      	str	r3, [r7, #48]	@ 0x30
	while (*iptr && isdigit(*iptr)) {
200005e6:	e016      	b.n	20000616 <xvsprintf+0xae>
	    width += (*iptr - '0');
200005e8:	6d3b      	ldr	r3, [r7, #80]	@ 0x50
200005ea:	781b      	ldrb	r3, [r3, #0]
200005ec:	3b30      	subs	r3, #48	@ 0x30
200005ee:	6b3a      	ldr	r2, [r7, #48]	@ 0x30
200005f0:	4413      	add	r3, r2
200005f2:	633b      	str	r3, [r7, #48]	@ 0x30
	    iptr++;
200005f4:	6d3b      	ldr	r3, [r7, #80]	@ 0x50
200005f6:	3301      	adds	r3, #1
200005f8:	653b      	str	r3, [r7, #80]	@ 0x50
	    if (isdigit(*iptr)) width *= 10;
200005fa:	6d3b      	ldr	r3, [r7, #80]	@ 0x50
200005fc:	781b      	ldrb	r3, [r3, #0]
200005fe:	2b2f      	cmp	r3, #47	@ 0x2f
20000600:	d909      	bls.n	20000616 <xvsprintf+0xae>
20000602:	6d3b      	ldr	r3, [r7, #80]	@ 0x50
20000604:	781b      	ldrb	r3, [r3, #0]
20000606:	2b39      	cmp	r3, #57	@ 0x39
20000608:	d805      	bhi.n	20000616 <xvsprintf+0xae>
2000060a:	6b3a      	ldr	r2, [r7, #48]	@ 0x30
2000060c:	4613      	mov	r3, r2
2000060e:	009b      	lsls	r3, r3, #2
20000610:	4413      	add	r3, r2
20000612:	005b      	lsls	r3, r3, #1
20000614:	633b      	str	r3, [r7, #48]	@ 0x30
	while (*iptr && isdigit(*iptr)) {
20000616:	6d3b      	ldr	r3, [r7, #80]	@ 0x50
20000618:	781b      	ldrb	r3, [r3, #0]
2000061a:	2b00      	cmp	r3, #0
2000061c:	d007      	beq.n	2000062e <xvsprintf+0xc6>
2000061e:	6d3b      	ldr	r3, [r7, #80]	@ 0x50
20000620:	781b      	ldrb	r3, [r3, #0]
20000622:	2b2f      	cmp	r3, #47	@ 0x2f
20000624:	d903      	bls.n	2000062e <xvsprintf+0xc6>
20000626:	6d3b      	ldr	r3, [r7, #80]	@ 0x50
20000628:	781b      	ldrb	r3, [r3, #0]
2000062a:	2b39      	cmp	r3, #57	@ 0x39
2000062c:	d9dc      	bls.n	200005e8 <xvsprintf+0x80>
	    }
	if (*iptr == '.') {
2000062e:	6d3b      	ldr	r3, [r7, #80]	@ 0x50
20000630:	781b      	ldrb	r3, [r3, #0]
20000632:	2b2e      	cmp	r3, #46	@ 0x2e
20000634:	d128      	bne.n	20000688 <xvsprintf+0x120>
	    iptr++;
20000636:	6d3b      	ldr	r3, [r7, #80]	@ 0x50
20000638:	3301      	adds	r3, #1
2000063a:	653b      	str	r3, [r7, #80]	@ 0x50
	    width2 = 0;
2000063c:	2300      	movs	r3, #0
2000063e:	62fb      	str	r3, [r7, #44]	@ 0x2c
	    while (*iptr && isdigit(*iptr)) {
20000640:	e016      	b.n	20000670 <xvsprintf+0x108>
		width2 += (*iptr - '0');
20000642:	6d3b      	ldr	r3, [r7, #80]	@ 0x50
20000644:	781b      	ldrb	r3, [r3, #0]
20000646:	3b30      	subs	r3, #48	@ 0x30
20000648:	6afa      	ldr	r2, [r7, #44]	@ 0x2c
2000064a:	4413      	add	r3, r2
2000064c:	62fb      	str	r3, [r7, #44]	@ 0x2c
		iptr++;
2000064e:	6d3b      	ldr	r3, [r7, #80]	@ 0x50
20000650:	3301      	adds	r3, #1
20000652:	653b      	str	r3, [r7, #80]	@ 0x50
		if (isdigit(*iptr)) width2 *= 10;
20000654:	6d3b      	ldr	r3, [r7, #80]	@ 0x50
20000656:	781b      	ldrb	r3, [r3, #0]
20000658:	2b2f      	cmp	r3, #47	@ 0x2f
2000065a:	d909      	bls.n	20000670 <xvsprintf+0x108>
2000065c:	6d3b      	ldr	r3, [r7, #80]	@ 0x50
2000065e:	781b      	ldrb	r3, [r3, #0]
20000660:	2b39      	cmp	r3, #57	@ 0x39
20000662:	d805      	bhi.n	20000670 <xvsprintf+0x108>
20000664:	6afa      	ldr	r2, [r7, #44]	@ 0x2c
20000666:	4613      	mov	r3, r2
20000668:	009b      	lsls	r3, r3, #2
2000066a:	4413      	add	r3, r2
2000066c:	005b      	lsls	r3, r3, #1
2000066e:	62fb      	str	r3, [r7, #44]	@ 0x2c
	    while (*iptr && isdigit(*iptr)) {
20000670:	6d3b      	ldr	r3, [r7, #80]	@ 0x50
20000672:	781b      	ldrb	r3, [r3, #0]
20000674:	2b00      	cmp	r3, #0
20000676:	d007      	beq.n	20000688 <xvsprintf+0x120>
20000678:	6d3b      	ldr	r3, [r7, #80]	@ 0x50
2000067a:	781b      	ldrb	r3, [r3, #0]
2000067c:	2b2f      	cmp	r3, #47	@ 0x2f
2000067e:	d903      	bls.n	20000688 <xvsprintf+0x120>
20000680:	6d3b      	ldr	r3, [r7, #80]	@ 0x50
20000682:	781b      	ldrb	r3, [r3, #0]
20000684:	2b39      	cmp	r3, #57	@ 0x39
20000686:	d9dc      	bls.n	20000642 <xvsprintf+0xda>
		}
	    }

	islong = 0;
20000688:	2300      	movs	r3, #0
2000068a:	637b      	str	r3, [r7, #52]	@ 0x34
	if (*iptr == 'l') { islong++; iptr++; }
2000068c:	6d3b      	ldr	r3, [r7, #80]	@ 0x50
2000068e:	781b      	ldrb	r3, [r3, #0]
20000690:	2b6c      	cmp	r3, #108	@ 0x6c
20000692:	d105      	bne.n	200006a0 <xvsprintf+0x138>
20000694:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
20000696:	3301      	adds	r3, #1
20000698:	637b      	str	r3, [r7, #52]	@ 0x34
2000069a:	6d3b      	ldr	r3, [r7, #80]	@ 0x50
2000069c:	3301      	adds	r3, #1
2000069e:	653b      	str	r3, [r7, #80]	@ 0x50
	if (*iptr == 'l') { islong++; iptr++; }
200006a0:	6d3b      	ldr	r3, [r7, #80]	@ 0x50
200006a2:	781b      	ldrb	r3, [r3, #0]
200006a4:	2b6c      	cmp	r3, #108	@ 0x6c
200006a6:	d105      	bne.n	200006b4 <xvsprintf+0x14c>
200006a8:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
200006aa:	3301      	adds	r3, #1
200006ac:	637b      	str	r3, [r7, #52]	@ 0x34
200006ae:	6d3b      	ldr	r3, [r7, #80]	@ 0x50
200006b0:	3301      	adds	r3, #1
200006b2:	653b      	str	r3, [r7, #80]	@ 0x50

	switch (*iptr) {
200006b4:	6d3b      	ldr	r3, [r7, #80]	@ 0x50
200006b6:	781b      	ldrb	r3, [r3, #0]
200006b8:	3b49      	subs	r3, #73	@ 0x49
200006ba:	2b2f      	cmp	r3, #47	@ 0x2f
200006bc:	f200 8280 	bhi.w	20000bc0 <xvsprintf+0x658>
200006c0:	a201      	add	r2, pc, #4	@ (adr r2, 200006c8 <xvsprintf+0x160>)
200006c2:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
200006c6:	bf00      	nop
200006c8:	20000789 	.word	0x20000789
200006cc:	20000bc1 	.word	0x20000bc1
200006d0:	20000bc1 	.word	0x20000bc1
200006d4:	20000bc1 	.word	0x20000bc1
200006d8:	20000bc1 	.word	0x20000bc1
200006dc:	20000bc1 	.word	0x20000bc1
200006e0:	20000bc1 	.word	0x20000bc1
200006e4:	20000ad9 	.word	0x20000ad9
200006e8:	20000bc1 	.word	0x20000bc1
200006ec:	20000bc1 	.word	0x20000bc1
200006f0:	20000bc1 	.word	0x20000bc1
200006f4:	20000bc1 	.word	0x20000bc1
200006f8:	20000bc1 	.word	0x20000bc1
200006fc:	20000bc1 	.word	0x20000bc1
20000700:	20000bc1 	.word	0x20000bc1
20000704:	20000a4b 	.word	0x20000a4b
20000708:	20000bc1 	.word	0x20000bc1
2000070c:	20000b63 	.word	0x20000b63
20000710:	20000bc1 	.word	0x20000bc1
20000714:	20000bc1 	.word	0x20000bc1
20000718:	20000bc1 	.word	0x20000bc1
2000071c:	20000bc1 	.word	0x20000bc1
20000720:	20000bc1 	.word	0x20000bc1
20000724:	20000bc1 	.word	0x20000bc1
20000728:	200008b3 	.word	0x200008b3
2000072c:	20000b37 	.word	0x20000b37
20000730:	20000ba9 	.word	0x20000ba9
20000734:	2000091f 	.word	0x2000091f
20000738:	20000bc1 	.word	0x20000bc1
2000073c:	20000bc1 	.word	0x20000bc1
20000740:	20000bc1 	.word	0x20000bc1
20000744:	20000bc1 	.word	0x20000bc1
20000748:	20000bc1 	.word	0x20000bc1
2000074c:	20000bc1 	.word	0x20000bc1
20000750:	20000bc1 	.word	0x20000bc1
20000754:	20000bc1 	.word	0x20000bc1
20000758:	20000bc1 	.word	0x20000bc1
2000075c:	20000bc1 	.word	0x20000bc1
20000760:	20000bc1 	.word	0x20000bc1
20000764:	20000ad9 	.word	0x20000ad9
20000768:	20000bc1 	.word	0x20000bc1
2000076c:	20000bc1 	.word	0x20000bc1
20000770:	2000083b 	.word	0x2000083b
20000774:	20000bc1 	.word	0x20000bc1
20000778:	200009cd 	.word	0x200009cd
2000077c:	20000bc1 	.word	0x20000bc1
20000780:	20000b0b 	.word	0x20000b0b
20000784:	20000a4b 	.word	0x20000a4b
	    case 'I':
		tmpptr = (unsigned char *) va_arg(marker,unsigned char *);
20000788:	687b      	ldr	r3, [r7, #4]
2000078a:	1d1a      	adds	r2, r3, #4
2000078c:	607a      	str	r2, [r7, #4]
2000078e:	681b      	ldr	r3, [r3, #0]
20000790:	64fb      	str	r3, [r7, #76]	@ 0x4c
		optr += __atox(optr,*tmpptr++,10,0,digits);
20000792:	6cfb      	ldr	r3, [r7, #76]	@ 0x4c
20000794:	1c5a      	adds	r2, r3, #1
20000796:	64fa      	str	r2, [r7, #76]	@ 0x4c
20000798:	781b      	ldrb	r3, [r3, #0]
2000079a:	4619      	mov	r1, r3
2000079c:	4b9a      	ldr	r3, [pc, #616]	@ (20000a08 <xvsprintf+0x4a0>)
2000079e:	9300      	str	r3, [sp, #0]
200007a0:	2300      	movs	r3, #0
200007a2:	220a      	movs	r2, #10
200007a4:	6d78      	ldr	r0, [r7, #84]	@ 0x54
200007a6:	f7ff fe27 	bl	200003f8 <__atox>
200007aa:	4603      	mov	r3, r0
200007ac:	461a      	mov	r2, r3
200007ae:	6d7b      	ldr	r3, [r7, #84]	@ 0x54
200007b0:	4413      	add	r3, r2
200007b2:	657b      	str	r3, [r7, #84]	@ 0x54
		*optr++ = '.';
200007b4:	6d7b      	ldr	r3, [r7, #84]	@ 0x54
200007b6:	1c5a      	adds	r2, r3, #1
200007b8:	657a      	str	r2, [r7, #84]	@ 0x54
200007ba:	222e      	movs	r2, #46	@ 0x2e
200007bc:	701a      	strb	r2, [r3, #0]
		optr += __atox(optr,*tmpptr++,10,0,digits);
200007be:	6cfb      	ldr	r3, [r7, #76]	@ 0x4c
200007c0:	1c5a      	adds	r2, r3, #1
200007c2:	64fa      	str	r2, [r7, #76]	@ 0x4c
200007c4:	781b      	ldrb	r3, [r3, #0]
200007c6:	4619      	mov	r1, r3
200007c8:	4b8f      	ldr	r3, [pc, #572]	@ (20000a08 <xvsprintf+0x4a0>)
200007ca:	9300      	str	r3, [sp, #0]
200007cc:	2300      	movs	r3, #0
200007ce:	220a      	movs	r2, #10
200007d0:	6d78      	ldr	r0, [r7, #84]	@ 0x54
200007d2:	f7ff fe11 	bl	200003f8 <__atox>
200007d6:	4603      	mov	r3, r0
200007d8:	461a      	mov	r2, r3
200007da:	6d7b      	ldr	r3, [r7, #84]	@ 0x54
200007dc:	4413      	add	r3, r2
200007de:	657b      	str	r3, [r7, #84]	@ 0x54
		*optr++ = '.';
200007e0:	6d7b      	ldr	r3, [r7, #84]	@ 0x54
200007e2:	1c5a      	adds	r2, r3, #1
200007e4:	657a      	str	r2, [r7, #84]	@ 0x54
200007e6:	222e      	movs	r2, #46	@ 0x2e
200007e8:	701a      	strb	r2, [r3, #0]
		optr += __atox(optr,*tmpptr++,10,0,digits);
200007ea:	6cfb      	ldr	r3, [r7, #76]	@ 0x4c
200007ec:	1c5a      	adds	r2, r3, #1
200007ee:	64fa      	str	r2, [r7, #76]	@ 0x4c
200007f0:	781b      	ldrb	r3, [r3, #0]
200007f2:	4619      	mov	r1, r3
200007f4:	4b84      	ldr	r3, [pc, #528]	@ (20000a08 <xvsprintf+0x4a0>)
200007f6:	9300      	str	r3, [sp, #0]
200007f8:	2300      	movs	r3, #0
200007fa:	220a      	movs	r2, #10
200007fc:	6d78      	ldr	r0, [r7, #84]	@ 0x54
200007fe:	f7ff fdfb 	bl	200003f8 <__atox>
20000802:	4603      	mov	r3, r0
20000804:	461a      	mov	r2, r3
20000806:	6d7b      	ldr	r3, [r7, #84]	@ 0x54
20000808:	4413      	add	r3, r2
2000080a:	657b      	str	r3, [r7, #84]	@ 0x54
		*optr++ = '.';
2000080c:	6d7b      	ldr	r3, [r7, #84]	@ 0x54
2000080e:	1c5a      	adds	r2, r3, #1
20000810:	657a      	str	r2, [r7, #84]	@ 0x54
20000812:	222e      	movs	r2, #46	@ 0x2e
20000814:	701a      	strb	r2, [r3, #0]
		optr += __atox(optr,*tmpptr++,10,0,digits);
20000816:	6cfb      	ldr	r3, [r7, #76]	@ 0x4c
20000818:	1c5a      	adds	r2, r3, #1
2000081a:	64fa      	str	r2, [r7, #76]	@ 0x4c
2000081c:	781b      	ldrb	r3, [r3, #0]
2000081e:	4619      	mov	r1, r3
20000820:	4b79      	ldr	r3, [pc, #484]	@ (20000a08 <xvsprintf+0x4a0>)
20000822:	9300      	str	r3, [sp, #0]
20000824:	2300      	movs	r3, #0
20000826:	220a      	movs	r2, #10
20000828:	6d78      	ldr	r0, [r7, #84]	@ 0x54
2000082a:	f7ff fde5 	bl	200003f8 <__atox>
2000082e:	4603      	mov	r3, r0
20000830:	461a      	mov	r2, r3
20000832:	6d7b      	ldr	r3, [r7, #84]	@ 0x54
20000834:	4413      	add	r3, r2
20000836:	657b      	str	r3, [r7, #84]	@ 0x54
		break;
20000838:	e1c9      	b.n	20000bce <xvsprintf+0x666>
	    case 's':
		tmpptr = (unsigned char *) va_arg(marker,unsigned char *);
2000083a:	687b      	ldr	r3, [r7, #4]
2000083c:	1d1a      	adds	r2, r3, #4
2000083e:	607a      	str	r2, [r7, #4]
20000840:	681b      	ldr	r3, [r3, #0]
20000842:	64fb      	str	r3, [r7, #76]	@ 0x4c
		if (!tmpptr) tmpptr = (unsigned char *) "(null)";
20000844:	6cfb      	ldr	r3, [r7, #76]	@ 0x4c
20000846:	2b00      	cmp	r3, #0
20000848:	d101      	bne.n	2000084e <xvsprintf+0x2e6>
2000084a:	4b70      	ldr	r3, [pc, #448]	@ (20000a0c <xvsprintf+0x4a4>)
2000084c:	64fb      	str	r3, [r7, #76]	@ 0x4c
		if ((width == 0) & (width2 == 0)) {
2000084e:	6b3a      	ldr	r2, [r7, #48]	@ 0x30
20000850:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
20000852:	4313      	orrs	r3, r2
20000854:	2b00      	cmp	r3, #0
20000856:	d118      	bne.n	2000088a <xvsprintf+0x322>
		    while (*tmpptr) *optr++ = *tmpptr++;
20000858:	e007      	b.n	2000086a <xvsprintf+0x302>
2000085a:	6cfa      	ldr	r2, [r7, #76]	@ 0x4c
2000085c:	1c53      	adds	r3, r2, #1
2000085e:	64fb      	str	r3, [r7, #76]	@ 0x4c
20000860:	6d7b      	ldr	r3, [r7, #84]	@ 0x54
20000862:	1c59      	adds	r1, r3, #1
20000864:	6579      	str	r1, [r7, #84]	@ 0x54
20000866:	7812      	ldrb	r2, [r2, #0]
20000868:	701a      	strb	r2, [r3, #0]
2000086a:	6cfb      	ldr	r3, [r7, #76]	@ 0x4c
2000086c:	781b      	ldrb	r3, [r3, #0]
2000086e:	2b00      	cmp	r3, #0
20000870:	d1f3      	bne.n	2000085a <xvsprintf+0x2f2>
		    break;
20000872:	e1ac      	b.n	20000bce <xvsprintf+0x666>
		    }
		while (width && *tmpptr) {
		    *optr++ = *tmpptr++;
20000874:	6cfa      	ldr	r2, [r7, #76]	@ 0x4c
20000876:	1c53      	adds	r3, r2, #1
20000878:	64fb      	str	r3, [r7, #76]	@ 0x4c
2000087a:	6d7b      	ldr	r3, [r7, #84]	@ 0x54
2000087c:	1c59      	adds	r1, r3, #1
2000087e:	6579      	str	r1, [r7, #84]	@ 0x54
20000880:	7812      	ldrb	r2, [r2, #0]
20000882:	701a      	strb	r2, [r3, #0]
		    width--;
20000884:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
20000886:	3b01      	subs	r3, #1
20000888:	633b      	str	r3, [r7, #48]	@ 0x30
		while (width && *tmpptr) {
2000088a:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
2000088c:	2b00      	cmp	r3, #0
2000088e:	d00c      	beq.n	200008aa <xvsprintf+0x342>
20000890:	6cfb      	ldr	r3, [r7, #76]	@ 0x4c
20000892:	781b      	ldrb	r3, [r3, #0]
20000894:	2b00      	cmp	r3, #0
20000896:	d1ed      	bne.n	20000874 <xvsprintf+0x30c>
		    }
		while (width) {
20000898:	e007      	b.n	200008aa <xvsprintf+0x342>
		    *optr++ = ' ';
2000089a:	6d7b      	ldr	r3, [r7, #84]	@ 0x54
2000089c:	1c5a      	adds	r2, r3, #1
2000089e:	657a      	str	r2, [r7, #84]	@ 0x54
200008a0:	2220      	movs	r2, #32
200008a2:	701a      	strb	r2, [r3, #0]
		    width--;
200008a4:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
200008a6:	3b01      	subs	r3, #1
200008a8:	633b      	str	r3, [r7, #48]	@ 0x30
		while (width) {
200008aa:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
200008ac:	2b00      	cmp	r3, #0
200008ae:	d1f4      	bne.n	2000089a <xvsprintf+0x332>
		    }
		break;
200008b0:	e18d      	b.n	20000bce <xvsprintf+0x666>
	    case 'a':
		tmpptr = (unsigned char *) va_arg(marker,unsigned char *);
200008b2:	687b      	ldr	r3, [r7, #4]
200008b4:	1d1a      	adds	r2, r3, #4
200008b6:	607a      	str	r2, [r7, #4]
200008b8:	681b      	ldr	r3, [r3, #0]
200008ba:	64fb      	str	r3, [r7, #76]	@ 0x4c
		for (x = 0; x < 5; x++) {
200008bc:	2300      	movs	r3, #0
200008be:	64bb      	str	r3, [r7, #72]	@ 0x48
200008c0:	e018      	b.n	200008f4 <xvsprintf+0x38c>
		    optr += __atox(optr,*tmpptr++,16,2,digits);
200008c2:	6cfb      	ldr	r3, [r7, #76]	@ 0x4c
200008c4:	1c5a      	adds	r2, r3, #1
200008c6:	64fa      	str	r2, [r7, #76]	@ 0x4c
200008c8:	781b      	ldrb	r3, [r3, #0]
200008ca:	4619      	mov	r1, r3
200008cc:	4b4e      	ldr	r3, [pc, #312]	@ (20000a08 <xvsprintf+0x4a0>)
200008ce:	9300      	str	r3, [sp, #0]
200008d0:	2302      	movs	r3, #2
200008d2:	2210      	movs	r2, #16
200008d4:	6d78      	ldr	r0, [r7, #84]	@ 0x54
200008d6:	f7ff fd8f 	bl	200003f8 <__atox>
200008da:	4603      	mov	r3, r0
200008dc:	461a      	mov	r2, r3
200008de:	6d7b      	ldr	r3, [r7, #84]	@ 0x54
200008e0:	4413      	add	r3, r2
200008e2:	657b      	str	r3, [r7, #84]	@ 0x54
		    *optr++ = '-';
200008e4:	6d7b      	ldr	r3, [r7, #84]	@ 0x54
200008e6:	1c5a      	adds	r2, r3, #1
200008e8:	657a      	str	r2, [r7, #84]	@ 0x54
200008ea:	222d      	movs	r2, #45	@ 0x2d
200008ec:	701a      	strb	r2, [r3, #0]
		for (x = 0; x < 5; x++) {
200008ee:	6cbb      	ldr	r3, [r7, #72]	@ 0x48
200008f0:	3301      	adds	r3, #1
200008f2:	64bb      	str	r3, [r7, #72]	@ 0x48
200008f4:	6cbb      	ldr	r3, [r7, #72]	@ 0x48
200008f6:	2b04      	cmp	r3, #4
200008f8:	dde3      	ble.n	200008c2 <xvsprintf+0x35a>
		    }
		optr += __atox(optr,*tmpptr++,16,2,digits);
200008fa:	6cfb      	ldr	r3, [r7, #76]	@ 0x4c
200008fc:	1c5a      	adds	r2, r3, #1
200008fe:	64fa      	str	r2, [r7, #76]	@ 0x4c
20000900:	781b      	ldrb	r3, [r3, #0]
20000902:	4619      	mov	r1, r3
20000904:	4b40      	ldr	r3, [pc, #256]	@ (20000a08 <xvsprintf+0x4a0>)
20000906:	9300      	str	r3, [sp, #0]
20000908:	2302      	movs	r3, #2
2000090a:	2210      	movs	r2, #16
2000090c:	6d78      	ldr	r0, [r7, #84]	@ 0x54
2000090e:	f7ff fd73 	bl	200003f8 <__atox>
20000912:	4603      	mov	r3, r0
20000914:	461a      	mov	r2, r3
20000916:	6d7b      	ldr	r3, [r7, #84]	@ 0x54
20000918:	4413      	add	r3, r2
2000091a:	657b      	str	r3, [r7, #84]	@ 0x54
		break;
2000091c:	e157      	b.n	20000bce <xvsprintf+0x666>
2000091e:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
20000920:	2b01      	cmp	r3, #1
20000922:	dc03      	bgt.n	2000092c <xvsprintf+0x3c4>
20000924:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
20000926:	2b00      	cmp	r3, #0
20000928:	da04      	bge.n	20000934 <xvsprintf+0x3cc>
			ll = va_arg(marker,long long int);
			if (ll < 0) { *optr++='-'; ll = -ll;}
			optr += __llatox(optr,ll,10,width,digits);
			break;
		    }
		break;
2000092a:	e150      	b.n	20000bce <xvsprintf+0x666>
2000092c:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
2000092e:	2b02      	cmp	r3, #2
20000930:	d01e      	beq.n	20000970 <xvsprintf+0x408>
20000932:	e14c      	b.n	20000bce <xvsprintf+0x666>
			i = va_arg(marker,int);
20000934:	687b      	ldr	r3, [r7, #4]
20000936:	1d1a      	adds	r2, r3, #4
20000938:	607a      	str	r2, [r7, #4]
2000093a:	681b      	ldr	r3, [r3, #0]
2000093c:	647b      	str	r3, [r7, #68]	@ 0x44
			if (i < 0) { *optr++='-'; i = -i;}
2000093e:	6c7b      	ldr	r3, [r7, #68]	@ 0x44
20000940:	2b00      	cmp	r3, #0
20000942:	da07      	bge.n	20000954 <xvsprintf+0x3ec>
20000944:	6d7b      	ldr	r3, [r7, #84]	@ 0x54
20000946:	1c5a      	adds	r2, r3, #1
20000948:	657a      	str	r2, [r7, #84]	@ 0x54
2000094a:	222d      	movs	r2, #45	@ 0x2d
2000094c:	701a      	strb	r2, [r3, #0]
2000094e:	6c7b      	ldr	r3, [r7, #68]	@ 0x44
20000950:	425b      	negs	r3, r3
20000952:	647b      	str	r3, [r7, #68]	@ 0x44
			optr += __atox(optr,i,10,width,digits);
20000954:	6c79      	ldr	r1, [r7, #68]	@ 0x44
20000956:	4b2c      	ldr	r3, [pc, #176]	@ (20000a08 <xvsprintf+0x4a0>)
20000958:	9300      	str	r3, [sp, #0]
2000095a:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
2000095c:	220a      	movs	r2, #10
2000095e:	6d78      	ldr	r0, [r7, #84]	@ 0x54
20000960:	f7ff fd4a 	bl	200003f8 <__atox>
20000964:	4603      	mov	r3, r0
20000966:	461a      	mov	r2, r3
20000968:	6d7b      	ldr	r3, [r7, #84]	@ 0x54
2000096a:	4413      	add	r3, r2
2000096c:	657b      	str	r3, [r7, #84]	@ 0x54
			break;
2000096e:	e02c      	b.n	200009ca <xvsprintf+0x462>
			ll = va_arg(marker,long long int);
20000970:	687b      	ldr	r3, [r7, #4]
20000972:	3307      	adds	r3, #7
20000974:	f023 0307 	bic.w	r3, r3, #7
20000978:	f103 0208 	add.w	r2, r3, #8
2000097c:	607a      	str	r2, [r7, #4]
2000097e:	e9d3 2300 	ldrd	r2, r3, [r3]
20000982:	e9c7 230e 	strd	r2, r3, [r7, #56]	@ 0x38
			if (ll < 0) { *optr++='-'; ll = -ll;}
20000986:	e9d7 230e 	ldrd	r2, r3, [r7, #56]	@ 0x38
2000098a:	2b00      	cmp	r3, #0
2000098c:	da0c      	bge.n	200009a8 <xvsprintf+0x440>
2000098e:	6d7b      	ldr	r3, [r7, #84]	@ 0x54
20000990:	1c5a      	adds	r2, r3, #1
20000992:	657a      	str	r2, [r7, #84]	@ 0x54
20000994:	222d      	movs	r2, #45	@ 0x2d
20000996:	701a      	strb	r2, [r3, #0]
20000998:	e9d7 230e 	ldrd	r2, r3, [r7, #56]	@ 0x38
2000099c:	2100      	movs	r1, #0
2000099e:	4254      	negs	r4, r2
200009a0:	eb61 0503 	sbc.w	r5, r1, r3
200009a4:	e9c7 450e 	strd	r4, r5, [r7, #56]	@ 0x38
			optr += __llatox(optr,ll,10,width,digits);
200009a8:	e9d7 230e 	ldrd	r2, r3, [r7, #56]	@ 0x38
200009ac:	4916      	ldr	r1, [pc, #88]	@ (20000a08 <xvsprintf+0x4a0>)
200009ae:	9102      	str	r1, [sp, #8]
200009b0:	6b39      	ldr	r1, [r7, #48]	@ 0x30
200009b2:	9101      	str	r1, [sp, #4]
200009b4:	210a      	movs	r1, #10
200009b6:	9100      	str	r1, [sp, #0]
200009b8:	6d78      	ldr	r0, [r7, #84]	@ 0x54
200009ba:	f7ff fd73 	bl	200004a4 <__llatox>
200009be:	4603      	mov	r3, r0
200009c0:	461a      	mov	r2, r3
200009c2:	6d7b      	ldr	r3, [r7, #84]	@ 0x54
200009c4:	4413      	add	r3, r2
200009c6:	657b      	str	r3, [r7, #84]	@ 0x54
			break;
200009c8:	bf00      	nop
		break;
200009ca:	e100      	b.n	20000bce <xvsprintf+0x666>
200009cc:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
200009ce:	2b01      	cmp	r3, #1
200009d0:	dc03      	bgt.n	200009da <xvsprintf+0x472>
200009d2:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
200009d4:	2b00      	cmp	r3, #0
200009d6:	da04      	bge.n	200009e2 <xvsprintf+0x47a>
		    case 2:
			ulx = va_arg(marker,unsigned long long);
			optr += __llatox(optr,ulx,10,width,digits);
			break;
		    }
		break;
200009d8:	e0f9      	b.n	20000bce <xvsprintf+0x666>
200009da:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
200009dc:	2b02      	cmp	r3, #2
200009de:	d017      	beq.n	20000a10 <xvsprintf+0x4a8>
200009e0:	e0f5      	b.n	20000bce <xvsprintf+0x666>
			ux = va_arg(marker,unsigned int);
200009e2:	687b      	ldr	r3, [r7, #4]
200009e4:	1d1a      	adds	r2, r3, #4
200009e6:	607a      	str	r2, [r7, #4]
200009e8:	681b      	ldr	r3, [r3, #0]
200009ea:	617b      	str	r3, [r7, #20]
			optr += __atox(optr,ux,10,width,digits);
200009ec:	4b06      	ldr	r3, [pc, #24]	@ (20000a08 <xvsprintf+0x4a0>)
200009ee:	9300      	str	r3, [sp, #0]
200009f0:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
200009f2:	220a      	movs	r2, #10
200009f4:	6979      	ldr	r1, [r7, #20]
200009f6:	6d78      	ldr	r0, [r7, #84]	@ 0x54
200009f8:	f7ff fcfe 	bl	200003f8 <__atox>
200009fc:	4603      	mov	r3, r0
200009fe:	461a      	mov	r2, r3
20000a00:	6d7b      	ldr	r3, [r7, #84]	@ 0x54
20000a02:	4413      	add	r3, r2
20000a04:	657b      	str	r3, [r7, #84]	@ 0x54
			break;
20000a06:	e01f      	b.n	20000a48 <xvsprintf+0x4e0>
20000a08:	2000489c 	.word	0x2000489c
20000a0c:	20004464 	.word	0x20004464
			ulx = va_arg(marker,unsigned long long);
20000a10:	687b      	ldr	r3, [r7, #4]
20000a12:	3307      	adds	r3, #7
20000a14:	f023 0307 	bic.w	r3, r3, #7
20000a18:	f103 0208 	add.w	r2, r3, #8
20000a1c:	607a      	str	r2, [r7, #4]
20000a1e:	e9d3 2300 	ldrd	r2, r3, [r3]
20000a22:	e9c7 2306 	strd	r2, r3, [r7, #24]
			optr += __llatox(optr,ulx,10,width,digits);
20000a26:	4b73      	ldr	r3, [pc, #460]	@ (20000bf4 <xvsprintf+0x68c>)
20000a28:	9302      	str	r3, [sp, #8]
20000a2a:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
20000a2c:	9301      	str	r3, [sp, #4]
20000a2e:	230a      	movs	r3, #10
20000a30:	9300      	str	r3, [sp, #0]
20000a32:	e9d7 2306 	ldrd	r2, r3, [r7, #24]
20000a36:	6d78      	ldr	r0, [r7, #84]	@ 0x54
20000a38:	f7ff fd34 	bl	200004a4 <__llatox>
20000a3c:	4603      	mov	r3, r0
20000a3e:	461a      	mov	r2, r3
20000a40:	6d7b      	ldr	r3, [r7, #84]	@ 0x54
20000a42:	4413      	add	r3, r2
20000a44:	657b      	str	r3, [r7, #84]	@ 0x54
			break;
20000a46:	bf00      	nop
		break;
20000a48:	e0c1      	b.n	20000bce <xvsprintf+0x666>
20000a4a:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
20000a4c:	2b01      	cmp	r3, #1
20000a4e:	dc03      	bgt.n	20000a58 <xvsprintf+0x4f0>
20000a50:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
20000a52:	2b00      	cmp	r3, #0
20000a54:	da04      	bge.n	20000a60 <xvsprintf+0x4f8>
			ulx = va_arg(marker,unsigned long long);
			optr += __llatox(optr,ulx,16,width,
				       (*iptr == 'X') ? digits : ldigits);
			break;
		    }
		break;
20000a56:	e0ba      	b.n	20000bce <xvsprintf+0x666>
20000a58:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
20000a5a:	2b02      	cmp	r3, #2
20000a5c:	d019      	beq.n	20000a92 <xvsprintf+0x52a>
20000a5e:	e0b6      	b.n	20000bce <xvsprintf+0x666>
			ux = va_arg(marker,unsigned int);
20000a60:	687b      	ldr	r3, [r7, #4]
20000a62:	1d1a      	adds	r2, r3, #4
20000a64:	607a      	str	r2, [r7, #4]
20000a66:	681b      	ldr	r3, [r3, #0]
20000a68:	617b      	str	r3, [r7, #20]
				       (*iptr == 'X') ? digits : ldigits);
20000a6a:	6d3b      	ldr	r3, [r7, #80]	@ 0x50
20000a6c:	781b      	ldrb	r3, [r3, #0]
			optr += __atox(optr,ux,16,width,
20000a6e:	2b58      	cmp	r3, #88	@ 0x58
20000a70:	d101      	bne.n	20000a76 <xvsprintf+0x50e>
20000a72:	4b60      	ldr	r3, [pc, #384]	@ (20000bf4 <xvsprintf+0x68c>)
20000a74:	e000      	b.n	20000a78 <xvsprintf+0x510>
20000a76:	4b60      	ldr	r3, [pc, #384]	@ (20000bf8 <xvsprintf+0x690>)
20000a78:	9300      	str	r3, [sp, #0]
20000a7a:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
20000a7c:	2210      	movs	r2, #16
20000a7e:	6979      	ldr	r1, [r7, #20]
20000a80:	6d78      	ldr	r0, [r7, #84]	@ 0x54
20000a82:	f7ff fcb9 	bl	200003f8 <__atox>
20000a86:	4603      	mov	r3, r0
20000a88:	461a      	mov	r2, r3
20000a8a:	6d7b      	ldr	r3, [r7, #84]	@ 0x54
20000a8c:	4413      	add	r3, r2
20000a8e:	657b      	str	r3, [r7, #84]	@ 0x54
			break;
20000a90:	e021      	b.n	20000ad6 <xvsprintf+0x56e>
			ulx = va_arg(marker,unsigned long long);
20000a92:	687b      	ldr	r3, [r7, #4]
20000a94:	3307      	adds	r3, #7
20000a96:	f023 0307 	bic.w	r3, r3, #7
20000a9a:	f103 0208 	add.w	r2, r3, #8
20000a9e:	607a      	str	r2, [r7, #4]
20000aa0:	e9d3 2300 	ldrd	r2, r3, [r3]
20000aa4:	e9c7 2306 	strd	r2, r3, [r7, #24]
				       (*iptr == 'X') ? digits : ldigits);
20000aa8:	6d3b      	ldr	r3, [r7, #80]	@ 0x50
20000aaa:	781b      	ldrb	r3, [r3, #0]
			optr += __llatox(optr,ulx,16,width,
20000aac:	2b58      	cmp	r3, #88	@ 0x58
20000aae:	d101      	bne.n	20000ab4 <xvsprintf+0x54c>
20000ab0:	4b50      	ldr	r3, [pc, #320]	@ (20000bf4 <xvsprintf+0x68c>)
20000ab2:	e000      	b.n	20000ab6 <xvsprintf+0x54e>
20000ab4:	4b50      	ldr	r3, [pc, #320]	@ (20000bf8 <xvsprintf+0x690>)
20000ab6:	9302      	str	r3, [sp, #8]
20000ab8:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
20000aba:	9301      	str	r3, [sp, #4]
20000abc:	2310      	movs	r3, #16
20000abe:	9300      	str	r3, [sp, #0]
20000ac0:	e9d7 2306 	ldrd	r2, r3, [r7, #24]
20000ac4:	6d78      	ldr	r0, [r7, #84]	@ 0x54
20000ac6:	f7ff fced 	bl	200004a4 <__llatox>
20000aca:	4603      	mov	r3, r0
20000acc:	461a      	mov	r2, r3
20000ace:	6d7b      	ldr	r3, [r7, #84]	@ 0x54
20000ad0:	4413      	add	r3, r2
20000ad2:	657b      	str	r3, [r7, #84]	@ 0x54
			break;
20000ad4:	bf00      	nop
		break;
20000ad6:	e07a      	b.n	20000bce <xvsprintf+0x666>
#ifdef __long64
		lx = va_arg(marker,long long);
		optr += __llatox(optr,lx,16,16,
				 (*iptr == 'P') ? digits : ldigits);
#else
		x = va_arg(marker,long);
20000ad8:	687b      	ldr	r3, [r7, #4]
20000ada:	1d1a      	adds	r2, r3, #4
20000adc:	607a      	str	r2, [r7, #4]
20000ade:	681b      	ldr	r3, [r3, #0]
20000ae0:	64bb      	str	r3, [r7, #72]	@ 0x48
		optr += __atox(optr,x,16,8,
20000ae2:	6cb9      	ldr	r1, [r7, #72]	@ 0x48
			       (*iptr == 'P') ? digits : ldigits);
20000ae4:	6d3b      	ldr	r3, [r7, #80]	@ 0x50
20000ae6:	781b      	ldrb	r3, [r3, #0]
		optr += __atox(optr,x,16,8,
20000ae8:	2b50      	cmp	r3, #80	@ 0x50
20000aea:	d101      	bne.n	20000af0 <xvsprintf+0x588>
20000aec:	4b41      	ldr	r3, [pc, #260]	@ (20000bf4 <xvsprintf+0x68c>)
20000aee:	e000      	b.n	20000af2 <xvsprintf+0x58a>
20000af0:	4b41      	ldr	r3, [pc, #260]	@ (20000bf8 <xvsprintf+0x690>)
20000af2:	9300      	str	r3, [sp, #0]
20000af4:	2308      	movs	r3, #8
20000af6:	2210      	movs	r2, #16
20000af8:	6d78      	ldr	r0, [r7, #84]	@ 0x54
20000afa:	f7ff fc7d 	bl	200003f8 <__atox>
20000afe:	4603      	mov	r3, r0
20000b00:	461a      	mov	r2, r3
20000b02:	6d7b      	ldr	r3, [r7, #84]	@ 0x54
20000b04:	4413      	add	r3, r2
20000b06:	657b      	str	r3, [r7, #84]	@ 0x54
#endif
		break;
20000b08:	e061      	b.n	20000bce <xvsprintf+0x666>
	    case 'w':
		x = va_arg(marker,unsigned int);
20000b0a:	687b      	ldr	r3, [r7, #4]
20000b0c:	1d1a      	adds	r2, r3, #4
20000b0e:	607a      	str	r2, [r7, #4]
20000b10:	681b      	ldr	r3, [r3, #0]
20000b12:	64bb      	str	r3, [r7, #72]	@ 0x48
	        x &= 0x0000FFFF;
20000b14:	6cbb      	ldr	r3, [r7, #72]	@ 0x48
20000b16:	b29b      	uxth	r3, r3
20000b18:	64bb      	str	r3, [r7, #72]	@ 0x48
		optr += __atox(optr,x,16,4,digits);
20000b1a:	6cb9      	ldr	r1, [r7, #72]	@ 0x48
20000b1c:	4b35      	ldr	r3, [pc, #212]	@ (20000bf4 <xvsprintf+0x68c>)
20000b1e:	9300      	str	r3, [sp, #0]
20000b20:	2304      	movs	r3, #4
20000b22:	2210      	movs	r2, #16
20000b24:	6d78      	ldr	r0, [r7, #84]	@ 0x54
20000b26:	f7ff fc67 	bl	200003f8 <__atox>
20000b2a:	4603      	mov	r3, r0
20000b2c:	461a      	mov	r2, r3
20000b2e:	6d7b      	ldr	r3, [r7, #84]	@ 0x54
20000b30:	4413      	add	r3, r2
20000b32:	657b      	str	r3, [r7, #84]	@ 0x54
		break;
20000b34:	e04b      	b.n	20000bce <xvsprintf+0x666>
	    case 'b':
		x = va_arg(marker,unsigned int);
20000b36:	687b      	ldr	r3, [r7, #4]
20000b38:	1d1a      	adds	r2, r3, #4
20000b3a:	607a      	str	r2, [r7, #4]
20000b3c:	681b      	ldr	r3, [r3, #0]
20000b3e:	64bb      	str	r3, [r7, #72]	@ 0x48
	        x &= 0x0000FF;
20000b40:	6cbb      	ldr	r3, [r7, #72]	@ 0x48
20000b42:	b2db      	uxtb	r3, r3
20000b44:	64bb      	str	r3, [r7, #72]	@ 0x48
		optr += __atox(optr,x,16,2,digits);
20000b46:	6cb9      	ldr	r1, [r7, #72]	@ 0x48
20000b48:	4b2a      	ldr	r3, [pc, #168]	@ (20000bf4 <xvsprintf+0x68c>)
20000b4a:	9300      	str	r3, [sp, #0]
20000b4c:	2302      	movs	r3, #2
20000b4e:	2210      	movs	r2, #16
20000b50:	6d78      	ldr	r0, [r7, #84]	@ 0x54
20000b52:	f7ff fc51 	bl	200003f8 <__atox>
20000b56:	4603      	mov	r3, r0
20000b58:	461a      	mov	r2, r3
20000b5a:	6d7b      	ldr	r3, [r7, #84]	@ 0x54
20000b5c:	4413      	add	r3, r2
20000b5e:	657b      	str	r3, [r7, #84]	@ 0x54
		break;
20000b60:	e035      	b.n	20000bce <xvsprintf+0x666>
	    case 'Z':
		x = va_arg(marker,unsigned int);
20000b62:	687b      	ldr	r3, [r7, #4]
20000b64:	1d1a      	adds	r2, r3, #4
20000b66:	607a      	str	r2, [r7, #4]
20000b68:	681b      	ldr	r3, [r3, #0]
20000b6a:	64bb      	str	r3, [r7, #72]	@ 0x48
		tmpptr = va_arg(marker,unsigned char *);
20000b6c:	687b      	ldr	r3, [r7, #4]
20000b6e:	1d1a      	adds	r2, r3, #4
20000b70:	607a      	str	r2, [r7, #4]
20000b72:	681b      	ldr	r3, [r3, #0]
20000b74:	64fb      	str	r3, [r7, #76]	@ 0x4c
		while (x) {
20000b76:	e013      	b.n	20000ba0 <xvsprintf+0x638>
		    optr += __atox(optr,*tmpptr++,16,2,digits);
20000b78:	6cfb      	ldr	r3, [r7, #76]	@ 0x4c
20000b7a:	1c5a      	adds	r2, r3, #1
20000b7c:	64fa      	str	r2, [r7, #76]	@ 0x4c
20000b7e:	781b      	ldrb	r3, [r3, #0]
20000b80:	4619      	mov	r1, r3
20000b82:	4b1c      	ldr	r3, [pc, #112]	@ (20000bf4 <xvsprintf+0x68c>)
20000b84:	9300      	str	r3, [sp, #0]
20000b86:	2302      	movs	r3, #2
20000b88:	2210      	movs	r2, #16
20000b8a:	6d78      	ldr	r0, [r7, #84]	@ 0x54
20000b8c:	f7ff fc34 	bl	200003f8 <__atox>
20000b90:	4603      	mov	r3, r0
20000b92:	461a      	mov	r2, r3
20000b94:	6d7b      	ldr	r3, [r7, #84]	@ 0x54
20000b96:	4413      	add	r3, r2
20000b98:	657b      	str	r3, [r7, #84]	@ 0x54
		    x--;
20000b9a:	6cbb      	ldr	r3, [r7, #72]	@ 0x48
20000b9c:	3b01      	subs	r3, #1
20000b9e:	64bb      	str	r3, [r7, #72]	@ 0x48
		while (x) {
20000ba0:	6cbb      	ldr	r3, [r7, #72]	@ 0x48
20000ba2:	2b00      	cmp	r3, #0
20000ba4:	d1e8      	bne.n	20000b78 <xvsprintf+0x610>
		    }
		break;
20000ba6:	e012      	b.n	20000bce <xvsprintf+0x666>
	    case 'c':
		x = va_arg(marker, int);
20000ba8:	687b      	ldr	r3, [r7, #4]
20000baa:	1d1a      	adds	r2, r3, #4
20000bac:	607a      	str	r2, [r7, #4]
20000bae:	681b      	ldr	r3, [r3, #0]
20000bb0:	64bb      	str	r3, [r7, #72]	@ 0x48
		*optr++ = x & 0xff;
20000bb2:	6d7b      	ldr	r3, [r7, #84]	@ 0x54
20000bb4:	1c5a      	adds	r2, r3, #1
20000bb6:	657a      	str	r2, [r7, #84]	@ 0x54
20000bb8:	6cba      	ldr	r2, [r7, #72]	@ 0x48
20000bba:	b2d2      	uxtb	r2, r2
20000bbc:	701a      	strb	r2, [r3, #0]
		break;
20000bbe:	e006      	b.n	20000bce <xvsprintf+0x666>

	    default:
		*optr++ = *iptr;
20000bc0:	6d7b      	ldr	r3, [r7, #84]	@ 0x54
20000bc2:	1c5a      	adds	r2, r3, #1
20000bc4:	657a      	str	r2, [r7, #84]	@ 0x54
20000bc6:	6d3a      	ldr	r2, [r7, #80]	@ 0x50
20000bc8:	7812      	ldrb	r2, [r2, #0]
20000bca:	701a      	strb	r2, [r3, #0]
		break;
20000bcc:	bf00      	nop
	    }
	iptr++;
20000bce:	6d3b      	ldr	r3, [r7, #80]	@ 0x50
20000bd0:	3301      	adds	r3, #1
20000bd2:	653b      	str	r3, [r7, #80]	@ 0x50
    while (*iptr) {
20000bd4:	6d3b      	ldr	r3, [r7, #80]	@ 0x50
20000bd6:	781b      	ldrb	r3, [r3, #0]
20000bd8:	2b00      	cmp	r3, #0
20000bda:	f47f acd4 	bne.w	20000586 <xvsprintf+0x1e>
	}

 //   *optr++ = '\r';
 //   *optr++ = '\n';
    *optr = '\0';
20000bde:	6d7b      	ldr	r3, [r7, #84]	@ 0x54
20000be0:	2200      	movs	r2, #0
20000be2:	701a      	strb	r2, [r3, #0]

    return (optr - outbuf);
20000be4:	6d7a      	ldr	r2, [r7, #84]	@ 0x54
20000be6:	68fb      	ldr	r3, [r7, #12]
20000be8:	1ad3      	subs	r3, r2, r3
}
20000bea:	4618      	mov	r0, r3
20000bec:	3758      	adds	r7, #88	@ 0x58
20000bee:	46bd      	mov	sp, r7
20000bf0:	bdb0      	pop	{r4, r5, r7, pc}
20000bf2:	bf00      	nop
20000bf4:	2000489c 	.word	0x2000489c
20000bf8:	200048b0 	.word	0x200048b0

20000bfc <xsprintf>:
    *
    *  Return Value:
    *      number of bytes copied to buffer
    ********************************************************************* */
int xsprintf(char *buf,const char *templat,...)
{
20000bfc:	b40e      	push	{r1, r2, r3}
20000bfe:	b580      	push	{r7, lr}
20000c00:	b085      	sub	sp, #20
20000c02:	af00      	add	r7, sp, #0
20000c04:	6078      	str	r0, [r7, #4]
    va_list marker;
    int count;

    va_start(marker,templat);
20000c06:	f107 0320 	add.w	r3, r7, #32
20000c0a:	60bb      	str	r3, [r7, #8]
    count = xvsprintf(buf,templat,marker);
20000c0c:	68ba      	ldr	r2, [r7, #8]
20000c0e:	69f9      	ldr	r1, [r7, #28]
20000c10:	6878      	ldr	r0, [r7, #4]
20000c12:	f7ff fca9 	bl	20000568 <xvsprintf>
20000c16:	60f8      	str	r0, [r7, #12]
    va_end(marker);

    return count;
20000c18:	68fb      	ldr	r3, [r7, #12]
}
20000c1a:	4618      	mov	r0, r3
20000c1c:	3714      	adds	r7, #20
20000c1e:	46bd      	mov	sp, r7
20000c20:	e8bd 4080 	ldmia.w	sp!, {r7, lr}
20000c24:	b003      	add	sp, #12
20000c26:	4770      	bx	lr

20000c28 <printf>:
    *  Return value:
    *  	   number of bytes written
    ********************************************************************* */

int printf(const char *templat,...)
{
20000c28:	b40f      	push	{r0, r1, r2, r3}
20000c2a:	b580      	push	{r7, lr}
20000c2c:	f5ad 7d04 	sub.w	sp, sp, #528	@ 0x210
20000c30:	af00      	add	r7, sp, #0
    va_list marker;
    int count;
    char buffer[512];

    va_start(marker,templat);
20000c32:	f507 7307 	add.w	r3, r7, #540	@ 0x21c
20000c36:	f8c7 3204 	str.w	r3, [r7, #516]	@ 0x204
    count = xvsprintf(buffer,templat,marker);
20000c3a:	1d3b      	adds	r3, r7, #4
20000c3c:	f8d7 2204 	ldr.w	r2, [r7, #516]	@ 0x204
20000c40:	f8d7 1218 	ldr.w	r1, [r7, #536]	@ 0x218
20000c44:	4618      	mov	r0, r3
20000c46:	f7ff fc8f 	bl	20000568 <xvsprintf>
20000c4a:	f8c7 0208 	str.w	r0, [r7, #520]	@ 0x208
    va_end(marker);


    for(int i = 0; i< count; i++){
20000c4e:	2300      	movs	r3, #0
20000c50:	f8c7 320c 	str.w	r3, [r7, #524]	@ 0x20c
20000c54:	e00f      	b.n	20000c76 <printf+0x4e>
    	putc(buffer[i]);
20000c56:	f507 7304 	add.w	r3, r7, #528	@ 0x210
20000c5a:	f5a3 7203 	sub.w	r2, r3, #524	@ 0x20c
20000c5e:	f8d7 320c 	ldr.w	r3, [r7, #524]	@ 0x20c
20000c62:	4413      	add	r3, r2
20000c64:	781b      	ldrb	r3, [r3, #0]
20000c66:	4618      	mov	r0, r3
20000c68:	f000 f816 	bl	20000c98 <putc>
    for(int i = 0; i< count; i++){
20000c6c:	f8d7 320c 	ldr.w	r3, [r7, #524]	@ 0x20c
20000c70:	3301      	adds	r3, #1
20000c72:	f8c7 320c 	str.w	r3, [r7, #524]	@ 0x20c
20000c76:	f8d7 220c 	ldr.w	r2, [r7, #524]	@ 0x20c
20000c7a:	f8d7 3208 	ldr.w	r3, [r7, #520]	@ 0x208
20000c7e:	429a      	cmp	r2, r3
20000c80:	dbe9      	blt.n	20000c56 <printf+0x2e>
    }

    return count;
20000c82:	f8d7 3208 	ldr.w	r3, [r7, #520]	@ 0x208
}
20000c86:	4618      	mov	r0, r3
20000c88:	f507 7704 	add.w	r7, r7, #528	@ 0x210
20000c8c:	46bd      	mov	sp, r7
20000c8e:	e8bd 4080 	ldmia.w	sp!, {r7, lr}
20000c92:	b004      	add	sp, #16
20000c94:	4770      	bx	lr
	...

20000c98 <putc>:
	for(int i = 0; i< strlen(str); i++)
		putc(*str++);
}


void putc(char c) {
20000c98:	b480      	push	{r7}
20000c9a:	b085      	sub	sp, #20
20000c9c:	af00      	add	r7, sp, #0
20000c9e:	4603      	mov	r3, r0
20000ca0:	71fb      	strb	r3, [r7, #7]
    volatile uint32_t *usart_isr = (volatile uint32_t *)(0x40013800 + 0x1C);
20000ca2:	4b0a      	ldr	r3, [pc, #40]	@ (20000ccc <putc+0x34>)
20000ca4:	60fb      	str	r3, [r7, #12]
    volatile uint32_t *usart_tdr = (volatile uint32_t *)(0x40013800 + 0x28);
20000ca6:	4b0a      	ldr	r3, [pc, #40]	@ (20000cd0 <putc+0x38>)
20000ca8:	60bb      	str	r3, [r7, #8]

    while((*usart_isr & (1 << 7)) == 0);
20000caa:	bf00      	nop
20000cac:	68fb      	ldr	r3, [r7, #12]
20000cae:	681b      	ldr	r3, [r3, #0]
20000cb0:	f003 0380 	and.w	r3, r3, #128	@ 0x80
20000cb4:	2b00      	cmp	r3, #0
20000cb6:	d0f9      	beq.n	20000cac <putc+0x14>


    *usart_tdr = c;
20000cb8:	79fa      	ldrb	r2, [r7, #7]
20000cba:	68bb      	ldr	r3, [r7, #8]
20000cbc:	601a      	str	r2, [r3, #0]
}
20000cbe:	bf00      	nop
20000cc0:	3714      	adds	r7, #20
20000cc2:	46bd      	mov	sp, r7
20000cc4:	f85d 7b04 	ldr.w	r7, [sp], #4
20000cc8:	4770      	bx	lr
20000cca:	bf00      	nop
20000ccc:	4001381c 	.word	0x4001381c
20000cd0:	40013828 	.word	0x40013828

20000cd4 <puts>:

void puts(const char *templat,...) {
20000cd4:	b40f      	push	{r0, r1, r2, r3}
20000cd6:	b580      	push	{r7, lr}
20000cd8:	af00      	add	r7, sp, #0
    printf(templat);
20000cda:	68b8      	ldr	r0, [r7, #8]
20000cdc:	f7ff ffa4 	bl	20000c28 <printf>
}
20000ce0:	bf00      	nop
20000ce2:	46bd      	mov	sp, r7
20000ce4:	e8bd 4080 	ldmia.w	sp!, {r7, lr}
20000ce8:	b004      	add	sp, #16
20000cea:	4770      	bx	lr

20000cec <putchar>:

void putchar(char c) {
20000cec:	b480      	push	{r7}
20000cee:	b085      	sub	sp, #20
20000cf0:	af00      	add	r7, sp, #0
20000cf2:	4603      	mov	r3, r0
20000cf4:	71fb      	strb	r3, [r7, #7]
    volatile uint32_t *usart_isr = (volatile uint32_t *)(0x40013800 + 0x1C);
20000cf6:	4b0a      	ldr	r3, [pc, #40]	@ (20000d20 <putchar+0x34>)
20000cf8:	60fb      	str	r3, [r7, #12]
    volatile uint32_t *usart_tdr = (volatile uint32_t *)(0x40013800 + 0x28);
20000cfa:	4b0a      	ldr	r3, [pc, #40]	@ (20000d24 <putchar+0x38>)
20000cfc:	60bb      	str	r3, [r7, #8]

    while((*usart_isr & (1 << 7)) == 0);
20000cfe:	bf00      	nop
20000d00:	68fb      	ldr	r3, [r7, #12]
20000d02:	681b      	ldr	r3, [r3, #0]
20000d04:	f003 0380 	and.w	r3, r3, #128	@ 0x80
20000d08:	2b00      	cmp	r3, #0
20000d0a:	d0f9      	beq.n	20000d00 <putchar+0x14>


    *usart_tdr = c;
20000d0c:	79fa      	ldrb	r2, [r7, #7]
20000d0e:	68bb      	ldr	r3, [r7, #8]
20000d10:	601a      	str	r2, [r3, #0]
}
20000d12:	bf00      	nop
20000d14:	3714      	adds	r7, #20
20000d16:	46bd      	mov	sp, r7
20000d18:	f85d 7b04 	ldr.w	r7, [sp], #4
20000d1c:	4770      	bx	lr
20000d1e:	bf00      	nop
20000d20:	4001381c 	.word	0x4001381c
20000d24:	40013828 	.word	0x40013828

20000d28 <stm32_uart_probe>:

static void
stm32_uart_probe(cfe_driver_t *drv,
		    unsigned long probe_a, unsigned long probe_b,
		    void *probe_ptr)
{
20000d28:	b580      	push	{r7, lr}
20000d2a:	b084      	sub	sp, #16
20000d2c:	af00      	add	r7, sp, #0
20000d2e:	60f8      	str	r0, [r7, #12]
20000d30:	60b9      	str	r1, [r7, #8]
20000d32:	607a      	str	r2, [r7, #4]
20000d34:	603b      	str	r3, [r7, #0]
    cfe_attach(drv, NULL, NULL, NULL);
20000d36:	2300      	movs	r3, #0
20000d38:	2200      	movs	r2, #0
20000d3a:	2100      	movs	r1, #0
20000d3c:	68f8      	ldr	r0, [r7, #12]
20000d3e:	f000 fc5b 	bl	200015f8 <cfe_attach>
}
20000d42:	bf00      	nop
20000d44:	3710      	adds	r7, #16
20000d46:	46bd      	mov	sp, r7
20000d48:	bd80      	pop	{r7, pc}

20000d4a <stm32_uart_open>:

static int
stm32_uart_open(cfe_devctx_t *ctx) {
20000d4a:	b480      	push	{r7}
20000d4c:	b083      	sub	sp, #12
20000d4e:	af00      	add	r7, sp, #0
20000d50:	6078      	str	r0, [r7, #4]

   return 0;
20000d52:	2300      	movs	r3, #0
}
20000d54:	4618      	mov	r0, r3
20000d56:	370c      	adds	r7, #12
20000d58:	46bd      	mov	sp, r7
20000d5a:	f85d 7b04 	ldr.w	r7, [sp], #4
20000d5e:	4770      	bx	lr

20000d60 <stm32_uart_read>:


static int
stm32_uart_read(cfe_devctx_t *ctx, iocb_buffer_t *buffer)
{
20000d60:	b480      	push	{r7}
20000d62:	b089      	sub	sp, #36	@ 0x24
20000d64:	af00      	add	r7, sp, #0
20000d66:	6078      	str	r0, [r7, #4]
20000d68:	6039      	str	r1, [r7, #0]
    volatile uint32_t *LPUART_ISR = (uint32_t *)(0x40013800 + 0x1C);
20000d6a:	4b13      	ldr	r3, [pc, #76]	@ (20000db8 <stm32_uart_read+0x58>)
20000d6c:	61bb      	str	r3, [r7, #24]
    volatile uint32_t *LPUART_RDR = (uint32_t *)(0x40013800 + 0x24);
20000d6e:	4b13      	ldr	r3, [pc, #76]	@ (20000dbc <stm32_uart_read+0x5c>)
20000d70:	617b      	str	r3, [r7, #20]
    char *ptr = buffer->buf_ptr;
20000d72:	683b      	ldr	r3, [r7, #0]
20000d74:	689b      	ldr	r3, [r3, #8]
20000d76:	613b      	str	r3, [r7, #16]
    uint32_t len = buffer->buf_length;
20000d78:	683b      	ldr	r3, [r7, #0]
20000d7a:	68db      	ldr	r3, [r3, #12]
20000d7c:	61fb      	str	r3, [r7, #28]
    uint32_t read_len = 0;
20000d7e:	2300      	movs	r3, #0
20000d80:	60fb      	str	r3, [r7, #12]

    while (len > 0)
20000d82:	e00d      	b.n	20000da0 <stm32_uart_read+0x40>
    {
        if (*LPUART_ISR & (1 << 5) )
20000d84:	69bb      	ldr	r3, [r7, #24]
20000d86:	681b      	ldr	r3, [r3, #0]
20000d88:	f003 0320 	and.w	r3, r3, #32
20000d8c:	2b00      	cmp	r3, #0
20000d8e:	d00b      	beq.n	20000da8 <stm32_uart_read+0x48>
        {
        	*ptr = (*LPUART_RDR);
20000d90:	697b      	ldr	r3, [r7, #20]
20000d92:	681b      	ldr	r3, [r3, #0]
20000d94:	b2da      	uxtb	r2, r3
20000d96:	693b      	ldr	r3, [r7, #16]
20000d98:	701a      	strb	r2, [r3, #0]
        	len--;
20000d9a:	69fb      	ldr	r3, [r7, #28]
20000d9c:	3b01      	subs	r3, #1
20000d9e:	61fb      	str	r3, [r7, #28]
    while (len > 0)
20000da0:	69fb      	ldr	r3, [r7, #28]
20000da2:	2b00      	cmp	r3, #0
20000da4:	d1ee      	bne.n	20000d84 <stm32_uart_read+0x24>
20000da6:	e000      	b.n	20000daa <stm32_uart_read+0x4a>

        }
        else
        {
            break;
20000da8:	bf00      	nop
        }
    }


    return 0;
20000daa:	2300      	movs	r3, #0
}
20000dac:	4618      	mov	r0, r3
20000dae:	3724      	adds	r7, #36	@ 0x24
20000db0:	46bd      	mov	sp, r7
20000db2:	f85d 7b04 	ldr.w	r7, [sp], #4
20000db6:	4770      	bx	lr
20000db8:	4001381c 	.word	0x4001381c
20000dbc:	40013824 	.word	0x40013824

20000dc0 <stm32_uart_inpstat>:
static int
stm32_uart_inpstat(cfe_devctx_t *ctx, iocb_inpstat_t *inpstat)
{
20000dc0:	b480      	push	{r7}
20000dc2:	b085      	sub	sp, #20
20000dc4:	af00      	add	r7, sp, #0
20000dc6:	6078      	str	r0, [r7, #4]
20000dc8:	6039      	str	r1, [r7, #0]

	volatile uint32_t *LPUART_ISR  = (volatile uint32_t *)(0x40013800 + 0x1C);
20000dca:	4b0b      	ldr	r3, [pc, #44]	@ (20000df8 <stm32_uart_inpstat+0x38>)
20000dcc:	60fb      	str	r3, [r7, #12]


	if (*LPUART_ISR & (1 << 5))
20000dce:	68fb      	ldr	r3, [r7, #12]
20000dd0:	681b      	ldr	r3, [r3, #0]
20000dd2:	f003 0320 	and.w	r3, r3, #32
20000dd6:	2b00      	cmp	r3, #0
20000dd8:	d003      	beq.n	20000de2 <stm32_uart_inpstat+0x22>
	{
		inpstat->inp_status = 1;
20000dda:	683b      	ldr	r3, [r7, #0]
20000ddc:	2201      	movs	r2, #1
20000dde:	601a      	str	r2, [r3, #0]
20000de0:	e002      	b.n	20000de8 <stm32_uart_inpstat+0x28>
	}
	else
	{
		inpstat->inp_status = 0;
20000de2:	683b      	ldr	r3, [r7, #0]
20000de4:	2200      	movs	r2, #0
20000de6:	601a      	str	r2, [r3, #0]
	}

	return 0;
20000de8:	2300      	movs	r3, #0
}
20000dea:	4618      	mov	r0, r3
20000dec:	3714      	adds	r7, #20
20000dee:	46bd      	mov	sp, r7
20000df0:	f85d 7b04 	ldr.w	r7, [sp], #4
20000df4:	4770      	bx	lr
20000df6:	bf00      	nop
20000df8:	4001381c 	.word	0x4001381c

20000dfc <stm32_uart_write>:

static int
stm32_uart_write(cfe_devctx_t *ctx, iocb_buffer_t *buffer)
{
20000dfc:	b580      	push	{r7, lr}
20000dfe:	b086      	sub	sp, #24
20000e00:	af00      	add	r7, sp, #0
20000e02:	6078      	str	r0, [r7, #4]
20000e04:	6039      	str	r1, [r7, #0]
    char* ptr = buffer->buf_ptr;
20000e06:	683b      	ldr	r3, [r7, #0]
20000e08:	689b      	ldr	r3, [r3, #8]
20000e0a:	617b      	str	r3, [r7, #20]
    uint32_t len = buffer->buf_length;
20000e0c:	683b      	ldr	r3, [r7, #0]
20000e0e:	68db      	ldr	r3, [r3, #12]
20000e10:	60fb      	str	r3, [r7, #12]
    for(int i =0; i< len; i++)
20000e12:	2300      	movs	r3, #0
20000e14:	613b      	str	r3, [r7, #16]
20000e16:	e009      	b.n	20000e2c <stm32_uart_write+0x30>
    	putchar(*ptr++);
20000e18:	697b      	ldr	r3, [r7, #20]
20000e1a:	1c5a      	adds	r2, r3, #1
20000e1c:	617a      	str	r2, [r7, #20]
20000e1e:	781b      	ldrb	r3, [r3, #0]
20000e20:	4618      	mov	r0, r3
20000e22:	f7ff ff63 	bl	20000cec <putchar>
    for(int i =0; i< len; i++)
20000e26:	693b      	ldr	r3, [r7, #16]
20000e28:	3301      	adds	r3, #1
20000e2a:	613b      	str	r3, [r7, #16]
20000e2c:	693b      	ldr	r3, [r7, #16]
20000e2e:	68fa      	ldr	r2, [r7, #12]
20000e30:	429a      	cmp	r2, r3
20000e32:	d8f1      	bhi.n	20000e18 <stm32_uart_write+0x1c>

    buffer->buf_retlen = len;
20000e34:	683b      	ldr	r3, [r7, #0]
20000e36:	68fa      	ldr	r2, [r7, #12]
20000e38:	611a      	str	r2, [r3, #16]
    return 0;
20000e3a:	2300      	movs	r3, #0
}
20000e3c:	4618      	mov	r0, r3
20000e3e:	3718      	adds	r7, #24
20000e40:	46bd      	mov	sp, r7
20000e42:	bd80      	pop	{r7, pc}

20000e44 <board_init>:

void board_init() {
20000e44:	b598      	push	{r3, r4, r7, lr}
20000e46:	af00      	add	r7, sp, #0
	cfe_add_device(&stm32_uart, 0, 0, 0);
20000e48:	4b05      	ldr	r3, [pc, #20]	@ (20000e60 <board_init+0x1c>)
20000e4a:	691c      	ldr	r4, [r3, #16]
20000e4c:	2300      	movs	r3, #0
20000e4e:	2200      	movs	r2, #0
20000e50:	2100      	movs	r1, #0
20000e52:	4803      	ldr	r0, [pc, #12]	@ (20000e60 <board_init+0x1c>)
20000e54:	47a0      	blx	r4
	cfe_set_console("uart0");
20000e56:	4803      	ldr	r0, [pc, #12]	@ (20000e64 <board_init+0x20>)
20000e58:	f000 fd50 	bl	200018fc <cfe_set_console>
}
20000e5c:	bf00      	nop
20000e5e:	bd98      	pop	{r3, r4, r7, pc}
20000e60:	20004a6c 	.word	0x20004a6c
20000e64:	20004480 	.word	0x20004480

20000e68 <kmeminit>:
    *  	   nothing
    ********************************************************************* */


void kmeminit(mempool_t *pool,unsigned char *buffer,int length)
{
20000e68:	b480      	push	{r7}
20000e6a:	b085      	sub	sp, #20
20000e6c:	af00      	add	r7, sp, #0
20000e6e:	60f8      	str	r0, [r7, #12]
20000e70:	60b9      	str	r1, [r7, #8]
20000e72:	607a      	str	r2, [r7, #4]
    pool->root = (memnode_t *) buffer;
20000e74:	68fb      	ldr	r3, [r7, #12]
20000e76:	68ba      	ldr	r2, [r7, #8]
20000e78:	601a      	str	r2, [r3, #0]
    pool->root->seal = MEMNODE_SEAL;
20000e7a:	68fb      	ldr	r3, [r7, #12]
20000e7c:	681b      	ldr	r3, [r3, #0]
20000e7e:	4a10      	ldr	r2, [pc, #64]	@ (20000ec0 <kmeminit+0x58>)
20000e80:	601a      	str	r2, [r3, #0]
    pool->root->length = length - sizeof(memnode_t);
20000e82:	687a      	ldr	r2, [r7, #4]
20000e84:	68fb      	ldr	r3, [r7, #12]
20000e86:	681b      	ldr	r3, [r3, #0]
20000e88:	3a18      	subs	r2, #24
20000e8a:	609a      	str	r2, [r3, #8]
    pool->root->data = memnode_data(unsigned char *,pool->root);
20000e8c:	68fb      	ldr	r3, [r7, #12]
20000e8e:	681a      	ldr	r2, [r3, #0]
20000e90:	68fb      	ldr	r3, [r7, #12]
20000e92:	681b      	ldr	r3, [r3, #0]
20000e94:	3218      	adds	r2, #24
20000e96:	611a      	str	r2, [r3, #16]
    pool->root->status = memnode_free;
20000e98:	68fb      	ldr	r3, [r7, #12]
20000e9a:	681b      	ldr	r3, [r3, #0]
20000e9c:	2200      	movs	r2, #0
20000e9e:	731a      	strb	r2, [r3, #12]
    pool->root->next = NULL;
20000ea0:	68fb      	ldr	r3, [r7, #12]
20000ea2:	681b      	ldr	r3, [r3, #0]
20000ea4:	2200      	movs	r2, #0
20000ea6:	605a      	str	r2, [r3, #4]

    pool->base = buffer;
20000ea8:	68fb      	ldr	r3, [r7, #12]
20000eaa:	68ba      	ldr	r2, [r7, #8]
20000eac:	605a      	str	r2, [r3, #4]
    pool->length = length;
20000eae:	687a      	ldr	r2, [r7, #4]
20000eb0:	68fb      	ldr	r3, [r7, #12]
20000eb2:	609a      	str	r2, [r3, #8]
}
20000eb4:	bf00      	nop
20000eb6:	3714      	adds	r7, #20
20000eb8:	46bd      	mov	sp, r7
20000eba:	f85d 7b04 	ldr.w	r7, [sp], #4
20000ebe:	4770      	bx	lr
20000ec0:	faafa123 	.word	0xfaafa123

20000ec4 <kmemcompact>:
    *  Return value:
    *  	   nothing
    ********************************************************************* */

static void kmemcompact(mempool_t *pool)
{
20000ec4:	b480      	push	{r7}
20000ec6:	b085      	sub	sp, #20
20000ec8:	af00      	add	r7, sp, #0
20000eca:	6078      	str	r0, [r7, #4]
    memnode_t *m;
    int compacted;

    do {
	compacted = 0;
20000ecc:	2300      	movs	r3, #0
20000ece:	60bb      	str	r3, [r7, #8]

	for (m = pool->root; m; m = m->next) {
20000ed0:	687b      	ldr	r3, [r7, #4]
20000ed2:	681b      	ldr	r3, [r3, #0]
20000ed4:	60fb      	str	r3, [r7, #12]
20000ed6:	e02a      	b.n	20000f2e <kmemcompact+0x6a>

	    /* Check seal to be sure that we're doing ok */

	    if (m->seal != MEMNODE_SEAL) {
20000ed8:	68fb      	ldr	r3, [r7, #12]
20000eda:	681b      	ldr	r3, [r3, #0]
20000edc:	4a1a      	ldr	r2, [pc, #104]	@ (20000f48 <kmemcompact+0x84>)
20000ede:	4293      	cmp	r3, r2
20000ee0:	d12c      	bne.n	20000f3c <kmemcompact+0x78>
	    /* 
	     * If we're not on the last block and both this
	     * block and the next one are free, combine them
	     */

	    if (m->next && 
20000ee2:	68fb      	ldr	r3, [r7, #12]
20000ee4:	685b      	ldr	r3, [r3, #4]
20000ee6:	2b00      	cmp	r3, #0
20000ee8:	d01e      	beq.n	20000f28 <kmemcompact+0x64>
		(m->status == memnode_free) &&
20000eea:	68fb      	ldr	r3, [r7, #12]
20000eec:	7b1b      	ldrb	r3, [r3, #12]
	    if (m->next && 
20000eee:	2b00      	cmp	r3, #0
20000ef0:	d11a      	bne.n	20000f28 <kmemcompact+0x64>
		(m->next->status == memnode_free)) {
20000ef2:	68fb      	ldr	r3, [r7, #12]
20000ef4:	685b      	ldr	r3, [r3, #4]
20000ef6:	7b1b      	ldrb	r3, [r3, #12]
		(m->status == memnode_free) &&
20000ef8:	2b00      	cmp	r3, #0
20000efa:	d115      	bne.n	20000f28 <kmemcompact+0x64>
		m->length += sizeof(memnode_t) + m->next->length;
20000efc:	68fb      	ldr	r3, [r7, #12]
20000efe:	689a      	ldr	r2, [r3, #8]
20000f00:	68fb      	ldr	r3, [r7, #12]
20000f02:	685b      	ldr	r3, [r3, #4]
20000f04:	689b      	ldr	r3, [r3, #8]
20000f06:	4413      	add	r3, r2
20000f08:	f103 0218 	add.w	r2, r3, #24
20000f0c:	68fb      	ldr	r3, [r7, #12]
20000f0e:	609a      	str	r2, [r3, #8]
		m->next->seal = 0;
20000f10:	68fb      	ldr	r3, [r7, #12]
20000f12:	685b      	ldr	r3, [r3, #4]
20000f14:	2200      	movs	r2, #0
20000f16:	601a      	str	r2, [r3, #0]
		m->next = m->next->next;
20000f18:	68fb      	ldr	r3, [r7, #12]
20000f1a:	685b      	ldr	r3, [r3, #4]
20000f1c:	685a      	ldr	r2, [r3, #4]
20000f1e:	68fb      	ldr	r3, [r7, #12]
20000f20:	605a      	str	r2, [r3, #4]
		compacted++;
20000f22:	68bb      	ldr	r3, [r7, #8]
20000f24:	3301      	adds	r3, #1
20000f26:	60bb      	str	r3, [r7, #8]
	for (m = pool->root; m; m = m->next) {
20000f28:	68fb      	ldr	r3, [r7, #12]
20000f2a:	685b      	ldr	r3, [r3, #4]
20000f2c:	60fb      	str	r3, [r7, #12]
20000f2e:	68fb      	ldr	r3, [r7, #12]
20000f30:	2b00      	cmp	r3, #0
20000f32:	d1d1      	bne.n	20000ed8 <kmemcompact+0x14>
		}

	    /* Keep going till we make a pass without doing anything. */
	    }
	} while (compacted > 0);
20000f34:	68bb      	ldr	r3, [r7, #8]
20000f36:	2b00      	cmp	r3, #0
20000f38:	dcc8      	bgt.n	20000ecc <kmemcompact+0x8>
20000f3a:	e000      	b.n	20000f3e <kmemcompact+0x7a>
		return;
20000f3c:	bf00      	nop
}
20000f3e:	3714      	adds	r7, #20
20000f40:	46bd      	mov	sp, r7
20000f42:	f85d 7b04 	ldr.w	r7, [sp], #4
20000f46:	4770      	bx	lr
20000f48:	faafa123 	.word	0xfaafa123

20000f4c <kfree>:
    *  Return value:
    *  	   nothing
    ********************************************************************* */

void kfree(mempool_t *pool,void *ptr)
{
20000f4c:	b580      	push	{r7, lr}
20000f4e:	b084      	sub	sp, #16
20000f50:	af00      	add	r7, sp, #0
20000f52:	6078      	str	r0, [r7, #4]
20000f54:	6039      	str	r1, [r7, #0]
    memnode_t **backptr;
    memnode_t *m;

    if (((unsigned char *) ptr < pool->base) ||
20000f56:	687b      	ldr	r3, [r7, #4]
20000f58:	685b      	ldr	r3, [r3, #4]
20000f5a:	683a      	ldr	r2, [r7, #0]
20000f5c:	429a      	cmp	r2, r3
20000f5e:	d319      	bcc.n	20000f94 <kfree+0x48>
	((unsigned char *) ptr >= (pool->base+pool->length))) {
20000f60:	687b      	ldr	r3, [r7, #4]
20000f62:	685a      	ldr	r2, [r3, #4]
20000f64:	687b      	ldr	r3, [r7, #4]
20000f66:	689b      	ldr	r3, [r3, #8]
20000f68:	4413      	add	r3, r2
    if (((unsigned char *) ptr < pool->base) ||
20000f6a:	683a      	ldr	r2, [r7, #0]
20000f6c:	429a      	cmp	r2, r3
20000f6e:	d211      	bcs.n	20000f94 <kfree+0x48>
	printf("Pointer %08X does not belong to pool %08X\n",ptr,pool);
#endif
	return;
	}

    backptr = (memnode_t **) (((unsigned char *) ptr) - sizeof(memnode_t *));
20000f70:	683b      	ldr	r3, [r7, #0]
20000f72:	3b04      	subs	r3, #4
20000f74:	60fb      	str	r3, [r7, #12]
    m = *backptr;
20000f76:	68fb      	ldr	r3, [r7, #12]
20000f78:	681b      	ldr	r3, [r3, #0]
20000f7a:	60bb      	str	r3, [r7, #8]

    if (m->seal != MEMNODE_SEAL) {
20000f7c:	68bb      	ldr	r3, [r7, #8]
20000f7e:	681b      	ldr	r3, [r3, #0]
20000f80:	4a07      	ldr	r2, [pc, #28]	@ (20000fa0 <kfree+0x54>)
20000f82:	4293      	cmp	r3, r2
20000f84:	d108      	bne.n	20000f98 <kfree+0x4c>
	printf("Invalid node freed: %08X\n",m);
#endif
	return;
	}

    m->status = memnode_free;
20000f86:	68bb      	ldr	r3, [r7, #8]
20000f88:	2200      	movs	r2, #0
20000f8a:	731a      	strb	r2, [r3, #12]

    kmemcompact(pool);
20000f8c:	6878      	ldr	r0, [r7, #4]
20000f8e:	f7ff ff99 	bl	20000ec4 <kmemcompact>
20000f92:	e002      	b.n	20000f9a <kfree+0x4e>
	return;
20000f94:	bf00      	nop
20000f96:	e000      	b.n	20000f9a <kfree+0x4e>
	return;
20000f98:	bf00      	nop
}
20000f9a:	3710      	adds	r7, #16
20000f9c:	46bd      	mov	sp, r7
20000f9e:	bd80      	pop	{r7, pc}
20000fa0:	faafa123 	.word	0xfaafa123

20000fa4 <lib_outofmemory>:
    *  	   nothing
    ********************************************************************* */

void lib_outofmemory(void);
void lib_outofmemory(void)
{
20000fa4:	b480      	push	{r7}
20000fa6:	af00      	add	r7, sp, #0
    //xprintf("PANIC: out of memory!\n");
}
20000fa8:	bf00      	nop
20000faa:	46bd      	mov	sp, r7
20000fac:	f85d 7b04 	ldr.w	r7, [sp], #4
20000fb0:	4770      	bx	lr
	...

20000fb4 <kmalloc>:
    *  Return value:
    *  	   pointer to data, or NULL if no memory left
    ********************************************************************* */

void *kmalloc(mempool_t *pool,unsigned int size,unsigned int align)
{
20000fb4:	b580      	push	{r7, lr}
20000fb6:	b08c      	sub	sp, #48	@ 0x30
20000fb8:	af00      	add	r7, sp, #0
20000fba:	60f8      	str	r0, [r7, #12]
20000fbc:	60b9      	str	r1, [r7, #8]
20000fbe:	607a      	str	r2, [r7, #4]
    memnode_t *m;
    memnode_t *newm;
    memnode_t **backptr;
    uintptr_t daddr = 0;
20000fc0:	2300      	movs	r3, #0
20000fc2:	62bb      	str	r3, [r7, #40]	@ 0x28
    uintptr_t realsize = 0;
20000fc4:	2300      	movs	r3, #0
20000fc6:	627b      	str	r3, [r7, #36]	@ 0x24
    /*
     * Everything should be aligned by at least the
     * size of an int64
     */

    ptralign = (uintptr_t) align;
20000fc8:	687b      	ldr	r3, [r7, #4]
20000fca:	61fb      	str	r3, [r7, #28]
    if (ptralign < sizeof(void *)) ptralign = sizeof(uint64_t);
20000fcc:	69fb      	ldr	r3, [r7, #28]
20000fce:	2b03      	cmp	r3, #3
20000fd0:	d801      	bhi.n	20000fd6 <kmalloc+0x22>
20000fd2:	2308      	movs	r3, #8
20000fd4:	61fb      	str	r3, [r7, #28]
    /*	
     * Everything should be at least a multiple of the 
     * size of a pointer.
     */

    if (size == 0) size = sizeof(void *);
20000fd6:	68bb      	ldr	r3, [r7, #8]
20000fd8:	2b00      	cmp	r3, #0
20000fda:	d101      	bne.n	20000fe0 <kmalloc+0x2c>
20000fdc:	2304      	movs	r3, #4
20000fde:	60bb      	str	r3, [r7, #8]
    if (size & (sizeof(void *)-1)) {
20000fe0:	68bb      	ldr	r3, [r7, #8]
20000fe2:	f003 0303 	and.w	r3, r3, #3
20000fe6:	2b00      	cmp	r3, #0
20000fe8:	d006      	beq.n	20000ff8 <kmalloc+0x44>
	size += sizeof(void *);
20000fea:	68bb      	ldr	r3, [r7, #8]
20000fec:	3304      	adds	r3, #4
20000fee:	60bb      	str	r3, [r7, #8]
	size &= ~(sizeof(void *)-1);
20000ff0:	68bb      	ldr	r3, [r7, #8]
20000ff2:	f023 0303 	bic.w	r3, r3, #3
20000ff6:	60bb      	str	r3, [r7, #8]
    /*
     * Find a memnode at least big enough to hold the storage we
     * want.
     */

    for (m = pool->root; m; m = m->next) {
20000ff8:	68fb      	ldr	r3, [r7, #12]
20000ffa:	681b      	ldr	r3, [r3, #0]
20000ffc:	62fb      	str	r3, [r7, #44]	@ 0x2c
20000ffe:	e025      	b.n	2000104c <kmalloc+0x98>

	if (m->status == memnode_alloc) continue;
20001000:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
20001002:	7b1b      	ldrb	r3, [r3, #12]
20001004:	2b01      	cmp	r3, #1
20001006:	d01d      	beq.n	20001044 <kmalloc+0x90>
	/*
	 * If we wanted a particular alignment, we will
	 * need to adjust the size.
	 */

	daddr = memnode_data(uintptr_t,m);
20001008:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
2000100a:	3318      	adds	r3, #24
2000100c:	62bb      	str	r3, [r7, #40]	@ 0x28
	extra = 0;
2000100e:	2300      	movs	r3, #0
20001010:	623b      	str	r3, [r7, #32]
	if (daddr & (ptralign-1)) {
20001012:	69fb      	ldr	r3, [r7, #28]
20001014:	1e5a      	subs	r2, r3, #1
20001016:	6abb      	ldr	r3, [r7, #40]	@ 0x28
20001018:	4013      	ands	r3, r2
2000101a:	2b00      	cmp	r3, #0
2000101c:	d008      	beq.n	20001030 <kmalloc+0x7c>
	    extra = size + (ptralign - (daddr & (ptralign-1)));
2000101e:	69fb      	ldr	r3, [r7, #28]
20001020:	1e5a      	subs	r2, r3, #1
20001022:	6abb      	ldr	r3, [r7, #40]	@ 0x28
20001024:	4013      	ands	r3, r2
20001026:	69fa      	ldr	r2, [r7, #28]
20001028:	1ad3      	subs	r3, r2, r3
2000102a:	68ba      	ldr	r2, [r7, #8]
2000102c:	4413      	add	r3, r2
2000102e:	623b      	str	r3, [r7, #32]
	    }
	realsize = size + extra;
20001030:	68ba      	ldr	r2, [r7, #8]
20001032:	6a3b      	ldr	r3, [r7, #32]
20001034:	4413      	add	r3, r2
20001036:	627b      	str	r3, [r7, #36]	@ 0x24

	if (m->length < realsize) continue;
20001038:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
2000103a:	689b      	ldr	r3, [r3, #8]
2000103c:	6a7a      	ldr	r2, [r7, #36]	@ 0x24
2000103e:	429a      	cmp	r2, r3
20001040:	d908      	bls.n	20001054 <kmalloc+0xa0>
20001042:	e000      	b.n	20001046 <kmalloc+0x92>
	if (m->status == memnode_alloc) continue;
20001044:	bf00      	nop
    for (m = pool->root; m; m = m->next) {
20001046:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
20001048:	685b      	ldr	r3, [r3, #4]
2000104a:	62fb      	str	r3, [r7, #44]	@ 0x2c
2000104c:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
2000104e:	2b00      	cmp	r3, #0
20001050:	d1d6      	bne.n	20001000 <kmalloc+0x4c>
20001052:	e000      	b.n	20001056 <kmalloc+0xa2>
	break;
20001054:	bf00      	nop

    /*
     * If m is null, there's no memory left.
     */

    if (m == NULL) {
20001056:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
20001058:	2b00      	cmp	r3, #0
2000105a:	d103      	bne.n	20001064 <kmalloc+0xb0>
	lib_outofmemory();
2000105c:	f7ff ffa2 	bl	20000fa4 <lib_outofmemory>
	return NULL;
20001060:	2300      	movs	r3, #0
20001062:	e061      	b.n	20001128 <kmalloc+0x174>
    /*
     * Otherwise, use this block.  Calculate the address of the data
     * to preserve the alignment.
     */

    if (daddr & (ptralign-1)) {
20001064:	69fb      	ldr	r3, [r7, #28]
20001066:	1e5a      	subs	r2, r3, #1
20001068:	6abb      	ldr	r3, [r7, #40]	@ 0x28
2000106a:	4013      	ands	r3, r2
2000106c:	2b00      	cmp	r3, #0
2000106e:	d008      	beq.n	20001082 <kmalloc+0xce>
	daddr += ptralign;
20001070:	6aba      	ldr	r2, [r7, #40]	@ 0x28
20001072:	69fb      	ldr	r3, [r7, #28]
20001074:	4413      	add	r3, r2
20001076:	62bb      	str	r3, [r7, #40]	@ 0x28
	daddr &= ~(ptralign-1);
20001078:	69fb      	ldr	r3, [r7, #28]
2000107a:	425b      	negs	r3, r3
2000107c:	6aba      	ldr	r2, [r7, #40]	@ 0x28
2000107e:	4013      	ands	r3, r2
20001080:	62bb      	str	r3, [r7, #40]	@ 0x28
	}

    /* Mark this node as allocated. */

    m->data   = (unsigned char *) daddr;
20001082:	6aba      	ldr	r2, [r7, #40]	@ 0x28
20001084:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
20001086:	611a      	str	r2, [r3, #16]
    m->status = memnode_alloc;
20001088:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
2000108a:	2201      	movs	r2, #1
2000108c:	731a      	strb	r2, [r3, #12]
     * aligned, backing up will put us inside the memnode
     * structure itself... that's why the memnodeptr field
     * is there, as a placeholder for this eventuality.
     */

    backptr   = (memnode_t **) (m->data - sizeof(memnode_t *));
2000108e:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
20001090:	691b      	ldr	r3, [r3, #16]
20001092:	3b04      	subs	r3, #4
20001094:	61bb      	str	r3, [r7, #24]
    *backptr  = m;
20001096:	69bb      	ldr	r3, [r7, #24]
20001098:	6afa      	ldr	r2, [r7, #44]	@ 0x2c
2000109a:	601a      	str	r2, [r3, #0]
     * See if we need to split it.
     * Don't bother to split if the resulting size will be 
     * less than MINBLKSIZE bytes
     */

    if (m->length - realsize < MINBLKSIZE) {
2000109c:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
2000109e:	689a      	ldr	r2, [r3, #8]
200010a0:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
200010a2:	1ad3      	subs	r3, r2, r3
200010a4:	2b3f      	cmp	r3, #63	@ 0x3f
200010a6:	d802      	bhi.n	200010ae <kmalloc+0xfa>
	return m->data;
200010a8:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
200010aa:	691b      	ldr	r3, [r3, #16]
200010ac:	e03c      	b.n	20001128 <kmalloc+0x174>
    /*
     * Split this block.  Align the address on a pointer-size
     * boundary.
     */

    daddr += size;
200010ae:	6aba      	ldr	r2, [r7, #40]	@ 0x28
200010b0:	68bb      	ldr	r3, [r7, #8]
200010b2:	4413      	add	r3, r2
200010b4:	62bb      	str	r3, [r7, #40]	@ 0x28
    if (daddr & (uintptr_t)(sizeof(void *)-1)) {
200010b6:	6abb      	ldr	r3, [r7, #40]	@ 0x28
200010b8:	f003 0303 	and.w	r3, r3, #3
200010bc:	2b00      	cmp	r3, #0
200010be:	d006      	beq.n	200010ce <kmalloc+0x11a>
	daddr += (uintptr_t)sizeof(void *);
200010c0:	6abb      	ldr	r3, [r7, #40]	@ 0x28
200010c2:	3304      	adds	r3, #4
200010c4:	62bb      	str	r3, [r7, #40]	@ 0x28
	daddr &= ~(uintptr_t)(sizeof(void *)-1);
200010c6:	6abb      	ldr	r3, [r7, #40]	@ 0x28
200010c8:	f023 0303 	bic.w	r3, r3, #3
200010cc:	62bb      	str	r3, [r7, #40]	@ 0x28
	}

    blkend = memnode_data(uintptr_t,m) + (uintptr_t)(m->length);
200010ce:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
200010d0:	689a      	ldr	r2, [r3, #8]
200010d2:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
200010d4:	4413      	add	r3, r2
200010d6:	3318      	adds	r3, #24
200010d8:	617b      	str	r3, [r7, #20]

    newm = (memnode_t *) daddr;
200010da:	6abb      	ldr	r3, [r7, #40]	@ 0x28
200010dc:	613b      	str	r3, [r7, #16]

    newm->next   = m->next;
200010de:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
200010e0:	685a      	ldr	r2, [r3, #4]
200010e2:	693b      	ldr	r3, [r7, #16]
200010e4:	605a      	str	r2, [r3, #4]
    m->length    = (unsigned int) (daddr - memnode_data(uintptr_t,m));
200010e6:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
200010e8:	6aba      	ldr	r2, [r7, #40]	@ 0x28
200010ea:	1ad3      	subs	r3, r2, r3
200010ec:	f1a3 0218 	sub.w	r2, r3, #24
200010f0:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
200010f2:	609a      	str	r2, [r3, #8]
    m->next      = newm;
200010f4:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
200010f6:	693a      	ldr	r2, [r7, #16]
200010f8:	605a      	str	r2, [r3, #4]
    m->status    = memnode_alloc;
200010fa:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
200010fc:	2201      	movs	r2, #1
200010fe:	731a      	strb	r2, [r3, #12]
    newm->seal   = MEMNODE_SEAL;
20001100:	693b      	ldr	r3, [r7, #16]
20001102:	4a0b      	ldr	r2, [pc, #44]	@ (20001130 <kmalloc+0x17c>)
20001104:	601a      	str	r2, [r3, #0]
    newm->data    = memnode_data(unsigned char *,newm);
20001106:	693b      	ldr	r3, [r7, #16]
20001108:	f103 0218 	add.w	r2, r3, #24
2000110c:	693b      	ldr	r3, [r7, #16]
2000110e:	611a      	str	r2, [r3, #16]
    newm->length = (unsigned int) (blkend - memnode_data(uintptr_t,newm));
20001110:	693b      	ldr	r3, [r7, #16]
20001112:	697a      	ldr	r2, [r7, #20]
20001114:	1ad3      	subs	r3, r2, r3
20001116:	f1a3 0218 	sub.w	r2, r3, #24
2000111a:	693b      	ldr	r3, [r7, #16]
2000111c:	609a      	str	r2, [r3, #8]
    newm->status = memnode_free;
2000111e:	693b      	ldr	r3, [r7, #16]
20001120:	2200      	movs	r2, #0
20001122:	731a      	strb	r2, [r3, #12]

    return m->data;    
20001124:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
20001126:	691b      	ldr	r3, [r3, #16]
}
20001128:	4618      	mov	r0, r3
2000112a:	3730      	adds	r7, #48	@ 0x30
2000112c:	46bd      	mov	sp, r7
2000112e:	bd80      	pop	{r7, pc}
20001130:	faafa123 	.word	0xfaafa123

20001134 <q_enqueue>:
    *  Return Value:		
    *      Nothing.		
    ********************************************************************* */

void q_enqueue(queue_t *qb,queue_t *item)
{
20001134:	b480      	push	{r7}
20001136:	b083      	sub	sp, #12
20001138:	af00      	add	r7, sp, #0
2000113a:	6078      	str	r0, [r7, #4]
2000113c:	6039      	str	r1, [r7, #0]
    qb->q_prev->q_next = item;
2000113e:	687b      	ldr	r3, [r7, #4]
20001140:	685b      	ldr	r3, [r3, #4]
20001142:	683a      	ldr	r2, [r7, #0]
20001144:	601a      	str	r2, [r3, #0]
    item->q_next = qb;
20001146:	683b      	ldr	r3, [r7, #0]
20001148:	687a      	ldr	r2, [r7, #4]
2000114a:	601a      	str	r2, [r3, #0]
    item->q_prev = qb->q_prev;
2000114c:	687b      	ldr	r3, [r7, #4]
2000114e:	685a      	ldr	r2, [r3, #4]
20001150:	683b      	ldr	r3, [r7, #0]
20001152:	605a      	str	r2, [r3, #4]
    qb->q_prev = item;
20001154:	687b      	ldr	r3, [r7, #4]
20001156:	683a      	ldr	r2, [r7, #0]
20001158:	605a      	str	r2, [r3, #4]
}
2000115a:	bf00      	nop
2000115c:	370c      	adds	r7, #12
2000115e:	46bd      	mov	sp, r7
20001160:	f85d 7b04 	ldr.w	r7, [sp], #4
20001164:	4770      	bx	lr

20001166 <q_dequeue>:
    *  Return Value:			
    *      Nothing.			
    ********************************************************************* */

void q_dequeue(queue_t *item)
{
20001166:	b480      	push	{r7}
20001168:	b083      	sub	sp, #12
2000116a:	af00      	add	r7, sp, #0
2000116c:	6078      	str	r0, [r7, #4]
    item->q_prev->q_next = item->q_next;
2000116e:	687b      	ldr	r3, [r7, #4]
20001170:	685b      	ldr	r3, [r3, #4]
20001172:	687a      	ldr	r2, [r7, #4]
20001174:	6812      	ldr	r2, [r2, #0]
20001176:	601a      	str	r2, [r3, #0]
    item->q_next->q_prev = item->q_prev;
20001178:	687b      	ldr	r3, [r7, #4]
2000117a:	681b      	ldr	r3, [r3, #0]
2000117c:	687a      	ldr	r2, [r7, #4]
2000117e:	6852      	ldr	r2, [r2, #4]
20001180:	605a      	str	r2, [r3, #4]
}
20001182:	bf00      	nop
20001184:	370c      	adds	r7, #12
20001186:	46bd      	mov	sp, r7
20001188:	f85d 7b04 	ldr.w	r7, [sp], #4
2000118c:	4770      	bx	lr

2000118e <q_deqnext>:
    *  Return Value:		
    *      next element, or NULL
    ********************************************************************* */

queue_t *q_deqnext(queue_t *qb)
{
2000118e:	b480      	push	{r7}
20001190:	b083      	sub	sp, #12
20001192:	af00      	add	r7, sp, #0
20001194:	6078      	str	r0, [r7, #4]
    if (qb->q_next == qb) {
20001196:	687b      	ldr	r3, [r7, #4]
20001198:	681b      	ldr	r3, [r3, #0]
2000119a:	687a      	ldr	r2, [r7, #4]
2000119c:	429a      	cmp	r2, r3
2000119e:	d101      	bne.n	200011a4 <q_deqnext+0x16>
	return NULL;
200011a0:	2300      	movs	r3, #0
200011a2:	e00d      	b.n	200011c0 <q_deqnext+0x32>
	}

    qb = qb->q_next;
200011a4:	687b      	ldr	r3, [r7, #4]
200011a6:	681b      	ldr	r3, [r3, #0]
200011a8:	607b      	str	r3, [r7, #4]

    qb->q_prev->q_next = qb->q_next;
200011aa:	687b      	ldr	r3, [r7, #4]
200011ac:	685b      	ldr	r3, [r3, #4]
200011ae:	687a      	ldr	r2, [r7, #4]
200011b0:	6812      	ldr	r2, [r2, #0]
200011b2:	601a      	str	r2, [r3, #0]
    qb->q_next->q_prev = qb->q_prev;
200011b4:	687b      	ldr	r3, [r7, #4]
200011b6:	681b      	ldr	r3, [r3, #0]
200011b8:	687a      	ldr	r2, [r7, #4]
200011ba:	6852      	ldr	r2, [r2, #4]
200011bc:	605a      	str	r2, [r3, #4]

    return qb;
200011be:	687b      	ldr	r3, [r7, #4]
}
200011c0:	4618      	mov	r0, r3
200011c2:	370c      	adds	r7, #12
200011c4:	46bd      	mov	sp, r7
200011c6:	f85d 7b04 	ldr.w	r7, [sp], #4
200011ca:	4770      	bx	lr

200011cc <q_count>:
    *      								*
    *  Return Value:							*
    *      number of elements						*
    ********************************************************************* */
int q_count(queue_t *qb)
{
200011cc:	b480      	push	{r7}
200011ce:	b085      	sub	sp, #20
200011d0:	af00      	add	r7, sp, #0
200011d2:	6078      	str	r0, [r7, #4]
    queue_t *qe;
    int res = 0;
200011d4:	2300      	movs	r3, #0
200011d6:	60bb      	str	r3, [r7, #8]

    qe = qb;
200011d8:	687b      	ldr	r3, [r7, #4]
200011da:	60fb      	str	r3, [r7, #12]

    while (qe->q_next != qb) {
200011dc:	e005      	b.n	200011ea <q_count+0x1e>
	qe = qe->q_next;
200011de:	68fb      	ldr	r3, [r7, #12]
200011e0:	681b      	ldr	r3, [r3, #0]
200011e2:	60fb      	str	r3, [r7, #12]
	res++;
200011e4:	68bb      	ldr	r3, [r7, #8]
200011e6:	3301      	adds	r3, #1
200011e8:	60bb      	str	r3, [r7, #8]
    while (qe->q_next != qb) {
200011ea:	68fb      	ldr	r3, [r7, #12]
200011ec:	681b      	ldr	r3, [r3, #0]
200011ee:	687a      	ldr	r2, [r7, #4]
200011f0:	429a      	cmp	r2, r3
200011f2:	d1f4      	bne.n	200011de <q_count+0x12>
	}

    return res;
200011f4:	68bb      	ldr	r3, [r7, #8]
}
200011f6:	4618      	mov	r0, r3
200011f8:	3714      	adds	r7, #20
200011fa:	46bd      	mov	sp, r7
200011fc:	f85d 7b04 	ldr.w	r7, [sp], #4
20001200:	4770      	bx	lr

20001202 <lib_strcpy>:
#include "lib_types.h"
#define _LIB_NO_MACROS_
#include "lib_string.h"

char *lib_strcpy(char *dest,const char *src)
{
20001202:	b480      	push	{r7}
20001204:	b085      	sub	sp, #20
20001206:	af00      	add	r7, sp, #0
20001208:	6078      	str	r0, [r7, #4]
2000120a:	6039      	str	r1, [r7, #0]
    char *ptr = dest;
2000120c:	687b      	ldr	r3, [r7, #4]
2000120e:	60fb      	str	r3, [r7, #12]

    while (*src) *ptr++ = *src++;
20001210:	e007      	b.n	20001222 <lib_strcpy+0x20>
20001212:	683a      	ldr	r2, [r7, #0]
20001214:	1c53      	adds	r3, r2, #1
20001216:	603b      	str	r3, [r7, #0]
20001218:	68fb      	ldr	r3, [r7, #12]
2000121a:	1c59      	adds	r1, r3, #1
2000121c:	60f9      	str	r1, [r7, #12]
2000121e:	7812      	ldrb	r2, [r2, #0]
20001220:	701a      	strb	r2, [r3, #0]
20001222:	683b      	ldr	r3, [r7, #0]
20001224:	781b      	ldrb	r3, [r3, #0]
20001226:	2b00      	cmp	r3, #0
20001228:	d1f3      	bne.n	20001212 <lib_strcpy+0x10>
    *ptr = '\0';
2000122a:	68fb      	ldr	r3, [r7, #12]
2000122c:	2200      	movs	r2, #0
2000122e:	701a      	strb	r2, [r3, #0]

    return dest;
20001230:	687b      	ldr	r3, [r7, #4]
}
20001232:	4618      	mov	r0, r3
20001234:	3714      	adds	r7, #20
20001236:	46bd      	mov	sp, r7
20001238:	f85d 7b04 	ldr.w	r7, [sp], #4
2000123c:	4770      	bx	lr

2000123e <lib_xstrncpy>:
    return dest;
}


size_t lib_xstrncpy(char *dest,const char *src,size_t cnt)
{
2000123e:	b480      	push	{r7}
20001240:	b087      	sub	sp, #28
20001242:	af00      	add	r7, sp, #0
20001244:	60f8      	str	r0, [r7, #12]
20001246:	60b9      	str	r1, [r7, #8]
20001248:	607a      	str	r2, [r7, #4]
    char *ptr = dest;
2000124a:	68fb      	ldr	r3, [r7, #12]
2000124c:	617b      	str	r3, [r7, #20]
    size_t copied = 0;
2000124e:	2300      	movs	r3, #0
20001250:	613b      	str	r3, [r7, #16]

    while (*src && (cnt > 1)) {
20001252:	e00d      	b.n	20001270 <lib_xstrncpy+0x32>
	*ptr++ = *src++;
20001254:	68ba      	ldr	r2, [r7, #8]
20001256:	1c53      	adds	r3, r2, #1
20001258:	60bb      	str	r3, [r7, #8]
2000125a:	697b      	ldr	r3, [r7, #20]
2000125c:	1c59      	adds	r1, r3, #1
2000125e:	6179      	str	r1, [r7, #20]
20001260:	7812      	ldrb	r2, [r2, #0]
20001262:	701a      	strb	r2, [r3, #0]
	cnt--;
20001264:	687b      	ldr	r3, [r7, #4]
20001266:	3b01      	subs	r3, #1
20001268:	607b      	str	r3, [r7, #4]
	copied++;
2000126a:	693b      	ldr	r3, [r7, #16]
2000126c:	3301      	adds	r3, #1
2000126e:	613b      	str	r3, [r7, #16]
    while (*src && (cnt > 1)) {
20001270:	68bb      	ldr	r3, [r7, #8]
20001272:	781b      	ldrb	r3, [r3, #0]
20001274:	2b00      	cmp	r3, #0
20001276:	d002      	beq.n	2000127e <lib_xstrncpy+0x40>
20001278:	687b      	ldr	r3, [r7, #4]
2000127a:	2b01      	cmp	r3, #1
2000127c:	dcea      	bgt.n	20001254 <lib_xstrncpy+0x16>
	}
    *ptr = '\0';
2000127e:	697b      	ldr	r3, [r7, #20]
20001280:	2200      	movs	r2, #0
20001282:	701a      	strb	r2, [r3, #0]

    return copied;
20001284:	693b      	ldr	r3, [r7, #16]
}
20001286:	4618      	mov	r0, r3
20001288:	371c      	adds	r7, #28
2000128a:	46bd      	mov	sp, r7
2000128c:	f85d 7b04 	ldr.w	r7, [sp], #4
20001290:	4770      	bx	lr

20001292 <lib_strlen>:

size_t lib_strlen(const char *str)
{
20001292:	b480      	push	{r7}
20001294:	b085      	sub	sp, #20
20001296:	af00      	add	r7, sp, #0
20001298:	6078      	str	r0, [r7, #4]
    size_t cnt = 0;
2000129a:	2300      	movs	r3, #0
2000129c:	60fb      	str	r3, [r7, #12]

    while (*str) {
2000129e:	e005      	b.n	200012ac <lib_strlen+0x1a>
	str++;
200012a0:	687b      	ldr	r3, [r7, #4]
200012a2:	3301      	adds	r3, #1
200012a4:	607b      	str	r3, [r7, #4]
	cnt++;
200012a6:	68fb      	ldr	r3, [r7, #12]
200012a8:	3301      	adds	r3, #1
200012aa:	60fb      	str	r3, [r7, #12]
    while (*str) {
200012ac:	687b      	ldr	r3, [r7, #4]
200012ae:	781b      	ldrb	r3, [r3, #0]
200012b0:	2b00      	cmp	r3, #0
200012b2:	d1f5      	bne.n	200012a0 <lib_strlen+0xe>
	}

    return cnt;
200012b4:	68fb      	ldr	r3, [r7, #12]
}
200012b6:	4618      	mov	r0, r3
200012b8:	3714      	adds	r7, #20
200012ba:	46bd      	mov	sp, r7
200012bc:	f85d 7b04 	ldr.w	r7, [sp], #4
200012c0:	4770      	bx	lr

200012c2 <lib_strcmp>:


int lib_strcmp(const char *dest,const char *src)
{
200012c2:	b480      	push	{r7}
200012c4:	b083      	sub	sp, #12
200012c6:	af00      	add	r7, sp, #0
200012c8:	6078      	str	r0, [r7, #4]
200012ca:	6039      	str	r1, [r7, #0]
    while (*src && *dest) {
200012cc:	e016      	b.n	200012fc <lib_strcmp+0x3a>
	if (*dest < *src) return -1;
200012ce:	687b      	ldr	r3, [r7, #4]
200012d0:	781a      	ldrb	r2, [r3, #0]
200012d2:	683b      	ldr	r3, [r7, #0]
200012d4:	781b      	ldrb	r3, [r3, #0]
200012d6:	429a      	cmp	r2, r3
200012d8:	d202      	bcs.n	200012e0 <lib_strcmp+0x1e>
200012da:	f04f 33ff 	mov.w	r3, #4294967295	@ 0xffffffff
200012de:	e02b      	b.n	20001338 <lib_strcmp+0x76>
	if (*dest > *src) return 1;
200012e0:	687b      	ldr	r3, [r7, #4]
200012e2:	781a      	ldrb	r2, [r3, #0]
200012e4:	683b      	ldr	r3, [r7, #0]
200012e6:	781b      	ldrb	r3, [r3, #0]
200012e8:	429a      	cmp	r2, r3
200012ea:	d901      	bls.n	200012f0 <lib_strcmp+0x2e>
200012ec:	2301      	movs	r3, #1
200012ee:	e023      	b.n	20001338 <lib_strcmp+0x76>
	dest++;	
200012f0:	687b      	ldr	r3, [r7, #4]
200012f2:	3301      	adds	r3, #1
200012f4:	607b      	str	r3, [r7, #4]
	src++;
200012f6:	683b      	ldr	r3, [r7, #0]
200012f8:	3301      	adds	r3, #1
200012fa:	603b      	str	r3, [r7, #0]
    while (*src && *dest) {
200012fc:	683b      	ldr	r3, [r7, #0]
200012fe:	781b      	ldrb	r3, [r3, #0]
20001300:	2b00      	cmp	r3, #0
20001302:	d003      	beq.n	2000130c <lib_strcmp+0x4a>
20001304:	687b      	ldr	r3, [r7, #4]
20001306:	781b      	ldrb	r3, [r3, #0]
20001308:	2b00      	cmp	r3, #0
2000130a:	d1e0      	bne.n	200012ce <lib_strcmp+0xc>
	}

    if (*dest && !*src) return 1;
2000130c:	687b      	ldr	r3, [r7, #4]
2000130e:	781b      	ldrb	r3, [r3, #0]
20001310:	2b00      	cmp	r3, #0
20001312:	d005      	beq.n	20001320 <lib_strcmp+0x5e>
20001314:	683b      	ldr	r3, [r7, #0]
20001316:	781b      	ldrb	r3, [r3, #0]
20001318:	2b00      	cmp	r3, #0
2000131a:	d101      	bne.n	20001320 <lib_strcmp+0x5e>
2000131c:	2301      	movs	r3, #1
2000131e:	e00b      	b.n	20001338 <lib_strcmp+0x76>
    if (!*dest && *src) return -1;
20001320:	687b      	ldr	r3, [r7, #4]
20001322:	781b      	ldrb	r3, [r3, #0]
20001324:	2b00      	cmp	r3, #0
20001326:	d106      	bne.n	20001336 <lib_strcmp+0x74>
20001328:	683b      	ldr	r3, [r7, #0]
2000132a:	781b      	ldrb	r3, [r3, #0]
2000132c:	2b00      	cmp	r3, #0
2000132e:	d002      	beq.n	20001336 <lib_strcmp+0x74>
20001330:	f04f 33ff 	mov.w	r3, #4294967295	@ 0xffffffff
20001334:	e000      	b.n	20001338 <lib_strcmp+0x76>
    return 0;
20001336:	2300      	movs	r3, #0
}
20001338:	4618      	mov	r0, r3
2000133a:	370c      	adds	r7, #12
2000133c:	46bd      	mov	sp, r7
2000133e:	f85d 7b04 	ldr.w	r7, [sp], #4
20001342:	4770      	bx	lr

20001344 <lib_strchr>:
    return 0;
}


char *lib_strchr(const char *dest,int c)
{
20001344:	b480      	push	{r7}
20001346:	b083      	sub	sp, #12
20001348:	af00      	add	r7, sp, #0
2000134a:	6078      	str	r0, [r7, #4]
2000134c:	6039      	str	r1, [r7, #0]
    while (*dest) {
2000134e:	e00a      	b.n	20001366 <lib_strchr+0x22>
	if (*dest == c) return (char *) dest;
20001350:	687b      	ldr	r3, [r7, #4]
20001352:	781b      	ldrb	r3, [r3, #0]
20001354:	461a      	mov	r2, r3
20001356:	683b      	ldr	r3, [r7, #0]
20001358:	4293      	cmp	r3, r2
2000135a:	d101      	bne.n	20001360 <lib_strchr+0x1c>
2000135c:	687b      	ldr	r3, [r7, #4]
2000135e:	e007      	b.n	20001370 <lib_strchr+0x2c>
	dest++;
20001360:	687b      	ldr	r3, [r7, #4]
20001362:	3301      	adds	r3, #1
20001364:	607b      	str	r3, [r7, #4]
    while (*dest) {
20001366:	687b      	ldr	r3, [r7, #4]
20001368:	781b      	ldrb	r3, [r3, #0]
2000136a:	2b00      	cmp	r3, #0
2000136c:	d1f0      	bne.n	20001350 <lib_strchr+0xc>
	}
    return NULL;
2000136e:	2300      	movs	r3, #0
}
20001370:	4618      	mov	r0, r3
20001372:	370c      	adds	r7, #12
20001374:	46bd      	mov	sp, r7
20001376:	f85d 7b04 	ldr.w	r7, [sp], #4
2000137a:	4770      	bx	lr

2000137c <lib_memcpy>:

    return 0;
}

void *lib_memcpy(void *dest,const void *src,size_t cnt)
{
2000137c:	b480      	push	{r7}
2000137e:	b087      	sub	sp, #28
20001380:	af00      	add	r7, sp, #0
20001382:	60f8      	str	r0, [r7, #12]
20001384:	60b9      	str	r1, [r7, #8]
20001386:	607a      	str	r2, [r7, #4]
    unsigned char *d;
    const unsigned char *s;

    d = (unsigned char *) dest;
20001388:	68fb      	ldr	r3, [r7, #12]
2000138a:	617b      	str	r3, [r7, #20]
    s = (const unsigned char *) src;
2000138c:	68bb      	ldr	r3, [r7, #8]
2000138e:	613b      	str	r3, [r7, #16]

    while (cnt) {
20001390:	e00a      	b.n	200013a8 <lib_memcpy+0x2c>
	*d++ = *s++;
20001392:	693a      	ldr	r2, [r7, #16]
20001394:	1c53      	adds	r3, r2, #1
20001396:	613b      	str	r3, [r7, #16]
20001398:	697b      	ldr	r3, [r7, #20]
2000139a:	1c59      	adds	r1, r3, #1
2000139c:	6179      	str	r1, [r7, #20]
2000139e:	7812      	ldrb	r2, [r2, #0]
200013a0:	701a      	strb	r2, [r3, #0]
	cnt--;
200013a2:	687b      	ldr	r3, [r7, #4]
200013a4:	3b01      	subs	r3, #1
200013a6:	607b      	str	r3, [r7, #4]
    while (cnt) {
200013a8:	687b      	ldr	r3, [r7, #4]
200013aa:	2b00      	cmp	r3, #0
200013ac:	d1f1      	bne.n	20001392 <lib_memcpy+0x16>
	}

    return dest;
200013ae:	68fb      	ldr	r3, [r7, #12]
}
200013b0:	4618      	mov	r0, r3
200013b2:	371c      	adds	r7, #28
200013b4:	46bd      	mov	sp, r7
200013b6:	f85d 7b04 	ldr.w	r7, [sp], #4
200013ba:	4770      	bx	lr

200013bc <lib_memset>:

void *lib_memset(void *dest,int c,size_t cnt)
{
200013bc:	b480      	push	{r7}
200013be:	b087      	sub	sp, #28
200013c0:	af00      	add	r7, sp, #0
200013c2:	60f8      	str	r0, [r7, #12]
200013c4:	60b9      	str	r1, [r7, #8]
200013c6:	607a      	str	r2, [r7, #4]
    unsigned char *d;

    d = dest;
200013c8:	68fb      	ldr	r3, [r7, #12]
200013ca:	617b      	str	r3, [r7, #20]

    while (cnt) {
200013cc:	e008      	b.n	200013e0 <lib_memset+0x24>
	*d++ = (unsigned char) c;
200013ce:	697b      	ldr	r3, [r7, #20]
200013d0:	1c5a      	adds	r2, r3, #1
200013d2:	617a      	str	r2, [r7, #20]
200013d4:	68ba      	ldr	r2, [r7, #8]
200013d6:	b2d2      	uxtb	r2, r2
200013d8:	701a      	strb	r2, [r3, #0]
	cnt--;
200013da:	687b      	ldr	r3, [r7, #4]
200013dc:	3b01      	subs	r3, #1
200013de:	607b      	str	r3, [r7, #4]
    while (cnt) {
200013e0:	687b      	ldr	r3, [r7, #4]
200013e2:	2b00      	cmp	r3, #0
200013e4:	d1f3      	bne.n	200013ce <lib_memset+0x12>
	}

    return d;
200013e6:	697b      	ldr	r3, [r7, #20]
}
200013e8:	4618      	mov	r0, r3
200013ea:	371c      	adds	r7, #28
200013ec:	46bd      	mov	sp, r7
200013ee:	f85d 7b04 	ldr.w	r7, [sp], #4
200013f2:	4770      	bx	lr

200013f4 <lib_strcat>:
	str++;
	}
}

char *lib_strcat(char *dest,const char *src)
{
200013f4:	b480      	push	{r7}
200013f6:	b085      	sub	sp, #20
200013f8:	af00      	add	r7, sp, #0
200013fa:	6078      	str	r0, [r7, #4]
200013fc:	6039      	str	r1, [r7, #0]
    char *ptr = dest;
200013fe:	687b      	ldr	r3, [r7, #4]
20001400:	60fb      	str	r3, [r7, #12]

    while (*ptr) ptr++;
20001402:	e002      	b.n	2000140a <lib_strcat+0x16>
20001404:	68fb      	ldr	r3, [r7, #12]
20001406:	3301      	adds	r3, #1
20001408:	60fb      	str	r3, [r7, #12]
2000140a:	68fb      	ldr	r3, [r7, #12]
2000140c:	781b      	ldrb	r3, [r3, #0]
2000140e:	2b00      	cmp	r3, #0
20001410:	d1f8      	bne.n	20001404 <lib_strcat+0x10>
    while (*src) *ptr++ = *src++;
20001412:	e007      	b.n	20001424 <lib_strcat+0x30>
20001414:	683a      	ldr	r2, [r7, #0]
20001416:	1c53      	adds	r3, r2, #1
20001418:	603b      	str	r3, [r7, #0]
2000141a:	68fb      	ldr	r3, [r7, #12]
2000141c:	1c59      	adds	r1, r3, #1
2000141e:	60f9      	str	r1, [r7, #12]
20001420:	7812      	ldrb	r2, [r2, #0]
20001422:	701a      	strb	r2, [r3, #0]
20001424:	683b      	ldr	r3, [r7, #0]
20001426:	781b      	ldrb	r3, [r3, #0]
20001428:	2b00      	cmp	r3, #0
2000142a:	d1f3      	bne.n	20001414 <lib_strcat+0x20>
    *ptr = '\0';
2000142c:	68fb      	ldr	r3, [r7, #12]
2000142e:	2200      	movs	r2, #0
20001430:	701a      	strb	r2, [r3, #0]

    return dest;
20001432:	687b      	ldr	r3, [r7, #4]
}
20001434:	4618      	mov	r0, r3
20001436:	3714      	adds	r7, #20
20001438:	46bd      	mov	sp, r7
2000143a:	f85d 7b04 	ldr.w	r7, [sp], #4
2000143e:	4770      	bx	lr

20001440 <lib_strdup>:
#define _LIB_NO_MACROS_
#include "lib_string.h"


char *lib_strdup(char *str)
{
20001440:	b580      	push	{r7, lr}
20001442:	b084      	sub	sp, #16
20001444:	af00      	add	r7, sp, #0
20001446:	6078      	str	r0, [r7, #4]
    char *buf;

    buf = KMALLOC(lib_strlen(str)+1,0);
20001448:	6878      	ldr	r0, [r7, #4]
2000144a:	f7ff ff22 	bl	20001292 <lib_strlen>
2000144e:	4603      	mov	r3, r0
20001450:	3301      	adds	r3, #1
20001452:	2200      	movs	r2, #0
20001454:	4619      	mov	r1, r3
20001456:	4808      	ldr	r0, [pc, #32]	@ (20001478 <lib_strdup+0x38>)
20001458:	f7ff fdac 	bl	20000fb4 <kmalloc>
2000145c:	60f8      	str	r0, [r7, #12]
    if (buf) {
2000145e:	68fb      	ldr	r3, [r7, #12]
20001460:	2b00      	cmp	r3, #0
20001462:	d003      	beq.n	2000146c <lib_strdup+0x2c>
	lib_strcpy(buf,str);
20001464:	6879      	ldr	r1, [r7, #4]
20001466:	68f8      	ldr	r0, [r7, #12]
20001468:	f7ff fecb 	bl	20001202 <lib_strcpy>
	}

    return buf;
2000146c:	68fb      	ldr	r3, [r7, #12]
}
2000146e:	4618      	mov	r0, r3
20001470:	3710      	adds	r7, #16
20001472:	46bd      	mov	sp, r7
20001474:	bd80      	pop	{r7, pc}
20001476:	bf00      	nop
20001478:	20004ab4 	.word	0x20004ab4

2000147c <cfe_finddev>:
    *  Return value:
    *  	   cfe_device_t pointer or NULL
    ********************************************************************* */

cfe_device_t *cfe_finddev(char *name)
{
2000147c:	b580      	push	{r7, lr}
2000147e:	b084      	sub	sp, #16
20001480:	af00      	add	r7, sp, #0
20001482:	6078      	str	r0, [r7, #4]
    queue_t *qb;
    cfe_device_t *dev;

    for (qb = cfe_devices.q_next; qb != &cfe_devices; qb = qb->q_next) {
20001484:	4b0e      	ldr	r3, [pc, #56]	@ (200014c0 <cfe_finddev+0x44>)
20001486:	681b      	ldr	r3, [r3, #0]
20001488:	60fb      	str	r3, [r7, #12]
2000148a:	e00f      	b.n	200014ac <cfe_finddev+0x30>
	dev = (cfe_device_t *) qb;
2000148c:	68fb      	ldr	r3, [r7, #12]
2000148e:	60bb      	str	r3, [r7, #8]
	if (strcmp(dev->dev_fullname,name) == 0) {
20001490:	68bb      	ldr	r3, [r7, #8]
20001492:	689b      	ldr	r3, [r3, #8]
20001494:	6879      	ldr	r1, [r7, #4]
20001496:	4618      	mov	r0, r3
20001498:	f7ff ff13 	bl	200012c2 <lib_strcmp>
2000149c:	4603      	mov	r3, r0
2000149e:	2b00      	cmp	r3, #0
200014a0:	d101      	bne.n	200014a6 <cfe_finddev+0x2a>
	    return dev;
200014a2:	68bb      	ldr	r3, [r7, #8]
200014a4:	e007      	b.n	200014b6 <cfe_finddev+0x3a>
    for (qb = cfe_devices.q_next; qb != &cfe_devices; qb = qb->q_next) {
200014a6:	68fb      	ldr	r3, [r7, #12]
200014a8:	681b      	ldr	r3, [r3, #0]
200014aa:	60fb      	str	r3, [r7, #12]
200014ac:	68fb      	ldr	r3, [r7, #12]
200014ae:	4a04      	ldr	r2, [pc, #16]	@ (200014c0 <cfe_finddev+0x44>)
200014b0:	4293      	cmp	r3, r2
200014b2:	d1eb      	bne.n	2000148c <cfe_finddev+0x10>
	    }
	}

    return NULL;
200014b4:	2300      	movs	r3, #0
}
200014b6:	4618      	mov	r0, r3
200014b8:	3710      	adds	r7, #16
200014ba:	46bd      	mov	sp, r7
200014bc:	bd80      	pop	{r7, pc}
200014be:	bf00      	nop
200014c0:	20004a80 	.word	0x20004a80

200014c4 <cfe_dev_enum>:
    *  	   0 if ok
    *  	   else -1
    ********************************************************************* */

int cfe_dev_enum(int idx,char *name,int *namelen)
{
200014c4:	b580      	push	{r7, lr}
200014c6:	b086      	sub	sp, #24
200014c8:	af00      	add	r7, sp, #0
200014ca:	60f8      	str	r0, [r7, #12]
200014cc:	60b9      	str	r1, [r7, #8]
200014ce:	607a      	str	r2, [r7, #4]
    queue_t *qb;
    cfe_device_t *dev;

    for (qb = cfe_devices.q_next; qb != &cfe_devices; qb = qb->q_next) {
200014d0:	4b15      	ldr	r3, [pc, #84]	@ (20001528 <cfe_dev_enum+0x64>)
200014d2:	681b      	ldr	r3, [r3, #0]
200014d4:	617b      	str	r3, [r7, #20]
200014d6:	e008      	b.n	200014ea <cfe_dev_enum+0x26>
	if (idx == 0) break;
200014d8:	68fb      	ldr	r3, [r7, #12]
200014da:	2b00      	cmp	r3, #0
200014dc:	d00a      	beq.n	200014f4 <cfe_dev_enum+0x30>
	idx--;
200014de:	68fb      	ldr	r3, [r7, #12]
200014e0:	3b01      	subs	r3, #1
200014e2:	60fb      	str	r3, [r7, #12]
    for (qb = cfe_devices.q_next; qb != &cfe_devices; qb = qb->q_next) {
200014e4:	697b      	ldr	r3, [r7, #20]
200014e6:	681b      	ldr	r3, [r3, #0]
200014e8:	617b      	str	r3, [r7, #20]
200014ea:	697b      	ldr	r3, [r7, #20]
200014ec:	4a0e      	ldr	r2, [pc, #56]	@ (20001528 <cfe_dev_enum+0x64>)
200014ee:	4293      	cmp	r3, r2
200014f0:	d1f2      	bne.n	200014d8 <cfe_dev_enum+0x14>
200014f2:	e000      	b.n	200014f6 <cfe_dev_enum+0x32>
	if (idx == 0) break;
200014f4:	bf00      	nop
	}

    if (qb == &cfe_devices) return (-1);
200014f6:	697b      	ldr	r3, [r7, #20]
200014f8:	4a0b      	ldr	r2, [pc, #44]	@ (20001528 <cfe_dev_enum+0x64>)
200014fa:	4293      	cmp	r3, r2
200014fc:	d102      	bne.n	20001504 <cfe_dev_enum+0x40>
200014fe:	f04f 33ff 	mov.w	r3, #4294967295	@ 0xffffffff
20001502:	e00d      	b.n	20001520 <cfe_dev_enum+0x5c>
    dev = (cfe_device_t *) qb;
20001504:	697b      	ldr	r3, [r7, #20]
20001506:	613b      	str	r3, [r7, #16]

    *namelen = xstrncpy(name,dev->dev_fullname,*namelen);
20001508:	693b      	ldr	r3, [r7, #16]
2000150a:	6899      	ldr	r1, [r3, #8]
2000150c:	687b      	ldr	r3, [r7, #4]
2000150e:	681b      	ldr	r3, [r3, #0]
20001510:	461a      	mov	r2, r3
20001512:	68b8      	ldr	r0, [r7, #8]
20001514:	f7ff fe93 	bl	2000123e <lib_xstrncpy>
20001518:	4602      	mov	r2, r0
2000151a:	687b      	ldr	r3, [r7, #4]
2000151c:	601a      	str	r2, [r3, #0]

    return 0;
2000151e:	2300      	movs	r3, #0

}
20001520:	4618      	mov	r0, r3
20001522:	3718      	adds	r7, #24
20001524:	46bd      	mov	sp, r7
20001526:	bd80      	pop	{r7, pc}
20001528:	20004a80 	.word	0x20004a80

2000152c <cfe_attach_idx>:
    *  	   1 if we were successful.
    ********************************************************************* */

int cfe_attach_idx(cfe_driver_t *drv,int idx,void *softc,
		   char *bootinfo,char *description)
{
2000152c:	b580      	push	{r7, lr}
2000152e:	b096      	sub	sp, #88	@ 0x58
20001530:	af00      	add	r7, sp, #0
20001532:	60f8      	str	r0, [r7, #12]
20001534:	60b9      	str	r1, [r7, #8]
20001536:	607a      	str	r2, [r7, #4]
20001538:	603b      	str	r3, [r7, #0]
    char name[64];
    cfe_device_t *dev;

    xsprintf(name,"%s%d",drv->drv_bootname,idx);
2000153a:	68fb      	ldr	r3, [r7, #12]
2000153c:	685a      	ldr	r2, [r3, #4]
2000153e:	f107 0014 	add.w	r0, r7, #20
20001542:	68bb      	ldr	r3, [r7, #8]
20001544:	4928      	ldr	r1, [pc, #160]	@ (200015e8 <cfe_attach_idx+0xbc>)
20001546:	f7ff fb59 	bl	20000bfc <xsprintf>

    if (bootinfo) {
2000154a:	683b      	ldr	r3, [r7, #0]
2000154c:	2b00      	cmp	r3, #0
2000154e:	d00b      	beq.n	20001568 <cfe_attach_idx+0x3c>
	strcat(name,".");
20001550:	f107 0314 	add.w	r3, r7, #20
20001554:	4925      	ldr	r1, [pc, #148]	@ (200015ec <cfe_attach_idx+0xc0>)
20001556:	4618      	mov	r0, r3
20001558:	f7ff ff4c 	bl	200013f4 <lib_strcat>
	strcat(name,bootinfo);
2000155c:	f107 0314 	add.w	r3, r7, #20
20001560:	6839      	ldr	r1, [r7, #0]
20001562:	4618      	mov	r0, r3
20001564:	f7ff ff46 	bl	200013f4 <lib_strcat>
	}

    if (cfe_finddev(name) != NULL) {
20001568:	f107 0314 	add.w	r3, r7, #20
2000156c:	4618      	mov	r0, r3
2000156e:	f7ff ff85 	bl	2000147c <cfe_finddev>
20001572:	4603      	mov	r3, r0
20001574:	2b00      	cmp	r3, #0
20001576:	d001      	beq.n	2000157c <cfe_attach_idx+0x50>
	return 0;
20001578:	2300      	movs	r3, #0
2000157a:	e031      	b.n	200015e0 <cfe_attach_idx+0xb4>
	}

    dev = (cfe_device_t *) KMALLOC(sizeof(cfe_device_t),0);
2000157c:	2200      	movs	r2, #0
2000157e:	2120      	movs	r1, #32
20001580:	481b      	ldr	r0, [pc, #108]	@ (200015f0 <cfe_attach_idx+0xc4>)
20001582:	f7ff fd17 	bl	20000fb4 <kmalloc>
20001586:	6578      	str	r0, [r7, #84]	@ 0x54
    if (!dev) return -1;
20001588:	6d7b      	ldr	r3, [r7, #84]	@ 0x54
2000158a:	2b00      	cmp	r3, #0
2000158c:	d102      	bne.n	20001594 <cfe_attach_idx+0x68>
2000158e:	f04f 33ff 	mov.w	r3, #4294967295	@ 0xffffffff
20001592:	e025      	b.n	200015e0 <cfe_attach_idx+0xb4>

    dev->dev_fullname = strdup(name);
20001594:	f107 0314 	add.w	r3, r7, #20
20001598:	4618      	mov	r0, r3
2000159a:	f7ff ff51 	bl	20001440 <lib_strdup>
2000159e:	4602      	mov	r2, r0
200015a0:	6d7b      	ldr	r3, [r7, #84]	@ 0x54
200015a2:	609a      	str	r2, [r3, #8]
    dev->dev_softc = softc;
200015a4:	6d7b      	ldr	r3, [r7, #84]	@ 0x54
200015a6:	687a      	ldr	r2, [r7, #4]
200015a8:	60da      	str	r2, [r3, #12]
    dev->dev_class = drv->drv_class;
200015aa:	68fb      	ldr	r3, [r7, #12]
200015ac:	689a      	ldr	r2, [r3, #8]
200015ae:	6d7b      	ldr	r3, [r7, #84]	@ 0x54
200015b0:	611a      	str	r2, [r3, #16]
    dev->dev_dispatch = drv->drv_dispatch;
200015b2:	68fb      	ldr	r3, [r7, #12]
200015b4:	68da      	ldr	r2, [r3, #12]
200015b6:	6d7b      	ldr	r3, [r7, #84]	@ 0x54
200015b8:	615a      	str	r2, [r3, #20]
    dev->dev_description = description ? strdup(description) : NULL;
200015ba:	6e3b      	ldr	r3, [r7, #96]	@ 0x60
200015bc:	2b00      	cmp	r3, #0
200015be:	d004      	beq.n	200015ca <cfe_attach_idx+0x9e>
200015c0:	6e38      	ldr	r0, [r7, #96]	@ 0x60
200015c2:	f7ff ff3d 	bl	20001440 <lib_strdup>
200015c6:	4603      	mov	r3, r0
200015c8:	e000      	b.n	200015cc <cfe_attach_idx+0xa0>
200015ca:	2300      	movs	r3, #0
200015cc:	6d7a      	ldr	r2, [r7, #84]	@ 0x54
200015ce:	61d3      	str	r3, [r2, #28]
    dev->dev_opencount = 0;
200015d0:	6d7b      	ldr	r3, [r7, #84]	@ 0x54
200015d2:	2200      	movs	r2, #0
200015d4:	619a      	str	r2, [r3, #24]

    q_enqueue(&cfe_devices,(queue_t *) dev);
200015d6:	6d79      	ldr	r1, [r7, #84]	@ 0x54
200015d8:	4806      	ldr	r0, [pc, #24]	@ (200015f4 <cfe_attach_idx+0xc8>)
200015da:	f7ff fdab 	bl	20001134 <q_enqueue>

    return 1;
200015de:	2301      	movs	r3, #1

}
200015e0:	4618      	mov	r0, r3
200015e2:	3758      	adds	r7, #88	@ 0x58
200015e4:	46bd      	mov	sp, r7
200015e6:	bd80      	pop	{r7, pc}
200015e8:	20004488 	.word	0x20004488
200015ec:	20004490 	.word	0x20004490
200015f0:	20004ab4 	.word	0x20004ab4
200015f4:	20004a80 	.word	0x20004a80

200015f8 <cfe_attach>:
    ********************************************************************* */

void cfe_attach(cfe_driver_t *drv,void *softc,
		char *bootinfo,
		char *description)
{
200015f8:	b580      	push	{r7, lr}
200015fa:	b088      	sub	sp, #32
200015fc:	af02      	add	r7, sp, #8
200015fe:	60f8      	str	r0, [r7, #12]
20001600:	60b9      	str	r1, [r7, #8]
20001602:	607a      	str	r2, [r7, #4]
20001604:	603b      	str	r3, [r7, #0]
     * Try device indicies 0..CFE_MAX_DEVINST to assign a unique
     * device name for this device.  This is a really braindead way to 
     * do this, but how many devices are we expecting anyway?
     */

    for (idx = 0; idx < CFE_MAX_DEVINST; idx++) {
20001606:	2300      	movs	r3, #0
20001608:	617b      	str	r3, [r7, #20]
2000160a:	e011      	b.n	20001630 <cfe_attach+0x38>

	res = cfe_attach_idx(drv,idx,softc,bootinfo,description);
2000160c:	683b      	ldr	r3, [r7, #0]
2000160e:	9300      	str	r3, [sp, #0]
20001610:	687b      	ldr	r3, [r7, #4]
20001612:	68ba      	ldr	r2, [r7, #8]
20001614:	6979      	ldr	r1, [r7, #20]
20001616:	68f8      	ldr	r0, [r7, #12]
20001618:	f7ff ff88 	bl	2000152c <cfe_attach_idx>
2000161c:	6138      	str	r0, [r7, #16]

	if (res < 0) break;	/* out of memory or other badness */
2000161e:	693b      	ldr	r3, [r7, #16]
20001620:	2b00      	cmp	r3, #0
20001622:	db09      	blt.n	20001638 <cfe_attach+0x40>
	if (res > 0) break;	/* success! */
20001624:	693b      	ldr	r3, [r7, #16]
20001626:	2b00      	cmp	r3, #0
20001628:	dc08      	bgt.n	2000163c <cfe_attach+0x44>
    for (idx = 0; idx < CFE_MAX_DEVINST; idx++) {
2000162a:	697b      	ldr	r3, [r7, #20]
2000162c:	3301      	adds	r3, #1
2000162e:	617b      	str	r3, [r7, #20]
20001630:	697b      	ldr	r3, [r7, #20]
20001632:	2b3f      	cmp	r3, #63	@ 0x3f
20001634:	ddea      	ble.n	2000160c <cfe_attach+0x14>
	/* otherwise, try again, slot is taken */
	}

}
20001636:	e002      	b.n	2000163e <cfe_attach+0x46>
	if (res < 0) break;	/* out of memory or other badness */
20001638:	bf00      	nop
2000163a:	e000      	b.n	2000163e <cfe_attach+0x46>
	if (res > 0) break;	/* success! */
2000163c:	bf00      	nop
}
2000163e:	bf00      	nop
20001640:	3718      	adds	r7, #24
20001642:	46bd      	mov	sp, r7
20001644:	bd80      	pop	{r7, pc}
	...

20001648 <cfe_attach_init>:
    *  	  
    *  Return value:
    *  	   nothing
    ********************************************************************* */
void cfe_attach_init(void)
{
20001648:	b480      	push	{r7}
2000164a:	af00      	add	r7, sp, #0
    q_init(&(cfe_devices));
2000164c:	4b05      	ldr	r3, [pc, #20]	@ (20001664 <cfe_attach_init+0x1c>)
2000164e:	4a05      	ldr	r2, [pc, #20]	@ (20001664 <cfe_attach_init+0x1c>)
20001650:	605a      	str	r2, [r3, #4]
20001652:	4b04      	ldr	r3, [pc, #16]	@ (20001664 <cfe_attach_init+0x1c>)
20001654:	4a03      	ldr	r2, [pc, #12]	@ (20001664 <cfe_attach_init+0x1c>)
20001656:	601a      	str	r2, [r3, #0]
}
20001658:	bf00      	nop
2000165a:	46bd      	mov	sp, r7
2000165c:	f85d 7b04 	ldr.w	r7, [sp], #4
20001660:	4770      	bx	lr
20001662:	bf00      	nop
20001664:	20004a80 	.word	0x20004a80

20001668 <cfe_bg_init>:
    *  Return value:
    *  	   nothing
    ********************************************************************* */

void cfe_bg_init(void)
{
20001668:	b580      	push	{r7, lr}
2000166a:	af00      	add	r7, sp, #0
    memset(cfe_bg_tasklist,0,sizeof(cfe_bg_tasklist));
2000166c:	2240      	movs	r2, #64	@ 0x40
2000166e:	2100      	movs	r1, #0
20001670:	4802      	ldr	r0, [pc, #8]	@ (2000167c <cfe_bg_init+0x14>)
20001672:	f7ff fea3 	bl	200013bc <lib_memset>
}
20001676:	bf00      	nop
20001678:	bd80      	pop	{r7, pc}
2000167a:	bf00      	nop
2000167c:	20004ac0 	.word	0x20004ac0

20001680 <cfe_bg_add>:
    *  Return value:
    *  	   nothing
    ********************************************************************* */

void cfe_bg_add(void (*func)(void *x),void *arg)
{
20001680:	b480      	push	{r7}
20001682:	b085      	sub	sp, #20
20001684:	af00      	add	r7, sp, #0
20001686:	6078      	str	r0, [r7, #4]
20001688:	6039      	str	r1, [r7, #0]
    int idx;

    for (idx = 0; idx < MAX_BACKGROUND_TASKS; idx++) {
2000168a:	2300      	movs	r3, #0
2000168c:	60fb      	str	r3, [r7, #12]
2000168e:	e013      	b.n	200016b8 <cfe_bg_add+0x38>
	if (cfe_bg_tasklist[idx] == NULL) {
20001690:	4a0d      	ldr	r2, [pc, #52]	@ (200016c8 <cfe_bg_add+0x48>)
20001692:	68fb      	ldr	r3, [r7, #12]
20001694:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
20001698:	2b00      	cmp	r3, #0
2000169a:	d10a      	bne.n	200016b2 <cfe_bg_add+0x32>
	    cfe_bg_tasklist[idx] = func;
2000169c:	490a      	ldr	r1, [pc, #40]	@ (200016c8 <cfe_bg_add+0x48>)
2000169e:	68fb      	ldr	r3, [r7, #12]
200016a0:	687a      	ldr	r2, [r7, #4]
200016a2:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
	    cfe_bg_args[idx] = arg;
200016a6:	4909      	ldr	r1, [pc, #36]	@ (200016cc <cfe_bg_add+0x4c>)
200016a8:	68fb      	ldr	r3, [r7, #12]
200016aa:	683a      	ldr	r2, [r7, #0]
200016ac:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
	    return;
200016b0:	e005      	b.n	200016be <cfe_bg_add+0x3e>
    for (idx = 0; idx < MAX_BACKGROUND_TASKS; idx++) {
200016b2:	68fb      	ldr	r3, [r7, #12]
200016b4:	3301      	adds	r3, #1
200016b6:	60fb      	str	r3, [r7, #12]
200016b8:	68fb      	ldr	r3, [r7, #12]
200016ba:	2b0f      	cmp	r3, #15
200016bc:	dde8      	ble.n	20001690 <cfe_bg_add+0x10>
	    }
	}
}
200016be:	3714      	adds	r7, #20
200016c0:	46bd      	mov	sp, r7
200016c2:	f85d 7b04 	ldr.w	r7, [sp], #4
200016c6:	4770      	bx	lr
200016c8:	20004ac0 	.word	0x20004ac0
200016cc:	20004b00 	.word	0x20004b00

200016d0 <background>:
    *  Return value:
    *  	   nothing
    ********************************************************************* */

void background(void)
{
200016d0:	b580      	push	{r7, lr}
200016d2:	b082      	sub	sp, #8
200016d4:	af00      	add	r7, sp, #0
    int idx;
    void (*func)(void *arg);

    for (idx = 0; idx < MAX_BACKGROUND_TASKS; idx++) {
200016d6:	2300      	movs	r3, #0
200016d8:	607b      	str	r3, [r7, #4]
200016da:	e011      	b.n	20001700 <background+0x30>
	func = cfe_bg_tasklist[idx];
200016dc:	4a0d      	ldr	r2, [pc, #52]	@ (20001714 <background+0x44>)
200016de:	687b      	ldr	r3, [r7, #4]
200016e0:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
200016e4:	603b      	str	r3, [r7, #0]
	if (func == NULL) break;
200016e6:	683b      	ldr	r3, [r7, #0]
200016e8:	2b00      	cmp	r3, #0
200016ea:	d00d      	beq.n	20001708 <background+0x38>
	(*func)(cfe_bg_args[idx]);
200016ec:	4a0a      	ldr	r2, [pc, #40]	@ (20001718 <background+0x48>)
200016ee:	687b      	ldr	r3, [r7, #4]
200016f0:	f852 2023 	ldr.w	r2, [r2, r3, lsl #2]
200016f4:	683b      	ldr	r3, [r7, #0]
200016f6:	4610      	mov	r0, r2
200016f8:	4798      	blx	r3
    for (idx = 0; idx < MAX_BACKGROUND_TASKS; idx++) {
200016fa:	687b      	ldr	r3, [r7, #4]
200016fc:	3301      	adds	r3, #1
200016fe:	607b      	str	r3, [r7, #4]
20001700:	687b      	ldr	r3, [r7, #4]
20001702:	2b0f      	cmp	r3, #15
20001704:	ddea      	ble.n	200016dc <background+0xc>
	}
}
20001706:	e000      	b.n	2000170a <background+0x3a>
	if (func == NULL) break;
20001708:	bf00      	nop
}
2000170a:	bf00      	nop
2000170c:	3708      	adds	r7, #8
2000170e:	46bd      	mov	sp, r7
20001710:	bd80      	pop	{r7, pc}
20001712:	bf00      	nop
20001714:	20004ac0 	.word	0x20004ac0
20001718:	20004b00 	.word	0x20004b00

2000171c <console_open>:
    *  	   0 if ok, else return code.  
    *  	   console_handle contains the console's handle
    ********************************************************************* */

int console_open(char *name)
{
2000171c:	b580      	push	{r7, lr}
2000171e:	b084      	sub	sp, #16
20001720:	af00      	add	r7, sp, #0
20001722:	6078      	str	r0, [r7, #4]

#else

    int flushbuf;

    console_name = NULL;
20001724:	4b14      	ldr	r3, [pc, #80]	@ (20001778 <console_open+0x5c>)
20001726:	2200      	movs	r2, #0
20001728:	601a      	str	r2, [r3, #0]

    if (console_handle != -1) {
2000172a:	4b14      	ldr	r3, [pc, #80]	@ (2000177c <console_open+0x60>)
2000172c:	681b      	ldr	r3, [r3, #0]
2000172e:	f1b3 3fff 	cmp.w	r3, #4294967295	@ 0xffffffff
20001732:	d001      	beq.n	20001738 <console_open+0x1c>
	console_close();
20001734:	f000 f826 	bl	20001784 <console_close>
	}

    flushbuf = console_buffer_flg;
20001738:	4b11      	ldr	r3, [pc, #68]	@ (20001780 <console_open+0x64>)
2000173a:	681b      	ldr	r3, [r3, #0]
2000173c:	60fb      	str	r3, [r7, #12]
    console_buffer_flg = 0;
2000173e:	4b10      	ldr	r3, [pc, #64]	@ (20001780 <console_open+0x64>)
20001740:	2200      	movs	r2, #0
20001742:	601a      	str	r2, [r3, #0]

    console_handle = cfe_open(name);
20001744:	6878      	ldr	r0, [r7, #4]
20001746:	f001 f842 	bl	200027ce <cfe_open>
2000174a:	4603      	mov	r3, r0
2000174c:	4a0b      	ldr	r2, [pc, #44]	@ (2000177c <console_open+0x60>)
2000174e:	6013      	str	r3, [r2, #0]
    if (console_handle < 0) return CFE_ERR_DEVNOTFOUND;
20001750:	4b0a      	ldr	r3, [pc, #40]	@ (2000177c <console_open+0x60>)
20001752:	681b      	ldr	r3, [r3, #0]
20001754:	2b00      	cmp	r3, #0
20001756:	da02      	bge.n	2000175e <console_open+0x42>
20001758:	f06f 0305 	mvn.w	r3, #5
2000175c:	e008      	b.n	20001770 <console_open+0x54>

    console_name = name;
2000175e:	4a06      	ldr	r2, [pc, #24]	@ (20001778 <console_open+0x5c>)
20001760:	687b      	ldr	r3, [r7, #4]
20001762:	6013      	str	r3, [r2, #0]
    if (flushbuf) console_flushbuffer();
20001764:	68fb      	ldr	r3, [r7, #12]
20001766:	2b00      	cmp	r3, #0
20001768:	d001      	beq.n	2000176e <console_open+0x52>
2000176a:	f000 f8f9 	bl	20001960 <console_flushbuffer>
#endif

    return 0;
2000176e:	2300      	movs	r3, #0
}
20001770:	4618      	mov	r0, r3
20001772:	3710      	adds	r7, #16
20001774:	46bd      	mov	sp, r7
20001776:	bd80      	pop	{r7, pc}
20001778:	20004bc8 	.word	0x20004bc8
2000177c:	20004a90 	.word	0x20004a90
20001780:	20004bc0 	.word	0x20004bc0

20001784 <console_close>:
    *  Return value:
    *  	   0
    ********************************************************************* */

int console_close(void)
{
20001784:	b580      	push	{r7, lr}
20001786:	af00      	add	r7, sp, #0
    if (console_handle != -1) {
20001788:	4b08      	ldr	r3, [pc, #32]	@ (200017ac <console_close+0x28>)
2000178a:	681b      	ldr	r3, [r3, #0]
2000178c:	f1b3 3fff 	cmp.w	r3, #4294967295	@ 0xffffffff
20001790:	d004      	beq.n	2000179c <console_close+0x18>
	cfe_close(console_handle);
20001792:	4b06      	ldr	r3, [pc, #24]	@ (200017ac <console_close+0x28>)
20001794:	681b      	ldr	r3, [r3, #0]
20001796:	4618      	mov	r0, r3
20001798:	f001 f843 	bl	20002822 <cfe_close>
	}

    console_handle = -1;
2000179c:	4b03      	ldr	r3, [pc, #12]	@ (200017ac <console_close+0x28>)
2000179e:	f04f 32ff 	mov.w	r2, #4294967295	@ 0xffffffff
200017a2:	601a      	str	r2, [r3, #0]

    return 0;
200017a4:	2300      	movs	r3, #0
}
200017a6:	4618      	mov	r0, r3
200017a8:	bd80      	pop	{r7, pc}
200017aa:	bf00      	nop
200017ac:	20004a90 	.word	0x20004a90

200017b0 <console_read>:
    *  Return value:
    *  	   number of characters received, or <0 if error code
    ********************************************************************* */

int console_read(unsigned char *buffer,int length)
{
200017b0:	b580      	push	{r7, lr}
200017b2:	b082      	sub	sp, #8
200017b4:	af00      	add	r7, sp, #0
200017b6:	6078      	str	r0, [r7, #4]
200017b8:	6039      	str	r1, [r7, #0]
    if (console_handle == -1) return -1;
200017ba:	4b0a      	ldr	r3, [pc, #40]	@ (200017e4 <console_read+0x34>)
200017bc:	681b      	ldr	r3, [r3, #0]
200017be:	f1b3 3fff 	cmp.w	r3, #4294967295	@ 0xffffffff
200017c2:	d102      	bne.n	200017ca <console_read+0x1a>
200017c4:	f04f 33ff 	mov.w	r3, #4294967295	@ 0xffffffff
200017c8:	e007      	b.n	200017da <console_read+0x2a>

    return cfe_read(console_handle,PTR2HSADDR(buffer),length);
200017ca:	4b06      	ldr	r3, [pc, #24]	@ (200017e4 <console_read+0x34>)
200017cc:	681b      	ldr	r3, [r3, #0]
200017ce:	6879      	ldr	r1, [r7, #4]
200017d0:	683a      	ldr	r2, [r7, #0]
200017d2:	4618      	mov	r0, r3
200017d4:	f001 f866 	bl	200028a4 <cfe_read>
200017d8:	4603      	mov	r3, r0
}
200017da:	4618      	mov	r0, r3
200017dc:	3708      	adds	r7, #8
200017de:	46bd      	mov	sp, r7
200017e0:	bd80      	pop	{r7, pc}
200017e2:	bf00      	nop
200017e4:	20004a90 	.word	0x20004a90

200017e8 <console_write>:
    *  Return value:
    *  	   number of characters written or <0 if error
    ********************************************************************* */

int console_write(unsigned char *buffer,int length)
{
200017e8:	b580      	push	{r7, lr}
200017ea:	b084      	sub	sp, #16
200017ec:	af00      	add	r7, sp, #0
200017ee:	6078      	str	r0, [r7, #4]
200017f0:	6039      	str	r1, [r7, #0]

#if !CFG_MINIMAL_SIZE
    /*
     * Buffer text if requested
     */
    if (console_buffer_flg) {
200017f2:	4b1b      	ldr	r3, [pc, #108]	@ (20001860 <console_write+0x78>)
200017f4:	681b      	ldr	r3, [r3, #0]
200017f6:	2b00      	cmp	r3, #0
200017f8:	d005      	beq.n	20001806 <console_write+0x1e>
	console_save(buffer,length);
200017fa:	6839      	ldr	r1, [r7, #0]
200017fc:	6878      	ldr	r0, [r7, #4]
200017fe:	f000 f8eb 	bl	200019d8 <console_save>
	return length;
20001802:	683b      	ldr	r3, [r7, #0]
20001804:	e028      	b.n	20001858 <console_write+0x70>

    /*
     * Do nothing if no console
     */

    if (console_handle == -1) return -1;
20001806:	4b17      	ldr	r3, [pc, #92]	@ (20001864 <console_write+0x7c>)
20001808:	681b      	ldr	r3, [r3, #0]
2000180a:	f1b3 3fff 	cmp.w	r3, #4294967295	@ 0xffffffff
2000180e:	d102      	bne.n	20001816 <console_write+0x2e>
20001810:	f04f 33ff 	mov.w	r3, #4294967295	@ 0xffffffff
20001814:	e020      	b.n	20001858 <console_write+0x70>
    /*
     * Write text to device
     */

    for (;;) {
	res = cfe_write(console_handle,PTR2HSADDR(buffer),length);
20001816:	4b13      	ldr	r3, [pc, #76]	@ (20001864 <console_write+0x7c>)
20001818:	681b      	ldr	r3, [r3, #0]
2000181a:	6879      	ldr	r1, [r7, #4]
2000181c:	683a      	ldr	r2, [r7, #0]
2000181e:	4618      	mov	r0, r3
20001820:	f001 f87f 	bl	20002922 <cfe_write>
20001824:	60f8      	str	r0, [r7, #12]
	if (res < 0) break;
20001826:	68fb      	ldr	r3, [r7, #12]
20001828:	2b00      	cmp	r3, #0
2000182a:	db0b      	blt.n	20001844 <console_write+0x5c>
	buffer += res;
2000182c:	68fb      	ldr	r3, [r7, #12]
2000182e:	687a      	ldr	r2, [r7, #4]
20001830:	4413      	add	r3, r2
20001832:	607b      	str	r3, [r7, #4]
	length -= res;
20001834:	683a      	ldr	r2, [r7, #0]
20001836:	68fb      	ldr	r3, [r7, #12]
20001838:	1ad3      	subs	r3, r2, r3
2000183a:	603b      	str	r3, [r7, #0]
	if (length == 0) break;
2000183c:	683b      	ldr	r3, [r7, #0]
2000183e:	2b00      	cmp	r3, #0
20001840:	d002      	beq.n	20001848 <console_write+0x60>
	res = cfe_write(console_handle,PTR2HSADDR(buffer),length);
20001842:	e7e8      	b.n	20001816 <console_write+0x2e>
	if (res < 0) break;
20001844:	bf00      	nop
20001846:	e000      	b.n	2000184a <console_write+0x62>
	if (length == 0) break;
20001848:	bf00      	nop
	}

    if (res < 0) return -1;
2000184a:	68fb      	ldr	r3, [r7, #12]
2000184c:	2b00      	cmp	r3, #0
2000184e:	da02      	bge.n	20001856 <console_write+0x6e>
20001850:	f04f 33ff 	mov.w	r3, #4294967295	@ 0xffffffff
20001854:	e000      	b.n	20001858 <console_write+0x70>
    return 0;			 
20001856:	2300      	movs	r3, #0
}
20001858:	4618      	mov	r0, r3
2000185a:	3710      	adds	r7, #16
2000185c:	46bd      	mov	sp, r7
2000185e:	bd80      	pop	{r7, pc}
20001860:	20004bc0 	.word	0x20004bc0
20001864:	20004a90 	.word	0x20004a90

20001868 <console_status>:
    *  	   0 if no characters are available
    *  	   1 if characters are available.
    ********************************************************************* */

int console_status(void)
{
20001868:	b580      	push	{r7, lr}
2000186a:	af00      	add	r7, sp, #0
    if (console_handle == -1) return 0;
2000186c:	4b07      	ldr	r3, [pc, #28]	@ (2000188c <console_status+0x24>)
2000186e:	681b      	ldr	r3, [r3, #0]
20001870:	f1b3 3fff 	cmp.w	r3, #4294967295	@ 0xffffffff
20001874:	d101      	bne.n	2000187a <console_status+0x12>
20001876:	2300      	movs	r3, #0
20001878:	e005      	b.n	20001886 <console_status+0x1e>

    return cfe_inpstat(console_handle);
2000187a:	4b04      	ldr	r3, [pc, #16]	@ (2000188c <console_status+0x24>)
2000187c:	681b      	ldr	r3, [r3, #0]
2000187e:	4618      	mov	r0, r3
20001880:	f001 f865 	bl	2000294e <cfe_inpstat>
20001884:	4603      	mov	r3, r0
}
20001886:	4618      	mov	r0, r3
20001888:	bd80      	pop	{r7, pc}
2000188a:	bf00      	nop
2000188c:	20004a90 	.word	0x20004a90

20001890 <console_xprint>:
    *  Return value:
    *  	   number of characters written
    ********************************************************************* */

static int console_xprint(const char *str)
{
20001890:	b580      	push	{r7, lr}
20001892:	b086      	sub	sp, #24
20001894:	af00      	add	r7, sp, #0
20001896:	6078      	str	r0, [r7, #4]
    int count = 0;	
20001898:	2300      	movs	r3, #0
2000189a:	617b      	str	r3, [r7, #20]
    int len;
    const char *p;

    /* Convert CR to CRLF as we write things out */

    while ((p = strchr(str,'\n'))) {
2000189c:	e013      	b.n	200018c6 <console_xprint+0x36>
	console_write((unsigned char *) str,p-str);
2000189e:	693a      	ldr	r2, [r7, #16]
200018a0:	687b      	ldr	r3, [r7, #4]
200018a2:	1ad3      	subs	r3, r2, r3
200018a4:	4619      	mov	r1, r3
200018a6:	6878      	ldr	r0, [r7, #4]
200018a8:	f7ff ff9e 	bl	200017e8 <console_write>
	console_write((unsigned char *)"\r\n",2);
200018ac:	2102      	movs	r1, #2
200018ae:	4812      	ldr	r0, [pc, #72]	@ (200018f8 <console_xprint+0x68>)
200018b0:	f7ff ff9a 	bl	200017e8 <console_write>
	count += (p-str);
200018b4:	693a      	ldr	r2, [r7, #16]
200018b6:	687b      	ldr	r3, [r7, #4]
200018b8:	1ad3      	subs	r3, r2, r3
200018ba:	697a      	ldr	r2, [r7, #20]
200018bc:	4413      	add	r3, r2
200018be:	617b      	str	r3, [r7, #20]
	str = p + 1;
200018c0:	693b      	ldr	r3, [r7, #16]
200018c2:	3301      	adds	r3, #1
200018c4:	607b      	str	r3, [r7, #4]
    while ((p = strchr(str,'\n'))) {
200018c6:	210a      	movs	r1, #10
200018c8:	6878      	ldr	r0, [r7, #4]
200018ca:	f7ff fd3b 	bl	20001344 <lib_strchr>
200018ce:	6138      	str	r0, [r7, #16]
200018d0:	693b      	ldr	r3, [r7, #16]
200018d2:	2b00      	cmp	r3, #0
200018d4:	d1e3      	bne.n	2000189e <console_xprint+0xe>
	}

    len = strlen(str);
200018d6:	6878      	ldr	r0, [r7, #4]
200018d8:	f7ff fcdb 	bl	20001292 <lib_strlen>
200018dc:	60f8      	str	r0, [r7, #12]
    console_write((unsigned char *) str, len);
200018de:	68f9      	ldr	r1, [r7, #12]
200018e0:	6878      	ldr	r0, [r7, #4]
200018e2:	f7ff ff81 	bl	200017e8 <console_write>
    count += len;
200018e6:	697a      	ldr	r2, [r7, #20]
200018e8:	68fb      	ldr	r3, [r7, #12]
200018ea:	4413      	add	r3, r2
200018ec:	617b      	str	r3, [r7, #20]

    return count;
200018ee:	697b      	ldr	r3, [r7, #20]
}
200018f0:	4618      	mov	r0, r3
200018f2:	3718      	adds	r7, #24
200018f4:	46bd      	mov	sp, r7
200018f6:	bd80      	pop	{r7, pc}
200018f8:	200044a0 	.word	0x200044a0

200018fc <cfe_set_console>:
    *  	   0 if ok
    *  	   else error code
    ********************************************************************* */

int cfe_set_console(char *name)
{
200018fc:	b580      	push	{r7, lr}
200018fe:	b084      	sub	sp, #16
20001900:	af00      	add	r7, sp, #0
20001902:	6078      	str	r0, [r7, #4]
    xprinthook = console_xprint;
20001904:	4b11      	ldr	r3, [pc, #68]	@ (2000194c <cfe_set_console+0x50>)
20001906:	4a12      	ldr	r2, [pc, #72]	@ (20001950 <cfe_set_console+0x54>)
20001908:	601a      	str	r2, [r3, #0]

#if !CFG_MINIMAL_SIZE
    if (strcmp(name,CFE_BUFFER_CONSOLE) == 0) {
2000190a:	4912      	ldr	r1, [pc, #72]	@ (20001954 <cfe_set_console+0x58>)
2000190c:	6878      	ldr	r0, [r7, #4]
2000190e:	f7ff fcd8 	bl	200012c2 <lib_strcmp>
20001912:	4603      	mov	r3, r0
20001914:	2b00      	cmp	r3, #0
20001916:	d104      	bne.n	20001922 <cfe_set_console+0x26>
	console_buffer_flg = 1;
20001918:	4b0f      	ldr	r3, [pc, #60]	@ (20001958 <cfe_set_console+0x5c>)
2000191a:	2201      	movs	r2, #1
2000191c:	601a      	str	r2, [r3, #0]
	return 0;
2000191e:	2300      	movs	r3, #0
20001920:	e010      	b.n	20001944 <cfe_set_console+0x48>
	}
#endif

    if (name) {
20001922:	687b      	ldr	r3, [r7, #4]
20001924:	2b00      	cmp	r3, #0
20001926:	d00b      	beq.n	20001940 <cfe_set_console+0x44>
	int res;
	res = env_setenv("BOOT_CONSOLE",name,
20001928:	f240 1203 	movw	r2, #259	@ 0x103
2000192c:	6879      	ldr	r1, [r7, #4]
2000192e:	480b      	ldr	r0, [pc, #44]	@ (2000195c <cfe_set_console+0x60>)
20001930:	f001 fe5c 	bl	200035ec <env_setenv>
20001934:	60f8      	str	r0, [r7, #12]
		   ENV_FLG_BUILTIN | ENV_FLG_READONLY | ENV_FLG_ADMIN);
	return console_open(name);
20001936:	6878      	ldr	r0, [r7, #4]
20001938:	f7ff fef0 	bl	2000171c <console_open>
2000193c:	4603      	mov	r3, r0
2000193e:	e001      	b.n	20001944 <cfe_set_console+0x48>
	}
    return -1;
20001940:	f04f 33ff 	mov.w	r3, #4294967295	@ 0xffffffff
}
20001944:	4618      	mov	r0, r3
20001946:	3710      	adds	r7, #16
20001948:	46bd      	mov	sp, r7
2000194a:	bd80      	pop	{r7, pc}
2000194c:	20004ab0 	.word	0x20004ab0
20001950:	20001891 	.word	0x20001891
20001954:	200044b0 	.word	0x200044b0
20001958:	20004bc0 	.word	0x20004bc0
2000195c:	200044b8 	.word	0x200044b8

20001960 <console_flushbuffer>:
    *  Return value:
    *  	   nothing
    ********************************************************************* */

static void console_flushbuffer(void)
{
20001960:	b580      	push	{r7, lr}
20001962:	b084      	sub	sp, #16
20001964:	af00      	add	r7, sp, #0

    /*
     * Remove console messages from the queue 
     */

    while ((msg = (msgqueue_t *) q_deqnext(&console_msgq))) {
20001966:	e025      	b.n	200019b4 <console_flushbuffer+0x54>

	buffer = msg->data;
20001968:	687b      	ldr	r3, [r7, #4]
2000196a:	330c      	adds	r3, #12
2000196c:	60fb      	str	r3, [r7, #12]
	length = msg->len;
2000196e:	687b      	ldr	r3, [r7, #4]
20001970:	689b      	ldr	r3, [r3, #8]
20001972:	60bb      	str	r3, [r7, #8]
	res = 0;
20001974:	2300      	movs	r3, #0
20001976:	603b      	str	r3, [r7, #0]
	/*
	 * Write each message to the console 
	 */

	for (;;) {
	    res = cfe_write(console_handle,PTR2HSADDR(buffer),length);
20001978:	4b14      	ldr	r3, [pc, #80]	@ (200019cc <console_flushbuffer+0x6c>)
2000197a:	681b      	ldr	r3, [r3, #0]
2000197c:	68f9      	ldr	r1, [r7, #12]
2000197e:	68ba      	ldr	r2, [r7, #8]
20001980:	4618      	mov	r0, r3
20001982:	f000 ffce 	bl	20002922 <cfe_write>
20001986:	6038      	str	r0, [r7, #0]
	    if (res < 0) break;
20001988:	683b      	ldr	r3, [r7, #0]
2000198a:	2b00      	cmp	r3, #0
2000198c:	db0b      	blt.n	200019a6 <console_flushbuffer+0x46>
	    buffer += res;
2000198e:	683b      	ldr	r3, [r7, #0]
20001990:	68fa      	ldr	r2, [r7, #12]
20001992:	4413      	add	r3, r2
20001994:	60fb      	str	r3, [r7, #12]
	    length -= res;
20001996:	68ba      	ldr	r2, [r7, #8]
20001998:	683b      	ldr	r3, [r7, #0]
2000199a:	1ad3      	subs	r3, r2, r3
2000199c:	60bb      	str	r3, [r7, #8]
	    if (length == 0) break;
2000199e:	68bb      	ldr	r3, [r7, #8]
200019a0:	2b00      	cmp	r3, #0
200019a2:	d002      	beq.n	200019aa <console_flushbuffer+0x4a>
	    res = cfe_write(console_handle,PTR2HSADDR(buffer),length);
200019a4:	e7e8      	b.n	20001978 <console_flushbuffer+0x18>
	    if (res < 0) break;
200019a6:	bf00      	nop
200019a8:	e000      	b.n	200019ac <console_flushbuffer+0x4c>
	    if (length == 0) break;
200019aa:	bf00      	nop

	/*
	 * Free the storage
	 */

	KFREE(msg);
200019ac:	6879      	ldr	r1, [r7, #4]
200019ae:	4808      	ldr	r0, [pc, #32]	@ (200019d0 <console_flushbuffer+0x70>)
200019b0:	f7ff facc 	bl	20000f4c <kfree>
    while ((msg = (msgqueue_t *) q_deqnext(&console_msgq))) {
200019b4:	4807      	ldr	r0, [pc, #28]	@ (200019d4 <console_flushbuffer+0x74>)
200019b6:	f7ff fbea 	bl	2000118e <q_deqnext>
200019ba:	6078      	str	r0, [r7, #4]
200019bc:	687b      	ldr	r3, [r7, #4]
200019be:	2b00      	cmp	r3, #0
200019c0:	d1d2      	bne.n	20001968 <console_flushbuffer+0x8>
	}
}
200019c2:	bf00      	nop
200019c4:	bf00      	nop
200019c6:	3710      	adds	r7, #16
200019c8:	46bd      	mov	sp, r7
200019ca:	bd80      	pop	{r7, pc}
200019cc:	20004a90 	.word	0x20004a90
200019d0:	20004ab4 	.word	0x20004ab4
200019d4:	20004a88 	.word	0x20004a88

200019d8 <console_save>:
    *  Return value:
    *  	   nothing
    ********************************************************************* */

static void console_save(unsigned char *buffer,int length)
{
200019d8:	b580      	push	{r7, lr}
200019da:	b084      	sub	sp, #16
200019dc:	af00      	add	r7, sp, #0
200019de:	6078      	str	r0, [r7, #4]
200019e0:	6039      	str	r1, [r7, #0]
    /*
     * Get a pointer to the last message in the queue.  If 
     * it's full, preprare to allocate a new one
     */

    msg = (msgqueue_t *) console_msgq.q_prev;
200019e2:	4b2a      	ldr	r3, [pc, #168]	@ (20001a8c <console_save+0xb4>)
200019e4:	685b      	ldr	r3, [r3, #4]
200019e6:	60fb      	str	r3, [r7, #12]
    if (q_isempty(&(console_msgq)) || (msg->len == MSGQUEUESIZE)) {
200019e8:	4b28      	ldr	r3, [pc, #160]	@ (20001a8c <console_save+0xb4>)
200019ea:	681b      	ldr	r3, [r3, #0]
200019ec:	4a27      	ldr	r2, [pc, #156]	@ (20001a8c <console_save+0xb4>)
200019ee:	4293      	cmp	r3, r2
200019f0:	d004      	beq.n	200019fc <console_save+0x24>
200019f2:	68fb      	ldr	r3, [r7, #12]
200019f4:	689b      	ldr	r3, [r3, #8]
200019f6:	f5b3 7f80 	cmp.w	r3, #256	@ 0x100
200019fa:	d13f      	bne.n	20001a7c <console_save+0xa4>
	msg = NULL;
200019fc:	2300      	movs	r3, #0
200019fe:	60fb      	str	r3, [r7, #12]

    /*
     * Stuff characters into message chunks till we're done
     */

    while (length) {
20001a00:	e03c      	b.n	20001a7c <console_save+0xa4>

	/*
	 * New chunk 
	 */
	if (msg == NULL) {
20001a02:	68fb      	ldr	r3, [r7, #12]
20001a04:	2b00      	cmp	r3, #0
20001a06:	d122      	bne.n	20001a4e <console_save+0x76>

	    msg = (msgqueue_t *) KMALLOC(sizeof(msgqueue_t),0);
20001a08:	2200      	movs	r2, #0
20001a0a:	f44f 7186 	mov.w	r1, #268	@ 0x10c
20001a0e:	4820      	ldr	r0, [pc, #128]	@ (20001a90 <console_save+0xb8>)
20001a10:	f7ff fad0 	bl	20000fb4 <kmalloc>
20001a14:	60f8      	str	r0, [r7, #12]
	    if (msg == NULL) return;
20001a16:	68fb      	ldr	r3, [r7, #12]
20001a18:	2b00      	cmp	r3, #0
20001a1a:	d033      	beq.n	20001a84 <console_save+0xac>
	    msg->len = 0;
20001a1c:	68fb      	ldr	r3, [r7, #12]
20001a1e:	2200      	movs	r2, #0
20001a20:	609a      	str	r2, [r3, #8]
	    q_enqueue(&console_msgq,(queue_t *) msg);
20001a22:	68f9      	ldr	r1, [r7, #12]
20001a24:	4819      	ldr	r0, [pc, #100]	@ (20001a8c <console_save+0xb4>)
20001a26:	f7ff fb85 	bl	20001134 <q_enqueue>

	    /*
	     * Remove chunks to prevent chewing too much memory
	     */

	    while (q_count(&console_msgq) > MSGQUEUEMAX) {
20001a2a:	e00a      	b.n	20001a42 <console_save+0x6a>
		msgqueue_t *dropmsg;
		dropmsg = (msgqueue_t *) q_deqnext(&console_msgq);
20001a2c:	4817      	ldr	r0, [pc, #92]	@ (20001a8c <console_save+0xb4>)
20001a2e:	f7ff fbae 	bl	2000118e <q_deqnext>
20001a32:	60b8      	str	r0, [r7, #8]
		if (dropmsg) KFREE(dropmsg);
20001a34:	68bb      	ldr	r3, [r7, #8]
20001a36:	2b00      	cmp	r3, #0
20001a38:	d003      	beq.n	20001a42 <console_save+0x6a>
20001a3a:	68b9      	ldr	r1, [r7, #8]
20001a3c:	4814      	ldr	r0, [pc, #80]	@ (20001a90 <console_save+0xb8>)
20001a3e:	f7ff fa85 	bl	20000f4c <kfree>
	    while (q_count(&console_msgq) > MSGQUEUEMAX) {
20001a42:	4812      	ldr	r0, [pc, #72]	@ (20001a8c <console_save+0xb4>)
20001a44:	f7ff fbc2 	bl	200011cc <q_count>
20001a48:	4603      	mov	r3, r0
20001a4a:	2b0a      	cmp	r3, #10
20001a4c:	dcee      	bgt.n	20001a2c <console_save+0x54>

	/*
	 * Save text.  If we run off the end of the buffer, prepare
	 * to allocate a new one
	 */
	msg->data[msg->len++] = *buffer++;
20001a4e:	687a      	ldr	r2, [r7, #4]
20001a50:	1c53      	adds	r3, r2, #1
20001a52:	607b      	str	r3, [r7, #4]
20001a54:	68fb      	ldr	r3, [r7, #12]
20001a56:	689b      	ldr	r3, [r3, #8]
20001a58:	1c58      	adds	r0, r3, #1
20001a5a:	68f9      	ldr	r1, [r7, #12]
20001a5c:	6088      	str	r0, [r1, #8]
20001a5e:	7811      	ldrb	r1, [r2, #0]
20001a60:	68fa      	ldr	r2, [r7, #12]
20001a62:	4413      	add	r3, r2
20001a64:	460a      	mov	r2, r1
20001a66:	731a      	strb	r2, [r3, #12]
	length--;
20001a68:	683b      	ldr	r3, [r7, #0]
20001a6a:	3b01      	subs	r3, #1
20001a6c:	603b      	str	r3, [r7, #0]
	if (msg->len == MSGQUEUESIZE) msg = NULL;
20001a6e:	68fb      	ldr	r3, [r7, #12]
20001a70:	689b      	ldr	r3, [r3, #8]
20001a72:	f5b3 7f80 	cmp.w	r3, #256	@ 0x100
20001a76:	d101      	bne.n	20001a7c <console_save+0xa4>
20001a78:	2300      	movs	r3, #0
20001a7a:	60fb      	str	r3, [r7, #12]
    while (length) {
20001a7c:	683b      	ldr	r3, [r7, #0]
20001a7e:	2b00      	cmp	r3, #0
20001a80:	d1bf      	bne.n	20001a02 <console_save+0x2a>
20001a82:	e000      	b.n	20001a86 <console_save+0xae>
	    if (msg == NULL) return;
20001a84:	bf00      	nop
	}
}
20001a86:	3710      	adds	r7, #16
20001a88:	46bd      	mov	sp, r7
20001a8a:	bd80      	pop	{r7, pc}
20001a8c:	20004a88 	.word	0x20004a88
20001a90:	20004ab4 	.word	0x20004ab4

20001a94 <console_readnum>:
    *  Return value:
    *  	   nothing
    ********************************************************************* */

static void console_readnum(int *num,unsigned char *ch)
{
20001a94:	b580      	push	{r7, lr}
20001a96:	b084      	sub	sp, #16
20001a98:	af00      	add	r7, sp, #0
20001a9a:	6078      	str	r0, [r7, #4]
20001a9c:	6039      	str	r1, [r7, #0]
    int total = 0;
20001a9e:	2300      	movs	r3, #0
20001aa0:	60fb      	str	r3, [r7, #12]

    for (;;) {
	total = (total * 10) + (*ch - '0');
20001aa2:	68fa      	ldr	r2, [r7, #12]
20001aa4:	4613      	mov	r3, r2
20001aa6:	009b      	lsls	r3, r3, #2
20001aa8:	4413      	add	r3, r2
20001aaa:	005b      	lsls	r3, r3, #1
20001aac:	461a      	mov	r2, r3
20001aae:	683b      	ldr	r3, [r7, #0]
20001ab0:	781b      	ldrb	r3, [r3, #0]
20001ab2:	3b30      	subs	r3, #48	@ 0x30
20001ab4:	4413      	add	r3, r2
20001ab6:	60fb      	str	r3, [r7, #12]
	while (console_read(ch,1) != 1) { POLL(); }
20001ab8:	e001      	b.n	20001abe <console_readnum+0x2a>
20001aba:	f7ff fe09 	bl	200016d0 <background>
20001abe:	2101      	movs	r1, #1
20001ac0:	6838      	ldr	r0, [r7, #0]
20001ac2:	f7ff fe75 	bl	200017b0 <console_read>
20001ac6:	4603      	mov	r3, r0
20001ac8:	2b01      	cmp	r3, #1
20001aca:	d1f6      	bne.n	20001aba <console_readnum+0x26>
	if (!((*ch >= '0') && (*ch <= '9'))) break;
20001acc:	683b      	ldr	r3, [r7, #0]
20001ace:	781b      	ldrb	r3, [r3, #0]
20001ad0:	2b2f      	cmp	r3, #47	@ 0x2f
20001ad2:	d904      	bls.n	20001ade <console_readnum+0x4a>
20001ad4:	683b      	ldr	r3, [r7, #0]
20001ad6:	781b      	ldrb	r3, [r3, #0]
20001ad8:	2b39      	cmp	r3, #57	@ 0x39
20001ada:	d800      	bhi.n	20001ade <console_readnum+0x4a>
	total = (total * 10) + (*ch - '0');
20001adc:	e7e1      	b.n	20001aa2 <console_readnum+0xe>
	}

    *num = total;
20001ade:	687b      	ldr	r3, [r7, #4]
20001ae0:	68fa      	ldr	r2, [r7, #12]
20001ae2:	601a      	str	r2, [r3, #0]
}
20001ae4:	bf00      	nop
20001ae6:	3710      	adds	r7, #16
20001ae8:	46bd      	mov	sp, r7
20001aea:	bd80      	pop	{r7, pc}

20001aec <console_readkey>:
    *  Return value:
    *  	   virtual key code
    ********************************************************************* */

int console_readkey(void)
{
20001aec:	b580      	push	{r7, lr}
20001aee:	b082      	sub	sp, #8
20001af0:	af00      	add	r7, sp, #0
    unsigned char ch;
    int num;

    GETCHAR(ch);
20001af2:	e001      	b.n	20001af8 <console_readkey+0xc>
20001af4:	f7ff fdec 	bl	200016d0 <background>
20001af8:	1dfb      	adds	r3, r7, #7
20001afa:	2101      	movs	r1, #1
20001afc:	4618      	mov	r0, r3
20001afe:	f7ff fe57 	bl	200017b0 <console_read>
20001b02:	4603      	mov	r3, r0
20001b04:	2b01      	cmp	r3, #1
20001b06:	d1f5      	bne.n	20001af4 <console_readkey+0x8>

    switch (ch) {
20001b08:	79fb      	ldrb	r3, [r7, #7]
20001b0a:	2b1b      	cmp	r3, #27
20001b0c:	f040 80f6 	bne.w	20001cfc <console_readkey+0x210>
	case VKEY_ESC:
	    GETCHAR(ch);
20001b10:	e001      	b.n	20001b16 <console_readkey+0x2a>
20001b12:	f7ff fddd 	bl	200016d0 <background>
20001b16:	1dfb      	adds	r3, r7, #7
20001b18:	2101      	movs	r1, #1
20001b1a:	4618      	mov	r0, r3
20001b1c:	f7ff fe48 	bl	200017b0 <console_read>
20001b20:	4603      	mov	r3, r0
20001b22:	2b01      	cmp	r3, #1
20001b24:	d1f5      	bne.n	20001b12 <console_readkey+0x26>
	    switch (ch) {
20001b26:	79fb      	ldrb	r3, [r7, #7]
20001b28:	2b4f      	cmp	r3, #79	@ 0x4f
20001b2a:	d004      	beq.n	20001b36 <console_readkey+0x4a>
20001b2c:	2b5b      	cmp	r3, #91	@ 0x5b
20001b2e:	d029      	beq.n	20001b84 <console_readkey+0x98>
20001b30:	e0e2      	b.n	20001cf8 <console_readkey+0x20c>
		case 'O':
		    GETCHAR(ch);
20001b32:	f7ff fdcd 	bl	200016d0 <background>
20001b36:	1dfb      	adds	r3, r7, #7
20001b38:	2101      	movs	r1, #1
20001b3a:	4618      	mov	r0, r3
20001b3c:	f7ff fe38 	bl	200017b0 <console_read>
20001b40:	4603      	mov	r3, r0
20001b42:	2b01      	cmp	r3, #1
20001b44:	d1f5      	bne.n	20001b32 <console_readkey+0x46>
		    switch (ch) {
20001b46:	79fb      	ldrb	r3, [r7, #7]
20001b48:	3b50      	subs	r3, #80	@ 0x50
20001b4a:	2b03      	cmp	r3, #3
20001b4c:	d816      	bhi.n	20001b7c <console_readkey+0x90>
20001b4e:	a201      	add	r2, pc, #4	@ (adr r2, 20001b54 <console_readkey+0x68>)
20001b50:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
20001b54:	20001b65 	.word	0x20001b65
20001b58:	20001b6b 	.word	0x20001b6b
20001b5c:	20001b71 	.word	0x20001b71
20001b60:	20001b77 	.word	0x20001b77
			case 'P':
			    return VKEY_F1;
20001b64:	f44f 7388 	mov.w	r3, #272	@ 0x110
20001b68:	e0c9      	b.n	20001cfe <console_readkey+0x212>
			case 'Q':
			    return VKEY_F2;
20001b6a:	f240 1311 	movw	r3, #273	@ 0x111
20001b6e:	e0c6      	b.n	20001cfe <console_readkey+0x212>
			case 'R':
			    return VKEY_F3;
20001b70:	f44f 7389 	mov.w	r3, #274	@ 0x112
20001b74:	e0c3      	b.n	20001cfe <console_readkey+0x212>
			case 'S':
			    return VKEY_F4;
20001b76:	f240 1313 	movw	r3, #275	@ 0x113
20001b7a:	e0c0      	b.n	20001cfe <console_readkey+0x212>
			}
		    return (int)ch;
20001b7c:	79fb      	ldrb	r3, [r7, #7]
20001b7e:	e0be      	b.n	20001cfe <console_readkey+0x212>

		case '[':
		    GETCHAR(ch);
20001b80:	f7ff fda6 	bl	200016d0 <background>
20001b84:	1dfb      	adds	r3, r7, #7
20001b86:	2101      	movs	r1, #1
20001b88:	4618      	mov	r0, r3
20001b8a:	f7ff fe11 	bl	200017b0 <console_read>
20001b8e:	4603      	mov	r3, r0
20001b90:	2b01      	cmp	r3, #1
20001b92:	d1f5      	bne.n	20001b80 <console_readkey+0x94>
		    if ((ch >= '0') && (ch <= '9')) {
20001b94:	79fb      	ldrb	r3, [r7, #7]
20001b96:	2b2f      	cmp	r3, #47	@ 0x2f
20001b98:	f240 8082 	bls.w	20001ca0 <console_readkey+0x1b4>
20001b9c:	79fb      	ldrb	r3, [r7, #7]
20001b9e:	2b39      	cmp	r3, #57	@ 0x39
20001ba0:	d87e      	bhi.n	20001ca0 <console_readkey+0x1b4>
			console_readnum(&num,&ch);
20001ba2:	1dfa      	adds	r2, r7, #7
20001ba4:	463b      	mov	r3, r7
20001ba6:	4611      	mov	r1, r2
20001ba8:	4618      	mov	r0, r3
20001baa:	f7ff ff73 	bl	20001a94 <console_readnum>
			if (ch == '~') {
20001bae:	79fb      	ldrb	r3, [r7, #7]
20001bb0:	2b7e      	cmp	r3, #126	@ 0x7e
20001bb2:	f040 80a1 	bne.w	20001cf8 <console_readkey+0x20c>
			    switch (num) {
20001bb6:	683b      	ldr	r3, [r7, #0]
20001bb8:	3b02      	subs	r3, #2
20001bba:	2b16      	cmp	r3, #22
20001bbc:	d86e      	bhi.n	20001c9c <console_readkey+0x1b0>
20001bbe:	a201      	add	r2, pc, #4	@ (adr r2, 20001bc4 <console_readkey+0xd8>)
20001bc0:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
20001bc4:	20001c21 	.word	0x20001c21
20001bc8:	20001c27 	.word	0x20001c27
20001bcc:	20001c9d 	.word	0x20001c9d
20001bd0:	20001c2d 	.word	0x20001c2d
20001bd4:	20001c41 	.word	0x20001c41
20001bd8:	20001c9d 	.word	0x20001c9d
20001bdc:	20001c9d 	.word	0x20001c9d
20001be0:	20001c9d 	.word	0x20001c9d
20001be4:	20001c9d 	.word	0x20001c9d
20001be8:	20001c55 	.word	0x20001c55
20001bec:	20001c5b 	.word	0x20001c5b
20001bf0:	20001c61 	.word	0x20001c61
20001bf4:	20001c67 	.word	0x20001c67
20001bf8:	20001c6d 	.word	0x20001c6d
20001bfc:	20001c9d 	.word	0x20001c9d
20001c00:	20001c73 	.word	0x20001c73
20001c04:	20001c79 	.word	0x20001c79
20001c08:	20001c7f 	.word	0x20001c7f
20001c0c:	20001c85 	.word	0x20001c85
20001c10:	20001c8b 	.word	0x20001c8b
20001c14:	20001c9d 	.word	0x20001c9d
20001c18:	20001c91 	.word	0x20001c91
20001c1c:	20001c97 	.word	0x20001c97
				case 2:
				    return VKEY_HOME;
20001c20:	f240 1307 	movw	r3, #263	@ 0x107
20001c24:	e06b      	b.n	20001cfe <console_readkey+0x212>
				case 3:
				    return VKEY_PGUP;
20001c26:	f240 1305 	movw	r3, #261	@ 0x105
20001c2a:	e068      	b.n	20001cfe <console_readkey+0x212>
				case 5:
				    if (console_mode == XTERM) return VKEY_PGUP;
20001c2c:	4b36      	ldr	r3, [pc, #216]	@ (20001d08 <console_readkey+0x21c>)
20001c2e:	681b      	ldr	r3, [r3, #0]
20001c30:	2b00      	cmp	r3, #0
20001c32:	d102      	bne.n	20001c3a <console_readkey+0x14e>
20001c34:	f240 1305 	movw	r3, #261	@ 0x105
20001c38:	e061      	b.n	20001cfe <console_readkey+0x212>
				    return VKEY_END;
20001c3a:	f44f 7384 	mov.w	r3, #264	@ 0x108
20001c3e:	e05e      	b.n	20001cfe <console_readkey+0x212>
				case 6:
				    if (console_mode == XTERM) return VKEY_PGDN;
20001c40:	4b31      	ldr	r3, [pc, #196]	@ (20001d08 <console_readkey+0x21c>)
20001c42:	681b      	ldr	r3, [r3, #0]
20001c44:	2b00      	cmp	r3, #0
20001c46:	d102      	bne.n	20001c4e <console_readkey+0x162>
20001c48:	f44f 7383 	mov.w	r3, #262	@ 0x106
20001c4c:	e057      	b.n	20001cfe <console_readkey+0x212>
				    return VKEY_PGDN;
20001c4e:	f44f 7383 	mov.w	r3, #262	@ 0x106
20001c52:	e054      	b.n	20001cfe <console_readkey+0x212>
				case 11:
				    return VKEY_F1;
20001c54:	f44f 7388 	mov.w	r3, #272	@ 0x110
20001c58:	e051      	b.n	20001cfe <console_readkey+0x212>
				case 12:
				    return VKEY_F2;
20001c5a:	f240 1311 	movw	r3, #273	@ 0x111
20001c5e:	e04e      	b.n	20001cfe <console_readkey+0x212>
				case 13:
				    return VKEY_F3;
20001c60:	f44f 7389 	mov.w	r3, #274	@ 0x112
20001c64:	e04b      	b.n	20001cfe <console_readkey+0x212>
				case 14:
				    return VKEY_F4;
20001c66:	f240 1313 	movw	r3, #275	@ 0x113
20001c6a:	e048      	b.n	20001cfe <console_readkey+0x212>
				case 15:
				    return VKEY_F5;
20001c6c:	f44f 738a 	mov.w	r3, #276	@ 0x114
20001c70:	e045      	b.n	20001cfe <console_readkey+0x212>
				case 17:
				    return VKEY_F6;
20001c72:	f240 1315 	movw	r3, #277	@ 0x115
20001c76:	e042      	b.n	20001cfe <console_readkey+0x212>
				case 18:
				    return VKEY_F7;
20001c78:	f44f 738b 	mov.w	r3, #278	@ 0x116
20001c7c:	e03f      	b.n	20001cfe <console_readkey+0x212>
				case 19:
				    return VKEY_F8;
20001c7e:	f240 1317 	movw	r3, #279	@ 0x117
20001c82:	e03c      	b.n	20001cfe <console_readkey+0x212>
				case 20:
				    return VKEY_F9;
20001c84:	f44f 738c 	mov.w	r3, #280	@ 0x118
20001c88:	e039      	b.n	20001cfe <console_readkey+0x212>
				case 21:
				    return VKEY_F10;
20001c8a:	f240 1319 	movw	r3, #281	@ 0x119
20001c8e:	e036      	b.n	20001cfe <console_readkey+0x212>
				case 23:
				    return VKEY_F11;
20001c90:	f44f 738d 	mov.w	r3, #282	@ 0x11a
20001c94:	e033      	b.n	20001cfe <console_readkey+0x212>
				case 24:
				    return VKEY_F12;
20001c96:	f240 131b 	movw	r3, #283	@ 0x11b
20001c9a:	e030      	b.n	20001cfe <console_readkey+0x212>
				}
			    return (int)ch;
20001c9c:	79fb      	ldrb	r3, [r7, #7]
20001c9e:	e02e      	b.n	20001cfe <console_readkey+0x212>
			    }
			}
		    else {
			switch (ch) {
20001ca0:	79fb      	ldrb	r3, [r7, #7]
20001ca2:	3b41      	subs	r3, #65	@ 0x41
20001ca4:	2b07      	cmp	r3, #7
20001ca6:	d825      	bhi.n	20001cf4 <console_readkey+0x208>
20001ca8:	a201      	add	r2, pc, #4	@ (adr r2, 20001cb0 <console_readkey+0x1c4>)
20001caa:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
20001cae:	bf00      	nop
20001cb0:	20001cd1 	.word	0x20001cd1
20001cb4:	20001cd7 	.word	0x20001cd7
20001cb8:	20001cdd 	.word	0x20001cdd
20001cbc:	20001ce3 	.word	0x20001ce3
20001cc0:	20001cf5 	.word	0x20001cf5
20001cc4:	20001ce9 	.word	0x20001ce9
20001cc8:	20001cf5 	.word	0x20001cf5
20001ccc:	20001cef 	.word	0x20001cef
			    case 'A':
				return VKEY_UP;
20001cd0:	f240 1301 	movw	r3, #257	@ 0x101
20001cd4:	e013      	b.n	20001cfe <console_readkey+0x212>
			    case 'B':
				return VKEY_DOWN;
20001cd6:	f44f 7381 	mov.w	r3, #258	@ 0x102
20001cda:	e010      	b.n	20001cfe <console_readkey+0x212>
			    case 'C':
				return VKEY_RIGHT;
20001cdc:	f44f 7382 	mov.w	r3, #260	@ 0x104
20001ce0:	e00d      	b.n	20001cfe <console_readkey+0x212>
			    case 'D':
				return VKEY_LEFT;
20001ce2:	f240 1303 	movw	r3, #259	@ 0x103
20001ce6:	e00a      	b.n	20001cfe <console_readkey+0x212>
			    case 'F':
				return VKEY_HOME;
20001ce8:	f240 1307 	movw	r3, #263	@ 0x107
20001cec:	e007      	b.n	20001cfe <console_readkey+0x212>
			    case 'H':
				return VKEY_END;
20001cee:	f44f 7384 	mov.w	r3, #264	@ 0x108
20001cf2:	e004      	b.n	20001cfe <console_readkey+0x212>
			    default:
				return (int) ch;
20001cf4:	79fb      	ldrb	r3, [r7, #7]
20001cf6:	e002      	b.n	20001cfe <console_readkey+0x212>
			    }
			}
		default:
		    return (int)ch;
20001cf8:	79fb      	ldrb	r3, [r7, #7]
20001cfa:	e000      	b.n	20001cfe <console_readkey+0x212>
	
		}
	default:
	    return (int) ch;
20001cfc:	79fb      	ldrb	r3, [r7, #7]
	}
}
20001cfe:	4618      	mov	r0, r3
20001d00:	3708      	adds	r7, #8
20001d02:	46bd      	mov	sp, r7
20001d04:	bd80      	pop	{r7, pc}
20001d06:	bf00      	nop
20001d08:	20004bc4 	.word	0x20004bc4

20001d0c <console_backspace>:
    *  Return value:
    *  	   nothing
    ********************************************************************* */

static void console_backspace(int n)
{
20001d0c:	b580      	push	{r7, lr}
20001d0e:	b084      	sub	sp, #16
20001d10:	af00      	add	r7, sp, #0
20001d12:	6078      	str	r0, [r7, #4]
    int t;

    for (t = 0; t < n; t++) console_write((unsigned char *)"\b",1);
20001d14:	2300      	movs	r3, #0
20001d16:	60fb      	str	r3, [r7, #12]
20001d18:	e006      	b.n	20001d28 <console_backspace+0x1c>
20001d1a:	2101      	movs	r1, #1
20001d1c:	4807      	ldr	r0, [pc, #28]	@ (20001d3c <console_backspace+0x30>)
20001d1e:	f7ff fd63 	bl	200017e8 <console_write>
20001d22:	68fb      	ldr	r3, [r7, #12]
20001d24:	3301      	adds	r3, #1
20001d26:	60fb      	str	r3, [r7, #12]
20001d28:	68fa      	ldr	r2, [r7, #12]
20001d2a:	687b      	ldr	r3, [r7, #4]
20001d2c:	429a      	cmp	r2, r3
20001d2e:	dbf4      	blt.n	20001d1a <console_backspace+0xe>
}
20001d30:	bf00      	nop
20001d32:	bf00      	nop
20001d34:	3710      	adds	r7, #16
20001d36:	46bd      	mov	sp, r7
20001d38:	bd80      	pop	{r7, pc}
20001d3a:	bf00      	nop
20001d3c:	200044c8 	.word	0x200044c8

20001d40 <console_whiteout>:

static void console_whiteout(int n)
{
20001d40:	b580      	push	{r7, lr}
20001d42:	b084      	sub	sp, #16
20001d44:	af00      	add	r7, sp, #0
20001d46:	6078      	str	r0, [r7, #4]
    int t;

    for (t = 0; t < n; t++) console_write((unsigned char *)" ",1);
20001d48:	2300      	movs	r3, #0
20001d4a:	60fb      	str	r3, [r7, #12]
20001d4c:	e006      	b.n	20001d5c <console_whiteout+0x1c>
20001d4e:	2101      	movs	r1, #1
20001d50:	480e      	ldr	r0, [pc, #56]	@ (20001d8c <console_whiteout+0x4c>)
20001d52:	f7ff fd49 	bl	200017e8 <console_write>
20001d56:	68fb      	ldr	r3, [r7, #12]
20001d58:	3301      	adds	r3, #1
20001d5a:	60fb      	str	r3, [r7, #12]
20001d5c:	68fa      	ldr	r2, [r7, #12]
20001d5e:	687b      	ldr	r3, [r7, #4]
20001d60:	429a      	cmp	r2, r3
20001d62:	dbf4      	blt.n	20001d4e <console_whiteout+0xe>
    for (t = 0; t < n; t++) console_write((unsigned char *)"\b",1);
20001d64:	2300      	movs	r3, #0
20001d66:	60fb      	str	r3, [r7, #12]
20001d68:	e006      	b.n	20001d78 <console_whiteout+0x38>
20001d6a:	2101      	movs	r1, #1
20001d6c:	4808      	ldr	r0, [pc, #32]	@ (20001d90 <console_whiteout+0x50>)
20001d6e:	f7ff fd3b 	bl	200017e8 <console_write>
20001d72:	68fb      	ldr	r3, [r7, #12]
20001d74:	3301      	adds	r3, #1
20001d76:	60fb      	str	r3, [r7, #12]
20001d78:	68fa      	ldr	r2, [r7, #12]
20001d7a:	687b      	ldr	r3, [r7, #4]
20001d7c:	429a      	cmp	r2, r3
20001d7e:	dbf4      	blt.n	20001d6a <console_whiteout+0x2a>
}
20001d80:	bf00      	nop
20001d82:	bf00      	nop
20001d84:	3710      	adds	r7, #16
20001d86:	46bd      	mov	sp, r7
20001d88:	bd80      	pop	{r7, pc}
20001d8a:	bf00      	nop
20001d8c:	200044cc 	.word	0x200044cc
20001d90:	200044c8 	.word	0x200044c8

20001d94 <console_eraseeol>:


static void console_eraseeol(void)
{
20001d94:	b580      	push	{r7, lr}
20001d96:	af00      	add	r7, sp, #0
    console_write((unsigned char *)"\033[K",3);
20001d98:	2103      	movs	r1, #3
20001d9a:	4802      	ldr	r0, [pc, #8]	@ (20001da4 <console_eraseeol+0x10>)
20001d9c:	f7ff fd24 	bl	200017e8 <console_write>
}
20001da0:	bf00      	nop
20001da2:	bd80      	pop	{r7, pc}
20001da4:	200044d0 	.word	0x200044d0

20001da8 <console_crlf>:

static void console_crlf(void)
{
20001da8:	b580      	push	{r7, lr}
20001daa:	af00      	add	r7, sp, #0
    console_write((unsigned char *)"\r\n",2);
20001dac:	2102      	movs	r1, #2
20001dae:	4802      	ldr	r0, [pc, #8]	@ (20001db8 <console_crlf+0x10>)
20001db0:	f7ff fd1a 	bl	200017e8 <console_write>
}
20001db4:	bf00      	nop
20001db6:	bd80      	pop	{r7, pc}
20001db8:	200044a0 	.word	0x200044a0

20001dbc <console_readline_default>:
    *  	   number of characters read (terminating newline is not
    *  	   placed in the buffer)
    ********************************************************************* */

int console_readline_default(char *prompt,char *str,int maxlen)
{
20001dbc:	b590      	push	{r4, r7, lr}
20001dbe:	b091      	sub	sp, #68	@ 0x44
20001dc0:	af00      	add	r7, sp, #0
20001dc2:	60f8      	str	r0, [r7, #12]
20001dc4:	60b9      	str	r1, [r7, #8]
20001dc6:	607a      	str	r2, [r7, #4]
    int reading = 1;
20001dc8:	2301      	movs	r3, #1
20001dca:	63fb      	str	r3, [r7, #60]	@ 0x3c
    int ch;
    int idx = 0;
20001dcc:	2300      	movs	r3, #0
20001dce:	63bb      	str	r3, [r7, #56]	@ 0x38
    int len = 0;
20001dd0:	2300      	movs	r3, #0
20001dd2:	637b      	str	r3, [r7, #52]	@ 0x34
    int t;
    int klen;
    int recall;
    int nosave = 0;
20001dd4:	2300      	movs	r3, #0
20001dd6:	62bb      	str	r3, [r7, #40]	@ 0x28
    char *x;
    char env[10];

    console_inreadline++;
20001dd8:	4b5d      	ldr	r3, [pc, #372]	@ (20001f50 <console_readline_default+0x194>)
20001dda:	681b      	ldr	r3, [r3, #0]
20001ddc:	3301      	adds	r3, #1
20001dde:	4a5c      	ldr	r2, [pc, #368]	@ (20001f50 <console_readline_default+0x194>)
20001de0:	6013      	str	r3, [r2, #0]
    recall = console_nextsave;
20001de2:	4b5c      	ldr	r3, [pc, #368]	@ (20001f54 <console_readline_default+0x198>)
20001de4:	681b      	ldr	r3, [r3, #0]
20001de6:	62fb      	str	r3, [r7, #44]	@ 0x2c

    if (console_savedlines[console_nextsave]) {
20001de8:	4b5a      	ldr	r3, [pc, #360]	@ (20001f54 <console_readline_default+0x198>)
20001dea:	681b      	ldr	r3, [r3, #0]
20001dec:	4a5a      	ldr	r2, [pc, #360]	@ (20001f58 <console_readline_default+0x19c>)
20001dee:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
20001df2:	2b00      	cmp	r3, #0
20001df4:	d00e      	beq.n	20001e14 <console_readline_default+0x58>
	KFREE(console_savedlines[console_nextsave]);
20001df6:	4b57      	ldr	r3, [pc, #348]	@ (20001f54 <console_readline_default+0x198>)
20001df8:	681b      	ldr	r3, [r3, #0]
20001dfa:	4a57      	ldr	r2, [pc, #348]	@ (20001f58 <console_readline_default+0x19c>)
20001dfc:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
20001e00:	4619      	mov	r1, r3
20001e02:	4856      	ldr	r0, [pc, #344]	@ (20001f5c <console_readline_default+0x1a0>)
20001e04:	f7ff f8a2 	bl	20000f4c <kfree>
	console_savedlines[console_nextsave] = NULL;
20001e08:	4b52      	ldr	r3, [pc, #328]	@ (20001f54 <console_readline_default+0x198>)
20001e0a:	681b      	ldr	r3, [r3, #0]
20001e0c:	4a52      	ldr	r2, [pc, #328]	@ (20001f58 <console_readline_default+0x19c>)
20001e0e:	2100      	movs	r1, #0
20001e10:	f842 1023 	str.w	r1, [r2, r3, lsl #2]
	}
    console_savedlines[console_nextsave] = strdup("");
20001e14:	4b4f      	ldr	r3, [pc, #316]	@ (20001f54 <console_readline_default+0x198>)
20001e16:	681c      	ldr	r4, [r3, #0]
20001e18:	4851      	ldr	r0, [pc, #324]	@ (20001f60 <console_readline_default+0x1a4>)
20001e1a:	f7ff fb11 	bl	20001440 <lib_strdup>
20001e1e:	4603      	mov	r3, r0
20001e20:	4a4d      	ldr	r2, [pc, #308]	@ (20001f58 <console_readline_default+0x19c>)
20001e22:	f842 3024 	str.w	r3, [r2, r4, lsl #2]

    idx = len = strlen(str);
20001e26:	68b8      	ldr	r0, [r7, #8]
20001e28:	f7ff fa33 	bl	20001292 <lib_strlen>
20001e2c:	6378      	str	r0, [r7, #52]	@ 0x34
20001e2e:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
20001e30:	63bb      	str	r3, [r7, #56]	@ 0x38

    if (prompt && *prompt) console_write((unsigned char *)prompt,strlen(prompt));
20001e32:	68fb      	ldr	r3, [r7, #12]
20001e34:	2b00      	cmp	r3, #0
20001e36:	d00b      	beq.n	20001e50 <console_readline_default+0x94>
20001e38:	68fb      	ldr	r3, [r7, #12]
20001e3a:	781b      	ldrb	r3, [r3, #0]
20001e3c:	2b00      	cmp	r3, #0
20001e3e:	d007      	beq.n	20001e50 <console_readline_default+0x94>
20001e40:	68f8      	ldr	r0, [r7, #12]
20001e42:	f7ff fa26 	bl	20001292 <lib_strlen>
20001e46:	4603      	mov	r3, r0
20001e48:	4619      	mov	r1, r3
20001e4a:	68f8      	ldr	r0, [r7, #12]
20001e4c:	f7ff fccc 	bl	200017e8 <console_write>
    console_write((unsigned char *)str,idx);
20001e50:	6bb9      	ldr	r1, [r7, #56]	@ 0x38
20001e52:	68b8      	ldr	r0, [r7, #8]
20001e54:	f7ff fcc8 	bl	200017e8 <console_write>

    POLL();
20001e58:	f7ff fc3a 	bl	200016d0 <background>
    while (reading) {
20001e5c:	f000 bc39 	b.w	200026d2 <console_readline_default+0x916>
	/*
	 * If someone used console_log (above) or hit Control-C (below),
	 * redisplay the prompt and the string we've got so far.
	 */

	if (console_redisplay) {
20001e60:	4b40      	ldr	r3, [pc, #256]	@ (20001f64 <console_readline_default+0x1a8>)
20001e62:	681b      	ldr	r3, [r3, #0]
20001e64:	2b00      	cmp	r3, #0
20001e66:	d017      	beq.n	20001e98 <console_readline_default+0xdc>
	    if (prompt && *prompt) console_write((unsigned char *)prompt,strlen(prompt));
20001e68:	68fb      	ldr	r3, [r7, #12]
20001e6a:	2b00      	cmp	r3, #0
20001e6c:	d00b      	beq.n	20001e86 <console_readline_default+0xca>
20001e6e:	68fb      	ldr	r3, [r7, #12]
20001e70:	781b      	ldrb	r3, [r3, #0]
20001e72:	2b00      	cmp	r3, #0
20001e74:	d007      	beq.n	20001e86 <console_readline_default+0xca>
20001e76:	68f8      	ldr	r0, [r7, #12]
20001e78:	f7ff fa0b 	bl	20001292 <lib_strlen>
20001e7c:	4603      	mov	r3, r0
20001e7e:	4619      	mov	r1, r3
20001e80:	68f8      	ldr	r0, [r7, #12]
20001e82:	f7ff fcb1 	bl	200017e8 <console_write>
	    console_write((unsigned char *)str,idx);
20001e86:	6bb9      	ldr	r1, [r7, #56]	@ 0x38
20001e88:	68b8      	ldr	r0, [r7, #8]
20001e8a:	f7ff fcad 	bl	200017e8 <console_write>
	    console_redisplay = 0;
20001e8e:	4b35      	ldr	r3, [pc, #212]	@ (20001f64 <console_readline_default+0x1a8>)
20001e90:	2200      	movs	r2, #0
20001e92:	601a      	str	r2, [r3, #0]
	    continue;
20001e94:	f000 bc1d 	b.w	200026d2 <console_readline_default+0x916>

	/*
	 * if nobody's typed anything, keep polling
	 */

	if (console_status() == 0) {
20001e98:	f7ff fce6 	bl	20001868 <console_status>
20001e9c:	4603      	mov	r3, r0
20001e9e:	2b00      	cmp	r3, #0
20001ea0:	d103      	bne.n	20001eaa <console_readline_default+0xee>
	    POLL();
20001ea2:	f7ff fc15 	bl	200016d0 <background>
	    continue;
20001ea6:	f000 bc14 	b.w	200026d2 <console_readline_default+0x916>

	/*
	 * Get the char from the keyboard
	 */

	ch = console_readkey();
20001eaa:	f7ff fe1f 	bl	20001aec <console_readkey>
20001eae:	6278      	str	r0, [r7, #36]	@ 0x24
	if (ch < 0) break;
20001eb0:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
20001eb2:	2b00      	cmp	r3, #0
20001eb4:	f2c0 841a 	blt.w	200026ec <console_readline_default+0x930>
	if (ch == 0) continue;
20001eb8:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
20001eba:	2b00      	cmp	r3, #0
20001ebc:	f000 83ee 	beq.w	2000269c <console_readline_default+0x8e0>

	/*
	 * And dispatch it.  Lots of yucky character manipulation follows
	 */

	switch (ch) {
20001ec0:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
20001ec2:	2b7f      	cmp	r3, #127	@ 0x7f
20001ec4:	f300 8156 	bgt.w	20002174 <console_readline_default+0x3b8>
20001ec8:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
20001eca:	2b00      	cmp	r3, #0
20001ecc:	dc4c      	bgt.n	20001f68 <console_readline_default+0x1ac>
20001ece:	e3a7      	b.n	20002620 <console_readline_default+0x864>
20001ed0:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
20001ed2:	f2a3 1301 	subw	r3, r3, #257	@ 0x101
20001ed6:	2b1a      	cmp	r3, #26
20001ed8:	f200 83a2 	bhi.w	20002620 <console_readline_default+0x864>
20001edc:	a201      	add	r2, pc, #4	@ (adr r2, 20001ee4 <console_readline_default+0x128>)
20001ede:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
20001ee2:	bf00      	nop
20001ee4:	20002469 	.word	0x20002469
20001ee8:	200024f3 	.word	0x200024f3
20001eec:	20002287 	.word	0x20002287
20001ef0:	2000229d 	.word	0x2000229d
20001ef4:	20002621 	.word	0x20002621
20001ef8:	20002621 	.word	0x20002621
20001efc:	20002621 	.word	0x20002621
20001f00:	20002621 	.word	0x20002621
20001f04:	20002621 	.word	0x20002621
20001f08:	20002621 	.word	0x20002621
20001f0c:	20002621 	.word	0x20002621
20001f10:	20002621 	.word	0x20002621
20001f14:	20002621 	.word	0x20002621
20001f18:	20002621 	.word	0x20002621
20001f1c:	20002621 	.word	0x20002621
20001f20:	20002555 	.word	0x20002555
20001f24:	20002555 	.word	0x20002555
20001f28:	20002555 	.word	0x20002555
20001f2c:	20002555 	.word	0x20002555
20001f30:	20002555 	.word	0x20002555
20001f34:	20002555 	.word	0x20002555
20001f38:	20002555 	.word	0x20002555
20001f3c:	20002555 	.word	0x20002555
20001f40:	20002555 	.word	0x20002555
20001f44:	20002555 	.word	0x20002555
20001f48:	20002555 	.word	0x20002555
20001f4c:	20002555 	.word	0x20002555
20001f50:	20004bcc 	.word	0x20004bcc
20001f54:	20004b40 	.word	0x20004b40
20001f58:	20004b44 	.word	0x20004b44
20001f5c:	20004ab4 	.word	0x20004ab4
20001f60:	200044d4 	.word	0x200044d4
20001f64:	20004bd0 	.word	0x20004bd0
20001f68:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
20001f6a:	3b01      	subs	r3, #1
20001f6c:	2b7e      	cmp	r3, #126	@ 0x7e
20001f6e:	f200 8357 	bhi.w	20002620 <console_readline_default+0x864>
20001f72:	a201      	add	r2, pc, #4	@ (adr r2, 20001f78 <console_readline_default+0x1bc>)
20001f74:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
20001f78:	200022bd 	.word	0x200022bd
20001f7c:	20002287 	.word	0x20002287
20001f80:	2000218b 	.word	0x2000218b
20001f84:	2000221f 	.word	0x2000221f
20001f88:	200022c9 	.word	0x200022c9
20001f8c:	2000229d 	.word	0x2000229d
20001f90:	20002621 	.word	0x20002621
20001f94:	200021a3 	.word	0x200021a3
20001f98:	20002621 	.word	0x20002621
20001f9c:	2000245f 	.word	0x2000245f
20001fa0:	200022eb 	.word	0x200022eb
20001fa4:	20002621 	.word	0x20002621
20001fa8:	2000245f 	.word	0x2000245f
20001fac:	200024f3 	.word	0x200024f3
20001fb0:	20002621 	.word	0x20002621
20001fb4:	20002469 	.word	0x20002469
20001fb8:	20002621 	.word	0x20002621
20001fbc:	2000240d 	.word	0x2000240d
20001fc0:	20002621 	.word	0x20002621
20001fc4:	20002621 	.word	0x20002621
20001fc8:	20002441 	.word	0x20002441
20001fcc:	20002621 	.word	0x20002621
20001fd0:	20002621 	.word	0x20002621
20001fd4:	20002621 	.word	0x20002621
20001fd8:	2000233b 	.word	0x2000233b
20001fdc:	20002621 	.word	0x20002621
20001fe0:	20002621 	.word	0x20002621
20001fe4:	20002621 	.word	0x20002621
20001fe8:	20002621 	.word	0x20002621
20001fec:	20002621 	.word	0x20002621
20001ff0:	20002621 	.word	0x20002621
20001ff4:	20002621 	.word	0x20002621
20001ff8:	20002621 	.word	0x20002621
20001ffc:	20002621 	.word	0x20002621
20002000:	20002621 	.word	0x20002621
20002004:	20002621 	.word	0x20002621
20002008:	20002621 	.word	0x20002621
2000200c:	20002621 	.word	0x20002621
20002010:	20002621 	.word	0x20002621
20002014:	20002621 	.word	0x20002621
20002018:	20002621 	.word	0x20002621
2000201c:	20002621 	.word	0x20002621
20002020:	20002621 	.word	0x20002621
20002024:	20002621 	.word	0x20002621
20002028:	20002621 	.word	0x20002621
2000202c:	20002621 	.word	0x20002621
20002030:	20002621 	.word	0x20002621
20002034:	20002621 	.word	0x20002621
20002038:	20002621 	.word	0x20002621
2000203c:	20002621 	.word	0x20002621
20002040:	20002621 	.word	0x20002621
20002044:	20002621 	.word	0x20002621
20002048:	20002621 	.word	0x20002621
2000204c:	20002621 	.word	0x20002621
20002050:	20002621 	.word	0x20002621
20002054:	20002621 	.word	0x20002621
20002058:	20002621 	.word	0x20002621
2000205c:	20002621 	.word	0x20002621
20002060:	20002621 	.word	0x20002621
20002064:	20002621 	.word	0x20002621
20002068:	20002621 	.word	0x20002621
2000206c:	20002621 	.word	0x20002621
20002070:	20002621 	.word	0x20002621
20002074:	20002621 	.word	0x20002621
20002078:	20002621 	.word	0x20002621
2000207c:	20002621 	.word	0x20002621
20002080:	20002621 	.word	0x20002621
20002084:	20002621 	.word	0x20002621
20002088:	20002621 	.word	0x20002621
2000208c:	20002621 	.word	0x20002621
20002090:	20002621 	.word	0x20002621
20002094:	20002621 	.word	0x20002621
20002098:	20002621 	.word	0x20002621
2000209c:	20002621 	.word	0x20002621
200020a0:	20002621 	.word	0x20002621
200020a4:	20002621 	.word	0x20002621
200020a8:	20002621 	.word	0x20002621
200020ac:	20002621 	.word	0x20002621
200020b0:	20002621 	.word	0x20002621
200020b4:	20002621 	.word	0x20002621
200020b8:	20002621 	.word	0x20002621
200020bc:	20002621 	.word	0x20002621
200020c0:	20002621 	.word	0x20002621
200020c4:	20002621 	.word	0x20002621
200020c8:	20002621 	.word	0x20002621
200020cc:	20002621 	.word	0x20002621
200020d0:	20002621 	.word	0x20002621
200020d4:	20002621 	.word	0x20002621
200020d8:	20002621 	.word	0x20002621
200020dc:	20002621 	.word	0x20002621
200020e0:	20002621 	.word	0x20002621
200020e4:	20002621 	.word	0x20002621
200020e8:	20002621 	.word	0x20002621
200020ec:	20002621 	.word	0x20002621
200020f0:	20002621 	.word	0x20002621
200020f4:	20002621 	.word	0x20002621
200020f8:	20002621 	.word	0x20002621
200020fc:	20002621 	.word	0x20002621
20002100:	20002621 	.word	0x20002621
20002104:	20002621 	.word	0x20002621
20002108:	20002621 	.word	0x20002621
2000210c:	20002621 	.word	0x20002621
20002110:	20002621 	.word	0x20002621
20002114:	20002621 	.word	0x20002621
20002118:	20002621 	.word	0x20002621
2000211c:	20002621 	.word	0x20002621
20002120:	20002621 	.word	0x20002621
20002124:	20002621 	.word	0x20002621
20002128:	20002621 	.word	0x20002621
2000212c:	20002621 	.word	0x20002621
20002130:	20002621 	.word	0x20002621
20002134:	20002621 	.word	0x20002621
20002138:	20002621 	.word	0x20002621
2000213c:	20002621 	.word	0x20002621
20002140:	20002621 	.word	0x20002621
20002144:	20002621 	.word	0x20002621
20002148:	20002621 	.word	0x20002621
2000214c:	20002621 	.word	0x20002621
20002150:	20002621 	.word	0x20002621
20002154:	20002621 	.word	0x20002621
20002158:	20002621 	.word	0x20002621
2000215c:	20002621 	.word	0x20002621
20002160:	20002621 	.word	0x20002621
20002164:	20002621 	.word	0x20002621
20002168:	20002621 	.word	0x20002621
2000216c:	20002621 	.word	0x20002621
20002170:	200021a3 	.word	0x200021a3
20002174:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
20002176:	f5b3 7f8e 	cmp.w	r3, #284	@ 0x11c
2000217a:	f280 8251 	bge.w	20002620 <console_readline_default+0x864>
2000217e:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
20002180:	f5b3 7f80 	cmp.w	r3, #256	@ 0x100
20002184:	f73f aea4 	bgt.w	20001ed0 <console_readline_default+0x114>
20002188:	e24a      	b.n	20002620 <console_readline_default+0x864>
	    case CTRL('C'):			/* Ctrl-C - cancel line */
		console_write((unsigned char *)"^C\r\n",4);
2000218a:	2104      	movs	r1, #4
2000218c:	489a      	ldr	r0, [pc, #616]	@ (200023f8 <console_readline_default+0x63c>)
2000218e:	f7ff fb2b 	bl	200017e8 <console_write>
		console_redisplay = 1;
20002192:	4b9a      	ldr	r3, [pc, #616]	@ (200023fc <console_readline_default+0x640>)
20002194:	2201      	movs	r2, #1
20002196:	601a      	str	r2, [r3, #0]
		nosave = 1;
20002198:	2301      	movs	r3, #1
2000219a:	62bb      	str	r3, [r7, #40]	@ 0x28
		idx = 0;
2000219c:	2300      	movs	r3, #0
2000219e:	63bb      	str	r3, [r7, #56]	@ 0x38
		break;
200021a0:	e297      	b.n	200026d2 <console_readline_default+0x916>

	    case 0x7f:				/* Backspace, Delete */
	    case CTRL('H'):
		if (idx > 0) {
200021a2:	6bbb      	ldr	r3, [r7, #56]	@ 0x38
200021a4:	2b00      	cmp	r3, #0
200021a6:	f340 827b 	ble.w	200026a0 <console_readline_default+0x8e4>
		    nosave = 0;
200021aa:	2300      	movs	r3, #0
200021ac:	62bb      	str	r3, [r7, #40]	@ 0x28
		    len--;
200021ae:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
200021b0:	3b01      	subs	r3, #1
200021b2:	637b      	str	r3, [r7, #52]	@ 0x34
		    idx--;
200021b4:	6bbb      	ldr	r3, [r7, #56]	@ 0x38
200021b6:	3b01      	subs	r3, #1
200021b8:	63bb      	str	r3, [r7, #56]	@ 0x38
		    console_write((unsigned char *)"\b",1);
200021ba:	2101      	movs	r1, #1
200021bc:	4890      	ldr	r0, [pc, #576]	@ (20002400 <console_readline_default+0x644>)
200021be:	f7ff fb13 	bl	200017e8 <console_write>
		    if (len != idx) {
200021c2:	6b7a      	ldr	r2, [r7, #52]	@ 0x34
200021c4:	6bbb      	ldr	r3, [r7, #56]	@ 0x38
200021c6:	429a      	cmp	r2, r3
200021c8:	d025      	beq.n	20002216 <console_readline_default+0x45a>
			for (t = idx; t < len; t++) str[t] = str[t+1];
200021ca:	6bbb      	ldr	r3, [r7, #56]	@ 0x38
200021cc:	633b      	str	r3, [r7, #48]	@ 0x30
200021ce:	e00b      	b.n	200021e8 <console_readline_default+0x42c>
200021d0:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
200021d2:	3301      	adds	r3, #1
200021d4:	68ba      	ldr	r2, [r7, #8]
200021d6:	441a      	add	r2, r3
200021d8:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
200021da:	68b9      	ldr	r1, [r7, #8]
200021dc:	440b      	add	r3, r1
200021de:	7812      	ldrb	r2, [r2, #0]
200021e0:	701a      	strb	r2, [r3, #0]
200021e2:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
200021e4:	3301      	adds	r3, #1
200021e6:	633b      	str	r3, [r7, #48]	@ 0x30
200021e8:	6b3a      	ldr	r2, [r7, #48]	@ 0x30
200021ea:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
200021ec:	429a      	cmp	r2, r3
200021ee:	dbef      	blt.n	200021d0 <console_readline_default+0x414>
			console_write((unsigned char *)&str[idx],len-idx);
200021f0:	6bbb      	ldr	r3, [r7, #56]	@ 0x38
200021f2:	68ba      	ldr	r2, [r7, #8]
200021f4:	18d0      	adds	r0, r2, r3
200021f6:	6b7a      	ldr	r2, [r7, #52]	@ 0x34
200021f8:	6bbb      	ldr	r3, [r7, #56]	@ 0x38
200021fa:	1ad3      	subs	r3, r2, r3
200021fc:	4619      	mov	r1, r3
200021fe:	f7ff faf3 	bl	200017e8 <console_write>
			console_whiteout(1);
20002202:	2001      	movs	r0, #1
20002204:	f7ff fd9c 	bl	20001d40 <console_whiteout>
			console_backspace(len-idx);
20002208:	6b7a      	ldr	r2, [r7, #52]	@ 0x34
2000220a:	6bbb      	ldr	r3, [r7, #56]	@ 0x38
2000220c:	1ad3      	subs	r3, r2, r3
2000220e:	4618      	mov	r0, r3
20002210:	f7ff fd7c 	bl	20001d0c <console_backspace>
			}
		    else {
			console_whiteout(1);
			}
		    }
		break;
20002214:	e244      	b.n	200026a0 <console_readline_default+0x8e4>
			console_whiteout(1);
20002216:	2001      	movs	r0, #1
20002218:	f7ff fd92 	bl	20001d40 <console_whiteout>
		break;
2000221c:	e240      	b.n	200026a0 <console_readline_default+0x8e4>

	    case CTRL('D'):			/* Ctrl-D */
		if ((idx >= 0) && (len != idx)) {
2000221e:	6bbb      	ldr	r3, [r7, #56]	@ 0x38
20002220:	2b00      	cmp	r3, #0
20002222:	f2c0 823f 	blt.w	200026a4 <console_readline_default+0x8e8>
20002226:	6b7a      	ldr	r2, [r7, #52]	@ 0x34
20002228:	6bbb      	ldr	r3, [r7, #56]	@ 0x38
2000222a:	429a      	cmp	r2, r3
2000222c:	f000 823a 	beq.w	200026a4 <console_readline_default+0x8e8>
		    nosave = 0;
20002230:	2300      	movs	r3, #0
20002232:	62bb      	str	r3, [r7, #40]	@ 0x28
		    len--;
20002234:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
20002236:	3b01      	subs	r3, #1
20002238:	637b      	str	r3, [r7, #52]	@ 0x34
		    for (t = idx; t < len; t++) str[t] = str[t+1];
2000223a:	6bbb      	ldr	r3, [r7, #56]	@ 0x38
2000223c:	633b      	str	r3, [r7, #48]	@ 0x30
2000223e:	e00b      	b.n	20002258 <console_readline_default+0x49c>
20002240:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
20002242:	3301      	adds	r3, #1
20002244:	68ba      	ldr	r2, [r7, #8]
20002246:	441a      	add	r2, r3
20002248:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
2000224a:	68b9      	ldr	r1, [r7, #8]
2000224c:	440b      	add	r3, r1
2000224e:	7812      	ldrb	r2, [r2, #0]
20002250:	701a      	strb	r2, [r3, #0]
20002252:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
20002254:	3301      	adds	r3, #1
20002256:	633b      	str	r3, [r7, #48]	@ 0x30
20002258:	6b3a      	ldr	r2, [r7, #48]	@ 0x30
2000225a:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
2000225c:	429a      	cmp	r2, r3
2000225e:	dbef      	blt.n	20002240 <console_readline_default+0x484>
		    console_write((unsigned char *)&str[idx],len-idx);
20002260:	6bbb      	ldr	r3, [r7, #56]	@ 0x38
20002262:	68ba      	ldr	r2, [r7, #8]
20002264:	18d0      	adds	r0, r2, r3
20002266:	6b7a      	ldr	r2, [r7, #52]	@ 0x34
20002268:	6bbb      	ldr	r3, [r7, #56]	@ 0x38
2000226a:	1ad3      	subs	r3, r2, r3
2000226c:	4619      	mov	r1, r3
2000226e:	f7ff fabb 	bl	200017e8 <console_write>
		    console_whiteout(1);
20002272:	2001      	movs	r0, #1
20002274:	f7ff fd64 	bl	20001d40 <console_whiteout>
		    console_backspace(len-idx);
20002278:	6b7a      	ldr	r2, [r7, #52]	@ 0x34
2000227a:	6bbb      	ldr	r3, [r7, #56]	@ 0x38
2000227c:	1ad3      	subs	r3, r2, r3
2000227e:	4618      	mov	r0, r3
20002280:	f7ff fd44 	bl	20001d0c <console_backspace>
		    }
		break;
20002284:	e20e      	b.n	200026a4 <console_readline_default+0x8e8>

	    case CTRL('B'):			/* cursor left */
	    case VKEY_LEFT:
		if (idx > 0) {
20002286:	6bbb      	ldr	r3, [r7, #56]	@ 0x38
20002288:	2b00      	cmp	r3, #0
2000228a:	f340 820d 	ble.w	200026a8 <console_readline_default+0x8ec>
		    idx--;
2000228e:	6bbb      	ldr	r3, [r7, #56]	@ 0x38
20002290:	3b01      	subs	r3, #1
20002292:	63bb      	str	r3, [r7, #56]	@ 0x38
		    console_backspace(1);
20002294:	2001      	movs	r0, #1
20002296:	f7ff fd39 	bl	20001d0c <console_backspace>
		    }
		break;
2000229a:	e205      	b.n	200026a8 <console_readline_default+0x8ec>

	    case CTRL('F'):			/* cursor right */
	    case VKEY_RIGHT:
		if (idx < len) {
2000229c:	6bba      	ldr	r2, [r7, #56]	@ 0x38
2000229e:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
200022a0:	429a      	cmp	r2, r3
200022a2:	f280 8203 	bge.w	200026ac <console_readline_default+0x8f0>
		    console_write((unsigned char *)&str[idx],1);
200022a6:	6bbb      	ldr	r3, [r7, #56]	@ 0x38
200022a8:	68ba      	ldr	r2, [r7, #8]
200022aa:	4413      	add	r3, r2
200022ac:	2101      	movs	r1, #1
200022ae:	4618      	mov	r0, r3
200022b0:	f7ff fa9a 	bl	200017e8 <console_write>
		    idx++;
200022b4:	6bbb      	ldr	r3, [r7, #56]	@ 0x38
200022b6:	3301      	adds	r3, #1
200022b8:	63bb      	str	r3, [r7, #56]	@ 0x38
		    }
		break;
200022ba:	e1f7      	b.n	200026ac <console_readline_default+0x8f0>

	    case CTRL('A'):			/* cursor to BOL */
		console_backspace(idx);
200022bc:	6bb8      	ldr	r0, [r7, #56]	@ 0x38
200022be:	f7ff fd25 	bl	20001d0c <console_backspace>
		idx = 0;
200022c2:	2300      	movs	r3, #0
200022c4:	63bb      	str	r3, [r7, #56]	@ 0x38
		break;
200022c6:	e204      	b.n	200026d2 <console_readline_default+0x916>

	    case CTRL('E'):			/* cursor to EOL */
		if (len-idx > 0) console_write((unsigned char *)&str[idx],len-idx);
200022c8:	6b7a      	ldr	r2, [r7, #52]	@ 0x34
200022ca:	6bbb      	ldr	r3, [r7, #56]	@ 0x38
200022cc:	1ad3      	subs	r3, r2, r3
200022ce:	2b00      	cmp	r3, #0
200022d0:	dd08      	ble.n	200022e4 <console_readline_default+0x528>
200022d2:	6bbb      	ldr	r3, [r7, #56]	@ 0x38
200022d4:	68ba      	ldr	r2, [r7, #8]
200022d6:	18d0      	adds	r0, r2, r3
200022d8:	6b7a      	ldr	r2, [r7, #52]	@ 0x34
200022da:	6bbb      	ldr	r3, [r7, #56]	@ 0x38
200022dc:	1ad3      	subs	r3, r2, r3
200022de:	4619      	mov	r1, r3
200022e0:	f7ff fa82 	bl	200017e8 <console_write>
		idx = len;
200022e4:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
200022e6:	63bb      	str	r3, [r7, #56]	@ 0x38
		break;
200022e8:	e1f3      	b.n	200026d2 <console_readline_default+0x916>

	    case CTRL('K'):			/* Kill to EOL */
		if (idx != len) {
200022ea:	6bba      	ldr	r2, [r7, #56]	@ 0x38
200022ec:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
200022ee:	429a      	cmp	r2, r3
200022f0:	f000 81de 	beq.w	200026b0 <console_readline_default+0x8f4>
		    str[len] = '\0';
200022f4:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
200022f6:	68ba      	ldr	r2, [r7, #8]
200022f8:	4413      	add	r3, r2
200022fa:	2200      	movs	r2, #0
200022fc:	701a      	strb	r2, [r3, #0]
		    if (console_killbuffer) KFREE(console_killbuffer);
200022fe:	4b41      	ldr	r3, [pc, #260]	@ (20002404 <console_readline_default+0x648>)
20002300:	681b      	ldr	r3, [r3, #0]
20002302:	2b00      	cmp	r3, #0
20002304:	d005      	beq.n	20002312 <console_readline_default+0x556>
20002306:	4b3f      	ldr	r3, [pc, #252]	@ (20002404 <console_readline_default+0x648>)
20002308:	681b      	ldr	r3, [r3, #0]
2000230a:	4619      	mov	r1, r3
2000230c:	483e      	ldr	r0, [pc, #248]	@ (20002408 <console_readline_default+0x64c>)
2000230e:	f7fe fe1d 	bl	20000f4c <kfree>
		    console_killbuffer = strdup(&str[idx]);
20002312:	6bbb      	ldr	r3, [r7, #56]	@ 0x38
20002314:	68ba      	ldr	r2, [r7, #8]
20002316:	4413      	add	r3, r2
20002318:	4618      	mov	r0, r3
2000231a:	f7ff f891 	bl	20001440 <lib_strdup>
2000231e:	4603      	mov	r3, r0
20002320:	4a38      	ldr	r2, [pc, #224]	@ (20002404 <console_readline_default+0x648>)
20002322:	6013      	str	r3, [r2, #0]
		    console_whiteout(len-idx);
20002324:	6b7a      	ldr	r2, [r7, #52]	@ 0x34
20002326:	6bbb      	ldr	r3, [r7, #56]	@ 0x38
20002328:	1ad3      	subs	r3, r2, r3
2000232a:	4618      	mov	r0, r3
2000232c:	f7ff fd08 	bl	20001d40 <console_whiteout>
		    len = idx;
20002330:	6bbb      	ldr	r3, [r7, #56]	@ 0x38
20002332:	637b      	str	r3, [r7, #52]	@ 0x34
		    nosave = 0;
20002334:	2300      	movs	r3, #0
20002336:	62bb      	str	r3, [r7, #40]	@ 0x28
		    }
		break;
20002338:	e1ba      	b.n	200026b0 <console_readline_default+0x8f4>

	    case CTRL('Y'):			/* Yank killed data */
		if (console_killbuffer == NULL) break;
2000233a:	4b32      	ldr	r3, [pc, #200]	@ (20002404 <console_readline_default+0x648>)
2000233c:	681b      	ldr	r3, [r3, #0]
2000233e:	2b00      	cmp	r3, #0
20002340:	f000 81b8 	beq.w	200026b4 <console_readline_default+0x8f8>
		klen = strlen(console_killbuffer);
20002344:	4b2f      	ldr	r3, [pc, #188]	@ (20002404 <console_readline_default+0x648>)
20002346:	681b      	ldr	r3, [r3, #0]
20002348:	4618      	mov	r0, r3
2000234a:	f7fe ffa2 	bl	20001292 <lib_strlen>
2000234e:	61f8      	str	r0, [r7, #28]
		if (klen == 0) break;
20002350:	69fb      	ldr	r3, [r7, #28]
20002352:	2b00      	cmp	r3, #0
20002354:	f000 81b0 	beq.w	200026b8 <console_readline_default+0x8fc>
		if (len + klen > maxlen) break;
20002358:	6b7a      	ldr	r2, [r7, #52]	@ 0x34
2000235a:	69fb      	ldr	r3, [r7, #28]
2000235c:	4413      	add	r3, r2
2000235e:	687a      	ldr	r2, [r7, #4]
20002360:	429a      	cmp	r2, r3
20002362:	f2c0 81ab 	blt.w	200026bc <console_readline_default+0x900>
		nosave = 0;
20002366:	2300      	movs	r3, #0
20002368:	62bb      	str	r3, [r7, #40]	@ 0x28
		for (t = len + klen; t > idx; t--) {
2000236a:	6b7a      	ldr	r2, [r7, #52]	@ 0x34
2000236c:	69fb      	ldr	r3, [r7, #28]
2000236e:	4413      	add	r3, r2
20002370:	633b      	str	r3, [r7, #48]	@ 0x30
20002372:	e00e      	b.n	20002392 <console_readline_default+0x5d6>
		    str[t-1] = str[t-klen-1];
20002374:	6b3a      	ldr	r2, [r7, #48]	@ 0x30
20002376:	69fb      	ldr	r3, [r7, #28]
20002378:	1ad3      	subs	r3, r2, r3
2000237a:	3b01      	subs	r3, #1
2000237c:	68ba      	ldr	r2, [r7, #8]
2000237e:	441a      	add	r2, r3
20002380:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
20002382:	3b01      	subs	r3, #1
20002384:	68b9      	ldr	r1, [r7, #8]
20002386:	440b      	add	r3, r1
20002388:	7812      	ldrb	r2, [r2, #0]
2000238a:	701a      	strb	r2, [r3, #0]
		for (t = len + klen; t > idx; t--) {
2000238c:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
2000238e:	3b01      	subs	r3, #1
20002390:	633b      	str	r3, [r7, #48]	@ 0x30
20002392:	6b3a      	ldr	r2, [r7, #48]	@ 0x30
20002394:	6bbb      	ldr	r3, [r7, #56]	@ 0x38
20002396:	429a      	cmp	r2, r3
20002398:	dcec      	bgt.n	20002374 <console_readline_default+0x5b8>
		    }
		for (t = 0; t < klen; t++) str[t+idx] = console_killbuffer[t];
2000239a:	2300      	movs	r3, #0
2000239c:	633b      	str	r3, [r7, #48]	@ 0x30
2000239e:	e00e      	b.n	200023be <console_readline_default+0x602>
200023a0:	4b18      	ldr	r3, [pc, #96]	@ (20002404 <console_readline_default+0x648>)
200023a2:	681a      	ldr	r2, [r3, #0]
200023a4:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
200023a6:	441a      	add	r2, r3
200023a8:	6b39      	ldr	r1, [r7, #48]	@ 0x30
200023aa:	6bbb      	ldr	r3, [r7, #56]	@ 0x38
200023ac:	440b      	add	r3, r1
200023ae:	4619      	mov	r1, r3
200023b0:	68bb      	ldr	r3, [r7, #8]
200023b2:	440b      	add	r3, r1
200023b4:	7812      	ldrb	r2, [r2, #0]
200023b6:	701a      	strb	r2, [r3, #0]
200023b8:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
200023ba:	3301      	adds	r3, #1
200023bc:	633b      	str	r3, [r7, #48]	@ 0x30
200023be:	6b3a      	ldr	r2, [r7, #48]	@ 0x30
200023c0:	69fb      	ldr	r3, [r7, #28]
200023c2:	429a      	cmp	r2, r3
200023c4:	dbec      	blt.n	200023a0 <console_readline_default+0x5e4>
		len += klen;
200023c6:	6b7a      	ldr	r2, [r7, #52]	@ 0x34
200023c8:	69fb      	ldr	r3, [r7, #28]
200023ca:	4413      	add	r3, r2
200023cc:	637b      	str	r3, [r7, #52]	@ 0x34
		console_write((unsigned char *)&str[idx],len-idx);
200023ce:	6bbb      	ldr	r3, [r7, #56]	@ 0x38
200023d0:	68ba      	ldr	r2, [r7, #8]
200023d2:	18d0      	adds	r0, r2, r3
200023d4:	6b7a      	ldr	r2, [r7, #52]	@ 0x34
200023d6:	6bbb      	ldr	r3, [r7, #56]	@ 0x38
200023d8:	1ad3      	subs	r3, r2, r3
200023da:	4619      	mov	r1, r3
200023dc:	f7ff fa04 	bl	200017e8 <console_write>
		idx += klen;
200023e0:	6bba      	ldr	r2, [r7, #56]	@ 0x38
200023e2:	69fb      	ldr	r3, [r7, #28]
200023e4:	4413      	add	r3, r2
200023e6:	63bb      	str	r3, [r7, #56]	@ 0x38
		console_backspace(len-idx-1);
200023e8:	6b7a      	ldr	r2, [r7, #52]	@ 0x34
200023ea:	6bbb      	ldr	r3, [r7, #56]	@ 0x38
200023ec:	1ad3      	subs	r3, r2, r3
200023ee:	3b01      	subs	r3, #1
200023f0:	4618      	mov	r0, r3
200023f2:	f7ff fc8b 	bl	20001d0c <console_backspace>
		break;
200023f6:	e16c      	b.n	200026d2 <console_readline_default+0x916>
200023f8:	200044a4 	.word	0x200044a4
200023fc:	20004bd0 	.word	0x20004bd0
20002400:	200044c8 	.word	0x200044c8
20002404:	20004bbc 	.word	0x20004bbc
20002408:	20004ab4 	.word	0x20004ab4

	    case CTRL('R'):			/* Redisplay line */
		str[len] = 0;
2000240c:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
2000240e:	68ba      	ldr	r2, [r7, #8]
20002410:	4413      	add	r3, r2
20002412:	2200      	movs	r2, #0
20002414:	701a      	strb	r2, [r3, #0]
		console_crlf();
20002416:	f7ff fcc7 	bl	20001da8 <console_crlf>
		console_write((unsigned char *)prompt,strlen(prompt));
2000241a:	68f8      	ldr	r0, [r7, #12]
2000241c:	f7fe ff39 	bl	20001292 <lib_strlen>
20002420:	4603      	mov	r3, r0
20002422:	4619      	mov	r1, r3
20002424:	68f8      	ldr	r0, [r7, #12]
20002426:	f7ff f9df 	bl	200017e8 <console_write>
		console_write((unsigned char *)str,len);
2000242a:	6b79      	ldr	r1, [r7, #52]	@ 0x34
2000242c:	68b8      	ldr	r0, [r7, #8]
2000242e:	f7ff f9db 	bl	200017e8 <console_write>
		console_backspace(len-idx);
20002432:	6b7a      	ldr	r2, [r7, #52]	@ 0x34
20002434:	6bbb      	ldr	r3, [r7, #56]	@ 0x38
20002436:	1ad3      	subs	r3, r2, r3
20002438:	4618      	mov	r0, r3
2000243a:	f7ff fc67 	bl	20001d0c <console_backspace>
		break;
2000243e:	e148      	b.n	200026d2 <console_readline_default+0x916>

	    case CTRL('U'):			/* Cancel line */
		console_backspace(idx);
20002440:	6bb8      	ldr	r0, [r7, #56]	@ 0x38
20002442:	f7ff fc63 	bl	20001d0c <console_backspace>
		console_eraseeol();
20002446:	f7ff fca5 	bl	20001d94 <console_eraseeol>
		if (len > 0) nosave = 1;
2000244a:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
2000244c:	2b00      	cmp	r3, #0
2000244e:	dd01      	ble.n	20002454 <console_readline_default+0x698>
20002450:	2301      	movs	r3, #1
20002452:	62bb      	str	r3, [r7, #40]	@ 0x28
		idx = 0;
20002454:	2300      	movs	r3, #0
20002456:	63bb      	str	r3, [r7, #56]	@ 0x38
		len = 0;
20002458:	2300      	movs	r3, #0
2000245a:	637b      	str	r3, [r7, #52]	@ 0x34
		break;
2000245c:	e139      	b.n	200026d2 <console_readline_default+0x916>

	    case CTRL('M'):			/* terminate */
	    case CTRL('J'):
		console_crlf();
2000245e:	f7ff fca3 	bl	20001da8 <console_crlf>
		reading = 0;
20002462:	2300      	movs	r3, #0
20002464:	63fb      	str	r3, [r7, #60]	@ 0x3c
		break;
20002466:	e134      	b.n	200026d2 <console_readline_default+0x916>

	    case CTRL('P'):
	    case VKEY_UP:			/* recall previous line */
		t = recall;
20002468:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
2000246a:	633b      	str	r3, [r7, #48]	@ 0x30
		t--;
2000246c:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
2000246e:	3b01      	subs	r3, #1
20002470:	633b      	str	r3, [r7, #48]	@ 0x30
		if (t < 0) t = MAXSAVELINES-1;
20002472:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
20002474:	2b00      	cmp	r3, #0
20002476:	da01      	bge.n	2000247c <console_readline_default+0x6c0>
20002478:	231d      	movs	r3, #29
2000247a:	633b      	str	r3, [r7, #48]	@ 0x30
		if (console_savedlines[t] == NULL) break;
2000247c:	4a97      	ldr	r2, [pc, #604]	@ (200026dc <console_readline_default+0x920>)
2000247e:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
20002480:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
20002484:	2b00      	cmp	r3, #0
20002486:	f000 811b 	beq.w	200026c0 <console_readline_default+0x904>
		recall = t;
2000248a:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
2000248c:	62fb      	str	r3, [r7, #44]	@ 0x2c
		console_backspace(idx);
2000248e:	6bb8      	ldr	r0, [r7, #56]	@ 0x38
20002490:	f7ff fc3c 	bl	20001d0c <console_backspace>
		strcpy(str,console_savedlines[recall]);
20002494:	4a91      	ldr	r2, [pc, #580]	@ (200026dc <console_readline_default+0x920>)
20002496:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
20002498:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
2000249c:	4619      	mov	r1, r3
2000249e:	68b8      	ldr	r0, [r7, #8]
200024a0:	f7fe feaf 	bl	20001202 <lib_strcpy>
		len = idx = strlen(console_savedlines[recall]);
200024a4:	4a8d      	ldr	r2, [pc, #564]	@ (200026dc <console_readline_default+0x920>)
200024a6:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
200024a8:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
200024ac:	4618      	mov	r0, r3
200024ae:	f7fe fef0 	bl	20001292 <lib_strlen>
200024b2:	63b8      	str	r0, [r7, #56]	@ 0x38
200024b4:	6bbb      	ldr	r3, [r7, #56]	@ 0x38
200024b6:	637b      	str	r3, [r7, #52]	@ 0x34
		console_eraseeol();
200024b8:	f7ff fc6c 	bl	20001d94 <console_eraseeol>
		console_write((unsigned char *)str,len);
200024bc:	6b79      	ldr	r1, [r7, #52]	@ 0x34
200024be:	68b8      	ldr	r0, [r7, #8]
200024c0:	f7ff f992 	bl	200017e8 <console_write>
		nosave = (t == ((console_nextsave - 1) % MAXSAVELINES));
200024c4:	4b86      	ldr	r3, [pc, #536]	@ (200026e0 <console_readline_default+0x924>)
200024c6:	681b      	ldr	r3, [r3, #0]
200024c8:	1e5a      	subs	r2, r3, #1
200024ca:	4b86      	ldr	r3, [pc, #536]	@ (200026e4 <console_readline_default+0x928>)
200024cc:	fb83 1302 	smull	r1, r3, r3, r2
200024d0:	4413      	add	r3, r2
200024d2:	1119      	asrs	r1, r3, #4
200024d4:	17d3      	asrs	r3, r2, #31
200024d6:	1ac9      	subs	r1, r1, r3
200024d8:	460b      	mov	r3, r1
200024da:	011b      	lsls	r3, r3, #4
200024dc:	1a5b      	subs	r3, r3, r1
200024de:	005b      	lsls	r3, r3, #1
200024e0:	1ad1      	subs	r1, r2, r3
200024e2:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
200024e4:	428b      	cmp	r3, r1
200024e6:	bf0c      	ite	eq
200024e8:	2301      	moveq	r3, #1
200024ea:	2300      	movne	r3, #0
200024ec:	b2db      	uxtb	r3, r3
200024ee:	62bb      	str	r3, [r7, #40]	@ 0x28
		break;
200024f0:	e0ef      	b.n	200026d2 <console_readline_default+0x916>
		
	    case CTRL('N'):
	    case VKEY_DOWN:			/* Recall next line */
		t = recall; 
200024f2:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
200024f4:	633b      	str	r3, [r7, #48]	@ 0x30
		t++;
200024f6:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
200024f8:	3301      	adds	r3, #1
200024fa:	633b      	str	r3, [r7, #48]	@ 0x30
		if (t == MAXSAVELINES) t = 0;
200024fc:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
200024fe:	2b1e      	cmp	r3, #30
20002500:	d101      	bne.n	20002506 <console_readline_default+0x74a>
20002502:	2300      	movs	r3, #0
20002504:	633b      	str	r3, [r7, #48]	@ 0x30
		if (console_savedlines[t] == NULL) break;
20002506:	4a75      	ldr	r2, [pc, #468]	@ (200026dc <console_readline_default+0x920>)
20002508:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
2000250a:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
2000250e:	2b00      	cmp	r3, #0
20002510:	f000 80d8 	beq.w	200026c4 <console_readline_default+0x908>
		recall = t;
20002514:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
20002516:	62fb      	str	r3, [r7, #44]	@ 0x2c
		console_backspace(idx);
20002518:	6bb8      	ldr	r0, [r7, #56]	@ 0x38
2000251a:	f7ff fbf7 	bl	20001d0c <console_backspace>
		strcpy(str,console_savedlines[recall]);
2000251e:	4a6f      	ldr	r2, [pc, #444]	@ (200026dc <console_readline_default+0x920>)
20002520:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
20002522:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
20002526:	4619      	mov	r1, r3
20002528:	68b8      	ldr	r0, [r7, #8]
2000252a:	f7fe fe6a 	bl	20001202 <lib_strcpy>
		len = idx = strlen(console_savedlines[recall]);
2000252e:	4a6b      	ldr	r2, [pc, #428]	@ (200026dc <console_readline_default+0x920>)
20002530:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
20002532:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
20002536:	4618      	mov	r0, r3
20002538:	f7fe feab 	bl	20001292 <lib_strlen>
2000253c:	63b8      	str	r0, [r7, #56]	@ 0x38
2000253e:	6bbb      	ldr	r3, [r7, #56]	@ 0x38
20002540:	637b      	str	r3, [r7, #52]	@ 0x34
		console_eraseeol();
20002542:	f7ff fc27 	bl	20001d94 <console_eraseeol>
		console_write((unsigned char *)str,len);
20002546:	6b79      	ldr	r1, [r7, #52]	@ 0x34
20002548:	68b8      	ldr	r0, [r7, #8]
2000254a:	f7ff f94d 	bl	200017e8 <console_write>
		nosave = 1;
2000254e:	2301      	movs	r3, #1
20002550:	62bb      	str	r3, [r7, #40]	@ 0x28
		break;
20002552:	e0be      	b.n	200026d2 <console_readline_default+0x916>
	    case VKEY_F8:
	    case VKEY_F9:
	    case VKEY_F10:
	    case VKEY_F11:
	    case VKEY_F12:
		sprintf(env,"F%d",ch-VKEY_F1+1);
20002554:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
20002556:	f2a3 120f 	subw	r2, r3, #271	@ 0x10f
2000255a:	f107 0310 	add.w	r3, r7, #16
2000255e:	4962      	ldr	r1, [pc, #392]	@ (200026e8 <console_readline_default+0x92c>)
20002560:	4618      	mov	r0, r3
20002562:	f7fe fb4b 	bl	20000bfc <xsprintf>
		x = env_getenv(env);
20002566:	f107 0310 	add.w	r3, r7, #16
2000256a:	4618      	mov	r0, r3
2000256c:	f001 f82a 	bl	200035c4 <env_getenv>
20002570:	6238      	str	r0, [r7, #32]
		if (x) {
20002572:	6a3b      	ldr	r3, [r7, #32]
20002574:	2b00      	cmp	r3, #0
20002576:	d019      	beq.n	200025ac <console_readline_default+0x7f0>
		    console_backspace(idx);
20002578:	6bb8      	ldr	r0, [r7, #56]	@ 0x38
2000257a:	f7ff fbc7 	bl	20001d0c <console_backspace>
		    strcpy(str,x);
2000257e:	6a39      	ldr	r1, [r7, #32]
20002580:	68b8      	ldr	r0, [r7, #8]
20002582:	f7fe fe3e 	bl	20001202 <lib_strcpy>
		    idx = len = strlen(str);
20002586:	68b8      	ldr	r0, [r7, #8]
20002588:	f7fe fe83 	bl	20001292 <lib_strlen>
2000258c:	6378      	str	r0, [r7, #52]	@ 0x34
2000258e:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
20002590:	63bb      	str	r3, [r7, #56]	@ 0x38
		    console_eraseeol();
20002592:	f7ff fbff 	bl	20001d94 <console_eraseeol>
		    console_write((unsigned char *)str,len);
20002596:	6b79      	ldr	r1, [r7, #52]	@ 0x34
20002598:	68b8      	ldr	r0, [r7, #8]
2000259a:	f7ff f925 	bl	200017e8 <console_write>
		    console_crlf();
2000259e:	f7ff fc03 	bl	20001da8 <console_crlf>
		    reading = 0;
200025a2:	2300      	movs	r3, #0
200025a4:	63fb      	str	r3, [r7, #60]	@ 0x3c
		    nosave = 1;
200025a6:	2301      	movs	r3, #1
200025a8:	62bb      	str	r3, [r7, #40]	@ 0x28
		    console_write((unsigned char *)str,len);
		    console_crlf();
		    reading = 0;
		    nosave = 1;
		    }
		break;
200025aa:	e08d      	b.n	200026c8 <console_readline_default+0x90c>
		else if (ch == VKEY_F12) {
200025ac:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
200025ae:	f240 121b 	movw	r2, #283	@ 0x11b
200025b2:	4293      	cmp	r3, r2
200025b4:	f040 8088 	bne.w	200026c8 <console_readline_default+0x90c>
		    t = recall;
200025b8:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
200025ba:	633b      	str	r3, [r7, #48]	@ 0x30
		    t--;
200025bc:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
200025be:	3b01      	subs	r3, #1
200025c0:	633b      	str	r3, [r7, #48]	@ 0x30
		    if (t < 0) t = MAXSAVELINES-1;
200025c2:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
200025c4:	2b00      	cmp	r3, #0
200025c6:	da01      	bge.n	200025cc <console_readline_default+0x810>
200025c8:	231d      	movs	r3, #29
200025ca:	633b      	str	r3, [r7, #48]	@ 0x30
		    if (console_savedlines[t] == NULL) break;
200025cc:	4a43      	ldr	r2, [pc, #268]	@ (200026dc <console_readline_default+0x920>)
200025ce:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
200025d0:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
200025d4:	2b00      	cmp	r3, #0
200025d6:	d079      	beq.n	200026cc <console_readline_default+0x910>
		    recall = t;
200025d8:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
200025da:	62fb      	str	r3, [r7, #44]	@ 0x2c
		    console_backspace(idx);
200025dc:	6bb8      	ldr	r0, [r7, #56]	@ 0x38
200025de:	f7ff fb95 	bl	20001d0c <console_backspace>
		    strcpy(str,console_savedlines[recall]);
200025e2:	4a3e      	ldr	r2, [pc, #248]	@ (200026dc <console_readline_default+0x920>)
200025e4:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
200025e6:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
200025ea:	4619      	mov	r1, r3
200025ec:	68b8      	ldr	r0, [r7, #8]
200025ee:	f7fe fe08 	bl	20001202 <lib_strcpy>
		    len = idx = strlen(console_savedlines[recall]);
200025f2:	4a3a      	ldr	r2, [pc, #232]	@ (200026dc <console_readline_default+0x920>)
200025f4:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
200025f6:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
200025fa:	4618      	mov	r0, r3
200025fc:	f7fe fe49 	bl	20001292 <lib_strlen>
20002600:	63b8      	str	r0, [r7, #56]	@ 0x38
20002602:	6bbb      	ldr	r3, [r7, #56]	@ 0x38
20002604:	637b      	str	r3, [r7, #52]	@ 0x34
		    console_eraseeol();
20002606:	f7ff fbc5 	bl	20001d94 <console_eraseeol>
		    console_write((unsigned char *)str,len);
2000260a:	6b79      	ldr	r1, [r7, #52]	@ 0x34
2000260c:	68b8      	ldr	r0, [r7, #8]
2000260e:	f7ff f8eb 	bl	200017e8 <console_write>
		    console_crlf();
20002612:	f7ff fbc9 	bl	20001da8 <console_crlf>
		    reading = 0;
20002616:	2300      	movs	r3, #0
20002618:	63fb      	str	r3, [r7, #60]	@ 0x3c
		    nosave = 1;
2000261a:	2301      	movs	r3, #1
2000261c:	62bb      	str	r3, [r7, #40]	@ 0x28
		break;
2000261e:	e053      	b.n	200026c8 <console_readline_default+0x90c>

	    default:				/* insert character */
		if (ch >= ' ') {
20002620:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
20002622:	2b1f      	cmp	r3, #31
20002624:	dd54      	ble.n	200026d0 <console_readline_default+0x914>
		    if (idx < (maxlen-1)) {
20002626:	687b      	ldr	r3, [r7, #4]
20002628:	3b01      	subs	r3, #1
2000262a:	6bba      	ldr	r2, [r7, #56]	@ 0x38
2000262c:	429a      	cmp	r2, r3
2000262e:	da4f      	bge.n	200026d0 <console_readline_default+0x914>
			nosave = 0;
20002630:	2300      	movs	r3, #0
20002632:	62bb      	str	r3, [r7, #40]	@ 0x28
			for (t = len; t > idx; t--) {
20002634:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
20002636:	633b      	str	r3, [r7, #48]	@ 0x30
20002638:	e00b      	b.n	20002652 <console_readline_default+0x896>
			    str[t] = str[t-1];
2000263a:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
2000263c:	3b01      	subs	r3, #1
2000263e:	68ba      	ldr	r2, [r7, #8]
20002640:	441a      	add	r2, r3
20002642:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
20002644:	68b9      	ldr	r1, [r7, #8]
20002646:	440b      	add	r3, r1
20002648:	7812      	ldrb	r2, [r2, #0]
2000264a:	701a      	strb	r2, [r3, #0]
			for (t = len; t > idx; t--) {
2000264c:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
2000264e:	3b01      	subs	r3, #1
20002650:	633b      	str	r3, [r7, #48]	@ 0x30
20002652:	6b3a      	ldr	r2, [r7, #48]	@ 0x30
20002654:	6bbb      	ldr	r3, [r7, #56]	@ 0x38
20002656:	429a      	cmp	r2, r3
20002658:	dcef      	bgt.n	2000263a <console_readline_default+0x87e>
			    }
			str[idx] = ch;
2000265a:	6bbb      	ldr	r3, [r7, #56]	@ 0x38
2000265c:	68ba      	ldr	r2, [r7, #8]
2000265e:	4413      	add	r3, r2
20002660:	6a7a      	ldr	r2, [r7, #36]	@ 0x24
20002662:	b2d2      	uxtb	r2, r2
20002664:	701a      	strb	r2, [r3, #0]
			len++;
20002666:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
20002668:	3301      	adds	r3, #1
2000266a:	637b      	str	r3, [r7, #52]	@ 0x34
			if (len != idx) {
2000266c:	6b7a      	ldr	r2, [r7, #52]	@ 0x34
2000266e:	6bbb      	ldr	r3, [r7, #56]	@ 0x38
20002670:	429a      	cmp	r2, r3
20002672:	d00f      	beq.n	20002694 <console_readline_default+0x8d8>
			    console_write((unsigned char *)&str[idx],len-idx);
20002674:	6bbb      	ldr	r3, [r7, #56]	@ 0x38
20002676:	68ba      	ldr	r2, [r7, #8]
20002678:	18d0      	adds	r0, r2, r3
2000267a:	6b7a      	ldr	r2, [r7, #52]	@ 0x34
2000267c:	6bbb      	ldr	r3, [r7, #56]	@ 0x38
2000267e:	1ad3      	subs	r3, r2, r3
20002680:	4619      	mov	r1, r3
20002682:	f7ff f8b1 	bl	200017e8 <console_write>
			    console_backspace(len-idx-1);
20002686:	6b7a      	ldr	r2, [r7, #52]	@ 0x34
20002688:	6bbb      	ldr	r3, [r7, #56]	@ 0x38
2000268a:	1ad3      	subs	r3, r2, r3
2000268c:	3b01      	subs	r3, #1
2000268e:	4618      	mov	r0, r3
20002690:	f7ff fb3c 	bl	20001d0c <console_backspace>
			    }
			idx++;
20002694:	6bbb      	ldr	r3, [r7, #56]	@ 0x38
20002696:	3301      	adds	r3, #1
20002698:	63bb      	str	r3, [r7, #56]	@ 0x38
			}
		    }
		break;
2000269a:	e019      	b.n	200026d0 <console_readline_default+0x914>
	if (ch == 0) continue;
2000269c:	bf00      	nop
2000269e:	e018      	b.n	200026d2 <console_readline_default+0x916>
		break;
200026a0:	bf00      	nop
200026a2:	e016      	b.n	200026d2 <console_readline_default+0x916>
		break;
200026a4:	bf00      	nop
200026a6:	e014      	b.n	200026d2 <console_readline_default+0x916>
		break;
200026a8:	bf00      	nop
200026aa:	e012      	b.n	200026d2 <console_readline_default+0x916>
		break;
200026ac:	bf00      	nop
200026ae:	e010      	b.n	200026d2 <console_readline_default+0x916>
		break;
200026b0:	bf00      	nop
200026b2:	e00e      	b.n	200026d2 <console_readline_default+0x916>
		if (console_killbuffer == NULL) break;
200026b4:	bf00      	nop
200026b6:	e00c      	b.n	200026d2 <console_readline_default+0x916>
		if (klen == 0) break;
200026b8:	bf00      	nop
200026ba:	e00a      	b.n	200026d2 <console_readline_default+0x916>
		if (len + klen > maxlen) break;
200026bc:	bf00      	nop
200026be:	e008      	b.n	200026d2 <console_readline_default+0x916>
		if (console_savedlines[t] == NULL) break;
200026c0:	bf00      	nop
200026c2:	e006      	b.n	200026d2 <console_readline_default+0x916>
		if (console_savedlines[t] == NULL) break;
200026c4:	bf00      	nop
200026c6:	e004      	b.n	200026d2 <console_readline_default+0x916>
		break;
200026c8:	bf00      	nop
200026ca:	e002      	b.n	200026d2 <console_readline_default+0x916>
		    if (console_savedlines[t] == NULL) break;
200026cc:	bf00      	nop
200026ce:	e000      	b.n	200026d2 <console_readline_default+0x916>
		break;
200026d0:	bf00      	nop
    while (reading) {
200026d2:	6bfb      	ldr	r3, [r7, #60]	@ 0x3c
200026d4:	2b00      	cmp	r3, #0
200026d6:	f47f abc3 	bne.w	20001e60 <console_readline_default+0xa4>
200026da:	e008      	b.n	200026ee <console_readline_default+0x932>
200026dc:	20004b44 	.word	0x20004b44
200026e0:	20004b40 	.word	0x20004b40
200026e4:	88888889 	.word	0x88888889
200026e8:	200044d8 	.word	0x200044d8
	if (ch < 0) break;
200026ec:	bf00      	nop
	    }
	}
    POLL();
200026ee:	f7fe ffef 	bl	200016d0 <background>

    console_inreadline--;
200026f2:	4b1d      	ldr	r3, [pc, #116]	@ (20002768 <console_readline_default+0x9ac>)
200026f4:	681b      	ldr	r3, [r3, #0]
200026f6:	3b01      	subs	r3, #1
200026f8:	4a1b      	ldr	r2, [pc, #108]	@ (20002768 <console_readline_default+0x9ac>)
200026fa:	6013      	str	r3, [r2, #0]

    str[len] = 0;
200026fc:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
200026fe:	68ba      	ldr	r2, [r7, #8]
20002700:	4413      	add	r3, r2
20002702:	2200      	movs	r2, #0
20002704:	701a      	strb	r2, [r3, #0]

    if ((len != 0) && !nosave) {
20002706:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
20002708:	2b00      	cmp	r3, #0
2000270a:	d027      	beq.n	2000275c <console_readline_default+0x9a0>
2000270c:	6abb      	ldr	r3, [r7, #40]	@ 0x28
2000270e:	2b00      	cmp	r3, #0
20002710:	d124      	bne.n	2000275c <console_readline_default+0x9a0>
	if (console_savedlines[console_nextsave]) {
20002712:	4b16      	ldr	r3, [pc, #88]	@ (2000276c <console_readline_default+0x9b0>)
20002714:	681b      	ldr	r3, [r3, #0]
20002716:	4a16      	ldr	r2, [pc, #88]	@ (20002770 <console_readline_default+0x9b4>)
20002718:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
2000271c:	2b00      	cmp	r3, #0
2000271e:	d008      	beq.n	20002732 <console_readline_default+0x976>
	    KFREE(console_savedlines[console_nextsave]);
20002720:	4b12      	ldr	r3, [pc, #72]	@ (2000276c <console_readline_default+0x9b0>)
20002722:	681b      	ldr	r3, [r3, #0]
20002724:	4a12      	ldr	r2, [pc, #72]	@ (20002770 <console_readline_default+0x9b4>)
20002726:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
2000272a:	4619      	mov	r1, r3
2000272c:	4811      	ldr	r0, [pc, #68]	@ (20002774 <console_readline_default+0x9b8>)
2000272e:	f7fe fc0d 	bl	20000f4c <kfree>
	    }
	console_savedlines[console_nextsave] = strdup(str);
20002732:	4b0e      	ldr	r3, [pc, #56]	@ (2000276c <console_readline_default+0x9b0>)
20002734:	681c      	ldr	r4, [r3, #0]
20002736:	68b8      	ldr	r0, [r7, #8]
20002738:	f7fe fe82 	bl	20001440 <lib_strdup>
2000273c:	4603      	mov	r3, r0
2000273e:	4a0c      	ldr	r2, [pc, #48]	@ (20002770 <console_readline_default+0x9b4>)
20002740:	f842 3024 	str.w	r3, [r2, r4, lsl #2]
	console_nextsave++;
20002744:	4b09      	ldr	r3, [pc, #36]	@ (2000276c <console_readline_default+0x9b0>)
20002746:	681b      	ldr	r3, [r3, #0]
20002748:	3301      	adds	r3, #1
2000274a:	4a08      	ldr	r2, [pc, #32]	@ (2000276c <console_readline_default+0x9b0>)
2000274c:	6013      	str	r3, [r2, #0]
	if (console_nextsave == MAXSAVELINES) console_nextsave = 0;
2000274e:	4b07      	ldr	r3, [pc, #28]	@ (2000276c <console_readline_default+0x9b0>)
20002750:	681b      	ldr	r3, [r3, #0]
20002752:	2b1e      	cmp	r3, #30
20002754:	d102      	bne.n	2000275c <console_readline_default+0x9a0>
20002756:	4b05      	ldr	r3, [pc, #20]	@ (2000276c <console_readline_default+0x9b0>)
20002758:	2200      	movs	r2, #0
2000275a:	601a      	str	r2, [r3, #0]
	}

    return len;
2000275c:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
}
2000275e:	4618      	mov	r0, r3
20002760:	3744      	adds	r7, #68	@ 0x44
20002762:	46bd      	mov	sp, r7
20002764:	bd90      	pop	{r4, r7, pc}
20002766:	bf00      	nop
20002768:	20004bcc 	.word	0x20004bcc
2000276c:	20004b40 	.word	0x20004b40
20002770:	20004b44 	.word	0x20004b44
20002774:	20004ab4 	.word	0x20004ab4

20002778 <console_readline>:

int console_readline(char *prompt,char *str,int maxlen)
{
20002778:	b580      	push	{r7, lr}
2000277a:	b084      	sub	sp, #16
2000277c:	af00      	add	r7, sp, #0
2000277e:	60f8      	str	r0, [r7, #12]
20002780:	60b9      	str	r1, [r7, #8]
20002782:	607a      	str	r2, [r7, #4]
    str[0] = '\0';
20002784:	68bb      	ldr	r3, [r7, #8]
20002786:	2200      	movs	r2, #0
20002788:	701a      	strb	r2, [r3, #0]
    return console_readline_default(prompt,str,maxlen);
2000278a:	687a      	ldr	r2, [r7, #4]
2000278c:	68b9      	ldr	r1, [r7, #8]
2000278e:	68f8      	ldr	r0, [r7, #12]
20002790:	f7ff fb14 	bl	20001dbc <console_readline_default>
20002794:	4603      	mov	r3, r0
}
20002796:	4618      	mov	r0, r3
20002798:	3710      	adds	r7, #16
2000279a:	46bd      	mov	sp, r7
2000279c:	bd80      	pop	{r7, pc}

2000279e <cfe_strlen>:
#include "cfe.h"

extern int cfe_iocb_dispatch(cfe_iocb_t *iocb);

static int cfe_strlen(char *name)
{
2000279e:	b480      	push	{r7}
200027a0:	b085      	sub	sp, #20
200027a2:	af00      	add	r7, sp, #0
200027a4:	6078      	str	r0, [r7, #4]
    int count = 0;
200027a6:	2300      	movs	r3, #0
200027a8:	60fb      	str	r3, [r7, #12]

    while (*name) {
200027aa:	e005      	b.n	200027b8 <cfe_strlen+0x1a>
	count++;
200027ac:	68fb      	ldr	r3, [r7, #12]
200027ae:	3301      	adds	r3, #1
200027b0:	60fb      	str	r3, [r7, #12]
	name++;
200027b2:	687b      	ldr	r3, [r7, #4]
200027b4:	3301      	adds	r3, #1
200027b6:	607b      	str	r3, [r7, #4]
    while (*name) {
200027b8:	687b      	ldr	r3, [r7, #4]
200027ba:	781b      	ldrb	r3, [r3, #0]
200027bc:	2b00      	cmp	r3, #0
200027be:	d1f5      	bne.n	200027ac <cfe_strlen+0xe>
	}

    return count;
200027c0:	68fb      	ldr	r3, [r7, #12]
}
200027c2:	4618      	mov	r0, r3
200027c4:	3714      	adds	r7, #20
200027c6:	46bd      	mov	sp, r7
200027c8:	f85d 7b04 	ldr.w	r7, [sp], #4
200027cc:	4770      	bx	lr

200027ce <cfe_open>:

int cfe_open(char *name)
{
200027ce:	b580      	push	{r7, lr}
200027d0:	b09c      	sub	sp, #112	@ 0x70
200027d2:	af00      	add	r7, sp, #0
200027d4:	6078      	str	r0, [r7, #4]
    cfe_iocb_t iocb;

    iocb.iocb_fcode = CFE_CMD_DEV_OPEN;
200027d6:	230b      	movs	r3, #11
200027d8:	60bb      	str	r3, [r7, #8]
    iocb.iocb_status = 0;
200027da:	2300      	movs	r3, #0
200027dc:	60fb      	str	r3, [r7, #12]
    iocb.iocb_handle = 0;
200027de:	2300      	movs	r3, #0
200027e0:	613b      	str	r3, [r7, #16]
    iocb.iocb_flags = 0;
200027e2:	2300      	movs	r3, #0
200027e4:	617b      	str	r3, [r7, #20]
    iocb.iocb_psize = sizeof(iocb_buffer_t);
200027e6:	2318      	movs	r3, #24
200027e8:	61bb      	str	r3, [r7, #24]
    iocb.plist.iocb_buffer.buf_offset = 0;
200027ea:	f04f 0200 	mov.w	r2, #0
200027ee:	f04f 0300 	mov.w	r3, #0
200027f2:	e9c7 2308 	strd	r2, r3, [r7, #32]
    iocb.plist.iocb_buffer.buf_ptr = PTR2HSADDR(name);
200027f6:	687b      	ldr	r3, [r7, #4]
200027f8:	62bb      	str	r3, [r7, #40]	@ 0x28
    iocb.plist.iocb_buffer.buf_length = cfe_strlen(name);
200027fa:	6878      	ldr	r0, [r7, #4]
200027fc:	f7ff ffcf 	bl	2000279e <cfe_strlen>
20002800:	4603      	mov	r3, r0
20002802:	62fb      	str	r3, [r7, #44]	@ 0x2c

    cfe_iocb_dispatch(&iocb);
20002804:	f107 0308 	add.w	r3, r7, #8
20002808:	4618      	mov	r0, r3
2000280a:	f000 f8e3 	bl	200029d4 <cfe_iocb_dispatch>

    return (iocb.iocb_status < 0) ? iocb.iocb_status : iocb.iocb_handle;
2000280e:	68fb      	ldr	r3, [r7, #12]
20002810:	2b00      	cmp	r3, #0
20002812:	da01      	bge.n	20002818 <cfe_open+0x4a>
20002814:	68fb      	ldr	r3, [r7, #12]
20002816:	e000      	b.n	2000281a <cfe_open+0x4c>
20002818:	693b      	ldr	r3, [r7, #16]
}
2000281a:	4618      	mov	r0, r3
2000281c:	3770      	adds	r7, #112	@ 0x70
2000281e:	46bd      	mov	sp, r7
20002820:	bd80      	pop	{r7, pc}

20002822 <cfe_close>:

int cfe_close(int handle)
{
20002822:	b580      	push	{r7, lr}
20002824:	b09c      	sub	sp, #112	@ 0x70
20002826:	af00      	add	r7, sp, #0
20002828:	6078      	str	r0, [r7, #4]
    cfe_iocb_t iocb;

    iocb.iocb_fcode = CFE_CMD_DEV_CLOSE;
2000282a:	2310      	movs	r3, #16
2000282c:	60bb      	str	r3, [r7, #8]
    iocb.iocb_status = 0;
2000282e:	2300      	movs	r3, #0
20002830:	60fb      	str	r3, [r7, #12]
    iocb.iocb_handle = handle;
20002832:	687b      	ldr	r3, [r7, #4]
20002834:	613b      	str	r3, [r7, #16]
    iocb.iocb_flags = 0;
20002836:	2300      	movs	r3, #0
20002838:	617b      	str	r3, [r7, #20]
    iocb.iocb_psize = 0;
2000283a:	2300      	movs	r3, #0
2000283c:	61bb      	str	r3, [r7, #24]

    cfe_iocb_dispatch(&iocb);
2000283e:	f107 0308 	add.w	r3, r7, #8
20002842:	4618      	mov	r0, r3
20002844:	f000 f8c6 	bl	200029d4 <cfe_iocb_dispatch>

    return (iocb.iocb_status);
20002848:	68fb      	ldr	r3, [r7, #12]

}
2000284a:	4618      	mov	r0, r3
2000284c:	3770      	adds	r7, #112	@ 0x70
2000284e:	46bd      	mov	sp, r7
20002850:	bd80      	pop	{r7, pc}

20002852 <cfe_readblk>:

int cfe_readblk(int handle,cfe_offset_t offset,hsaddr_t buffer,int length)
{
20002852:	b580      	push	{r7, lr}
20002854:	b09e      	sub	sp, #120	@ 0x78
20002856:	af00      	add	r7, sp, #0
20002858:	60f8      	str	r0, [r7, #12]
2000285a:	e9c7 2300 	strd	r2, r3, [r7]
    cfe_iocb_t iocb;

    iocb.iocb_fcode = CFE_CMD_DEV_READ;
2000285e:	230d      	movs	r3, #13
20002860:	613b      	str	r3, [r7, #16]
    iocb.iocb_status = 0;
20002862:	2300      	movs	r3, #0
20002864:	617b      	str	r3, [r7, #20]
    iocb.iocb_handle = handle;
20002866:	68fb      	ldr	r3, [r7, #12]
20002868:	61bb      	str	r3, [r7, #24]
    iocb.iocb_flags = 0;
2000286a:	2300      	movs	r3, #0
2000286c:	61fb      	str	r3, [r7, #28]
    iocb.iocb_psize = sizeof(iocb_buffer_t);
2000286e:	2318      	movs	r3, #24
20002870:	623b      	str	r3, [r7, #32]
    iocb.plist.iocb_buffer.buf_offset = offset;
20002872:	e9d7 2300 	ldrd	r2, r3, [r7]
20002876:	e9c7 230a 	strd	r2, r3, [r7, #40]	@ 0x28
    iocb.plist.iocb_buffer.buf_ptr = buffer;
2000287a:	f8d7 3080 	ldr.w	r3, [r7, #128]	@ 0x80
2000287e:	633b      	str	r3, [r7, #48]	@ 0x30
    iocb.plist.iocb_buffer.buf_length = length;
20002880:	f8d7 3084 	ldr.w	r3, [r7, #132]	@ 0x84
20002884:	637b      	str	r3, [r7, #52]	@ 0x34

    cfe_iocb_dispatch(&iocb);
20002886:	f107 0310 	add.w	r3, r7, #16
2000288a:	4618      	mov	r0, r3
2000288c:	f000 f8a2 	bl	200029d4 <cfe_iocb_dispatch>

    return (iocb.iocb_status < 0) ? iocb.iocb_status : iocb.plist.iocb_buffer.buf_retlen;
20002890:	697b      	ldr	r3, [r7, #20]
20002892:	2b00      	cmp	r3, #0
20002894:	da01      	bge.n	2000289a <cfe_readblk+0x48>
20002896:	697b      	ldr	r3, [r7, #20]
20002898:	e000      	b.n	2000289c <cfe_readblk+0x4a>
2000289a:	6bbb      	ldr	r3, [r7, #56]	@ 0x38
}
2000289c:	4618      	mov	r0, r3
2000289e:	3778      	adds	r7, #120	@ 0x78
200028a0:	46bd      	mov	sp, r7
200028a2:	bd80      	pop	{r7, pc}

200028a4 <cfe_read>:

int cfe_read(int handle,hsaddr_t buffer,int length)
{
200028a4:	b580      	push	{r7, lr}
200028a6:	b086      	sub	sp, #24
200028a8:	af02      	add	r7, sp, #8
200028aa:	60f8      	str	r0, [r7, #12]
200028ac:	60b9      	str	r1, [r7, #8]
200028ae:	607a      	str	r2, [r7, #4]
    return cfe_readblk(handle,0,buffer,length);
200028b0:	687b      	ldr	r3, [r7, #4]
200028b2:	9301      	str	r3, [sp, #4]
200028b4:	68bb      	ldr	r3, [r7, #8]
200028b6:	9300      	str	r3, [sp, #0]
200028b8:	f04f 0200 	mov.w	r2, #0
200028bc:	f04f 0300 	mov.w	r3, #0
200028c0:	68f8      	ldr	r0, [r7, #12]
200028c2:	f7ff ffc6 	bl	20002852 <cfe_readblk>
200028c6:	4603      	mov	r3, r0
}
200028c8:	4618      	mov	r0, r3
200028ca:	3710      	adds	r7, #16
200028cc:	46bd      	mov	sp, r7
200028ce:	bd80      	pop	{r7, pc}

200028d0 <cfe_writeblk>:


int cfe_writeblk(int handle,cfe_offset_t offset,hsaddr_t buffer,int length)
{
200028d0:	b580      	push	{r7, lr}
200028d2:	b09e      	sub	sp, #120	@ 0x78
200028d4:	af00      	add	r7, sp, #0
200028d6:	60f8      	str	r0, [r7, #12]
200028d8:	e9c7 2300 	strd	r2, r3, [r7]
    cfe_iocb_t iocb;

    iocb.iocb_fcode = CFE_CMD_DEV_WRITE;
200028dc:	230e      	movs	r3, #14
200028de:	613b      	str	r3, [r7, #16]
    iocb.iocb_status = 0;
200028e0:	2300      	movs	r3, #0
200028e2:	617b      	str	r3, [r7, #20]
    iocb.iocb_handle = handle;
200028e4:	68fb      	ldr	r3, [r7, #12]
200028e6:	61bb      	str	r3, [r7, #24]
    iocb.iocb_flags = 0;
200028e8:	2300      	movs	r3, #0
200028ea:	61fb      	str	r3, [r7, #28]
    iocb.iocb_psize = sizeof(iocb_buffer_t);
200028ec:	2318      	movs	r3, #24
200028ee:	623b      	str	r3, [r7, #32]
    iocb.plist.iocb_buffer.buf_offset = offset;
200028f0:	e9d7 2300 	ldrd	r2, r3, [r7]
200028f4:	e9c7 230a 	strd	r2, r3, [r7, #40]	@ 0x28
    iocb.plist.iocb_buffer.buf_ptr = buffer;
200028f8:	f8d7 3080 	ldr.w	r3, [r7, #128]	@ 0x80
200028fc:	633b      	str	r3, [r7, #48]	@ 0x30
    iocb.plist.iocb_buffer.buf_length = length;
200028fe:	f8d7 3084 	ldr.w	r3, [r7, #132]	@ 0x84
20002902:	637b      	str	r3, [r7, #52]	@ 0x34

    cfe_iocb_dispatch(&iocb);
20002904:	f107 0310 	add.w	r3, r7, #16
20002908:	4618      	mov	r0, r3
2000290a:	f000 f863 	bl	200029d4 <cfe_iocb_dispatch>

    return (iocb.iocb_status < 0) ? iocb.iocb_status : iocb.plist.iocb_buffer.buf_retlen;
2000290e:	697b      	ldr	r3, [r7, #20]
20002910:	2b00      	cmp	r3, #0
20002912:	da01      	bge.n	20002918 <cfe_writeblk+0x48>
20002914:	697b      	ldr	r3, [r7, #20]
20002916:	e000      	b.n	2000291a <cfe_writeblk+0x4a>
20002918:	6bbb      	ldr	r3, [r7, #56]	@ 0x38
}
2000291a:	4618      	mov	r0, r3
2000291c:	3778      	adds	r7, #120	@ 0x78
2000291e:	46bd      	mov	sp, r7
20002920:	bd80      	pop	{r7, pc}

20002922 <cfe_write>:

int cfe_write(int handle,hsaddr_t buffer,int length)
{
20002922:	b580      	push	{r7, lr}
20002924:	b086      	sub	sp, #24
20002926:	af02      	add	r7, sp, #8
20002928:	60f8      	str	r0, [r7, #12]
2000292a:	60b9      	str	r1, [r7, #8]
2000292c:	607a      	str	r2, [r7, #4]
    return cfe_writeblk(handle,0,buffer,length);
2000292e:	687b      	ldr	r3, [r7, #4]
20002930:	9301      	str	r3, [sp, #4]
20002932:	68bb      	ldr	r3, [r7, #8]
20002934:	9300      	str	r3, [sp, #0]
20002936:	f04f 0200 	mov.w	r2, #0
2000293a:	f04f 0300 	mov.w	r3, #0
2000293e:	68f8      	ldr	r0, [r7, #12]
20002940:	f7ff ffc6 	bl	200028d0 <cfe_writeblk>
20002944:	4603      	mov	r3, r0
}
20002946:	4618      	mov	r0, r3
20002948:	3710      	adds	r7, #16
2000294a:	46bd      	mov	sp, r7
2000294c:	bd80      	pop	{r7, pc}

2000294e <cfe_inpstat>:
    if (retlen) *retlen = iocb.plist.iocb_buffer.buf_retlen;
    return iocb.iocb_status;
}

int cfe_inpstat(int handle)
{
2000294e:	b580      	push	{r7, lr}
20002950:	b09c      	sub	sp, #112	@ 0x70
20002952:	af00      	add	r7, sp, #0
20002954:	6078      	str	r0, [r7, #4]
    cfe_iocb_t iocb;

    iocb.iocb_fcode = CFE_CMD_DEV_INPSTAT;
20002956:	230c      	movs	r3, #12
20002958:	60bb      	str	r3, [r7, #8]
    iocb.iocb_status = 0;
2000295a:	2300      	movs	r3, #0
2000295c:	60fb      	str	r3, [r7, #12]
    iocb.iocb_handle = handle;
2000295e:	687b      	ldr	r3, [r7, #4]
20002960:	613b      	str	r3, [r7, #16]
    iocb.iocb_flags = 0;
20002962:	2300      	movs	r3, #0
20002964:	617b      	str	r3, [r7, #20]
    iocb.iocb_psize = sizeof(iocb_inpstat_t);
20002966:	2304      	movs	r3, #4
20002968:	61bb      	str	r3, [r7, #24]
    iocb.plist.iocb_inpstat.inp_status = 0;
2000296a:	2300      	movs	r3, #0
2000296c:	623b      	str	r3, [r7, #32]

    cfe_iocb_dispatch(&iocb);
2000296e:	f107 0308 	add.w	r3, r7, #8
20002972:	4618      	mov	r0, r3
20002974:	f000 f82e 	bl	200029d4 <cfe_iocb_dispatch>

    if (iocb.iocb_status < 0) return iocb.iocb_status;
20002978:	68fb      	ldr	r3, [r7, #12]
2000297a:	2b00      	cmp	r3, #0
2000297c:	da01      	bge.n	20002982 <cfe_inpstat+0x34>
2000297e:	68fb      	ldr	r3, [r7, #12]
20002980:	e000      	b.n	20002984 <cfe_inpstat+0x36>

    return iocb.plist.iocb_inpstat.inp_status;
20002982:	6a3b      	ldr	r3, [r7, #32]

}
20002984:	4618      	mov	r0, r3
20002986:	3770      	adds	r7, #112	@ 0x70
20002988:	46bd      	mov	sp, r7
2000298a:	bd80      	pop	{r7, pc}

2000298c <hsgetstr>:
    *  	   nothing
    ********************************************************************* */


static void hsgetstr(char *dest,hsaddr_t src,int len)
{
2000298c:	b480      	push	{r7}
2000298e:	b087      	sub	sp, #28
20002990:	af00      	add	r7, sp, #0
20002992:	60f8      	str	r0, [r7, #12]
20002994:	60b9      	str	r1, [r7, #8]
20002996:	607a      	str	r2, [r7, #4]
    char b;

    while (len > 0) {
20002998:	e010      	b.n	200029bc <hsgetstr+0x30>
	b = hs_read8(src);
2000299a:	68bb      	ldr	r3, [r7, #8]
2000299c:	781b      	ldrb	r3, [r3, #0]
2000299e:	75fb      	strb	r3, [r7, #23]
	src++;
200029a0:	68bb      	ldr	r3, [r7, #8]
200029a2:	3301      	adds	r3, #1
200029a4:	60bb      	str	r3, [r7, #8]
	*dest++ = b;
200029a6:	68fb      	ldr	r3, [r7, #12]
200029a8:	1c5a      	adds	r2, r3, #1
200029aa:	60fa      	str	r2, [r7, #12]
200029ac:	7dfa      	ldrb	r2, [r7, #23]
200029ae:	701a      	strb	r2, [r3, #0]
	if (b == 0) break;
200029b0:	7dfb      	ldrb	r3, [r7, #23]
200029b2:	2b00      	cmp	r3, #0
200029b4:	d006      	beq.n	200029c4 <hsgetstr+0x38>
	len--;
200029b6:	687b      	ldr	r3, [r7, #4]
200029b8:	3b01      	subs	r3, #1
200029ba:	607b      	str	r3, [r7, #4]
    while (len > 0) {
200029bc:	687b      	ldr	r3, [r7, #4]
200029be:	2b00      	cmp	r3, #0
200029c0:	dceb      	bgt.n	2000299a <hsgetstr+0xe>
	}
}
200029c2:	e000      	b.n	200029c6 <hsgetstr+0x3a>
	if (b == 0) break;
200029c4:	bf00      	nop
}
200029c6:	bf00      	nop
200029c8:	371c      	adds	r7, #28
200029ca:	46bd      	mov	sp, r7
200029cc:	f85d 7b04 	ldr.w	r7, [sp], #4
200029d0:	4770      	bx	lr
	...

200029d4 <cfe_iocb_dispatch>:
	    }
	}
}

int cfe_iocb_dispatch(cfe_iocb_t *iocb)
{
200029d4:	b580      	push	{r7, lr}
200029d6:	b086      	sub	sp, #24
200029d8:	af00      	add	r7, sp, #0
200029da:	6078      	str	r0, [r7, #4]

    /*
     * Check for commands codes out of range
     */

    if ((iocb->iocb_fcode < 0) || (iocb->iocb_fcode >= CFE_CMD_MAX)) {
200029dc:	687b      	ldr	r3, [r7, #4]
200029de:	681b      	ldr	r3, [r3, #0]
200029e0:	2b1f      	cmp	r3, #31
200029e2:	d906      	bls.n	200029f2 <cfe_iocb_dispatch+0x1e>
	iocb->iocb_status = CFE_ERR_INV_COMMAND;
200029e4:	687b      	ldr	r3, [r7, #4]
200029e6:	f06f 0201 	mvn.w	r2, #1
200029ea:	605a      	str	r2, [r3, #4]
	return iocb->iocb_status;
200029ec:	687b      	ldr	r3, [r7, #4]
200029ee:	685b      	ldr	r3, [r3, #4]
200029f0:	e04f      	b.n	20002a92 <cfe_iocb_dispatch+0xbe>

    /*
     * Check for command codes in range but invalid
     */

    disp = &cfe_cmd_dispatch_table[iocb->iocb_fcode];
200029f2:	687b      	ldr	r3, [r7, #4]
200029f4:	681a      	ldr	r2, [r3, #0]
200029f6:	4613      	mov	r3, r2
200029f8:	005b      	lsls	r3, r3, #1
200029fa:	4413      	add	r3, r2
200029fc:	009b      	lsls	r3, r3, #2
200029fe:	4a27      	ldr	r2, [pc, #156]	@ (20002a9c <cfe_iocb_dispatch+0xc8>)
20002a00:	4413      	add	r3, r2
20002a02:	613b      	str	r3, [r7, #16]

    if (disp->plistsize < 0) {
20002a04:	693b      	ldr	r3, [r7, #16]
20002a06:	681b      	ldr	r3, [r3, #0]
20002a08:	2b00      	cmp	r3, #0
20002a0a:	da06      	bge.n	20002a1a <cfe_iocb_dispatch+0x46>
	iocb->iocb_status = CFE_ERR_INV_COMMAND;
20002a0c:	687b      	ldr	r3, [r7, #4]
20002a0e:	f06f 0201 	mvn.w	r2, #1
20002a12:	605a      	str	r2, [r3, #4]
	return iocb->iocb_status;
20002a14:	687b      	ldr	r3, [r7, #4]
20002a16:	685b      	ldr	r3, [r3, #4]
20002a18:	e03b      	b.n	20002a92 <cfe_iocb_dispatch+0xbe>

    /*
     * Check for invalid parameter list size
     */

    if (disp->plistsize != iocb->iocb_psize) {
20002a1a:	693b      	ldr	r3, [r7, #16]
20002a1c:	681b      	ldr	r3, [r3, #0]
20002a1e:	461a      	mov	r2, r3
20002a20:	687b      	ldr	r3, [r7, #4]
20002a22:	691b      	ldr	r3, [r3, #16]
20002a24:	429a      	cmp	r2, r3
20002a26:	d006      	beq.n	20002a36 <cfe_iocb_dispatch+0x62>
	iocb->iocb_status = CFE_ERR_INV_PARAM;
20002a28:	687b      	ldr	r3, [r7, #4]
20002a2a:	f06f 0207 	mvn.w	r2, #7
20002a2e:	605a      	str	r2, [r3, #4]
	return iocb->iocb_status;
20002a30:	687b      	ldr	r3, [r7, #4]
20002a32:	685b      	ldr	r3, [r3, #4]
20002a34:	e02d      	b.n	20002a92 <cfe_iocb_dispatch+0xbe>

    /*
     * Determine handle
     */
    
    ctx = NULL;
20002a36:	2300      	movs	r3, #0
20002a38:	617b      	str	r3, [r7, #20]
    if (disp->flags & HV) {
20002a3a:	693b      	ldr	r3, [r7, #16]
20002a3c:	685b      	ldr	r3, [r3, #4]
20002a3e:	f003 0301 	and.w	r3, r3, #1
20002a42:	2b00      	cmp	r3, #0
20002a44:	d01b      	beq.n	20002a7e <cfe_iocb_dispatch+0xaa>
	if ((iocb->iocb_handle >= CFE_MAX_HANDLE) || 
20002a46:	687b      	ldr	r3, [r7, #4]
20002a48:	689b      	ldr	r3, [r3, #8]
20002a4a:	2b3f      	cmp	r3, #63	@ 0x3f
20002a4c:	dc0a      	bgt.n	20002a64 <cfe_iocb_dispatch+0x90>
	    (iocb->iocb_handle < 0) ||
20002a4e:	687b      	ldr	r3, [r7, #4]
20002a50:	689b      	ldr	r3, [r3, #8]
	if ((iocb->iocb_handle >= CFE_MAX_HANDLE) || 
20002a52:	2b00      	cmp	r3, #0
20002a54:	db06      	blt.n	20002a64 <cfe_iocb_dispatch+0x90>
	    (cfe_handle_table[iocb->iocb_handle] == NULL)){
20002a56:	687b      	ldr	r3, [r7, #4]
20002a58:	689b      	ldr	r3, [r3, #8]
20002a5a:	4a11      	ldr	r2, [pc, #68]	@ (20002aa0 <cfe_iocb_dispatch+0xcc>)
20002a5c:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
	    (iocb->iocb_handle < 0) ||
20002a60:	2b00      	cmp	r3, #0
20002a62:	d106      	bne.n	20002a72 <cfe_iocb_dispatch+0x9e>
	    iocb->iocb_status = CFE_ERR_INV_PARAM;
20002a64:	687b      	ldr	r3, [r7, #4]
20002a66:	f06f 0207 	mvn.w	r2, #7
20002a6a:	605a      	str	r2, [r3, #4]
	    return iocb->iocb_status;
20002a6c:	687b      	ldr	r3, [r7, #4]
20002a6e:	685b      	ldr	r3, [r3, #4]
20002a70:	e00f      	b.n	20002a92 <cfe_iocb_dispatch+0xbe>
	    }
	ctx = cfe_handle_table[iocb->iocb_handle];
20002a72:	687b      	ldr	r3, [r7, #4]
20002a74:	689b      	ldr	r3, [r3, #8]
20002a76:	4a0a      	ldr	r2, [pc, #40]	@ (20002aa0 <cfe_iocb_dispatch+0xcc>)
20002a78:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
20002a7c:	617b      	str	r3, [r7, #20]

    /*
     * Dispatch to handler routine
     */

    res = (*disp->func)(ctx,iocb);
20002a7e:	693b      	ldr	r3, [r7, #16]
20002a80:	689b      	ldr	r3, [r3, #8]
20002a82:	6879      	ldr	r1, [r7, #4]
20002a84:	6978      	ldr	r0, [r7, #20]
20002a86:	4798      	blx	r3
20002a88:	60f8      	str	r0, [r7, #12]

    iocb->iocb_status = res;
20002a8a:	687b      	ldr	r3, [r7, #4]
20002a8c:	68fa      	ldr	r2, [r7, #12]
20002a8e:	605a      	str	r2, [r3, #4]
    return res;
20002a90:	68fb      	ldr	r3, [r7, #12]
}
20002a92:	4618      	mov	r0, r3
20002a94:	3718      	adds	r7, #24
20002a96:	46bd      	mov	sp, r7
20002a98:	bd80      	pop	{r7, pc}
20002a9a:	bf00      	nop
20002a9c:	200048e4 	.word	0x200048e4
20002aa0:	20004bd4 	.word	0x20004bd4

20002aa4 <cfe_newhandle>:

static int cfe_newhandle(void)
{
20002aa4:	b480      	push	{r7}
20002aa6:	b083      	sub	sp, #12
20002aa8:	af00      	add	r7, sp, #0
    int idx;

    for (idx = 0; idx < CFE_MAX_HANDLE; idx++) {
20002aaa:	2300      	movs	r3, #0
20002aac:	607b      	str	r3, [r7, #4]
20002aae:	e008      	b.n	20002ac2 <cfe_newhandle+0x1e>
	if (cfe_handle_table[idx] == NULL) break;
20002ab0:	4a0d      	ldr	r2, [pc, #52]	@ (20002ae8 <cfe_newhandle+0x44>)
20002ab2:	687b      	ldr	r3, [r7, #4]
20002ab4:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
20002ab8:	2b00      	cmp	r3, #0
20002aba:	d006      	beq.n	20002aca <cfe_newhandle+0x26>
    for (idx = 0; idx < CFE_MAX_HANDLE; idx++) {
20002abc:	687b      	ldr	r3, [r7, #4]
20002abe:	3301      	adds	r3, #1
20002ac0:	607b      	str	r3, [r7, #4]
20002ac2:	687b      	ldr	r3, [r7, #4]
20002ac4:	2b3f      	cmp	r3, #63	@ 0x3f
20002ac6:	ddf3      	ble.n	20002ab0 <cfe_newhandle+0xc>
20002ac8:	e000      	b.n	20002acc <cfe_newhandle+0x28>
	if (cfe_handle_table[idx] == NULL) break;
20002aca:	bf00      	nop
	}

    if (idx == CFE_MAX_HANDLE) return -1;
20002acc:	687b      	ldr	r3, [r7, #4]
20002ace:	2b40      	cmp	r3, #64	@ 0x40
20002ad0:	d102      	bne.n	20002ad8 <cfe_newhandle+0x34>
20002ad2:	f04f 33ff 	mov.w	r3, #4294967295	@ 0xffffffff
20002ad6:	e000      	b.n	20002ada <cfe_newhandle+0x36>

    return idx;
20002ad8:	687b      	ldr	r3, [r7, #4]
}
20002ada:	4618      	mov	r0, r3
20002adc:	370c      	adds	r7, #12
20002ade:	46bd      	mov	sp, r7
20002ae0:	f85d 7b04 	ldr.w	r7, [sp], #4
20002ae4:	4770      	bx	lr
20002ae6:	bf00      	nop
20002ae8:	20004bd4 	.word	0x20004bd4

20002aec <cfe_cmd_fw_getinfo>:
/*  *********************************************************************
    *  Implementation routines for each IOCB function
    ********************************************************************* */

static int cfe_cmd_fw_getinfo(cfe_devctx_t *ctx,cfe_iocb_t *iocb)
{
20002aec:	e92d 03b0 	stmdb	sp!, {r4, r5, r7, r8, r9}
20002af0:	b085      	sub	sp, #20
20002af2:	af00      	add	r7, sp, #0
20002af4:	6078      	str	r0, [r7, #4]
20002af6:	6039      	str	r1, [r7, #0]
    iocb_fwinfo_t *info = &iocb->plist.iocb_fwinfo;
20002af8:	683b      	ldr	r3, [r7, #0]
20002afa:	3318      	adds	r3, #24
20002afc:	60fb      	str	r3, [r7, #12]

    info->fwi_version = (CFE_VER_MAJOR << 16) |
20002afe:	68f9      	ldr	r1, [r7, #12]
20002b00:	f44f 7281 	mov.w	r2, #258	@ 0x102
20002b04:	f04f 0300 	mov.w	r3, #0
20002b08:	e9c1 2300 	strd	r2, r3, [r1]
	(CFE_VER_MINOR << 8) |
	(CFE_VER_BUILD);
    //info->fwi_totalmem = ((cfe_int64_t) mem_totalsize) << 20;
    info->fwi_flags = 
20002b0c:	68f9      	ldr	r1, [r7, #12]
20002b0e:	f04f 020a 	mov.w	r2, #10
20002b12:	f04f 0300 	mov.w	r3, #0
20002b16:	e9c1 2304 	strd	r2, r3, [r1, #16]
#ifdef _FUNCSIM_
	CFE_FWI_FUNCSIM |
#endif
	0;

    info->fwi_boardid = CFG_BOARD_ID;
20002b1a:	68f9      	ldr	r1, [r7, #12]
20002b1c:	f04f 0200 	mov.w	r2, #0
20002b20:	f04f 0300 	mov.w	r3, #0
20002b24:	e9c1 2306 	strd	r2, r3, [r1, #24]
    info->fwi_bootarea_pa = (cfe_int64_t) mem_bootarea_start;
20002b28:	4b19      	ldr	r3, [pc, #100]	@ (20002b90 <cfe_cmd_fw_getinfo+0xa4>)
20002b2a:	681b      	ldr	r3, [r3, #0]
20002b2c:	2200      	movs	r2, #0
20002b2e:	4698      	mov	r8, r3
20002b30:	4691      	mov	r9, r2
20002b32:	68fb      	ldr	r3, [r7, #12]
20002b34:	e9c3 890a 	strd	r8, r9, [r3, #40]	@ 0x28
    info->fwi_bootarea_va = BOOT_START_ADDRESS;
20002b38:	68f9      	ldr	r1, [r7, #12]
20002b3a:	f04f 5200 	mov.w	r2, #536870912	@ 0x20000000
20002b3e:	f04f 0300 	mov.w	r3, #0
20002b42:	e9c1 2308 	strd	r2, r3, [r1, #32]
    info->fwi_bootarea_size = (cfe_int64_t) mem_bootarea_size;
20002b46:	4b13      	ldr	r3, [pc, #76]	@ (20002b94 <cfe_cmd_fw_getinfo+0xa8>)
20002b48:	681b      	ldr	r3, [r3, #0]
20002b4a:	2200      	movs	r2, #0
20002b4c:	461c      	mov	r4, r3
20002b4e:	4615      	mov	r5, r2
20002b50:	68fb      	ldr	r3, [r7, #12]
20002b52:	e9c3 450c 	strd	r4, r5, [r3, #48]	@ 0x30
    info->fwi_reserved1 = 0;
20002b56:	68f9      	ldr	r1, [r7, #12]
20002b58:	f04f 0200 	mov.w	r2, #0
20002b5c:	f04f 0300 	mov.w	r3, #0
20002b60:	e9c1 230e 	strd	r2, r3, [r1, #56]	@ 0x38
    info->fwi_reserved2 = 0;
20002b64:	68f9      	ldr	r1, [r7, #12]
20002b66:	f04f 0200 	mov.w	r2, #0
20002b6a:	f04f 0300 	mov.w	r3, #0
20002b6e:	e9c1 2310 	strd	r2, r3, [r1, #64]	@ 0x40
    info->fwi_reserved3 = 0;
20002b72:	68f9      	ldr	r1, [r7, #12]
20002b74:	f04f 0200 	mov.w	r2, #0
20002b78:	f04f 0300 	mov.w	r3, #0
20002b7c:	e9c1 2312 	strd	r2, r3, [r1, #72]	@ 0x48

    return CFE_OK;
20002b80:	2300      	movs	r3, #0
}
20002b82:	4618      	mov	r0, r3
20002b84:	3714      	adds	r7, #20
20002b86:	46bd      	mov	sp, r7
20002b88:	e8bd 03b0 	ldmia.w	sp!, {r4, r5, r7, r8, r9}
20002b8c:	4770      	bx	lr
20002b8e:	bf00      	nop
20002b90:	20004cf0 	.word	0x20004cf0
20002b94:	20004cf4 	.word	0x20004cf4

20002b98 <cfe_cmd_fw_restart>:

static int cfe_cmd_fw_restart(cfe_devctx_t *ctx,cfe_iocb_t *iocb)
{
20002b98:	b480      	push	{r7}
20002b9a:	b083      	sub	sp, #12
20002b9c:	af00      	add	r7, sp, #0
20002b9e:	6078      	str	r0, [r7, #4]
20002ba0:	6039      	str	r1, [r7, #0]

    return CFE_OK;
20002ba2:	2300      	movs	r3, #0
}
20002ba4:	4618      	mov	r0, r3
20002ba6:	370c      	adds	r7, #12
20002ba8:	46bd      	mov	sp, r7
20002baa:	f85d 7b04 	ldr.w	r7, [sp], #4
20002bae:	4770      	bx	lr

20002bb0 <cfe_cmd_fw_boot>:

static int cfe_cmd_fw_boot(cfe_devctx_t *ctx,cfe_iocb_t *iocb)
{
20002bb0:	b480      	push	{r7}
20002bb2:	b083      	sub	sp, #12
20002bb4:	af00      	add	r7, sp, #0
20002bb6:	6078      	str	r0, [r7, #4]
20002bb8:	6039      	str	r1, [r7, #0]
    return CFE_ERR_INV_COMMAND;		/* not implemented yet */
20002bba:	f06f 0301 	mvn.w	r3, #1
}
20002bbe:	4618      	mov	r0, r3
20002bc0:	370c      	adds	r7, #12
20002bc2:	46bd      	mov	sp, r7
20002bc4:	f85d 7b04 	ldr.w	r7, [sp], #4
20002bc8:	4770      	bx	lr

20002bca <cfe_cmd_fw_cpuctl>:

static int cfe_cmd_fw_cpuctl(cfe_devctx_t *ctx,cfe_iocb_t *iocb)
{
20002bca:	b480      	push	{r7}
20002bcc:	b083      	sub	sp, #12
20002bce:	af00      	add	r7, sp, #0
20002bd0:	6078      	str	r0, [r7, #4]
20002bd2:	6039      	str	r1, [r7, #0]
	    res = CFE_ERR_INV_PARAM;
	}

    return res;
#else
    return CFE_ERR_INV_COMMAND;
20002bd4:	f06f 0301 	mvn.w	r3, #1
#endif
}
20002bd8:	4618      	mov	r0, r3
20002bda:	370c      	adds	r7, #12
20002bdc:	46bd      	mov	sp, r7
20002bde:	f85d 7b04 	ldr.w	r7, [sp], #4
20002be2:	4770      	bx	lr

20002be4 <cfe_cmd_fw_gettime>:

static int cfe_cmd_fw_gettime(cfe_devctx_t *ctx,cfe_iocb_t *iocb)
{
20002be4:	b580      	push	{r7, lr}
20002be6:	b082      	sub	sp, #8
20002be8:	af00      	add	r7, sp, #0
20002bea:	6078      	str	r0, [r7, #4]
20002bec:	6039      	str	r1, [r7, #0]
    POLL();
20002bee:	f7fe fd6f 	bl	200016d0 <background>

    iocb->plist.iocb_time.ticks = cfe_ticks;
20002bf2:	4b05      	ldr	r3, [pc, #20]	@ (20002c08 <cfe_cmd_fw_gettime+0x24>)
20002bf4:	e9d3 2300 	ldrd	r2, r3, [r3]
20002bf8:	6839      	ldr	r1, [r7, #0]
20002bfa:	e9c1 2306 	strd	r2, r3, [r1, #24]

    return CFE_OK;
20002bfe:	2300      	movs	r3, #0
}
20002c00:	4618      	mov	r0, r3
20002c02:	3708      	adds	r7, #8
20002c04:	46bd      	mov	sp, r7
20002c06:	bd80      	pop	{r7, pc}
20002c08:	20004cf8 	.word	0x20004cf8

20002c0c <cfe_cmd_fw_memenum>:

static int cfe_cmd_fw_memenum(cfe_devctx_t *ctx,cfe_iocb_t *iocb)
{
20002c0c:	b590      	push	{r4, r7, lr}
20002c0e:	b08b      	sub	sp, #44	@ 0x2c
20002c10:	af02      	add	r7, sp, #8
20002c12:	6078      	str	r0, [r7, #4]
20002c14:	6039      	str	r1, [r7, #0]
    int type;
    int res;
    uint64_t addr,size;

    res = cfe_arena_enum(iocb->plist.iocb_meminfo.mi_idx,
20002c16:	683b      	ldr	r3, [r7, #0]
20002c18:	6998      	ldr	r0, [r3, #24]
			 &type,
			 &addr,
			 &size,
			 (iocb->iocb_flags & CFE_FLG_FULL_ARENA) ? TRUE : FALSE);
20002c1a:	683b      	ldr	r3, [r7, #0]
20002c1c:	68db      	ldr	r3, [r3, #12]
    res = cfe_arena_enum(iocb->plist.iocb_meminfo.mi_idx,
20002c1e:	f003 0301 	and.w	r3, r3, #1
20002c22:	f107 0408 	add.w	r4, r7, #8
20002c26:	f107 0210 	add.w	r2, r7, #16
20002c2a:	f107 0118 	add.w	r1, r7, #24
20002c2e:	9300      	str	r3, [sp, #0]
20002c30:	4623      	mov	r3, r4
20002c32:	f000 fb23 	bl	2000327c <cfe_arena_enum>
20002c36:	61f8      	str	r0, [r7, #28]

    iocb->plist.iocb_meminfo.mi_addr = addr;
20002c38:	e9d7 2304 	ldrd	r2, r3, [r7, #16]
20002c3c:	6839      	ldr	r1, [r7, #0]
20002c3e:	e9c1 2308 	strd	r2, r3, [r1, #32]
    iocb->plist.iocb_meminfo.mi_size = size;
20002c42:	e9d7 2302 	ldrd	r2, r3, [r7, #8]
20002c46:	6839      	ldr	r1, [r7, #0]
20002c48:	e9c1 230a 	strd	r2, r3, [r1, #40]	@ 0x28
    iocb->plist.iocb_meminfo.mi_type = type;
20002c4c:	69ba      	ldr	r2, [r7, #24]
20002c4e:	683b      	ldr	r3, [r7, #0]
20002c50:	61da      	str	r2, [r3, #28]

    if (res == 0) {
20002c52:	69fb      	ldr	r3, [r7, #28]
20002c54:	2b00      	cmp	r3, #0
20002c56:	d109      	bne.n	20002c6c <cfe_cmd_fw_memenum+0x60>
	if (type == MEMTYPE_DRAM_AVAILABLE) {
20002c58:	69bb      	ldr	r3, [r7, #24]
20002c5a:	2b01      	cmp	r3, #1
20002c5c:	d103      	bne.n	20002c66 <cfe_cmd_fw_memenum+0x5a>
	    iocb->plist.iocb_meminfo.mi_type = CFE_MI_AVAILABLE;
20002c5e:	683b      	ldr	r3, [r7, #0]
20002c60:	2201      	movs	r2, #1
20002c62:	61da      	str	r2, [r3, #28]
20002c64:	e002      	b.n	20002c6c <cfe_cmd_fw_memenum+0x60>
	    }
	else {
	    iocb->plist.iocb_meminfo.mi_type = CFE_MI_RESERVED;
20002c66:	683b      	ldr	r3, [r7, #0]
20002c68:	2200      	movs	r2, #0
20002c6a:	61da      	str	r2, [r3, #28]
	    }
	}

    return res;
20002c6c:	69fb      	ldr	r3, [r7, #28]
}
20002c6e:	4618      	mov	r0, r3
20002c70:	3724      	adds	r7, #36	@ 0x24
20002c72:	46bd      	mov	sp, r7
20002c74:	bd90      	pop	{r4, r7, pc}

20002c76 <cfe_cmd_fw_flushcache>:

static int cfe_cmd_fw_flushcache(cfe_devctx_t *ctx,cfe_iocb_t *iocb)
{
20002c76:	b480      	push	{r7}
20002c78:	b083      	sub	sp, #12
20002c7a:	af00      	add	r7, sp, #0
20002c7c:	6078      	str	r0, [r7, #4]
20002c7e:	6039      	str	r1, [r7, #0]
  //  _cfe_flushcache(iocb->iocb_flags);
    return CFE_OK;
20002c80:	2300      	movs	r3, #0
}
20002c82:	4618      	mov	r0, r3
20002c84:	370c      	adds	r7, #12
20002c86:	46bd      	mov	sp, r7
20002c88:	f85d 7b04 	ldr.w	r7, [sp], #4
20002c8c:	4770      	bx	lr

20002c8e <cfe_cmd_dev_enum>:

static int cfe_cmd_dev_enum(cfe_devctx_t *ctx,cfe_iocb_t *iocb)
{
20002c8e:	b580      	push	{r7, lr}
20002c90:	b084      	sub	sp, #16
20002c92:	af00      	add	r7, sp, #0
20002c94:	6078      	str	r0, [r7, #4]
20002c96:	6039      	str	r1, [r7, #0]
    int namelen,res;

    namelen = iocb->plist.iocb_envbuf.name_length;
20002c98:	683b      	ldr	r3, [r7, #0]
20002c9a:	6a1b      	ldr	r3, [r3, #32]
20002c9c:	60bb      	str	r3, [r7, #8]

    res = cfe_dev_enum(iocb->plist.iocb_envbuf.enum_idx,
20002c9e:	683b      	ldr	r3, [r7, #0]
20002ca0:	6998      	ldr	r0, [r3, #24]
		   (char *)iocb->plist.iocb_envbuf.name_ptr,
20002ca2:	683b      	ldr	r3, [r7, #0]
20002ca4:	69db      	ldr	r3, [r3, #28]
    res = cfe_dev_enum(iocb->plist.iocb_envbuf.enum_idx,
20002ca6:	f107 0208 	add.w	r2, r7, #8
20002caa:	4619      	mov	r1, r3
20002cac:	f7fe fc0a 	bl	200014c4 <cfe_dev_enum>
20002cb0:	60f8      	str	r0, [r7, #12]
		   &namelen);

    if (res < 0) return CFE_ERR_DEVNOTFOUND;
20002cb2:	68fb      	ldr	r3, [r7, #12]
20002cb4:	2b00      	cmp	r3, #0
20002cb6:	da02      	bge.n	20002cbe <cfe_cmd_dev_enum+0x30>
20002cb8:	f06f 0305 	mvn.w	r3, #5
20002cbc:	e003      	b.n	20002cc6 <cfe_cmd_dev_enum+0x38>

	iocb->plist.iocb_envbuf.name_length = namelen;
20002cbe:	68ba      	ldr	r2, [r7, #8]
20002cc0:	683b      	ldr	r3, [r7, #0]
20002cc2:	621a      	str	r2, [r3, #32]

    return CFE_OK;
20002cc4:	2300      	movs	r3, #0
}
20002cc6:	4618      	mov	r0, r3
20002cc8:	3710      	adds	r7, #16
20002cca:	46bd      	mov	sp, r7
20002ccc:	bd80      	pop	{r7, pc}
	...

20002cd0 <cfe_cmd_dev_gethandle>:

static int cfe_cmd_dev_gethandle(cfe_devctx_t *ctx,cfe_iocb_t *iocb)
{
20002cd0:	b480      	push	{r7}
20002cd2:	b083      	sub	sp, #12
20002cd4:	af00      	add	r7, sp, #0
20002cd6:	6078      	str	r0, [r7, #4]
20002cd8:	6039      	str	r1, [r7, #0]
    switch (iocb->iocb_flags) {
20002cda:	683b      	ldr	r3, [r7, #0]
20002cdc:	68db      	ldr	r3, [r3, #12]
20002cde:	2b00      	cmp	r3, #0
20002ce0:	d10d      	bne.n	20002cfe <cfe_cmd_dev_gethandle+0x2e>
	case CFE_STDHANDLE_CONSOLE:
	    if (console_handle == -1) return CFE_ERR_DEVNOTFOUND;
20002ce2:	4b0b      	ldr	r3, [pc, #44]	@ (20002d10 <cfe_cmd_dev_gethandle+0x40>)
20002ce4:	681b      	ldr	r3, [r3, #0]
20002ce6:	f1b3 3fff 	cmp.w	r3, #4294967295	@ 0xffffffff
20002cea:	d102      	bne.n	20002cf2 <cfe_cmd_dev_gethandle+0x22>
20002cec:	f06f 0305 	mvn.w	r3, #5
20002cf0:	e007      	b.n	20002d02 <cfe_cmd_dev_gethandle+0x32>
	    iocb->iocb_handle = console_handle;
20002cf2:	4b07      	ldr	r3, [pc, #28]	@ (20002d10 <cfe_cmd_dev_gethandle+0x40>)
20002cf4:	681a      	ldr	r2, [r3, #0]
20002cf6:	683b      	ldr	r3, [r7, #0]
20002cf8:	609a      	str	r2, [r3, #8]
	    return CFE_OK;
20002cfa:	2300      	movs	r3, #0
20002cfc:	e001      	b.n	20002d02 <cfe_cmd_dev_gethandle+0x32>
	    break;
	default:
	    return CFE_ERR_INV_PARAM;
20002cfe:	f06f 0307 	mvn.w	r3, #7
	}
}
20002d02:	4618      	mov	r0, r3
20002d04:	370c      	adds	r7, #12
20002d06:	46bd      	mov	sp, r7
20002d08:	f85d 7b04 	ldr.w	r7, [sp], #4
20002d0c:	4770      	bx	lr
20002d0e:	bf00      	nop
20002d10:	20004a90 	.word	0x20004a90

20002d14 <cfe_cmd_dev_open>:

static int cfe_cmd_dev_open(cfe_devctx_t *ctx,cfe_iocb_t *iocb)
{
20002d14:	b580      	push	{r7, lr}
20002d16:	b096      	sub	sp, #88	@ 0x58
20002d18:	af00      	add	r7, sp, #0
20002d1a:	6078      	str	r0, [r7, #4]
20002d1c:	6039      	str	r1, [r7, #0]

    /*
     * Get device name
     */

    hsgetstr(devname,iocb->plist.iocb_buffer.buf_ptr,sizeof(devname));
20002d1e:	683b      	ldr	r3, [r7, #0]
20002d20:	6a19      	ldr	r1, [r3, #32]
20002d22:	f107 030c 	add.w	r3, r7, #12
20002d26:	2240      	movs	r2, #64	@ 0x40
20002d28:	4618      	mov	r0, r3
20002d2a:	f7ff fe2f 	bl	2000298c <hsgetstr>

    /*
     * Find device in device table
     */

    dev = cfe_finddev(devname);
20002d2e:	f107 030c 	add.w	r3, r7, #12
20002d32:	4618      	mov	r0, r3
20002d34:	f7fe fba2 	bl	2000147c <cfe_finddev>
20002d38:	6578      	str	r0, [r7, #84]	@ 0x54
    if (!dev) return CFE_ERR_DEVNOTFOUND;
20002d3a:	6d7b      	ldr	r3, [r7, #84]	@ 0x54
20002d3c:	2b00      	cmp	r3, #0
20002d3e:	d102      	bne.n	20002d46 <cfe_cmd_dev_open+0x32>
20002d40:	f06f 0305 	mvn.w	r3, #5
20002d44:	e047      	b.n	20002dd6 <cfe_cmd_dev_open+0xc2>

    /*
     * Fail if someone else already has the device open
     */

    if (dev->dev_opencount > 0) return CFE_ERR_DEVOPEN;
20002d46:	6d7b      	ldr	r3, [r7, #84]	@ 0x54
20002d48:	699b      	ldr	r3, [r3, #24]
20002d4a:	2b00      	cmp	r3, #0
20002d4c:	dd02      	ble.n	20002d54 <cfe_cmd_dev_open+0x40>
20002d4e:	f06f 0306 	mvn.w	r3, #6
20002d52:	e040      	b.n	20002dd6 <cfe_cmd_dev_open+0xc2>

    /*
     * Generate a new handle
     */

    h = cfe_newhandle();
20002d54:	f7ff fea6 	bl	20002aa4 <cfe_newhandle>
20002d58:	6538      	str	r0, [r7, #80]	@ 0x50
    if (h < 0) return CFE_ERR_NOMEM;
20002d5a:	6d3b      	ldr	r3, [r7, #80]	@ 0x50
20002d5c:	2b00      	cmp	r3, #0
20002d5e:	da02      	bge.n	20002d66 <cfe_cmd_dev_open+0x52>
20002d60:	f06f 0304 	mvn.w	r3, #4
20002d64:	e037      	b.n	20002dd6 <cfe_cmd_dev_open+0xc2>

    /*
     * Allocate a context
     */

    ctx = (cfe_devctx_t *) KMALLOC(sizeof(cfe_devctx_t),0);
20002d66:	2200      	movs	r2, #0
20002d68:	210c      	movs	r1, #12
20002d6a:	481d      	ldr	r0, [pc, #116]	@ (20002de0 <cfe_cmd_dev_open+0xcc>)
20002d6c:	f7fe f922 	bl	20000fb4 <kmalloc>
20002d70:	6078      	str	r0, [r7, #4]
    if (ctx == NULL) return CFE_ERR_NOMEM;
20002d72:	687b      	ldr	r3, [r7, #4]
20002d74:	2b00      	cmp	r3, #0
20002d76:	d102      	bne.n	20002d7e <cfe_cmd_dev_open+0x6a>
20002d78:	f06f 0304 	mvn.w	r3, #4
20002d7c:	e02b      	b.n	20002dd6 <cfe_cmd_dev_open+0xc2>

    /*
     * Fill in the context
     */

    ctx->dev_dev = dev;
20002d7e:	687b      	ldr	r3, [r7, #4]
20002d80:	6d7a      	ldr	r2, [r7, #84]	@ 0x54
20002d82:	601a      	str	r2, [r3, #0]
    ctx->dev_softc = dev->dev_softc;
20002d84:	6d7b      	ldr	r3, [r7, #84]	@ 0x54
20002d86:	68da      	ldr	r2, [r3, #12]
20002d88:	687b      	ldr	r3, [r7, #4]
20002d8a:	605a      	str	r2, [r3, #4]
    ctx->dev_openinfo = NULL;
20002d8c:	687b      	ldr	r3, [r7, #4]
20002d8e:	2200      	movs	r2, #0
20002d90:	609a      	str	r2, [r3, #8]
    /*
     * Call driver's open func.  First claim the device number in case
     * the open routine itself calls cfe_newhandle().
     */

    cfe_handle_table[h] = ctx;
20002d92:	4914      	ldr	r1, [pc, #80]	@ (20002de4 <cfe_cmd_dev_open+0xd0>)
20002d94:	6d3b      	ldr	r3, [r7, #80]	@ 0x50
20002d96:	687a      	ldr	r2, [r7, #4]
20002d98:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
    res = dev->dev_dispatch->dev_open(ctx);
20002d9c:	6d7b      	ldr	r3, [r7, #84]	@ 0x54
20002d9e:	695b      	ldr	r3, [r3, #20]
20002da0:	681b      	ldr	r3, [r3, #0]
20002da2:	6878      	ldr	r0, [r7, #4]
20002da4:	4798      	blx	r3
20002da6:	64f8      	str	r0, [r7, #76]	@ 0x4c

    if (res != 0) {
20002da8:	6cfb      	ldr	r3, [r7, #76]	@ 0x4c
20002daa:	2b00      	cmp	r3, #0
20002dac:	d00a      	beq.n	20002dc4 <cfe_cmd_dev_open+0xb0>
	cfe_handle_table[h] = NULL;
20002dae:	4a0d      	ldr	r2, [pc, #52]	@ (20002de4 <cfe_cmd_dev_open+0xd0>)
20002db0:	6d3b      	ldr	r3, [r7, #80]	@ 0x50
20002db2:	2100      	movs	r1, #0
20002db4:	f842 1023 	str.w	r1, [r2, r3, lsl #2]
	KFREE(ctx);
20002db8:	6879      	ldr	r1, [r7, #4]
20002dba:	4809      	ldr	r0, [pc, #36]	@ (20002de0 <cfe_cmd_dev_open+0xcc>)
20002dbc:	f7fe f8c6 	bl	20000f4c <kfree>
	return res;
20002dc0:	6cfb      	ldr	r3, [r7, #76]	@ 0x4c
20002dc2:	e008      	b.n	20002dd6 <cfe_cmd_dev_open+0xc2>

    /*
     * Increment refcnt
     */

    dev->dev_opencount++;
20002dc4:	6d7b      	ldr	r3, [r7, #84]	@ 0x54
20002dc6:	699b      	ldr	r3, [r3, #24]
20002dc8:	1c5a      	adds	r2, r3, #1
20002dca:	6d7b      	ldr	r3, [r7, #84]	@ 0x54
20002dcc:	619a      	str	r2, [r3, #24]
    iocb->iocb_handle = h;
20002dce:	683b      	ldr	r3, [r7, #0]
20002dd0:	6d3a      	ldr	r2, [r7, #80]	@ 0x50
20002dd2:	609a      	str	r2, [r3, #8]

    /*
     * Success!
     */

    return CFE_OK;
20002dd4:	2300      	movs	r3, #0
}
20002dd6:	4618      	mov	r0, r3
20002dd8:	3758      	adds	r7, #88	@ 0x58
20002dda:	46bd      	mov	sp, r7
20002ddc:	bd80      	pop	{r7, pc}
20002dde:	bf00      	nop
20002de0:	20004ab4 	.word	0x20004ab4
20002de4:	20004bd4 	.word	0x20004bd4

20002de8 <cfe_cmd_dev_inpstat>:

static int cfe_cmd_dev_inpstat(cfe_devctx_t *ctx,cfe_iocb_t *iocb)
{
20002de8:	b580      	push	{r7, lr}
20002dea:	b084      	sub	sp, #16
20002dec:	af00      	add	r7, sp, #0
20002dee:	6078      	str	r0, [r7, #4]
20002df0:	6039      	str	r1, [r7, #0]
    int status;

    status = ctx->dev_dev->dev_dispatch->dev_inpstat(ctx,&(iocb->plist.iocb_inpstat));
20002df2:	687b      	ldr	r3, [r7, #4]
20002df4:	681b      	ldr	r3, [r3, #0]
20002df6:	695b      	ldr	r3, [r3, #20]
20002df8:	689b      	ldr	r3, [r3, #8]
20002dfa:	683a      	ldr	r2, [r7, #0]
20002dfc:	3218      	adds	r2, #24
20002dfe:	4611      	mov	r1, r2
20002e00:	6878      	ldr	r0, [r7, #4]
20002e02:	4798      	blx	r3
20002e04:	60f8      	str	r0, [r7, #12]

    return status;
20002e06:	68fb      	ldr	r3, [r7, #12]
}
20002e08:	4618      	mov	r0, r3
20002e0a:	3710      	adds	r7, #16
20002e0c:	46bd      	mov	sp, r7
20002e0e:	bd80      	pop	{r7, pc}

20002e10 <cfe_cmd_dev_read>:

static int cfe_cmd_dev_read(cfe_devctx_t *ctx,cfe_iocb_t *iocb)
{
20002e10:	b580      	push	{r7, lr}
20002e12:	b084      	sub	sp, #16
20002e14:	af00      	add	r7, sp, #0
20002e16:	6078      	str	r0, [r7, #4]
20002e18:	6039      	str	r1, [r7, #0]
    int status;

    status = ctx->dev_dev->dev_dispatch->dev_read(ctx,&(iocb->plist.iocb_buffer));
20002e1a:	687b      	ldr	r3, [r7, #4]
20002e1c:	681b      	ldr	r3, [r3, #0]
20002e1e:	695b      	ldr	r3, [r3, #20]
20002e20:	685b      	ldr	r3, [r3, #4]
20002e22:	683a      	ldr	r2, [r7, #0]
20002e24:	3218      	adds	r2, #24
20002e26:	4611      	mov	r1, r2
20002e28:	6878      	ldr	r0, [r7, #4]
20002e2a:	4798      	blx	r3
20002e2c:	60f8      	str	r0, [r7, #12]

    return status;
20002e2e:	68fb      	ldr	r3, [r7, #12]
}
20002e30:	4618      	mov	r0, r3
20002e32:	3710      	adds	r7, #16
20002e34:	46bd      	mov	sp, r7
20002e36:	bd80      	pop	{r7, pc}

20002e38 <cfe_cmd_dev_write>:

static int cfe_cmd_dev_write(cfe_devctx_t *ctx,cfe_iocb_t *iocb)
{
20002e38:	b580      	push	{r7, lr}
20002e3a:	b084      	sub	sp, #16
20002e3c:	af00      	add	r7, sp, #0
20002e3e:	6078      	str	r0, [r7, #4]
20002e40:	6039      	str	r1, [r7, #0]
    int status;

    status = ctx->dev_dev->dev_dispatch->dev_write(ctx,&(iocb->plist.iocb_buffer));
20002e42:	687b      	ldr	r3, [r7, #4]
20002e44:	681b      	ldr	r3, [r3, #0]
20002e46:	695b      	ldr	r3, [r3, #20]
20002e48:	68db      	ldr	r3, [r3, #12]
20002e4a:	683a      	ldr	r2, [r7, #0]
20002e4c:	3218      	adds	r2, #24
20002e4e:	4611      	mov	r1, r2
20002e50:	6878      	ldr	r0, [r7, #4]
20002e52:	4798      	blx	r3
20002e54:	60f8      	str	r0, [r7, #12]

    return status;
20002e56:	68fb      	ldr	r3, [r7, #12]
}
20002e58:	4618      	mov	r0, r3
20002e5a:	3710      	adds	r7, #16
20002e5c:	46bd      	mov	sp, r7
20002e5e:	bd80      	pop	{r7, pc}

20002e60 <cfe_cmd_dev_ioctl>:

static int cfe_cmd_dev_ioctl(cfe_devctx_t *ctx,cfe_iocb_t *iocb)
{
20002e60:	b580      	push	{r7, lr}
20002e62:	b084      	sub	sp, #16
20002e64:	af00      	add	r7, sp, #0
20002e66:	6078      	str	r0, [r7, #4]
20002e68:	6039      	str	r1, [r7, #0]
    int status;

    status = ctx->dev_dev->dev_dispatch->dev_ioctl(ctx,&(iocb->plist.iocb_buffer));
20002e6a:	687b      	ldr	r3, [r7, #4]
20002e6c:	681b      	ldr	r3, [r3, #0]
20002e6e:	695b      	ldr	r3, [r3, #20]
20002e70:	691b      	ldr	r3, [r3, #16]
20002e72:	683a      	ldr	r2, [r7, #0]
20002e74:	3218      	adds	r2, #24
20002e76:	4611      	mov	r1, r2
20002e78:	6878      	ldr	r0, [r7, #4]
20002e7a:	4798      	blx	r3
20002e7c:	60f8      	str	r0, [r7, #12]

    return status;
20002e7e:	68fb      	ldr	r3, [r7, #12]
}
20002e80:	4618      	mov	r0, r3
20002e82:	3710      	adds	r7, #16
20002e84:	46bd      	mov	sp, r7
20002e86:	bd80      	pop	{r7, pc}

20002e88 <cfe_cmd_dev_close>:

static int cfe_cmd_dev_close(cfe_devctx_t *ctx,cfe_iocb_t *iocb)
{
20002e88:	b580      	push	{r7, lr}
20002e8a:	b082      	sub	sp, #8
20002e8c:	af00      	add	r7, sp, #0
20002e8e:	6078      	str	r0, [r7, #4]
20002e90:	6039      	str	r1, [r7, #0]
    /*
     * Call device close function
     */

    ctx->dev_dev->dev_dispatch->dev_close(ctx);
20002e92:	687b      	ldr	r3, [r7, #4]
20002e94:	681b      	ldr	r3, [r3, #0]
20002e96:	695b      	ldr	r3, [r3, #20]
20002e98:	695b      	ldr	r3, [r3, #20]
20002e9a:	6878      	ldr	r0, [r7, #4]
20002e9c:	4798      	blx	r3

    /*
     * Decrement refcnt
     */

    ctx->dev_dev->dev_opencount--;
20002e9e:	687b      	ldr	r3, [r7, #4]
20002ea0:	681b      	ldr	r3, [r3, #0]
20002ea2:	699a      	ldr	r2, [r3, #24]
20002ea4:	3a01      	subs	r2, #1
20002ea6:	619a      	str	r2, [r3, #24]

    /*
     * Wipe out handle
     */

    cfe_handle_table[iocb->iocb_handle] = NULL;
20002ea8:	683b      	ldr	r3, [r7, #0]
20002eaa:	689b      	ldr	r3, [r3, #8]
20002eac:	4a06      	ldr	r2, [pc, #24]	@ (20002ec8 <cfe_cmd_dev_close+0x40>)
20002eae:	2100      	movs	r1, #0
20002eb0:	f842 1023 	str.w	r1, [r2, r3, lsl #2]

    /*
     * Release device context
     */

    KFREE(ctx);
20002eb4:	6879      	ldr	r1, [r7, #4]
20002eb6:	4805      	ldr	r0, [pc, #20]	@ (20002ecc <cfe_cmd_dev_close+0x44>)
20002eb8:	f7fe f848 	bl	20000f4c <kfree>

    return CFE_OK;
20002ebc:	2300      	movs	r3, #0
}
20002ebe:	4618      	mov	r0, r3
20002ec0:	3708      	adds	r7, #8
20002ec2:	46bd      	mov	sp, r7
20002ec4:	bd80      	pop	{r7, pc}
20002ec6:	bf00      	nop
20002ec8:	20004bd4 	.word	0x20004bd4
20002ecc:	20004ab4 	.word	0x20004ab4

20002ed0 <cfe_cmd_dev_getinfo>:

static int cfe_cmd_dev_getinfo(cfe_devctx_t *ctx,cfe_iocb_t *iocb)
{
20002ed0:	b580      	push	{r7, lr}
20002ed2:	b094      	sub	sp, #80	@ 0x50
20002ed4:	af00      	add	r7, sp, #0
20002ed6:	6078      	str	r0, [r7, #4]
20002ed8:	6039      	str	r1, [r7, #0]

    /*
     * Get device name
     */

    hsgetstr(devname,iocb->plist.iocb_buffer.buf_ptr,sizeof(devname));
20002eda:	683b      	ldr	r3, [r7, #0]
20002edc:	6a19      	ldr	r1, [r3, #32]
20002ede:	f107 0308 	add.w	r3, r7, #8
20002ee2:	2240      	movs	r2, #64	@ 0x40
20002ee4:	4618      	mov	r0, r3
20002ee6:	f7ff fd51 	bl	2000298c <hsgetstr>

    /*
     * Find device in device table
     */

    if ((x = strchr(devname,':'))) *x = '\0';
20002eea:	f107 0308 	add.w	r3, r7, #8
20002eee:	213a      	movs	r1, #58	@ 0x3a
20002ef0:	4618      	mov	r0, r3
20002ef2:	f7fe fa27 	bl	20001344 <lib_strchr>
20002ef6:	64f8      	str	r0, [r7, #76]	@ 0x4c
20002ef8:	6cfb      	ldr	r3, [r7, #76]	@ 0x4c
20002efa:	2b00      	cmp	r3, #0
20002efc:	d002      	beq.n	20002f04 <cfe_cmd_dev_getinfo+0x34>
20002efe:	6cfb      	ldr	r3, [r7, #76]	@ 0x4c
20002f00:	2200      	movs	r2, #0
20002f02:	701a      	strb	r2, [r3, #0]
    dev = cfe_finddev(devname);
20002f04:	f107 0308 	add.w	r3, r7, #8
20002f08:	4618      	mov	r0, r3
20002f0a:	f7fe fab7 	bl	2000147c <cfe_finddev>
20002f0e:	64b8      	str	r0, [r7, #72]	@ 0x48
    if (!dev) return CFE_ERR_DEVNOTFOUND;
20002f10:	6cbb      	ldr	r3, [r7, #72]	@ 0x48
20002f12:	2b00      	cmp	r3, #0
20002f14:	d102      	bne.n	20002f1c <cfe_cmd_dev_getinfo+0x4c>
20002f16:	f06f 0305 	mvn.w	r3, #5
20002f1a:	e005      	b.n	20002f28 <cfe_cmd_dev_getinfo+0x58>

    /*
     * Return device class
     */

    iocb->plist.iocb_buffer.buf_devflags = dev->dev_class;
20002f1c:	6cbb      	ldr	r3, [r7, #72]	@ 0x48
20002f1e:	691b      	ldr	r3, [r3, #16]
20002f20:	461a      	mov	r2, r3
20002f22:	683b      	ldr	r3, [r7, #0]
20002f24:	62da      	str	r2, [r3, #44]	@ 0x2c

    return CFE_OK;
20002f26:	2300      	movs	r3, #0
}
20002f28:	4618      	mov	r0, r3
20002f2a:	3750      	adds	r7, #80	@ 0x50
20002f2c:	46bd      	mov	sp, r7
20002f2e:	bd80      	pop	{r7, pc}

20002f30 <cfe_cmd_env_enum>:

static int cfe_cmd_env_enum(cfe_devctx_t *ctx,cfe_iocb_t *iocb)
{
20002f30:	b590      	push	{r4, r7, lr}
20002f32:	b089      	sub	sp, #36	@ 0x24
20002f34:	af02      	add	r7, sp, #8
20002f36:	6078      	str	r0, [r7, #4]
20002f38:	6039      	str	r1, [r7, #0]
    int vallen,namelen,res;

    namelen = iocb->plist.iocb_envbuf.name_length;
20002f3a:	683b      	ldr	r3, [r7, #0]
20002f3c:	6a1b      	ldr	r3, [r3, #32]
20002f3e:	60fb      	str	r3, [r7, #12]
    vallen  = iocb->plist.iocb_envbuf.val_length;
20002f40:	683b      	ldr	r3, [r7, #0]
20002f42:	6a9b      	ldr	r3, [r3, #40]	@ 0x28
20002f44:	613b      	str	r3, [r7, #16]

    res = env_enum(iocb->plist.iocb_envbuf.enum_idx,
20002f46:	683b      	ldr	r3, [r7, #0]
20002f48:	6998      	ldr	r0, [r3, #24]
		   (char *)iocb->plist.iocb_envbuf.name_ptr,
20002f4a:	683b      	ldr	r3, [r7, #0]
20002f4c:	69d9      	ldr	r1, [r3, #28]
		   &namelen,
		   (char *)iocb->plist.iocb_envbuf.val_ptr,
20002f4e:	683b      	ldr	r3, [r7, #0]
20002f50:	6a5c      	ldr	r4, [r3, #36]	@ 0x24
    res = env_enum(iocb->plist.iocb_envbuf.enum_idx,
20002f52:	f107 020c 	add.w	r2, r7, #12
20002f56:	f107 0310 	add.w	r3, r7, #16
20002f5a:	9300      	str	r3, [sp, #0]
20002f5c:	4623      	mov	r3, r4
20002f5e:	f000 fab9 	bl	200034d4 <env_enum>
20002f62:	6178      	str	r0, [r7, #20]
		   &vallen);

    if (res < 0) return CFE_ERR_ENVNOTFOUND;
20002f64:	697b      	ldr	r3, [r7, #20]
20002f66:	2b00      	cmp	r3, #0
20002f68:	da02      	bge.n	20002f70 <cfe_cmd_env_enum+0x40>
20002f6a:	f06f 0308 	mvn.w	r3, #8
20002f6e:	e000      	b.n	20002f72 <cfe_cmd_env_enum+0x42>

    return CFE_OK;
20002f70:	2300      	movs	r3, #0
}
20002f72:	4618      	mov	r0, r3
20002f74:	371c      	adds	r7, #28
20002f76:	46bd      	mov	sp, r7
20002f78:	bd90      	pop	{r4, r7, pc}

20002f7a <cfe_cmd_env_get>:


static int cfe_cmd_env_get(cfe_devctx_t *ctx,cfe_iocb_t *iocb)
{
20002f7a:	b580      	push	{r7, lr}
20002f7c:	b084      	sub	sp, #16
20002f7e:	af00      	add	r7, sp, #0
20002f80:	6078      	str	r0, [r7, #4]
20002f82:	6039      	str	r1, [r7, #0]
    char *env;

    env = env_getenv((char *)iocb->plist.iocb_envbuf.name_ptr);
20002f84:	683b      	ldr	r3, [r7, #0]
20002f86:	69db      	ldr	r3, [r3, #28]
20002f88:	4618      	mov	r0, r3
20002f8a:	f000 fb1b 	bl	200035c4 <env_getenv>
20002f8e:	60f8      	str	r0, [r7, #12]

    if (env == NULL) return CFE_ERR_ENVNOTFOUND;
20002f90:	68fb      	ldr	r3, [r7, #12]
20002f92:	2b00      	cmp	r3, #0
20002f94:	d102      	bne.n	20002f9c <cfe_cmd_env_get+0x22>
20002f96:	f06f 0308 	mvn.w	r3, #8
20002f9a:	e008      	b.n	20002fae <cfe_cmd_env_get+0x34>

    xstrncpy((char *)iocb->plist.iocb_envbuf.val_ptr,
20002f9c:	683b      	ldr	r3, [r7, #0]
20002f9e:	6a58      	ldr	r0, [r3, #36]	@ 0x24
20002fa0:	683b      	ldr	r3, [r7, #0]
20002fa2:	6a9b      	ldr	r3, [r3, #40]	@ 0x28
20002fa4:	461a      	mov	r2, r3
20002fa6:	68f9      	ldr	r1, [r7, #12]
20002fa8:	f7fe f949 	bl	2000123e <lib_xstrncpy>
	     env,
	     iocb->plist.iocb_envbuf.val_length);

    return CFE_OK;
20002fac:	2300      	movs	r3, #0
}
20002fae:	4618      	mov	r0, r3
20002fb0:	3710      	adds	r7, #16
20002fb2:	46bd      	mov	sp, r7
20002fb4:	bd80      	pop	{r7, pc}

20002fb6 <cfe_cmd_env_set>:

static int cfe_cmd_env_set(cfe_devctx_t *ctx,cfe_iocb_t *iocb)
{
20002fb6:	b580      	push	{r7, lr}
20002fb8:	b084      	sub	sp, #16
20002fba:	af00      	add	r7, sp, #0
20002fbc:	6078      	str	r0, [r7, #4]
20002fbe:	6039      	str	r1, [r7, #0]
    int res;
    int flg;


    flg = (iocb->iocb_flags & CFE_FLG_ENV_PERMANENT) ? 
20002fc0:	683b      	ldr	r3, [r7, #0]
20002fc2:	68db      	ldr	r3, [r3, #12]
20002fc4:	f003 0301 	and.w	r3, r3, #1
	ENV_FLG_NORMAL : ENV_FLG_BUILTIN;
20002fc8:	2b00      	cmp	r3, #0
20002fca:	bf0c      	ite	eq
20002fcc:	2301      	moveq	r3, #1
20002fce:	2300      	movne	r3, #0
20002fd0:	b2db      	uxtb	r3, r3
    flg = (iocb->iocb_flags & CFE_FLG_ENV_PERMANENT) ? 
20002fd2:	60bb      	str	r3, [r7, #8]

    res = env_setenv((char *)iocb->plist.iocb_envbuf.name_ptr,
20002fd4:	683b      	ldr	r3, [r7, #0]
20002fd6:	69d8      	ldr	r0, [r3, #28]
		     (char *)iocb->plist.iocb_envbuf.val_ptr,
20002fd8:	683b      	ldr	r3, [r7, #0]
20002fda:	6a5b      	ldr	r3, [r3, #36]	@ 0x24
    res = env_setenv((char *)iocb->plist.iocb_envbuf.name_ptr,
20002fdc:	68ba      	ldr	r2, [r7, #8]
20002fde:	4619      	mov	r1, r3
20002fe0:	f000 fb04 	bl	200035ec <env_setenv>
20002fe4:	60f8      	str	r0, [r7, #12]
		     flg);

    if (res == 0) {
20002fe6:	68fb      	ldr	r3, [r7, #12]
20002fe8:	2b00      	cmp	r3, #0
20002fea:	d108      	bne.n	20002ffe <cfe_cmd_env_set+0x48>
	if (iocb->iocb_flags & CFE_FLG_ENV_PERMANENT) res = env_save();
20002fec:	683b      	ldr	r3, [r7, #0]
20002fee:	68db      	ldr	r3, [r3, #12]
20002ff0:	f003 0301 	and.w	r3, r3, #1
20002ff4:	2b00      	cmp	r3, #0
20002ff6:	d002      	beq.n	20002ffe <cfe_cmd_env_set+0x48>
20002ff8:	f000 fb5c 	bl	200036b4 <env_save>
20002ffc:	60f8      	str	r0, [r7, #12]
	}

    if (res < 0) return res;
20002ffe:	68fb      	ldr	r3, [r7, #12]
20003000:	2b00      	cmp	r3, #0
20003002:	da01      	bge.n	20003008 <cfe_cmd_env_set+0x52>
20003004:	68fb      	ldr	r3, [r7, #12]
20003006:	e000      	b.n	2000300a <cfe_cmd_env_set+0x54>

    return CFE_OK;
20003008:	2300      	movs	r3, #0
}
2000300a:	4618      	mov	r0, r3
2000300c:	3710      	adds	r7, #16
2000300e:	46bd      	mov	sp, r7
20003010:	bd80      	pop	{r7, pc}

20003012 <cfe_cmd_env_del>:

static int cfe_cmd_env_del(cfe_devctx_t *ctx,cfe_iocb_t *iocb)
{
20003012:	b580      	push	{r7, lr}
20003014:	b084      	sub	sp, #16
20003016:	af00      	add	r7, sp, #0
20003018:	6078      	str	r0, [r7, #4]
2000301a:	6039      	str	r1, [r7, #0]
    int res;
    int type;
    
    type = env_envtype((char *)iocb->plist.iocb_envbuf.name_ptr);
2000301c:	683b      	ldr	r3, [r7, #0]
2000301e:	69db      	ldr	r3, [r3, #28]
20003020:	4618      	mov	r0, r3
20003022:	f000 fa97 	bl	20003554 <env_envtype>
20003026:	60f8      	str	r0, [r7, #12]

    /* 
     * Make sure we remove from NVRAM device, if it's there.
     */
    if ((res = env_delenv((char *)iocb->plist.iocb_envbuf.name_ptr)) == 0 ) {
20003028:	683b      	ldr	r3, [r7, #0]
2000302a:	69db      	ldr	r3, [r3, #28]
2000302c:	4618      	mov	r0, r3
2000302e:	f000 faa5 	bl	2000357c <env_delenv>
20003032:	60b8      	str	r0, [r7, #8]
20003034:	68bb      	ldr	r3, [r7, #8]
20003036:	2b00      	cmp	r3, #0
20003038:	d107      	bne.n	2000304a <cfe_cmd_env_del+0x38>
	if ((type >= 0) && (type != ENV_FLG_BUILTIN)) env_save();
2000303a:	68fb      	ldr	r3, [r7, #12]
2000303c:	2b00      	cmp	r3, #0
2000303e:	db04      	blt.n	2000304a <cfe_cmd_env_del+0x38>
20003040:	68fb      	ldr	r3, [r7, #12]
20003042:	2b01      	cmp	r3, #1
20003044:	d001      	beq.n	2000304a <cfe_cmd_env_del+0x38>
20003046:	f000 fb35 	bl	200036b4 <env_save>
	}

    return res;
2000304a:	68bb      	ldr	r3, [r7, #8]
}
2000304c:	4618      	mov	r0, r3
2000304e:	3710      	adds	r7, #16
20003050:	46bd      	mov	sp, r7
20003052:	bd80      	pop	{r7, pc}

20003054 <cfe_setup_default_env>:
    ********************************************************************* */

uint32_t mem_totalsize = 0x1000000;

static void cfe_setup_default_env(void)
{
20003054:	b580      	push	{r7, lr}
20003056:	b096      	sub	sp, #88	@ 0x58
20003058:	af02      	add	r7, sp, #8
    char buffer[80];

    xsprintf(buffer,"%s%d.%d.%d",CFE_VER_PREFIX,CFE_VER_MAJOR,CFE_VER_MINOR,CFE_VER_BUILD);
2000305a:	4638      	mov	r0, r7
2000305c:	2302      	movs	r3, #2
2000305e:	9301      	str	r3, [sp, #4]
20003060:	2301      	movs	r3, #1
20003062:	9300      	str	r3, [sp, #0]
20003064:	2300      	movs	r3, #0
20003066:	4a13      	ldr	r2, [pc, #76]	@ (200030b4 <cfe_setup_default_env+0x60>)
20003068:	4913      	ldr	r1, [pc, #76]	@ (200030b8 <cfe_setup_default_env+0x64>)
2000306a:	f7fd fdc7 	bl	20000bfc <xsprintf>
    env_setenv("CFE_VERSION",buffer,ENV_FLG_BUILTIN | ENV_FLG_READONLY);
2000306e:	463b      	mov	r3, r7
20003070:	2203      	movs	r2, #3
20003072:	4619      	mov	r1, r3
20003074:	4811      	ldr	r0, [pc, #68]	@ (200030bc <cfe_setup_default_env+0x68>)
20003076:	f000 fab9 	bl	200035ec <env_setenv>

    if (cfe_boardname) {
2000307a:	4b11      	ldr	r3, [pc, #68]	@ (200030c0 <cfe_setup_default_env+0x6c>)
2000307c:	681b      	ldr	r3, [r3, #0]
2000307e:	2b00      	cmp	r3, #0
20003080:	d006      	beq.n	20003090 <cfe_setup_default_env+0x3c>
	env_setenv("CFE_BOARDNAME",(char *) cfe_boardname,
20003082:	4b0f      	ldr	r3, [pc, #60]	@ (200030c0 <cfe_setup_default_env+0x6c>)
20003084:	681b      	ldr	r3, [r3, #0]
20003086:	2203      	movs	r2, #3
20003088:	4619      	mov	r1, r3
2000308a:	480e      	ldr	r0, [pc, #56]	@ (200030c4 <cfe_setup_default_env+0x70>)
2000308c:	f000 faae 	bl	200035ec <env_setenv>
		   ENV_FLG_BUILTIN | ENV_FLG_READONLY);
	}

    xsprintf(buffer,"%d",mem_totalsize);
20003090:	4b0d      	ldr	r3, [pc, #52]	@ (200030c8 <cfe_setup_default_env+0x74>)
20003092:	681a      	ldr	r2, [r3, #0]
20003094:	463b      	mov	r3, r7
20003096:	490d      	ldr	r1, [pc, #52]	@ (200030cc <cfe_setup_default_env+0x78>)
20003098:	4618      	mov	r0, r3
2000309a:	f7fd fdaf 	bl	20000bfc <xsprintf>
    env_setenv("CFE_MEMORYSIZE",buffer,ENV_FLG_BUILTIN | ENV_FLG_READONLY);
2000309e:	463b      	mov	r3, r7
200030a0:	2203      	movs	r2, #3
200030a2:	4619      	mov	r1, r3
200030a4:	480a      	ldr	r0, [pc, #40]	@ (200030d0 <cfe_setup_default_env+0x7c>)
200030a6:	f000 faa1 	bl	200035ec <env_setenv>

}
200030aa:	bf00      	nop
200030ac:	3750      	adds	r7, #80	@ 0x50
200030ae:	46bd      	mov	sp, r7
200030b0:	bd80      	pop	{r7, pc}
200030b2:	bf00      	nop
200030b4:	200044f0 	.word	0x200044f0
200030b8:	200044f4 	.word	0x200044f4
200030bc:	20004500 	.word	0x20004500
200030c0:	20004a94 	.word	0x20004a94
200030c4:	2000450c 	.word	0x2000450c
200030c8:	20004a98 	.word	0x20004a98
200030cc:	2000451c 	.word	0x2000451c
200030d0:	20004520 	.word	0x20004520

200030d4 <cfe_leds>:
    *  Return value:
    *  	   nothing
    ********************************************************************* */

void cfe_leds(unsigned int val)
{
200030d4:	b480      	push	{r7}
200030d6:	b083      	sub	sp, #12
200030d8:	af00      	add	r7, sp, #0
200030da:	6078      	str	r0, [r7, #4]

}
200030dc:	bf00      	nop
200030de:	370c      	adds	r7, #12
200030e0:	46bd      	mov	sp, r7
200030e2:	f85d 7b04 	ldr.w	r7, [sp], #4
200030e6:	4770      	bx	lr

200030e8 <cfe_ledstr>:
void cfe_ledstr(const char *leds)
{
200030e8:	b580      	push	{r7, lr}
200030ea:	b084      	sub	sp, #16
200030ec:	af00      	add	r7, sp, #0
200030ee:	6078      	str	r0, [r7, #4]
    unsigned int val;

    val = ((((unsigned int) leds[0]) << 24) |
200030f0:	687b      	ldr	r3, [r7, #4]
200030f2:	781b      	ldrb	r3, [r3, #0]
200030f4:	061a      	lsls	r2, r3, #24
	   (((unsigned int) leds[1]) << 16) |
200030f6:	687b      	ldr	r3, [r7, #4]
200030f8:	3301      	adds	r3, #1
200030fa:	781b      	ldrb	r3, [r3, #0]
200030fc:	041b      	lsls	r3, r3, #16
    val = ((((unsigned int) leds[0]) << 24) |
200030fe:	431a      	orrs	r2, r3
	   (((unsigned int) leds[2]) << 8) |
20003100:	687b      	ldr	r3, [r7, #4]
20003102:	3302      	adds	r3, #2
20003104:	781b      	ldrb	r3, [r3, #0]
20003106:	021b      	lsls	r3, r3, #8
	   (((unsigned int) leds[1]) << 16) |
20003108:	4313      	orrs	r3, r2
	   ((unsigned int) leds[3]));
2000310a:	687a      	ldr	r2, [r7, #4]
2000310c:	3203      	adds	r2, #3
2000310e:	7812      	ldrb	r2, [r2, #0]
    val = ((((unsigned int) leds[0]) << 24) |
20003110:	4313      	orrs	r3, r2
20003112:	60fb      	str	r3, [r7, #12]

    cfe_leds(val);
20003114:	68f8      	ldr	r0, [r7, #12]
20003116:	f7ff ffdd 	bl	200030d4 <cfe_leds>
}
2000311a:	bf00      	nop
2000311c:	3710      	adds	r7, #16
2000311e:	46bd      	mov	sp, r7
20003120:	bd80      	pop	{r7, pc}
	...

20003124 <cfe_say_hello>:
    *  	   nothing
    ********************************************************************* */


static void cfe_say_hello(void)
{
20003124:	b580      	push	{r7, lr}
20003126:	af00      	add	r7, sp, #0

    printf("Copyright (C) 2000,2001,2002,2003,2004,2005 Broadcom Corporation.\n");
20003128:	4803      	ldr	r0, [pc, #12]	@ (20003138 <cfe_say_hello+0x14>)
2000312a:	f7fd fdd3 	bl	20000cd4 <puts>
    printf("\n");
2000312e:	200a      	movs	r0, #10
20003130:	f7fd fddc 	bl	20000cec <putchar>
}
20003134:	bf00      	nop
20003136:	bd80      	pop	{r7, pc}
20003138:	20004530 	.word	0x20004530

2000313c <cfe_startup_info>:
#define RELOCTEXT(x) ((x)-mem_textreloc)
#define RELOCDATA(x) ((x)-mem_datareloc)
#endif

static void cfe_startup_info(void)
{
2000313c:	b480      	push	{r7}
2000313e:	af00      	add	r7, sp, #0

}
20003140:	bf00      	nop
20003142:	46bd      	mov	sp, r7
20003144:	f85d 7b04 	ldr.w	r7, [sp], #4
20003148:	4770      	bx	lr
	...

2000314c <cfe_main>:
    *  Return value:
    *  	   does not return
    ********************************************************************* */

void cfe_main(int a,int b)
{
2000314c:	b580      	push	{r7, lr}
2000314e:	b082      	sub	sp, #8
20003150:	af00      	add	r7, sp, #0
20003152:	6078      	str	r0, [r7, #4]
20003154:	6039      	str	r1, [r7, #0]
     * 4. BSS has been zeroed.
     * 5. The data has been moved to R/W space.
     * 6. The "C" Stack has been initialized.
     */

    cfe_cpu_speed = 1000;
20003156:	4b21      	ldr	r3, [pc, #132]	@ (200031dc <cfe_main+0x90>)
20003158:	f44f 727a 	mov.w	r2, #1000	@ 0x3e8
2000315c:	601a      	str	r2, [r3, #0]
    printf("Initializing Arena.\n");
2000315e:	4820      	ldr	r0, [pc, #128]	@ (200031e0 <cfe_main+0x94>)
20003160:	f7fd fdb8 	bl	20000cd4 <puts>

    cfe_bg_init();		       		/* init background processing */
20003164:	f7fe fa80 	bl	20001668 <cfe_bg_init>
    cfe_attach_init();
20003168:	f7fe fa6e 	bl	20001648 <cfe_attach_init>
    cfe_timer_init(cfe_cpu_speed);		/* Timer process */
2000316c:	4b1b      	ldr	r3, [pc, #108]	@ (200031dc <cfe_main+0x90>)
2000316e:	681b      	ldr	r3, [r3, #0]
20003170:	4618      	mov	r0, r3
20003172:	f000 f92f 	bl	200033d4 <cfe_timer_init>

    /*
     * Initialize the memory allocator
     */

    SETLEDS("KMEM");
20003176:	481b      	ldr	r0, [pc, #108]	@ (200031e4 <cfe_main+0x98>)
20003178:	f7ff ffb6 	bl	200030e8 <cfe_ledstr>
    KMEMINIT((unsigned char *) (uintptr_t) 0x20002000,
2000317c:	f44f 3280 	mov.w	r2, #65536	@ 0x10000
20003180:	f04f 2120 	mov.w	r1, #536879104	@ 0x20002000
20003184:	4818      	ldr	r0, [pc, #96]	@ (200031e8 <cfe_main+0x9c>)
20003186:	f7fd fe6f 	bl	20000e68 <kmeminit>
     * Initialize the console.  It is done before the other devices
     * get turned on.  The console init also sets the variable that
     * contains the CPU speed.
     */

    SETLEDS("CONS");
2000318a:	4818      	ldr	r0, [pc, #96]	@ (200031ec <cfe_main+0xa0>)
2000318c:	f7ff ffac 	bl	200030e8 <cfe_ledstr>

    board_init();
20003190:	f7fd fe58 	bl	20000e44 <board_init>

    /*
     * Say hello.
     */

    SETLEDS("CIOK");
20003194:	4816      	ldr	r0, [pc, #88]	@ (200031f0 <cfe_main+0xa4>)
20003196:	f7ff ffa7 	bl	200030e8 <cfe_ledstr>
    cfe_say_hello();
2000319a:	f7ff ffc3 	bl	20003124 <cfe_say_hello>

    /*
     * Initialize the other devices.
     */

    SETLEDS("AREN");
2000319e:	4815      	ldr	r0, [pc, #84]	@ (200031f4 <cfe_main+0xa8>)
200031a0:	f7ff ffa2 	bl	200030e8 <cfe_ledstr>
    printf("Initializing Arena.\n");
200031a4:	480e      	ldr	r0, [pc, #56]	@ (200031e0 <cfe_main+0x94>)
200031a6:	f7fd fd95 	bl	20000cd4 <puts>
    cfe_arena_init();
200031aa:	f000 f85f 	bl	2000326c <cfe_arena_init>


    SETLEDS("DEVI");
200031ae:	4812      	ldr	r0, [pc, #72]	@ (200031f8 <cfe_main+0xac>)
200031b0:	f7ff ff9a 	bl	200030e8 <cfe_ledstr>
    printf("Initializing Devices.\n");
200031b4:	4811      	ldr	r0, [pc, #68]	@ (200031fc <cfe_main+0xb0>)
200031b6:	f7fd fd8d 	bl	20000cd4 <puts>
  //  board_device_init();

    cfe_startup_info();
200031ba:	f7ff ffbf 	bl	2000313c <cfe_startup_info>
    SETLEDS("ENVI");
200031be:	4810      	ldr	r0, [pc, #64]	@ (20003200 <cfe_main+0xb4>)
200031c0:	f7ff ff92 	bl	200030e8 <cfe_ledstr>
    cfe_setup_default_env();
200031c4:	f7ff ff46 	bl	20003054 <cfe_setup_default_env>

    printf("\n");
200031c8:	200a      	movs	r0, #10
200031ca:	f7fd fd8f 	bl	20000cec <putchar>

  //  board_final_init();


   // cfe_autostart();
    cfe_command_loop();
200031ce:	f000 f819 	bl	20003204 <cfe_command_loop>

}
200031d2:	bf00      	nop
200031d4:	3708      	adds	r7, #8
200031d6:	46bd      	mov	sp, r7
200031d8:	bd80      	pop	{r7, pc}
200031da:	bf00      	nop
200031dc:	20004d00 	.word	0x20004d00
200031e0:	2000457c 	.word	0x2000457c
200031e4:	20004590 	.word	0x20004590
200031e8:	20004ab4 	.word	0x20004ab4
200031ec:	20004598 	.word	0x20004598
200031f0:	200045a0 	.word	0x200045a0
200031f4:	200045a8 	.word	0x200045a8
200031f8:	200045b0 	.word	0x200045b0
200031fc:	200045b8 	.word	0x200045b8
20003200:	200045d0 	.word	0x200045d0

20003204 <cfe_command_loop>:
    *  Return value:
    *  	   does not return
    ********************************************************************* */

void cfe_command_loop()
{
20003204:	b580      	push	{r7, lr}
20003206:	b0ce      	sub	sp, #312	@ 0x138
20003208:	af00      	add	r7, sp, #0

    char buffer[300];
    int status;
    char *prompt;

    SETLEDS("CFE ");
2000320a:	4814      	ldr	r0, [pc, #80]	@ (2000325c <cfe_command_loop+0x58>)
2000320c:	f7ff ff6c 	bl	200030e8 <cfe_ledstr>

    for (;;) {
	prompt = env_getenv("PROMPT");
20003210:	4813      	ldr	r0, [pc, #76]	@ (20003260 <cfe_command_loop+0x5c>)
20003212:	f000 f9d7 	bl	200035c4 <env_getenv>
20003216:	f8c7 0134 	str.w	r0, [r7, #308]	@ 0x134

	if (!prompt) prompt = "CFE> ";
2000321a:	f8d7 3134 	ldr.w	r3, [r7, #308]	@ 0x134
2000321e:	2b00      	cmp	r3, #0
20003220:	d102      	bne.n	20003228 <cfe_command_loop+0x24>
20003222:	4b10      	ldr	r3, [pc, #64]	@ (20003264 <cfe_command_loop+0x60>)
20003224:	f8c7 3134 	str.w	r3, [r7, #308]	@ 0x134

	console_readline(prompt,buffer,sizeof(buffer));
20003228:	1d3b      	adds	r3, r7, #4
2000322a:	f44f 7296 	mov.w	r2, #300	@ 0x12c
2000322e:	4619      	mov	r1, r3
20003230:	f8d7 0134 	ldr.w	r0, [r7, #308]	@ 0x134
20003234:	f7ff faa0 	bl	20002778 <console_readline>

	status = ui_docommands(buffer);
20003238:	1d3b      	adds	r3, r7, #4
2000323a:	4618      	mov	r0, r3
2000323c:	f000 fb16 	bl	2000386c <ui_docommands>
20003240:	f8c7 0130 	str.w	r0, [r7, #304]	@ 0x130

	if (status != CMD_ERR_BLANK) {
20003244:	f8d7 3130 	ldr.w	r3, [r7, #304]	@ 0x130
20003248:	f113 0f03 	cmn.w	r3, #3
2000324c:	d0e0      	beq.n	20003210 <cfe_command_loop+0xc>
	    printf("*** command status = %d\n", status);
2000324e:	f8d7 1130 	ldr.w	r1, [r7, #304]	@ 0x130
20003252:	4805      	ldr	r0, [pc, #20]	@ (20003268 <cfe_command_loop+0x64>)
20003254:	f7fd fce8 	bl	20000c28 <printf>
	prompt = env_getenv("PROMPT");
20003258:	e7da      	b.n	20003210 <cfe_command_loop+0xc>
2000325a:	bf00      	nop
2000325c:	200045f8 	.word	0x200045f8
20003260:	20004600 	.word	0x20004600
20003264:	20004608 	.word	0x20004608
20003268:	20004610 	.word	0x20004610

2000326c <cfe_arena_init>:
    *  Return value:
    *  	   nothing
    ********************************************************************* */

void cfe_arena_init(void)
{
2000326c:	b480      	push	{r7}
2000326e:	af00      	add	r7, sp, #0
    //memlo = PHYSADDR(mem_bottomofmem) & ~4095;




}
20003270:	bf00      	nop
20003272:	46bd      	mov	sp, r7
20003274:	f85d 7b04 	ldr.w	r7, [sp], #4
20003278:	4770      	bx	lr
	...

2000327c <cfe_arena_enum>:
    *  	   0 if ok
    *  	   CFE_ERR_NOMORE if idx is beyond the last entry
    ********************************************************************* */

int cfe_arena_enum(int idx,int *type,uint64_t *start,uint64_t *size,int allrecs)
{
2000327c:	b480      	push	{r7}
2000327e:	b089      	sub	sp, #36	@ 0x24
20003280:	af00      	add	r7, sp, #0
20003282:	60f8      	str	r0, [r7, #12]
20003284:	60b9      	str	r1, [r7, #8]
20003286:	607a      	str	r2, [r7, #4]
20003288:	603b      	str	r3, [r7, #0]
    arena_node_t *node;
    queue_t *qb;
    arena_t *arena = &cfe_arena;
2000328a:	4b1c      	ldr	r3, [pc, #112]	@ (200032fc <cfe_arena_enum+0x80>)
2000328c:	61bb      	str	r3, [r7, #24]


    for (qb = (arena->arena_list.q_next); qb != &(arena->arena_list);
2000328e:	69bb      	ldr	r3, [r7, #24]
20003290:	681b      	ldr	r3, [r3, #0]
20003292:	61fb      	str	r3, [r7, #28]
20003294:	e026      	b.n	200032e4 <cfe_arena_enum+0x68>
	 qb = qb->q_next) {
	node = (arena_node_t *) qb;
20003296:	69fb      	ldr	r3, [r7, #28]
20003298:	617b      	str	r3, [r7, #20]

	if (allrecs || (!allrecs && (node->an_type == MEMTYPE_DRAM_AVAILABLE))) {
2000329a:	6abb      	ldr	r3, [r7, #40]	@ 0x28
2000329c:	2b00      	cmp	r3, #0
2000329e:	d106      	bne.n	200032ae <cfe_arena_enum+0x32>
200032a0:	6abb      	ldr	r3, [r7, #40]	@ 0x28
200032a2:	2b00      	cmp	r3, #0
200032a4:	d11b      	bne.n	200032de <cfe_arena_enum+0x62>
200032a6:	697b      	ldr	r3, [r7, #20]
200032a8:	699b      	ldr	r3, [r3, #24]
200032aa:	2b01      	cmp	r3, #1
200032ac:	d117      	bne.n	200032de <cfe_arena_enum+0x62>
	    if (idx == 0) {
200032ae:	68fb      	ldr	r3, [r7, #12]
200032b0:	2b00      	cmp	r3, #0
200032b2:	d111      	bne.n	200032d8 <cfe_arena_enum+0x5c>
		*type = node->an_type;
200032b4:	697b      	ldr	r3, [r7, #20]
200032b6:	699a      	ldr	r2, [r3, #24]
200032b8:	68bb      	ldr	r3, [r7, #8]
200032ba:	601a      	str	r2, [r3, #0]
		*start = node->an_address;
200032bc:	697b      	ldr	r3, [r7, #20]
200032be:	e9d3 2302 	ldrd	r2, r3, [r3, #8]
200032c2:	6879      	ldr	r1, [r7, #4]
200032c4:	e9c1 2300 	strd	r2, r3, [r1]
		*size = node->an_length;
200032c8:	697b      	ldr	r3, [r7, #20]
200032ca:	e9d3 2304 	ldrd	r2, r3, [r3, #16]
200032ce:	6839      	ldr	r1, [r7, #0]
200032d0:	e9c1 2300 	strd	r2, r3, [r1]
		return 0;
200032d4:	2300      	movs	r3, #0
200032d6:	e00b      	b.n	200032f0 <cfe_arena_enum+0x74>
		}
	    idx--;
200032d8:	68fb      	ldr	r3, [r7, #12]
200032da:	3b01      	subs	r3, #1
200032dc:	60fb      	str	r3, [r7, #12]
	 qb = qb->q_next) {
200032de:	69fb      	ldr	r3, [r7, #28]
200032e0:	681b      	ldr	r3, [r3, #0]
200032e2:	61fb      	str	r3, [r7, #28]
    for (qb = (arena->arena_list.q_next); qb != &(arena->arena_list);
200032e4:	69bb      	ldr	r3, [r7, #24]
200032e6:	69fa      	ldr	r2, [r7, #28]
200032e8:	429a      	cmp	r2, r3
200032ea:	d1d4      	bne.n	20003296 <cfe_arena_enum+0x1a>
	    }
	}

    return CFE_ERR_NOMORE;
200032ec:	f06f 031b 	mvn.w	r3, #27

}
200032f0:	4618      	mov	r0, r3
200032f2:	3724      	adds	r7, #36	@ 0x24
200032f4:	46bd      	mov	sp, r7
200032f6:	f85d 7b04 	ldr.w	r7, [sp], #4
200032fa:	4770      	bx	lr
200032fc:	20004cd8 	.word	0x20004cd8

20003300 <_getticks>:
    *  Return value:
    *  	   nothing
    ********************************************************************* */

uint32_t _getticks()
{
20003300:	b480      	push	{r7}
20003302:	af00      	add	r7, sp, #0
	return 1000;
20003304:	f44f 737a 	mov.w	r3, #1000	@ 0x3e8
}
20003308:	4618      	mov	r0, r3
2000330a:	46bd      	mov	sp, r7
2000330c:	f85d 7b04 	ldr.w	r7, [sp], #4
20003310:	4770      	bx	lr
	...

20003314 <cfe_timer_task>:
static void cfe_timer_task(void *arg)
{
20003314:	e92d 4fb0 	stmdb	sp!, {r4, r5, r7, r8, r9, sl, fp, lr}
20003318:	b086      	sub	sp, #24
2000331a:	af00      	add	r7, sp, #0
2000331c:	6078      	str	r0, [r7, #4]
    uint32_t count;
    uint32_t deltaticks;
    uint32_t clockspertick;

    clockspertick = cfe_clocks_per_tick;
2000331e:	4b29      	ldr	r3, [pc, #164]	@ (200033c4 <cfe_timer_task+0xb0>)
20003320:	681b      	ldr	r3, [r3, #0]
20003322:	617b      	str	r3, [r7, #20]

    count = _getticks();
20003324:	f7ff ffec 	bl	20003300 <_getticks>
20003328:	6138      	str	r0, [r7, #16]
    deltaticks    = (count - cfe_oldcount);
2000332a:	4b27      	ldr	r3, [pc, #156]	@ (200033c8 <cfe_timer_task+0xb4>)
2000332c:	681b      	ldr	r3, [r3, #0]
2000332e:	693a      	ldr	r2, [r7, #16]
20003330:	1ad3      	subs	r3, r2, r3
20003332:	60fb      	str	r3, [r7, #12]
    cfe_remticks += deltaticks;
20003334:	4b25      	ldr	r3, [pc, #148]	@ (200033cc <cfe_timer_task+0xb8>)
20003336:	681a      	ldr	r2, [r3, #0]
20003338:	68fb      	ldr	r3, [r7, #12]
2000333a:	4413      	add	r3, r2
2000333c:	4a23      	ldr	r2, [pc, #140]	@ (200033cc <cfe_timer_task+0xb8>)
2000333e:	6013      	str	r3, [r2, #0]
     * assume it only moved by one tick and use a simple
     * loop to update it.  This loop probably will not
     * execute more than once.
     */

    if (cfe_remticks > (clockspertick << 4)) {
20003340:	697b      	ldr	r3, [r7, #20]
20003342:	011a      	lsls	r2, r3, #4
20003344:	4b21      	ldr	r3, [pc, #132]	@ (200033cc <cfe_timer_task+0xb8>)
20003346:	681b      	ldr	r3, [r3, #0]
20003348:	429a      	cmp	r2, r3
2000334a:	d22d      	bcs.n	200033a8 <cfe_timer_task+0x94>
        cfe_ticks += (cfe_remticks / clockspertick);
2000334c:	4b1f      	ldr	r3, [pc, #124]	@ (200033cc <cfe_timer_task+0xb8>)
2000334e:	681a      	ldr	r2, [r3, #0]
20003350:	697b      	ldr	r3, [r7, #20]
20003352:	fbb2 f3f3 	udiv	r3, r2, r3
20003356:	2200      	movs	r2, #0
20003358:	461c      	mov	r4, r3
2000335a:	4615      	mov	r5, r2
2000335c:	4b1c      	ldr	r3, [pc, #112]	@ (200033d0 <cfe_timer_task+0xbc>)
2000335e:	e9d3 2300 	ldrd	r2, r3, [r3]
20003362:	eb14 0a02 	adds.w	sl, r4, r2
20003366:	eb45 0b03 	adc.w	fp, r5, r3
2000336a:	4b19      	ldr	r3, [pc, #100]	@ (200033d0 <cfe_timer_task+0xbc>)
2000336c:	e9c3 ab00 	strd	sl, fp, [r3]
        cfe_remticks %= clockspertick;
20003370:	4b16      	ldr	r3, [pc, #88]	@ (200033cc <cfe_timer_task+0xb8>)
20003372:	681b      	ldr	r3, [r3, #0]
20003374:	697a      	ldr	r2, [r7, #20]
20003376:	fbb3 f2f2 	udiv	r2, r3, r2
2000337a:	6979      	ldr	r1, [r7, #20]
2000337c:	fb01 f202 	mul.w	r2, r1, r2
20003380:	1a9b      	subs	r3, r3, r2
20003382:	4a12      	ldr	r2, [pc, #72]	@ (200033cc <cfe_timer_task+0xb8>)
20003384:	6013      	str	r3, [r2, #0]
20003386:	e014      	b.n	200033b2 <cfe_timer_task+0x9e>
        }
    else {
        while (cfe_remticks > clockspertick) {
            cfe_remticks -= clockspertick;
20003388:	4b10      	ldr	r3, [pc, #64]	@ (200033cc <cfe_timer_task+0xb8>)
2000338a:	681a      	ldr	r2, [r3, #0]
2000338c:	697b      	ldr	r3, [r7, #20]
2000338e:	1ad3      	subs	r3, r2, r3
20003390:	4a0e      	ldr	r2, [pc, #56]	@ (200033cc <cfe_timer_task+0xb8>)
20003392:	6013      	str	r3, [r2, #0]
            cfe_ticks++;
20003394:	4b0e      	ldr	r3, [pc, #56]	@ (200033d0 <cfe_timer_task+0xbc>)
20003396:	e9d3 2300 	ldrd	r2, r3, [r3]
2000339a:	f112 0801 	adds.w	r8, r2, #1
2000339e:	f143 0900 	adc.w	r9, r3, #0
200033a2:	4b0b      	ldr	r3, [pc, #44]	@ (200033d0 <cfe_timer_task+0xbc>)
200033a4:	e9c3 8900 	strd	r8, r9, [r3]
        while (cfe_remticks > clockspertick) {
200033a8:	4b08      	ldr	r3, [pc, #32]	@ (200033cc <cfe_timer_task+0xb8>)
200033aa:	681b      	ldr	r3, [r3, #0]
200033ac:	697a      	ldr	r2, [r7, #20]
200033ae:	429a      	cmp	r2, r3
200033b0:	d3ea      	bcc.n	20003388 <cfe_timer_task+0x74>
            }
        }

    cfe_oldcount = count;
200033b2:	4a05      	ldr	r2, [pc, #20]	@ (200033c8 <cfe_timer_task+0xb4>)
200033b4:	693b      	ldr	r3, [r7, #16]
200033b6:	6013      	str	r3, [r2, #0]
}
200033b8:	bf00      	nop
200033ba:	3718      	adds	r7, #24
200033bc:	46bd      	mov	sp, r7
200033be:	e8bd 8fb0 	ldmia.w	sp!, {r4, r5, r7, r8, r9, sl, fp, pc}
200033c2:	bf00      	nop
200033c4:	20004d0c 	.word	0x20004d0c
200033c8:	20004d10 	.word	0x20004d10
200033cc:	20004d14 	.word	0x20004d14
200033d0:	20004cf8 	.word	0x20004cf8

200033d4 <cfe_timer_init>:
    *  Return value:
    *  	   nothing
    ********************************************************************* */

void cfe_timer_init(unsigned int cpu_speed)
{
200033d4:	b580      	push	{r7, lr}
200033d6:	b082      	sub	sp, #8
200033d8:	af00      	add	r7, sp, #0
200033da:	6078      	str	r0, [r7, #4]
    cfe_clocks_per_tick = CFE_CLOCKSPERTICK(cpu_speed);
200033dc:	687b      	ldr	r3, [r7, #4]
200033de:	4a1e      	ldr	r2, [pc, #120]	@ (20003458 <cfe_timer_init+0x84>)
200033e0:	fba2 2303 	umull	r2, r3, r2, r3
200033e4:	08db      	lsrs	r3, r3, #3
200033e6:	4a1d      	ldr	r2, [pc, #116]	@ (2000345c <cfe_timer_init+0x88>)
200033e8:	6013      	str	r3, [r2, #0]
    cfe_clocks_per_Kns = CFE_CLOCKSPERKNS(cpu_speed);
200033ea:	687b      	ldr	r3, [r7, #4]
200033ec:	4a1c      	ldr	r2, [pc, #112]	@ (20003460 <cfe_timer_init+0x8c>)
200033ee:	fba2 2303 	umull	r2, r3, r2, r3
200033f2:	0cdb      	lsrs	r3, r3, #19
200033f4:	4a1b      	ldr	r2, [pc, #108]	@ (20003464 <cfe_timer_init+0x90>)
200033f6:	6013      	str	r3, [r2, #0]
    if (cfe_clocks_per_Kns == 0)
200033f8:	4b1a      	ldr	r3, [pc, #104]	@ (20003464 <cfe_timer_init+0x90>)
200033fa:	681b      	ldr	r3, [r3, #0]
200033fc:	2b00      	cmp	r3, #0
200033fe:	d102      	bne.n	20003406 <cfe_timer_init+0x32>
	cfe_clocks_per_Kns = 1;    /* for the simulator */
20003400:	4b18      	ldr	r3, [pc, #96]	@ (20003464 <cfe_timer_init+0x90>)
20003402:	2201      	movs	r2, #1
20003404:	601a      	str	r2, [r3, #0]
    cfe_clocks_per_usec = CFE_CLOCKSPERUSEC(cpu_speed);
20003406:	687b      	ldr	r3, [r7, #4]
20003408:	4a17      	ldr	r2, [pc, #92]	@ (20003468 <cfe_timer_init+0x94>)
2000340a:	fba2 2303 	umull	r2, r3, r2, r3
2000340e:	0c9b      	lsrs	r3, r3, #18
20003410:	4a16      	ldr	r2, [pc, #88]	@ (2000346c <cfe_timer_init+0x98>)
20003412:	6013      	str	r3, [r2, #0]
    if (cfe_clocks_per_usec == 0)
20003414:	4b15      	ldr	r3, [pc, #84]	@ (2000346c <cfe_timer_init+0x98>)
20003416:	681b      	ldr	r3, [r3, #0]
20003418:	2b00      	cmp	r3, #0
2000341a:	d102      	bne.n	20003422 <cfe_timer_init+0x4e>
	cfe_clocks_per_usec = 1;    /* for the simulator */
2000341c:	4b13      	ldr	r3, [pc, #76]	@ (2000346c <cfe_timer_init+0x98>)
2000341e:	2201      	movs	r2, #1
20003420:	601a      	str	r2, [r3, #0]

    cfe_oldcount = _getticks();		/* get current COUNT register */
20003422:	f7ff ff6d 	bl	20003300 <_getticks>
20003426:	4603      	mov	r3, r0
20003428:	4a11      	ldr	r2, [pc, #68]	@ (20003470 <cfe_timer_init+0x9c>)
2000342a:	6013      	str	r3, [r2, #0]
    cfe_ticks = 0;
2000342c:	4911      	ldr	r1, [pc, #68]	@ (20003474 <cfe_timer_init+0xa0>)
2000342e:	f04f 0200 	mov.w	r2, #0
20003432:	f04f 0300 	mov.w	r3, #0
20003436:	e9c1 2300 	strd	r2, r3, [r1]

    if (!cfe_timer_initflg) {
2000343a:	4b0f      	ldr	r3, [pc, #60]	@ (20003478 <cfe_timer_init+0xa4>)
2000343c:	681b      	ldr	r3, [r3, #0]
2000343e:	2b00      	cmp	r3, #0
20003440:	d106      	bne.n	20003450 <cfe_timer_init+0x7c>
	cfe_bg_add(cfe_timer_task,NULL); /* add task for background polling */
20003442:	2100      	movs	r1, #0
20003444:	480d      	ldr	r0, [pc, #52]	@ (2000347c <cfe_timer_init+0xa8>)
20003446:	f7fe f91b 	bl	20001680 <cfe_bg_add>
	cfe_timer_initflg = 1;
2000344a:	4b0b      	ldr	r3, [pc, #44]	@ (20003478 <cfe_timer_init+0xa4>)
2000344c:	2201      	movs	r2, #1
2000344e:	601a      	str	r2, [r3, #0]
	}
}
20003450:	bf00      	nop
20003452:	3708      	adds	r7, #8
20003454:	46bd      	mov	sp, r7
20003456:	bd80      	pop	{r7, pc}
20003458:	cccccccd 	.word	0xcccccccd
2000345c:	20004d0c 	.word	0x20004d0c
20003460:	89705aa5 	.word	0x89705aa5
20003464:	20004d04 	.word	0x20004d04
20003468:	431bde83 	.word	0x431bde83
2000346c:	20004d08 	.word	0x20004d08
20003470:	20004d10 	.word	0x20004d10
20003474:	20004cf8 	.word	0x20004cf8
20003478:	20004d18 	.word	0x20004d18
2000347c:	20003315 	.word	0x20003315

20003480 <env_findenv>:
    *  Return value:
    *  	   cfe_envvar_t pointer, or NULL if not found
    ********************************************************************* */

static cfe_envvar_t *env_findenv(const char *name)
{
20003480:	b580      	push	{r7, lr}
20003482:	b084      	sub	sp, #16
20003484:	af00      	add	r7, sp, #0
20003486:	6078      	str	r0, [r7, #4]
    queue_t *qb;
    cfe_envvar_t *env;

    for (qb = env_envvars.q_next; qb != &env_envvars; qb = qb->q_next) {
20003488:	4b11      	ldr	r3, [pc, #68]	@ (200034d0 <env_findenv+0x50>)
2000348a:	681b      	ldr	r3, [r3, #0]
2000348c:	60fb      	str	r3, [r7, #12]
2000348e:	e00d      	b.n	200034ac <env_findenv+0x2c>
	env = (cfe_envvar_t *) qb;
20003490:	68fb      	ldr	r3, [r7, #12]
20003492:	60bb      	str	r3, [r7, #8]
	if (strcmp(env->name,name) == 0) break;
20003494:	68bb      	ldr	r3, [r7, #8]
20003496:	68db      	ldr	r3, [r3, #12]
20003498:	6879      	ldr	r1, [r7, #4]
2000349a:	4618      	mov	r0, r3
2000349c:	f7fd ff11 	bl	200012c2 <lib_strcmp>
200034a0:	4603      	mov	r3, r0
200034a2:	2b00      	cmp	r3, #0
200034a4:	d007      	beq.n	200034b6 <env_findenv+0x36>
    for (qb = env_envvars.q_next; qb != &env_envvars; qb = qb->q_next) {
200034a6:	68fb      	ldr	r3, [r7, #12]
200034a8:	681b      	ldr	r3, [r3, #0]
200034aa:	60fb      	str	r3, [r7, #12]
200034ac:	68fb      	ldr	r3, [r7, #12]
200034ae:	4a08      	ldr	r2, [pc, #32]	@ (200034d0 <env_findenv+0x50>)
200034b0:	4293      	cmp	r3, r2
200034b2:	d1ed      	bne.n	20003490 <env_findenv+0x10>
200034b4:	e000      	b.n	200034b8 <env_findenv+0x38>
	if (strcmp(env->name,name) == 0) break;
200034b6:	bf00      	nop
	}

    if (qb == &env_envvars) return NULL;
200034b8:	68fb      	ldr	r3, [r7, #12]
200034ba:	4a05      	ldr	r2, [pc, #20]	@ (200034d0 <env_findenv+0x50>)
200034bc:	4293      	cmp	r3, r2
200034be:	d101      	bne.n	200034c4 <env_findenv+0x44>
200034c0:	2300      	movs	r3, #0
200034c2:	e000      	b.n	200034c6 <env_findenv+0x46>

    return (cfe_envvar_t *) qb;
200034c4:	68fb      	ldr	r3, [r7, #12]

}
200034c6:	4618      	mov	r0, r3
200034c8:	3710      	adds	r7, #16
200034ca:	46bd      	mov	sp, r7
200034cc:	bd80      	pop	{r7, pc}
200034ce:	bf00      	nop
200034d0:	20004a9c 	.word	0x20004a9c

200034d4 <env_enum>:
    *  	   0 if ok
    *  	   else error code
    ********************************************************************* */

int env_enum(int idx,char *name,int *namelen,char *val,int *vallen)
{
200034d4:	b580      	push	{r7, lr}
200034d6:	b086      	sub	sp, #24
200034d8:	af00      	add	r7, sp, #0
200034da:	60f8      	str	r0, [r7, #12]
200034dc:	60b9      	str	r1, [r7, #8]
200034de:	607a      	str	r2, [r7, #4]
200034e0:	603b      	str	r3, [r7, #0]
    queue_t *qb;
    cfe_envvar_t *env;

    for (qb = env_envvars.q_next; qb != &env_envvars; qb = qb->q_next) {
200034e2:	4b1b      	ldr	r3, [pc, #108]	@ (20003550 <env_enum+0x7c>)
200034e4:	681b      	ldr	r3, [r3, #0]
200034e6:	617b      	str	r3, [r7, #20]
200034e8:	e008      	b.n	200034fc <env_enum+0x28>
	if (idx == 0) break;
200034ea:	68fb      	ldr	r3, [r7, #12]
200034ec:	2b00      	cmp	r3, #0
200034ee:	d00a      	beq.n	20003506 <env_enum+0x32>
	idx--;
200034f0:	68fb      	ldr	r3, [r7, #12]
200034f2:	3b01      	subs	r3, #1
200034f4:	60fb      	str	r3, [r7, #12]
    for (qb = env_envvars.q_next; qb != &env_envvars; qb = qb->q_next) {
200034f6:	697b      	ldr	r3, [r7, #20]
200034f8:	681b      	ldr	r3, [r3, #0]
200034fa:	617b      	str	r3, [r7, #20]
200034fc:	697b      	ldr	r3, [r7, #20]
200034fe:	4a14      	ldr	r2, [pc, #80]	@ (20003550 <env_enum+0x7c>)
20003500:	4293      	cmp	r3, r2
20003502:	d1f2      	bne.n	200034ea <env_enum+0x16>
20003504:	e000      	b.n	20003508 <env_enum+0x34>
	if (idx == 0) break;
20003506:	bf00      	nop
	}

    if (qb == &env_envvars) return CFE_ERR_ENVNOTFOUND;
20003508:	697b      	ldr	r3, [r7, #20]
2000350a:	4a11      	ldr	r2, [pc, #68]	@ (20003550 <env_enum+0x7c>)
2000350c:	4293      	cmp	r3, r2
2000350e:	d102      	bne.n	20003516 <env_enum+0x42>
20003510:	f06f 0308 	mvn.w	r3, #8
20003514:	e018      	b.n	20003548 <env_enum+0x74>
    env = (cfe_envvar_t *) qb;
20003516:	697b      	ldr	r3, [r7, #20]
20003518:	613b      	str	r3, [r7, #16]

    *namelen = xstrncpy(name,env->name,*namelen);
2000351a:	693b      	ldr	r3, [r7, #16]
2000351c:	68d9      	ldr	r1, [r3, #12]
2000351e:	687b      	ldr	r3, [r7, #4]
20003520:	681b      	ldr	r3, [r3, #0]
20003522:	461a      	mov	r2, r3
20003524:	68b8      	ldr	r0, [r7, #8]
20003526:	f7fd fe8a 	bl	2000123e <lib_xstrncpy>
2000352a:	4602      	mov	r2, r0
2000352c:	687b      	ldr	r3, [r7, #4]
2000352e:	601a      	str	r2, [r3, #0]
    *vallen  = xstrncpy(val,env->value,*vallen);
20003530:	693b      	ldr	r3, [r7, #16]
20003532:	6919      	ldr	r1, [r3, #16]
20003534:	6a3b      	ldr	r3, [r7, #32]
20003536:	681b      	ldr	r3, [r3, #0]
20003538:	461a      	mov	r2, r3
2000353a:	6838      	ldr	r0, [r7, #0]
2000353c:	f7fd fe7f 	bl	2000123e <lib_xstrncpy>
20003540:	4602      	mov	r2, r0
20003542:	6a3b      	ldr	r3, [r7, #32]
20003544:	601a      	str	r2, [r3, #0]

    return 0;
20003546:	2300      	movs	r3, #0

}
20003548:	4618      	mov	r0, r3
2000354a:	3718      	adds	r7, #24
2000354c:	46bd      	mov	sp, r7
2000354e:	bd80      	pop	{r7, pc}
20003550:	20004a9c 	.word	0x20004a9c

20003554 <env_envtype>:
    *  	   
    *  Return value:
    *  	   flags, or <0 if error occured
    ********************************************************************* */
int env_envtype(const char *name)
{
20003554:	b580      	push	{r7, lr}
20003556:	b084      	sub	sp, #16
20003558:	af00      	add	r7, sp, #0
2000355a:	6078      	str	r0, [r7, #4]
    cfe_envvar_t *env;

    env = env_findenv(name);
2000355c:	6878      	ldr	r0, [r7, #4]
2000355e:	f7ff ff8f 	bl	20003480 <env_findenv>
20003562:	60f8      	str	r0, [r7, #12]

    if (env) {
20003564:	68fb      	ldr	r3, [r7, #12]
20003566:	2b00      	cmp	r3, #0
20003568:	d002      	beq.n	20003570 <env_envtype+0x1c>
	return env->flags;
2000356a:	68fb      	ldr	r3, [r7, #12]
2000356c:	689b      	ldr	r3, [r3, #8]
2000356e:	e001      	b.n	20003574 <env_envtype+0x20>
	}

    return CFE_ERR_ENVNOTFOUND;
20003570:	f06f 0308 	mvn.w	r3, #8
}
20003574:	4618      	mov	r0, r3
20003576:	3710      	adds	r7, #16
20003578:	46bd      	mov	sp, r7
2000357a:	bd80      	pop	{r7, pc}

2000357c <env_delenv>:
    *  	   0 if ok
    *  	   else error code
    ********************************************************************* */

int env_delenv(const char *name)
{
2000357c:	b580      	push	{r7, lr}
2000357e:	b084      	sub	sp, #16
20003580:	af00      	add	r7, sp, #0
20003582:	6078      	str	r0, [r7, #4]
    cfe_envvar_t *env;

    env = env_findenv(name);
20003584:	6878      	ldr	r0, [r7, #4]
20003586:	f7ff ff7b 	bl	20003480 <env_findenv>
2000358a:	60f8      	str	r0, [r7, #12]

    if (!env) return 0;
2000358c:	68fb      	ldr	r3, [r7, #12]
2000358e:	2b00      	cmp	r3, #0
20003590:	d101      	bne.n	20003596 <env_delenv+0x1a>
20003592:	2300      	movs	r3, #0
20003594:	e010      	b.n	200035b8 <env_delenv+0x3c>

    if (!(env->flags & ENV_FLG_READONLY)) {
20003596:	68fb      	ldr	r3, [r7, #12]
20003598:	689b      	ldr	r3, [r3, #8]
2000359a:	f003 0302 	and.w	r3, r3, #2
2000359e:	2b00      	cmp	r3, #0
200035a0:	d108      	bne.n	200035b4 <env_delenv+0x38>
	q_dequeue((queue_t *) env);
200035a2:	68f8      	ldr	r0, [r7, #12]
200035a4:	f7fd fddf 	bl	20001166 <q_dequeue>
	KFREE(env);
200035a8:	68f9      	ldr	r1, [r7, #12]
200035aa:	4805      	ldr	r0, [pc, #20]	@ (200035c0 <env_delenv+0x44>)
200035ac:	f7fd fcce 	bl	20000f4c <kfree>
	return 0;
200035b0:	2300      	movs	r3, #0
200035b2:	e001      	b.n	200035b8 <env_delenv+0x3c>
	}

    return CFE_ERR_ENVNOTFOUND;
200035b4:	f06f 0308 	mvn.w	r3, #8
}
200035b8:	4618      	mov	r0, r3
200035ba:	3710      	adds	r7, #16
200035bc:	46bd      	mov	sp, r7
200035be:	bd80      	pop	{r7, pc}
200035c0:	20004ab4 	.word	0x20004ab4

200035c4 <env_getenv>:
    *  Return value:
    *  	   value, or NULL if variable is not found
    ********************************************************************* */

char *env_getenv(const char *name)
{
200035c4:	b580      	push	{r7, lr}
200035c6:	b084      	sub	sp, #16
200035c8:	af00      	add	r7, sp, #0
200035ca:	6078      	str	r0, [r7, #4]
    cfe_envvar_t *env;

    env = env_findenv(name);
200035cc:	6878      	ldr	r0, [r7, #4]
200035ce:	f7ff ff57 	bl	20003480 <env_findenv>
200035d2:	60f8      	str	r0, [r7, #12]

    if (env) {
200035d4:	68fb      	ldr	r3, [r7, #12]
200035d6:	2b00      	cmp	r3, #0
200035d8:	d002      	beq.n	200035e0 <env_getenv+0x1c>
	return env->value;
200035da:	68fb      	ldr	r3, [r7, #12]
200035dc:	691b      	ldr	r3, [r3, #16]
200035de:	e000      	b.n	200035e2 <env_getenv+0x1e>
	}

    return NULL;
200035e0:	2300      	movs	r3, #0
}
200035e2:	4618      	mov	r0, r3
200035e4:	3710      	adds	r7, #16
200035e6:	46bd      	mov	sp, r7
200035e8:	bd80      	pop	{r7, pc}
	...

200035ec <env_setenv>:
    *  	   0 if ok
    *  	   else error code
    ********************************************************************* */

int env_setenv(const char *name,char *value,int flags)
{
200035ec:	b580      	push	{r7, lr}
200035ee:	b086      	sub	sp, #24
200035f0:	af00      	add	r7, sp, #0
200035f2:	60f8      	str	r0, [r7, #12]
200035f4:	60b9      	str	r1, [r7, #8]
200035f6:	607a      	str	r2, [r7, #4]
    cfe_envvar_t *env;
    int namelen;

    env = env_findenv(name);
200035f8:	68f8      	ldr	r0, [r7, #12]
200035fa:	f7ff ff41 	bl	20003480 <env_findenv>
200035fe:	6178      	str	r0, [r7, #20]
    if (env) {
20003600:	697b      	ldr	r3, [r7, #20]
20003602:	2b00      	cmp	r3, #0
20003604:	d014      	beq.n	20003630 <env_setenv+0x44>
	if (!(flags & ENV_FLG_ADMIN)) {
20003606:	687b      	ldr	r3, [r7, #4]
20003608:	f403 7380 	and.w	r3, r3, #256	@ 0x100
2000360c:	2b00      	cmp	r3, #0
2000360e:	d108      	bne.n	20003622 <env_setenv+0x36>
	    if (env->flags & ENV_FLG_READONLY) return CFE_ERR_ENVREADONLY;
20003610:	697b      	ldr	r3, [r7, #20]
20003612:	689b      	ldr	r3, [r3, #8]
20003614:	f003 0302 	and.w	r3, r3, #2
20003618:	2b00      	cmp	r3, #0
2000361a:	d002      	beq.n	20003622 <env_setenv+0x36>
2000361c:	f06f 0309 	mvn.w	r3, #9
20003620:	e03f      	b.n	200036a2 <env_setenv+0xb6>
	    }
	q_dequeue((queue_t *) env);
20003622:	6978      	ldr	r0, [r7, #20]
20003624:	f7fd fd9f 	bl	20001166 <q_dequeue>
	KFREE(env);
20003628:	6979      	ldr	r1, [r7, #20]
2000362a:	4820      	ldr	r0, [pc, #128]	@ (200036ac <env_setenv+0xc0>)
2000362c:	f7fd fc8e 	bl	20000f4c <kfree>
	}

    namelen = strlen(name);
20003630:	68f8      	ldr	r0, [r7, #12]
20003632:	f7fd fe2e 	bl	20001292 <lib_strlen>
20003636:	6138      	str	r0, [r7, #16]

    env = KMALLOC(sizeof(cfe_envvar_t) + namelen + 1 + strlen(value) + 1,0);
20003638:	68b8      	ldr	r0, [r7, #8]
2000363a:	f7fd fe2a 	bl	20001292 <lib_strlen>
2000363e:	4603      	mov	r3, r0
20003640:	461a      	mov	r2, r3
20003642:	693b      	ldr	r3, [r7, #16]
20003644:	4413      	add	r3, r2
20003646:	3316      	adds	r3, #22
20003648:	2200      	movs	r2, #0
2000364a:	4619      	mov	r1, r3
2000364c:	4817      	ldr	r0, [pc, #92]	@ (200036ac <env_setenv+0xc0>)
2000364e:	f7fd fcb1 	bl	20000fb4 <kmalloc>
20003652:	6178      	str	r0, [r7, #20]
    if (!env) return CFE_ERR_NOMEM;
20003654:	697b      	ldr	r3, [r7, #20]
20003656:	2b00      	cmp	r3, #0
20003658:	d102      	bne.n	20003660 <env_setenv+0x74>
2000365a:	f06f 0304 	mvn.w	r3, #4
2000365e:	e020      	b.n	200036a2 <env_setenv+0xb6>

    env->name = (char *) (env+1);
20003660:	697b      	ldr	r3, [r7, #20]
20003662:	f103 0214 	add.w	r2, r3, #20
20003666:	697b      	ldr	r3, [r7, #20]
20003668:	60da      	str	r2, [r3, #12]
    env->value = env->name + namelen + 1;
2000366a:	697b      	ldr	r3, [r7, #20]
2000366c:	68da      	ldr	r2, [r3, #12]
2000366e:	693b      	ldr	r3, [r7, #16]
20003670:	3301      	adds	r3, #1
20003672:	441a      	add	r2, r3
20003674:	697b      	ldr	r3, [r7, #20]
20003676:	611a      	str	r2, [r3, #16]
    env->flags = (flags & ENV_FLG_MASK);
20003678:	687b      	ldr	r3, [r7, #4]
2000367a:	b2da      	uxtb	r2, r3
2000367c:	697b      	ldr	r3, [r7, #20]
2000367e:	609a      	str	r2, [r3, #8]

    strcpy(env->name,name);
20003680:	697b      	ldr	r3, [r7, #20]
20003682:	68db      	ldr	r3, [r3, #12]
20003684:	68f9      	ldr	r1, [r7, #12]
20003686:	4618      	mov	r0, r3
20003688:	f7fd fdbb 	bl	20001202 <lib_strcpy>
    strcpy(env->value,value);
2000368c:	697b      	ldr	r3, [r7, #20]
2000368e:	691b      	ldr	r3, [r3, #16]
20003690:	68b9      	ldr	r1, [r7, #8]
20003692:	4618      	mov	r0, r3
20003694:	f7fd fdb5 	bl	20001202 <lib_strcpy>

    q_enqueue(&env_envvars,(queue_t *) env);
20003698:	6979      	ldr	r1, [r7, #20]
2000369a:	4805      	ldr	r0, [pc, #20]	@ (200036b0 <env_setenv+0xc4>)
2000369c:	f7fd fd4a 	bl	20001134 <q_enqueue>

    return 0;
200036a0:	2300      	movs	r3, #0
}
200036a2:	4618      	mov	r0, r3
200036a4:	3718      	adds	r7, #24
200036a6:	46bd      	mov	sp, r7
200036a8:	bd80      	pop	{r7, pc}
200036aa:	bf00      	nop
200036ac:	20004ab4 	.word	0x20004ab4
200036b0:	20004a9c 	.word	0x20004a9c

200036b4 <env_save>:
    *  Return value:
    *  	   0 if ok, else error code
    ********************************************************************* */

int env_save(void)
{
200036b4:	b480      	push	{r7}
200036b6:	af00      	add	r7, sp, #0
   return 0;
200036b8:	2300      	movs	r3, #0

}
200036ba:	4618      	mov	r0, r3
200036bc:	46bd      	mov	sp, r7
200036be:	f85d 7b04 	ldr.w	r7, [sp], #4
200036c2:	4770      	bx	lr

200036c4 <ui_do_one_command>:
    *  	   return value from CFE UI function
    ********************************************************************* */


static int ui_do_one_command(queue_t *head)
{
200036c4:	b590      	push	{r4, r7, lr}
200036c6:	b0fb      	sub	sp, #492	@ 0x1ec
200036c8:	af00      	add	r7, sp, #0
200036ca:	f507 73f4 	add.w	r3, r7, #488	@ 0x1e8
200036ce:	f5a3 73f2 	sub.w	r3, r3, #484	@ 0x1e4
200036d2:	6018      	str	r0, [r3, #0]
    int res;
    ui_cmdline_t cmd;

    res = cmd_lookup(head, &cmd);
200036d4:	f107 0208 	add.w	r2, r7, #8
200036d8:	f507 73f4 	add.w	r3, r7, #488	@ 0x1e8
200036dc:	f5a3 73f2 	sub.w	r3, r3, #484	@ 0x1e4
200036e0:	4611      	mov	r1, r2
200036e2:	6818      	ldr	r0, [r3, #0]
200036e4:	f000 fb26 	bl	20003d34 <cmd_lookup>
200036e8:	f8c7 01e4 	str.w	r0, [r7, #484]	@ 0x1e4

    if (res == 0) {
200036ec:	f8d7 31e4 	ldr.w	r3, [r7, #484]	@ 0x1e4
200036f0:	2b00      	cmp	r3, #0
200036f2:	d144      	bne.n	2000377e <ui_do_one_command+0xba>

	res = cmd_sw_validate(&cmd,cmd.switches);
200036f4:	f507 73f4 	add.w	r3, r7, #488	@ 0x1e8
200036f8:	f5a3 73f0 	sub.w	r3, r3, #480	@ 0x1e0
200036fc:	f8d3 21d8 	ldr.w	r2, [r3, #472]	@ 0x1d8
20003700:	f107 0308 	add.w	r3, r7, #8
20003704:	4611      	mov	r1, r2
20003706:	4618      	mov	r0, r3
20003708:	f000 f948 	bl	2000399c <cmd_sw_validate>
2000370c:	f8c7 01e4 	str.w	r0, [r7, #484]	@ 0x1e4
	if (res != -1) {
20003710:	f8d7 31e4 	ldr.w	r3, [r7, #484]	@ 0x1e4
20003714:	f1b3 3fff 	cmp.w	r3, #4294967295	@ 0xffffffff
20003718:	d00e      	beq.n	20003738 <ui_do_one_command+0x74>
	    printf("Invalid switch: %s\n",
2000371a:	f107 0308 	add.w	r3, r7, #8
2000371e:	f8d7 11e4 	ldr.w	r1, [r7, #484]	@ 0x1e4
20003722:	4618      	mov	r0, r3
20003724:	f000 f8da 	bl	200038dc <cmd_sw_name>
20003728:	4603      	mov	r3, r0
2000372a:	4619      	mov	r1, r3
2000372c:	481a      	ldr	r0, [pc, #104]	@ (20003798 <ui_do_one_command+0xd4>)
2000372e:	f7fd fa7b 	bl	20000c28 <printf>
		    cmd_sw_name(&cmd,res));
	    return CFE_ERR_INV_PARAM;
20003732:	f06f 0307 	mvn.w	r3, #7
20003736:	e029      	b.n	2000378c <ui_do_one_command+0xc8>
	    }

//	if (lib_setjmp(ui_jmpbuf) != 0) return -1;
	res = (*cmd.func)(&cmd,cmd.argc-cmd.argidx,
20003738:	f507 73f4 	add.w	r3, r7, #488	@ 0x1e8
2000373c:	f5a3 73f0 	sub.w	r3, r3, #480	@ 0x1e0
20003740:	f8d3 31c8 	ldr.w	r3, [r3, #456]	@ 0x1c8
20003744:	f507 72f4 	add.w	r2, r7, #488	@ 0x1e8
20003748:	f5a2 72f0 	sub.w	r2, r2, #480	@ 0x1e0
2000374c:	6811      	ldr	r1, [r2, #0]
2000374e:	f507 72f4 	add.w	r2, r7, #488	@ 0x1e8
20003752:	f5a2 72f0 	sub.w	r2, r2, #480	@ 0x1e0
20003756:	f8d2 21cc 	ldr.w	r2, [r2, #460]	@ 0x1cc
2000375a:	1a8c      	subs	r4, r1, r2
		    &(cmd.argv[cmd.argidx]));
2000375c:	f507 72f4 	add.w	r2, r7, #488	@ 0x1e8
20003760:	f5a2 72f0 	sub.w	r2, r2, #480	@ 0x1e0
20003764:	f8d2 21cc 	ldr.w	r2, [r2, #460]	@ 0x1cc
	res = (*cmd.func)(&cmd,cmd.argc-cmd.argidx,
20003768:	f107 0108 	add.w	r1, r7, #8
2000376c:	0092      	lsls	r2, r2, #2
2000376e:	440a      	add	r2, r1
20003770:	3204      	adds	r2, #4
20003772:	f107 0008 	add.w	r0, r7, #8
20003776:	4621      	mov	r1, r4
20003778:	4798      	blx	r3
2000377a:	f8c7 01e4 	str.w	r0, [r7, #484]	@ 0x1e4
	}
    cmd_free(&cmd);
2000377e:	f107 0308 	add.w	r3, r7, #8
20003782:	4618      	mov	r0, r3
20003784:	f000 f8ca 	bl	2000391c <cmd_free>
    return res;
20003788:	f8d7 31e4 	ldr.w	r3, [r7, #484]	@ 0x1e4
}
2000378c:	4618      	mov	r0, r3
2000378e:	f507 77f6 	add.w	r7, r7, #492	@ 0x1ec
20003792:	46bd      	mov	sp, r7
20003794:	bd90      	pop	{r4, r7, pc}
20003796:	bf00      	nop
20003798:	20004634 	.word	0x20004634

2000379c <ui_docommands_internal>:
    *  	   
    *  Return value:
    *  	   exit status of first command that failed, or null
    ********************************************************************* */
static int ui_docommands_internal(queue_t *head)
{
2000379c:	b580      	push	{r7, lr}
2000379e:	b088      	sub	sp, #32
200037a0:	af00      	add	r7, sp, #0
200037a2:	6078      	str	r0, [r7, #4]
    queue_t cmdqueue;
    ui_command_t *cmd;
    int status = CMD_ERR_BLANK;
200037a4:	f06f 0302 	mvn.w	r3, #2
200037a8:	61fb      	str	r3, [r7, #28]
    int term;

    q_init(&cmdqueue);
200037aa:	f107 030c 	add.w	r3, r7, #12
200037ae:	613b      	str	r3, [r7, #16]
200037b0:	f107 030c 	add.w	r3, r7, #12
200037b4:	60fb      	str	r3, [r7, #12]

    /*
     * Find all the individual commands
     */

    while ((cmd = cmd_readcommand(head))) {
200037b6:	e00b      	b.n	200037d0 <ui_docommands_internal+0x34>

	if (cmd == NULL) {
200037b8:	69bb      	ldr	r3, [r7, #24]
200037ba:	2b00      	cmp	r3, #0
200037bc:	d102      	bne.n	200037c4 <ui_docommands_internal+0x28>
	    return CMD_ERR_BLANK;
200037be:	f06f 0302 	mvn.w	r3, #2
200037c2:	e04d      	b.n	20003860 <ui_docommands_internal+0xc4>
	    }

	q_enqueue(&cmdqueue,(queue_t *) cmd);
200037c4:	f107 030c 	add.w	r3, r7, #12
200037c8:	69b9      	ldr	r1, [r7, #24]
200037ca:	4618      	mov	r0, r3
200037cc:	f7fd fcb2 	bl	20001134 <q_enqueue>
    while ((cmd = cmd_readcommand(head))) {
200037d0:	6878      	ldr	r0, [r7, #4]
200037d2:	f000 fb73 	bl	20003ebc <cmd_readcommand>
200037d6:	61b8      	str	r0, [r7, #24]
200037d8:	69bb      	ldr	r3, [r7, #24]
200037da:	2b00      	cmp	r3, #0
200037dc:	d1ec      	bne.n	200037b8 <ui_docommands_internal+0x1c>

    /*
     * Do each command
     */

    while ((cmd = (ui_command_t *) q_deqnext(&(cmdqueue)))) {
200037de:	e01e      	b.n	2000381e <ui_docommands_internal+0x82>
	status = ui_do_one_command(&(cmd->head));
200037e0:	69bb      	ldr	r3, [r7, #24]
200037e2:	3310      	adds	r3, #16
200037e4:	4618      	mov	r0, r3
200037e6:	f7ff ff6d 	bl	200036c4 <ui_do_one_command>
200037ea:	61f8      	str	r0, [r7, #28]
	term = cmd->term;
200037ec:	69bb      	ldr	r3, [r7, #24]
200037ee:	689b      	ldr	r3, [r3, #8]
200037f0:	617b      	str	r3, [r7, #20]
	KFREE(cmd);
200037f2:	69b9      	ldr	r1, [r7, #24]
200037f4:	481c      	ldr	r0, [pc, #112]	@ (20003868 <ui_docommands_internal+0xcc>)
200037f6:	f7fd fba9 	bl	20000f4c <kfree>
	if (status == CMD_ERR_BLANK) continue;
200037fa:	69fb      	ldr	r3, [r7, #28]
200037fc:	f113 0f03 	cmn.w	r3, #3
20003800:	d00c      	beq.n	2000381c <ui_docommands_internal+0x80>

	/*
	 * And causes us to stop at the first failure.
	 */
	if ((term == CMD_TERM_AND) && (status != 0)) break;
20003802:	697b      	ldr	r3, [r7, #20]
20003804:	2b02      	cmp	r3, #2
20003806:	d102      	bne.n	2000380e <ui_docommands_internal+0x72>
20003808:	69fb      	ldr	r3, [r7, #28]
2000380a:	2b00      	cmp	r3, #0
2000380c:	d111      	bne.n	20003832 <ui_docommands_internal+0x96>

	/*
	 * OR causes us to stop at the first success.
	 */

	if ((term == CMD_TERM_OR) && (status == 0)) break;
2000380e:	697b      	ldr	r3, [r7, #20]
20003810:	2b03      	cmp	r3, #3
20003812:	d104      	bne.n	2000381e <ui_docommands_internal+0x82>
20003814:	69fb      	ldr	r3, [r7, #28]
20003816:	2b00      	cmp	r3, #0
20003818:	d00d      	beq.n	20003836 <ui_docommands_internal+0x9a>
2000381a:	e000      	b.n	2000381e <ui_docommands_internal+0x82>
	if (status == CMD_ERR_BLANK) continue;
2000381c:	bf00      	nop
    while ((cmd = (ui_command_t *) q_deqnext(&(cmdqueue)))) {
2000381e:	f107 030c 	add.w	r3, r7, #12
20003822:	4618      	mov	r0, r3
20003824:	f7fd fcb3 	bl	2000118e <q_deqnext>
20003828:	61b8      	str	r0, [r7, #24]
2000382a:	69bb      	ldr	r3, [r7, #24]
2000382c:	2b00      	cmp	r3, #0
2000382e:	d1d7      	bne.n	200037e0 <ui_docommands_internal+0x44>
20003830:	e00c      	b.n	2000384c <ui_docommands_internal+0xb0>
	if ((term == CMD_TERM_AND) && (status != 0)) break;
20003832:	bf00      	nop
20003834:	e00a      	b.n	2000384c <ui_docommands_internal+0xb0>
	if ((term == CMD_TERM_OR) && (status == 0)) break;
20003836:	bf00      	nop

    /*
     * Free any remaining tokens and commands that we did not do
     */

    while ((cmd = (ui_command_t *) q_deqnext(&(cmdqueue)))) {
20003838:	e008      	b.n	2000384c <ui_docommands_internal+0xb0>
	cmd_free_tokens(&(cmd->head));
2000383a:	69bb      	ldr	r3, [r7, #24]
2000383c:	3310      	adds	r3, #16
2000383e:	4618      	mov	r0, r3
20003840:	f000 fdf4 	bl	2000442c <cmd_free_tokens>
	KFREE(cmd);
20003844:	69b9      	ldr	r1, [r7, #24]
20003846:	4808      	ldr	r0, [pc, #32]	@ (20003868 <ui_docommands_internal+0xcc>)
20003848:	f7fd fb80 	bl	20000f4c <kfree>
    while ((cmd = (ui_command_t *) q_deqnext(&(cmdqueue)))) {
2000384c:	f107 030c 	add.w	r3, r7, #12
20003850:	4618      	mov	r0, r3
20003852:	f7fd fc9c 	bl	2000118e <q_deqnext>
20003856:	61b8      	str	r0, [r7, #24]
20003858:	69bb      	ldr	r3, [r7, #24]
2000385a:	2b00      	cmp	r3, #0
2000385c:	d1ed      	bne.n	2000383a <ui_docommands_internal+0x9e>
	}

    return status;
2000385e:	69fb      	ldr	r3, [r7, #28]
}
20003860:	4618      	mov	r0, r3
20003862:	3720      	adds	r7, #32
20003864:	46bd      	mov	sp, r7
20003866:	bd80      	pop	{r7, pc}
20003868:	20004ab4 	.word	0x20004ab4

2000386c <ui_docommands>:
    *  	   return value of failing command, or 0 if all commands
    *  	   succeeded
    ********************************************************************* */

int ui_docommands(char *str)
{
2000386c:	b580      	push	{r7, lr}
2000386e:	b086      	sub	sp, #24
20003870:	af00      	add	r7, sp, #0
20003872:	6078      	str	r0, [r7, #4]
    queue_t cmd_list;
    int res;

    /* Convert the command into a token list */
    cmd_build_list(&cmd_list,str);
20003874:	f107 030c 	add.w	r3, r7, #12
20003878:	6879      	ldr	r1, [r7, #4]
2000387a:	4618      	mov	r0, r3
2000387c:	f000 fbca 	bl	20004014 <cmd_build_list>

    /* Walk the list and expand environment variables */
    cmd_walk_and_expand(&cmd_list);
20003880:	f107 030c 	add.w	r3, r7, #12
20003884:	4618      	mov	r0, r3
20003886:	f000 fd47 	bl	20004318 <cmd_walk_and_expand>

    /* Process each command.  This removes tokens from the list */
    res = ui_docommands_internal(&cmd_list);
2000388a:	f107 030c 	add.w	r3, r7, #12
2000388e:	4618      	mov	r0, r3
20003890:	f7ff ff84 	bl	2000379c <ui_docommands_internal>
20003894:	6178      	str	r0, [r7, #20]

    /* Free any leftover tokens.  There should not be any. */
    cmd_free_tokens(&cmd_list);
20003896:	f107 030c 	add.w	r3, r7, #12
2000389a:	4618      	mov	r0, r3
2000389c:	f000 fdc6 	bl	2000442c <cmd_free_tokens>

    return res;
200038a0:	697b      	ldr	r3, [r7, #20]
}
200038a2:	4618      	mov	r0, r3
200038a4:	3718      	adds	r7, #24
200038a6:	46bd      	mov	sp, r7
200038a8:	bd80      	pop	{r7, pc}
	...

200038ac <is_white_space>:

static char *cmd_eat_quoted_arg(queue_t *head,ui_token_t *t);


static inline int is_white_space(ui_token_t *t) 
{
200038ac:	b580      	push	{r7, lr}
200038ae:	b082      	sub	sp, #8
200038b0:	af00      	add	r7, sp, #0
200038b2:	6078      	str	r0, [r7, #4]
    return (strchr(spacechars,t->token) != NULL);
200038b4:	4b08      	ldr	r3, [pc, #32]	@ (200038d8 <is_white_space+0x2c>)
200038b6:	681a      	ldr	r2, [r3, #0]
200038b8:	687b      	ldr	r3, [r7, #4]
200038ba:	7a1b      	ldrb	r3, [r3, #8]
200038bc:	4619      	mov	r1, r3
200038be:	4610      	mov	r0, r2
200038c0:	f7fd fd40 	bl	20001344 <lib_strchr>
200038c4:	4603      	mov	r3, r0
200038c6:	2b00      	cmp	r3, #0
200038c8:	bf14      	ite	ne
200038ca:	2301      	movne	r3, #1
200038cc:	2300      	moveq	r3, #0
200038ce:	b2db      	uxtb	r3, r3
}
200038d0:	4618      	mov	r0, r3
200038d2:	3708      	adds	r7, #8
200038d4:	46bd      	mov	sp, r7
200038d6:	bd80      	pop	{r7, pc}
200038d8:	20004aa8 	.word	0x20004aa8

200038dc <cmd_sw_name>:

    return -1;
}

char *cmd_sw_name(ui_cmdline_t *cmd,int swidx)
{
200038dc:	b480      	push	{r7}
200038de:	b083      	sub	sp, #12
200038e0:	af00      	add	r7, sp, #0
200038e2:	6078      	str	r0, [r7, #4]
200038e4:	6039      	str	r1, [r7, #0]
    if ((swidx < 0) || (swidx >= cmd->swc)) return NULL;
200038e6:	683b      	ldr	r3, [r7, #0]
200038e8:	2b00      	cmp	r3, #0
200038ea:	db05      	blt.n	200038f8 <cmd_sw_name+0x1c>
200038ec:	687b      	ldr	r3, [r7, #4]
200038ee:	f8d3 3104 	ldr.w	r3, [r3, #260]	@ 0x104
200038f2:	683a      	ldr	r2, [r7, #0]
200038f4:	429a      	cmp	r2, r3
200038f6:	db01      	blt.n	200038fc <cmd_sw_name+0x20>
200038f8:	2300      	movs	r3, #0
200038fa:	e009      	b.n	20003910 <cmd_sw_name+0x34>

    return cmd->swv[swidx].swname;
200038fc:	6879      	ldr	r1, [r7, #4]
200038fe:	683a      	ldr	r2, [r7, #0]
20003900:	4613      	mov	r3, r2
20003902:	005b      	lsls	r3, r3, #1
20003904:	4413      	add	r3, r2
20003906:	009b      	lsls	r3, r3, #2
20003908:	440b      	add	r3, r1
2000390a:	f503 7386 	add.w	r3, r3, #268	@ 0x10c
2000390e:	681b      	ldr	r3, [r3, #0]
}
20003910:	4618      	mov	r0, r3
20003912:	370c      	adds	r7, #12
20003914:	46bd      	mov	sp, r7
20003916:	f85d 7b04 	ldr.w	r7, [sp], #4
2000391a:	4770      	bx	lr

2000391c <cmd_free>:
    if ((argnum < 0) || (argnum >= cmd->argc)) return NULL;
    return cmd->argv[argnum];
}

void cmd_free(ui_cmdline_t *cmd)
{
2000391c:	b580      	push	{r7, lr}
2000391e:	b084      	sub	sp, #16
20003920:	af00      	add	r7, sp, #0
20003922:	6078      	str	r0, [r7, #4]
    int idx;

    for (idx = 0; idx < cmd->argc; idx++) {
20003924:	2300      	movs	r3, #0
20003926:	60fb      	str	r3, [r7, #12]
20003928:	e00b      	b.n	20003942 <cmd_free+0x26>
	KFREE(cmd->argv[idx]);
2000392a:	687a      	ldr	r2, [r7, #4]
2000392c:	68fb      	ldr	r3, [r7, #12]
2000392e:	009b      	lsls	r3, r3, #2
20003930:	4413      	add	r3, r2
20003932:	685b      	ldr	r3, [r3, #4]
20003934:	4619      	mov	r1, r3
20003936:	4818      	ldr	r0, [pc, #96]	@ (20003998 <cmd_free+0x7c>)
20003938:	f7fd fb08 	bl	20000f4c <kfree>
    for (idx = 0; idx < cmd->argc; idx++) {
2000393c:	68fb      	ldr	r3, [r7, #12]
2000393e:	3301      	adds	r3, #1
20003940:	60fb      	str	r3, [r7, #12]
20003942:	687b      	ldr	r3, [r7, #4]
20003944:	681b      	ldr	r3, [r3, #0]
20003946:	68fa      	ldr	r2, [r7, #12]
20003948:	429a      	cmp	r2, r3
2000394a:	dbee      	blt.n	2000392a <cmd_free+0xe>
	}

    for (idx = 0; idx < cmd->swc; idx++) {
2000394c:	2300      	movs	r3, #0
2000394e:	60fb      	str	r3, [r7, #12]
20003950:	e010      	b.n	20003974 <cmd_free+0x58>
	KFREE(cmd->swv[idx].swname);
20003952:	6879      	ldr	r1, [r7, #4]
20003954:	68fa      	ldr	r2, [r7, #12]
20003956:	4613      	mov	r3, r2
20003958:	005b      	lsls	r3, r3, #1
2000395a:	4413      	add	r3, r2
2000395c:	009b      	lsls	r3, r3, #2
2000395e:	440b      	add	r3, r1
20003960:	f503 7386 	add.w	r3, r3, #268	@ 0x10c
20003964:	681b      	ldr	r3, [r3, #0]
20003966:	4619      	mov	r1, r3
20003968:	480b      	ldr	r0, [pc, #44]	@ (20003998 <cmd_free+0x7c>)
2000396a:	f7fd faef 	bl	20000f4c <kfree>
    for (idx = 0; idx < cmd->swc; idx++) {
2000396e:	68fb      	ldr	r3, [r7, #12]
20003970:	3301      	adds	r3, #1
20003972:	60fb      	str	r3, [r7, #12]
20003974:	687b      	ldr	r3, [r7, #4]
20003976:	f8d3 3104 	ldr.w	r3, [r3, #260]	@ 0x104
2000397a:	68fa      	ldr	r2, [r7, #12]
2000397c:	429a      	cmp	r2, r3
2000397e:	dbe8      	blt.n	20003952 <cmd_free+0x36>
	}

    cmd->argc = 0;
20003980:	687b      	ldr	r3, [r7, #4]
20003982:	2200      	movs	r2, #0
20003984:	601a      	str	r2, [r3, #0]
    cmd->swc = 0;
20003986:	687b      	ldr	r3, [r7, #4]
20003988:	2200      	movs	r2, #0
2000398a:	f8c3 2104 	str.w	r2, [r3, #260]	@ 0x104
}
2000398e:	bf00      	nop
20003990:	3710      	adds	r7, #16
20003992:	46bd      	mov	sp, r7
20003994:	bd80      	pop	{r7, pc}
20003996:	bf00      	nop
20003998:	20004ab4 	.word	0x20004ab4

2000399c <cmd_sw_validate>:

int cmd_sw_validate(ui_cmdline_t *cmd,char *validstr)
{
2000399c:	b580      	push	{r7, lr}
2000399e:	b08a      	sub	sp, #40	@ 0x28
200039a0:	af00      	add	r7, sp, #0
200039a2:	6078      	str	r0, [r7, #4]
200039a4:	6039      	str	r1, [r7, #0]
    char atype;
    char *x;
    int idx;
    int valid;

    if (cmd->swc == 0) return -1;
200039a6:	687b      	ldr	r3, [r7, #4]
200039a8:	f8d3 3104 	ldr.w	r3, [r3, #260]	@ 0x104
200039ac:	2b00      	cmp	r3, #0
200039ae:	d102      	bne.n	200039b6 <cmd_sw_validate+0x1a>
200039b0:	f04f 33ff 	mov.w	r3, #4294967295	@ 0xffffffff
200039b4:	e094      	b.n	20003ae0 <cmd_sw_validate+0x144>

    vdup = strdup(validstr);
200039b6:	6838      	ldr	r0, [r7, #0]
200039b8:	f7fd fd42 	bl	20001440 <lib_strdup>
200039bc:	6138      	str	r0, [r7, #16]

    for (idx = 0; idx < cmd->swc; idx++) {
200039be:	2300      	movs	r3, #0
200039c0:	61bb      	str	r3, [r7, #24]
200039c2:	e080      	b.n	20003ac6 <cmd_sw_validate+0x12a>
	vptr = vdup;
200039c4:	693b      	ldr	r3, [r7, #16]
200039c6:	627b      	str	r3, [r7, #36]	@ 0x24

	vnext = vptr;
200039c8:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
200039ca:	623b      	str	r3, [r7, #32]
	valid = 0;
200039cc:	2300      	movs	r3, #0
200039ce:	617b      	str	r3, [r7, #20]

	while (vnext) {
200039d0:	e06a      	b.n	20003aa8 <cmd_sw_validate+0x10c>

	    /*
	     * Eat the next switch description from the valid string
	     */
	    x = strchr(vptr,'|');
200039d2:	217c      	movs	r1, #124	@ 0x7c
200039d4:	6a78      	ldr	r0, [r7, #36]	@ 0x24
200039d6:	f7fd fcb5 	bl	20001344 <lib_strchr>
200039da:	60f8      	str	r0, [r7, #12]
	    if (x) {
200039dc:	68fb      	ldr	r3, [r7, #12]
200039de:	2b00      	cmp	r3, #0
200039e0:	d006      	beq.n	200039f0 <cmd_sw_validate+0x54>
		*x = '\0';
200039e2:	68fb      	ldr	r3, [r7, #12]
200039e4:	2200      	movs	r2, #0
200039e6:	701a      	strb	r2, [r3, #0]
		vnext = x+1;
200039e8:	68fb      	ldr	r3, [r7, #12]
200039ea:	3301      	adds	r3, #1
200039ec:	623b      	str	r3, [r7, #32]
200039ee:	e001      	b.n	200039f4 <cmd_sw_validate+0x58>
		}
	    else {
		vnext = NULL;
200039f0:	2300      	movs	r3, #0
200039f2:	623b      	str	r3, [r7, #32]
		}

	    /*
	     * Get the expected arg type, if any 
	     */
	    x = strchr(vptr,'=');
200039f4:	213d      	movs	r1, #61	@ 0x3d
200039f6:	6a78      	ldr	r0, [r7, #36]	@ 0x24
200039f8:	f7fd fca4 	bl	20001344 <lib_strchr>
200039fc:	60f8      	str	r0, [r7, #12]
	    if (x) {
200039fe:	68fb      	ldr	r3, [r7, #12]
20003a00:	2b00      	cmp	r3, #0
20003a02:	d006      	beq.n	20003a12 <cmd_sw_validate+0x76>
		atype = *(x+1);
20003a04:	68fb      	ldr	r3, [r7, #12]
20003a06:	785b      	ldrb	r3, [r3, #1]
20003a08:	77fb      	strb	r3, [r7, #31]
		*x = 0;
20003a0a:	68fb      	ldr	r3, [r7, #12]
20003a0c:	2200      	movs	r2, #0
20003a0e:	701a      	strb	r2, [r3, #0]
20003a10:	e00c      	b.n	20003a2c <cmd_sw_validate+0x90>
		}
	    else {
		if ((x = strchr(vptr,';'))) *x = 0;
20003a12:	213b      	movs	r1, #59	@ 0x3b
20003a14:	6a78      	ldr	r0, [r7, #36]	@ 0x24
20003a16:	f7fd fc95 	bl	20001344 <lib_strchr>
20003a1a:	60f8      	str	r0, [r7, #12]
20003a1c:	68fb      	ldr	r3, [r7, #12]
20003a1e:	2b00      	cmp	r3, #0
20003a20:	d002      	beq.n	20003a28 <cmd_sw_validate+0x8c>
20003a22:	68fb      	ldr	r3, [r7, #12]
20003a24:	2200      	movs	r2, #0
20003a26:	701a      	strb	r2, [r3, #0]
		atype = 0;
20003a28:	2300      	movs	r3, #0
20003a2a:	77fb      	strb	r3, [r7, #31]
	     * See if this matches what the user typed
	     * XXX for now, ignore the arg type processing but
	     * complain if an arg is missing.
	     */

	    if (strcmp(vptr,cmd->swv[idx].swname) == 0) {
20003a2c:	6879      	ldr	r1, [r7, #4]
20003a2e:	69ba      	ldr	r2, [r7, #24]
20003a30:	4613      	mov	r3, r2
20003a32:	005b      	lsls	r3, r3, #1
20003a34:	4413      	add	r3, r2
20003a36:	009b      	lsls	r3, r3, #2
20003a38:	440b      	add	r3, r1
20003a3a:	f503 7386 	add.w	r3, r3, #268	@ 0x10c
20003a3e:	681b      	ldr	r3, [r3, #0]
20003a40:	4619      	mov	r1, r3
20003a42:	6a78      	ldr	r0, [r7, #36]	@ 0x24
20003a44:	f7fd fc3d 	bl	200012c2 <lib_strcmp>
20003a48:	4603      	mov	r3, r0
20003a4a:	2b00      	cmp	r3, #0
20003a4c:	d126      	bne.n	20003a9c <cmd_sw_validate+0x100>
		/* Value not needed and not supplied */
		if ((atype == 0) && (cmd->swv[idx].swvalue == NULL)) {
20003a4e:	7ffb      	ldrb	r3, [r7, #31]
20003a50:	2b00      	cmp	r3, #0
20003a52:	d10d      	bne.n	20003a70 <cmd_sw_validate+0xd4>
20003a54:	6879      	ldr	r1, [r7, #4]
20003a56:	69ba      	ldr	r2, [r7, #24]
20003a58:	4613      	mov	r3, r2
20003a5a:	005b      	lsls	r3, r3, #1
20003a5c:	4413      	add	r3, r2
20003a5e:	009b      	lsls	r3, r3, #2
20003a60:	440b      	add	r3, r1
20003a62:	f503 7388 	add.w	r3, r3, #272	@ 0x110
20003a66:	681b      	ldr	r3, [r3, #0]
20003a68:	2b00      	cmp	r3, #0
20003a6a:	d101      	bne.n	20003a70 <cmd_sw_validate+0xd4>
		    valid = 1;
20003a6c:	2301      	movs	r3, #1
20003a6e:	617b      	str	r3, [r7, #20]
		    }
		/* value needed and supplied */
		if ((atype != 0) && (cmd->swv[idx].swvalue != NULL)) {
20003a70:	7ffb      	ldrb	r3, [r7, #31]
20003a72:	2b00      	cmp	r3, #0
20003a74:	d00d      	beq.n	20003a92 <cmd_sw_validate+0xf6>
20003a76:	6879      	ldr	r1, [r7, #4]
20003a78:	69ba      	ldr	r2, [r7, #24]
20003a7a:	4613      	mov	r3, r2
20003a7c:	005b      	lsls	r3, r3, #1
20003a7e:	4413      	add	r3, r2
20003a80:	009b      	lsls	r3, r3, #2
20003a82:	440b      	add	r3, r1
20003a84:	f503 7388 	add.w	r3, r3, #272	@ 0x110
20003a88:	681b      	ldr	r3, [r3, #0]
20003a8a:	2b00      	cmp	r3, #0
20003a8c:	d001      	beq.n	20003a92 <cmd_sw_validate+0xf6>
		    valid = 1;
20003a8e:	2301      	movs	r3, #1
20003a90:	617b      	str	r3, [r7, #20]
		    }
		strcpy(vdup,validstr);
20003a92:	6839      	ldr	r1, [r7, #0]
20003a94:	6938      	ldr	r0, [r7, #16]
20003a96:	f7fd fbb4 	bl	20001202 <lib_strcpy>
		break;
20003a9a:	e008      	b.n	20003aae <cmd_sw_validate+0x112>

	    /*
	     * Otherwise, next!
	     */

	    strcpy(vdup,validstr);
20003a9c:	6839      	ldr	r1, [r7, #0]
20003a9e:	6938      	ldr	r0, [r7, #16]
20003aa0:	f7fd fbaf 	bl	20001202 <lib_strcpy>
	    vptr = vnext;
20003aa4:	6a3b      	ldr	r3, [r7, #32]
20003aa6:	627b      	str	r3, [r7, #36]	@ 0x24
	while (vnext) {
20003aa8:	6a3b      	ldr	r3, [r7, #32]
20003aaa:	2b00      	cmp	r3, #0
20003aac:	d191      	bne.n	200039d2 <cmd_sw_validate+0x36>

	/*
	 * If not valid, return index of bad switch
	 */

	if (valid == 0) {
20003aae:	697b      	ldr	r3, [r7, #20]
20003ab0:	2b00      	cmp	r3, #0
20003ab2:	d105      	bne.n	20003ac0 <cmd_sw_validate+0x124>
	    KFREE(vdup);
20003ab4:	6939      	ldr	r1, [r7, #16]
20003ab6:	480c      	ldr	r0, [pc, #48]	@ (20003ae8 <cmd_sw_validate+0x14c>)
20003ab8:	f7fd fa48 	bl	20000f4c <kfree>
	    return idx;
20003abc:	69bb      	ldr	r3, [r7, #24]
20003abe:	e00f      	b.n	20003ae0 <cmd_sw_validate+0x144>
    for (idx = 0; idx < cmd->swc; idx++) {
20003ac0:	69bb      	ldr	r3, [r7, #24]
20003ac2:	3301      	adds	r3, #1
20003ac4:	61bb      	str	r3, [r7, #24]
20003ac6:	687b      	ldr	r3, [r7, #4]
20003ac8:	f8d3 3104 	ldr.w	r3, [r3, #260]	@ 0x104
20003acc:	69ba      	ldr	r2, [r7, #24]
20003ace:	429a      	cmp	r2, r3
20003ad0:	f6ff af78 	blt.w	200039c4 <cmd_sw_validate+0x28>
    /*
     * Return -1 if everything went well.  A little strange,
     * but it's easier this way.
     */

    KFREE(vdup);
20003ad4:	6939      	ldr	r1, [r7, #16]
20003ad6:	4804      	ldr	r0, [pc, #16]	@ (20003ae8 <cmd_sw_validate+0x14c>)
20003ad8:	f7fd fa38 	bl	20000f4c <kfree>
    return -1;
20003adc:	f04f 33ff 	mov.w	r3, #4294967295	@ 0xffffffff
}
20003ae0:	4618      	mov	r0, r3
20003ae2:	3728      	adds	r7, #40	@ 0x28
20003ae4:	46bd      	mov	sp, r7
20003ae6:	bd80      	pop	{r7, pc}
20003ae8:	20004ab4 	.word	0x20004ab4

20003aec <cmd_findword>:

static cmdtab_t *cmd_findword(cmdtab_t *list,char *cmdword)
{
20003aec:	b580      	push	{r7, lr}
20003aee:	b082      	sub	sp, #8
20003af0:	af00      	add	r7, sp, #0
20003af2:	6078      	str	r0, [r7, #4]
20003af4:	6039      	str	r1, [r7, #0]
    while (list) {
20003af6:	e00d      	b.n	20003b14 <cmd_findword+0x28>
	if (strcmp(cmdword,list->cmdword) == 0) return list;
20003af8:	687b      	ldr	r3, [r7, #4]
20003afa:	689b      	ldr	r3, [r3, #8]
20003afc:	4619      	mov	r1, r3
20003afe:	6838      	ldr	r0, [r7, #0]
20003b00:	f7fd fbdf 	bl	200012c2 <lib_strcmp>
20003b04:	4603      	mov	r3, r0
20003b06:	2b00      	cmp	r3, #0
20003b08:	d101      	bne.n	20003b0e <cmd_findword+0x22>
20003b0a:	687b      	ldr	r3, [r7, #4]
20003b0c:	e006      	b.n	20003b1c <cmd_findword+0x30>
	list = list->sibling;
20003b0e:	687b      	ldr	r3, [r7, #4]
20003b10:	681b      	ldr	r3, [r3, #0]
20003b12:	607b      	str	r3, [r7, #4]
    while (list) {
20003b14:	687b      	ldr	r3, [r7, #4]
20003b16:	2b00      	cmp	r3, #0
20003b18:	d1ee      	bne.n	20003af8 <cmd_findword+0xc>
	}

    return NULL;
20003b1a:	2300      	movs	r3, #0
}
20003b1c:	4618      	mov	r0, r3
20003b1e:	3708      	adds	r7, #8
20003b20:	46bd      	mov	sp, r7
20003b22:	bd80      	pop	{r7, pc}

20003b24 <cmd_build_cmdline>:


void cmd_build_cmdline(queue_t *head, ui_cmdline_t *cmd)
{
20003b24:	b590      	push	{r4, r7, lr}
20003b26:	b085      	sub	sp, #20
20003b28:	af00      	add	r7, sp, #0
20003b2a:	6078      	str	r0, [r7, #4]
20003b2c:	6039      	str	r1, [r7, #0]
    ui_token_t *t;
    ui_token_t *next;

    memset(cmd, 0, sizeof(ui_cmdline_t));
20003b2e:	f44f 72ee 	mov.w	r2, #476	@ 0x1dc
20003b32:	2100      	movs	r1, #0
20003b34:	6838      	ldr	r0, [r7, #0]
20003b36:	f7fd fc41 	bl	200013bc <lib_memset>

    t = (ui_token_t *) q_deqnext(head);
20003b3a:	6878      	ldr	r0, [r7, #4]
20003b3c:	f7fd fb27 	bl	2000118e <q_deqnext>
20003b40:	60f8      	str	r0, [r7, #12]

    while (t != NULL) {
20003b42:	e092      	b.n	20003c6a <cmd_build_cmdline+0x146>
	if (is_white_space(t)) {
20003b44:	68f8      	ldr	r0, [r7, #12]
20003b46:	f7ff feb1 	bl	200038ac <is_white_space>
20003b4a:	4603      	mov	r3, r0
20003b4c:	2b00      	cmp	r3, #0
20003b4e:	f040 8084 	bne.w	20003c5a <cmd_build_cmdline+0x136>
	    /* do nothing */
	    } 
	else if (t->token != '-') {
20003b52:	68fb      	ldr	r3, [r7, #12]
20003b54:	7a1b      	ldrb	r3, [r3, #8]
20003b56:	2b2d      	cmp	r3, #45	@ 0x2d
20003b58:	d014      	beq.n	20003b84 <cmd_build_cmdline+0x60>
	    if(cmd->argc < MAX_TOKENS){
20003b5a:	683b      	ldr	r3, [r7, #0]
20003b5c:	681b      	ldr	r3, [r3, #0]
20003b5e:	2b3f      	cmp	r3, #63	@ 0x3f
20003b60:	dc7b      	bgt.n	20003c5a <cmd_build_cmdline+0x136>
		cmd->argv[cmd->argc] = cmd_eat_quoted_arg(head,t);
20003b62:	683b      	ldr	r3, [r7, #0]
20003b64:	681c      	ldr	r4, [r3, #0]
20003b66:	68f9      	ldr	r1, [r7, #12]
20003b68:	6878      	ldr	r0, [r7, #4]
20003b6a:	f000 fb21 	bl	200041b0 <cmd_eat_quoted_arg>
20003b6e:	4601      	mov	r1, r0
20003b70:	683a      	ldr	r2, [r7, #0]
20003b72:	00a3      	lsls	r3, r4, #2
20003b74:	4413      	add	r3, r2
20003b76:	6059      	str	r1, [r3, #4]
		cmd->argc++;
20003b78:	683b      	ldr	r3, [r7, #0]
20003b7a:	681b      	ldr	r3, [r3, #0]
20003b7c:	1c5a      	adds	r2, r3, #1
20003b7e:	683b      	ldr	r3, [r7, #0]
20003b80:	601a      	str	r2, [r3, #0]
20003b82:	e06a      	b.n	20003c5a <cmd_build_cmdline+0x136>
		}
	    /* Token is a switch */
	    }
	else {
	    if (cmd->swc < MAX_SWITCHES) {
20003b84:	683b      	ldr	r3, [r7, #0]
20003b86:	f8d3 3104 	ldr.w	r3, [r3, #260]	@ 0x104
20003b8a:	2b0f      	cmp	r3, #15
20003b8c:	dc65      	bgt.n	20003c5a <cmd_build_cmdline+0x136>
		cmd->swv[cmd->swc].swname = lib_strdup(&(t->token));
20003b8e:	68fb      	ldr	r3, [r7, #12]
20003b90:	f103 0208 	add.w	r2, r3, #8
20003b94:	683b      	ldr	r3, [r7, #0]
20003b96:	f8d3 4104 	ldr.w	r4, [r3, #260]	@ 0x104
20003b9a:	4610      	mov	r0, r2
20003b9c:	f7fd fc50 	bl	20001440 <lib_strdup>
20003ba0:	4601      	mov	r1, r0
20003ba2:	683a      	ldr	r2, [r7, #0]
20003ba4:	4623      	mov	r3, r4
20003ba6:	005b      	lsls	r3, r3, #1
20003ba8:	4423      	add	r3, r4
20003baa:	009b      	lsls	r3, r3, #2
20003bac:	4413      	add	r3, r2
20003bae:	f503 7386 	add.w	r3, r3, #268	@ 0x10c
20003bb2:	6019      	str	r1, [r3, #0]

		if (t->qb.q_next != head) {			/* more tokens */
20003bb4:	68fb      	ldr	r3, [r7, #12]
20003bb6:	681b      	ldr	r3, [r3, #0]
20003bb8:	687a      	ldr	r2, [r7, #4]
20003bba:	429a      	cmp	r2, r3
20003bbc:	d038      	beq.n	20003c30 <cmd_build_cmdline+0x10c>
		    next = (ui_token_t *) t->qb.q_next;
20003bbe:	68fb      	ldr	r3, [r7, #12]
20003bc0:	681b      	ldr	r3, [r3, #0]
20003bc2:	60bb      	str	r3, [r7, #8]
		    if (next->token == '=') {			/* switch has value */
20003bc4:	68bb      	ldr	r3, [r7, #8]
20003bc6:	7a1b      	ldrb	r3, [r3, #8]
20003bc8:	2b3d      	cmp	r3, #61	@ 0x3d
20003bca:	d124      	bne.n	20003c16 <cmd_build_cmdline+0xf2>
			KFREE(t);				/* Free switch name */
20003bcc:	68f9      	ldr	r1, [r7, #12]
20003bce:	482b      	ldr	r0, [pc, #172]	@ (20003c7c <cmd_build_cmdline+0x158>)
20003bd0:	f7fd f9bc 	bl	20000f4c <kfree>
			t = (ui_token_t *) q_deqnext(head);	/* eat equal sign */
20003bd4:	6878      	ldr	r0, [r7, #4]
20003bd6:	f7fd fada 	bl	2000118e <q_deqnext>
20003bda:	60f8      	str	r0, [r7, #12]
			KFREE(t);				/* and free it */
20003bdc:	68f9      	ldr	r1, [r7, #12]
20003bde:	4827      	ldr	r0, [pc, #156]	@ (20003c7c <cmd_build_cmdline+0x158>)
20003be0:	f7fd f9b4 	bl	20000f4c <kfree>
			t = (ui_token_t *) q_deqnext(head);	/* now have value */
20003be4:	6878      	ldr	r0, [r7, #4]
20003be6:	f7fd fad2 	bl	2000118e <q_deqnext>
20003bea:	60f8      	str	r0, [r7, #12]
			if (t != NULL) {
20003bec:	68fb      	ldr	r3, [r7, #12]
20003bee:	2b00      	cmp	r3, #0
20003bf0:	d01e      	beq.n	20003c30 <cmd_build_cmdline+0x10c>
			    cmd->swv[cmd->swc].swvalue = cmd_eat_quoted_arg(head,t);
20003bf2:	683b      	ldr	r3, [r7, #0]
20003bf4:	f8d3 4104 	ldr.w	r4, [r3, #260]	@ 0x104
20003bf8:	68f9      	ldr	r1, [r7, #12]
20003bfa:	6878      	ldr	r0, [r7, #4]
20003bfc:	f000 fad8 	bl	200041b0 <cmd_eat_quoted_arg>
20003c00:	4601      	mov	r1, r0
20003c02:	683a      	ldr	r2, [r7, #0]
20003c04:	4623      	mov	r3, r4
20003c06:	005b      	lsls	r3, r3, #1
20003c08:	4423      	add	r3, r4
20003c0a:	009b      	lsls	r3, r3, #2
20003c0c:	4413      	add	r3, r2
20003c0e:	f503 7388 	add.w	r3, r3, #272	@ 0x110
20003c12:	6019      	str	r1, [r3, #0]
20003c14:	e00c      	b.n	20003c30 <cmd_build_cmdline+0x10c>
			    }
			}
		    else {					/* no value */
			cmd->swv[cmd->swc].swvalue = NULL;
20003c16:	683b      	ldr	r3, [r7, #0]
20003c18:	f8d3 2104 	ldr.w	r2, [r3, #260]	@ 0x104
20003c1c:	6839      	ldr	r1, [r7, #0]
20003c1e:	4613      	mov	r3, r2
20003c20:	005b      	lsls	r3, r3, #1
20003c22:	4413      	add	r3, r2
20003c24:	009b      	lsls	r3, r3, #2
20003c26:	440b      	add	r3, r1
20003c28:	f503 7388 	add.w	r3, r3, #272	@ 0x110
20003c2c:	2200      	movs	r2, #0
20003c2e:	601a      	str	r2, [r3, #0]
		/* 
		 * swidx is the index of the argument that this
		 * switch precedes.  So, if you have "foo -d bar",
		 * swidx for "-d" would be 1.
		 */
		cmd->swv[cmd->swc].swidx = cmd->argc;
20003c30:	683b      	ldr	r3, [r7, #0]
20003c32:	f8d3 2104 	ldr.w	r2, [r3, #260]	@ 0x104
20003c36:	683b      	ldr	r3, [r7, #0]
20003c38:	6819      	ldr	r1, [r3, #0]
20003c3a:	6838      	ldr	r0, [r7, #0]
20003c3c:	4613      	mov	r3, r2
20003c3e:	005b      	lsls	r3, r3, #1
20003c40:	4413      	add	r3, r2
20003c42:	009b      	lsls	r3, r3, #2
20003c44:	4403      	add	r3, r0
20003c46:	f503 7384 	add.w	r3, r3, #264	@ 0x108
20003c4a:	6019      	str	r1, [r3, #0]
		cmd->swc++;	
20003c4c:	683b      	ldr	r3, [r7, #0]
20003c4e:	f8d3 3104 	ldr.w	r3, [r3, #260]	@ 0x104
20003c52:	1c5a      	adds	r2, r3, #1
20003c54:	683b      	ldr	r3, [r7, #0]
20003c56:	f8c3 2104 	str.w	r2, [r3, #260]	@ 0x104
		}
	    }
	KFREE(t);
20003c5a:	68f9      	ldr	r1, [r7, #12]
20003c5c:	4807      	ldr	r0, [pc, #28]	@ (20003c7c <cmd_build_cmdline+0x158>)
20003c5e:	f7fd f975 	bl	20000f4c <kfree>
	t = (ui_token_t *) q_deqnext(head);
20003c62:	6878      	ldr	r0, [r7, #4]
20003c64:	f7fd fa93 	bl	2000118e <q_deqnext>
20003c68:	60f8      	str	r0, [r7, #12]
    while (t != NULL) {
20003c6a:	68fb      	ldr	r3, [r7, #12]
20003c6c:	2b00      	cmp	r3, #0
20003c6e:	f47f af69 	bne.w	20003b44 <cmd_build_cmdline+0x20>
	for (idx = 0; idx < cmd->swc; idx++) printf("switch[%s] = [%s]\n",cmd->swv[idx].swname,
						    cmd->swv[idx].swvalue);
	}
#endif

}
20003c72:	bf00      	nop
20003c74:	bf00      	nop
20003c76:	3714      	adds	r7, #20
20003c78:	46bd      	mov	sp, r7
20003c7a:	bd90      	pop	{r4, r7, pc}
20003c7c:	20004ab4 	.word	0x20004ab4

20003c80 <_showpossible>:
    _dumpcmds(cmd_root,0,words,verbose);
}


static void _showpossible(ui_cmdline_t *cline,cmdtab_t *cmd)
{
20003c80:	b580      	push	{r7, lr}
20003c82:	b084      	sub	sp, #16
20003c84:	af00      	add	r7, sp, #0
20003c86:	6078      	str	r0, [r7, #4]
20003c88:	6039      	str	r1, [r7, #0]
    int i;

    if (cline->argidx == 0) {
20003c8a:	687b      	ldr	r3, [r7, #4]
20003c8c:	f8d3 31cc 	ldr.w	r3, [r3, #460]	@ 0x1cc
20003c90:	2b00      	cmp	r3, #0
20003c92:	d103      	bne.n	20003c9c <_showpossible+0x1c>
	printf("Available commands: ");
20003c94:	481f      	ldr	r0, [pc, #124]	@ (20003d14 <_showpossible+0x94>)
20003c96:	f7fc ffc7 	bl	20000c28 <printf>
20003c9a:	e031      	b.n	20003d00 <_showpossible+0x80>
	}
    else {
	printf("Available \"");
20003c9c:	481e      	ldr	r0, [pc, #120]	@ (20003d18 <_showpossible+0x98>)
20003c9e:	f7fc ffc3 	bl	20000c28 <printf>
	for (i = 0; i < cline->argidx; i++) {
20003ca2:	2300      	movs	r3, #0
20003ca4:	60fb      	str	r3, [r7, #12]
20003ca6:	e011      	b.n	20003ccc <_showpossible+0x4c>
	    printf("%s%s",(i == 0) ? "" : " ",cline->argv[i]);
20003ca8:	68fb      	ldr	r3, [r7, #12]
20003caa:	2b00      	cmp	r3, #0
20003cac:	d101      	bne.n	20003cb2 <_showpossible+0x32>
20003cae:	491b      	ldr	r1, [pc, #108]	@ (20003d1c <_showpossible+0x9c>)
20003cb0:	e000      	b.n	20003cb4 <_showpossible+0x34>
20003cb2:	491b      	ldr	r1, [pc, #108]	@ (20003d20 <_showpossible+0xa0>)
20003cb4:	687a      	ldr	r2, [r7, #4]
20003cb6:	68fb      	ldr	r3, [r7, #12]
20003cb8:	009b      	lsls	r3, r3, #2
20003cba:	4413      	add	r3, r2
20003cbc:	685b      	ldr	r3, [r3, #4]
20003cbe:	461a      	mov	r2, r3
20003cc0:	4818      	ldr	r0, [pc, #96]	@ (20003d24 <_showpossible+0xa4>)
20003cc2:	f7fc ffb1 	bl	20000c28 <printf>
	for (i = 0; i < cline->argidx; i++) {
20003cc6:	68fb      	ldr	r3, [r7, #12]
20003cc8:	3301      	adds	r3, #1
20003cca:	60fb      	str	r3, [r7, #12]
20003ccc:	687b      	ldr	r3, [r7, #4]
20003cce:	f8d3 31cc 	ldr.w	r3, [r3, #460]	@ 0x1cc
20003cd2:	68fa      	ldr	r2, [r7, #12]
20003cd4:	429a      	cmp	r2, r3
20003cd6:	dbe7      	blt.n	20003ca8 <_showpossible+0x28>
	    }
	printf("\" commands: ");
20003cd8:	4813      	ldr	r0, [pc, #76]	@ (20003d28 <_showpossible+0xa8>)
20003cda:	f7fc ffa5 	bl	20000c28 <printf>
	}

    while (cmd) {
20003cde:	e00f      	b.n	20003d00 <_showpossible+0x80>
	printf("%s",cmd->cmdword);
20003ce0:	683b      	ldr	r3, [r7, #0]
20003ce2:	689b      	ldr	r3, [r3, #8]
20003ce4:	4619      	mov	r1, r3
20003ce6:	4811      	ldr	r0, [pc, #68]	@ (20003d2c <_showpossible+0xac>)
20003ce8:	f7fc ff9e 	bl	20000c28 <printf>
	if (cmd->sibling) printf(", ");
20003cec:	683b      	ldr	r3, [r7, #0]
20003cee:	681b      	ldr	r3, [r3, #0]
20003cf0:	2b00      	cmp	r3, #0
20003cf2:	d002      	beq.n	20003cfa <_showpossible+0x7a>
20003cf4:	480e      	ldr	r0, [pc, #56]	@ (20003d30 <_showpossible+0xb0>)
20003cf6:	f7fc ff97 	bl	20000c28 <printf>
	cmd = cmd->sibling;
20003cfa:	683b      	ldr	r3, [r7, #0]
20003cfc:	681b      	ldr	r3, [r3, #0]
20003cfe:	603b      	str	r3, [r7, #0]
    while (cmd) {
20003d00:	683b      	ldr	r3, [r7, #0]
20003d02:	2b00      	cmp	r3, #0
20003d04:	d1ec      	bne.n	20003ce0 <_showpossible+0x60>
	}

    printf("\n");
20003d06:	200a      	movs	r0, #10
20003d08:	f7fc fff0 	bl	20000cec <putchar>
}
20003d0c:	bf00      	nop
20003d0e:	3710      	adds	r7, #16
20003d10:	46bd      	mov	sp, r7
20003d12:	bd80      	pop	{r7, pc}
20003d14:	2000468c 	.word	0x2000468c
20003d18:	200046a4 	.word	0x200046a4
20003d1c:	200046b0 	.word	0x200046b0
20003d20:	200046b4 	.word	0x200046b4
20003d24:	200046b8 	.word	0x200046b8
20003d28:	200046c0 	.word	0x200046c0
20003d2c:	20004688 	.word	0x20004688
20003d30:	200046d0 	.word	0x200046d0

20003d34 <cmd_lookup>:
	       "");
}


int cmd_lookup(queue_t *head,ui_cmdline_t *cmd)
{
20003d34:	b580      	push	{r7, lr}
20003d36:	b086      	sub	sp, #24
20003d38:	af00      	add	r7, sp, #0
20003d3a:	6078      	str	r0, [r7, #4]
20003d3c:	6039      	str	r1, [r7, #0]

    /*
     * Reset the command line
     */

    memset(cmd,0,sizeof(ui_cmdline_t));
20003d3e:	f44f 72ee 	mov.w	r2, #476	@ 0x1dc
20003d42:	2100      	movs	r1, #0
20003d44:	6838      	ldr	r0, [r7, #0]
20003d46:	f7fd fb39 	bl	200013bc <lib_memset>

    /*
     * Break it up into tokens
     */
    
    cmd_build_cmdline(head, cmd);
20003d4a:	6839      	ldr	r1, [r7, #0]
20003d4c:	6878      	ldr	r0, [r7, #4]
20003d4e:	f7ff fee9 	bl	20003b24 <cmd_build_cmdline>

    if (cmd->argc == 0) return CMD_ERR_BLANK;
20003d52:	683b      	ldr	r3, [r7, #0]
20003d54:	681b      	ldr	r3, [r3, #0]
20003d56:	2b00      	cmp	r3, #0
20003d58:	d102      	bne.n	20003d60 <cmd_lookup+0x2c>
20003d5a:	f06f 0302 	mvn.w	r3, #2
20003d5e:	e07f      	b.n	20003e60 <cmd_lookup+0x12c>
    /*
     * Start walking the tree looking for a function	
     * to execute.
     */
  
    idx = 0;
20003d60:	2300      	movs	r3, #0
20003d62:	613b      	str	r3, [r7, #16]
    tab = &cmd_root;
20003d64:	4b40      	ldr	r3, [pc, #256]	@ (20003e68 <cmd_lookup+0x134>)
20003d66:	617b      	str	r3, [r7, #20]
    cword = NULL;
20003d68:	2300      	movs	r3, #0
20003d6a:	60fb      	str	r3, [r7, #12]

    for (;;) {
	cword = cmd_findword(*tab,cmd->argv[idx]);
20003d6c:	697b      	ldr	r3, [r7, #20]
20003d6e:	6818      	ldr	r0, [r3, #0]
20003d70:	683a      	ldr	r2, [r7, #0]
20003d72:	693b      	ldr	r3, [r7, #16]
20003d74:	009b      	lsls	r3, r3, #2
20003d76:	4413      	add	r3, r2
20003d78:	685b      	ldr	r3, [r3, #4]
20003d7a:	4619      	mov	r1, r3
20003d7c:	f7ff feb6 	bl	20003aec <cmd_findword>
20003d80:	60f8      	str	r0, [r7, #12]
	if (!cword) break;
20003d82:	68fb      	ldr	r3, [r7, #12]
20003d84:	2b00      	cmp	r3, #0
20003d86:	d00f      	beq.n	20003da8 <cmd_lookup+0x74>
	if (cword->func != NULL) break;
20003d88:	68fb      	ldr	r3, [r7, #12]
20003d8a:	68db      	ldr	r3, [r3, #12]
20003d8c:	2b00      	cmp	r3, #0
20003d8e:	d10d      	bne.n	20003dac <cmd_lookup+0x78>
	idx++;
20003d90:	693b      	ldr	r3, [r7, #16]
20003d92:	3301      	adds	r3, #1
20003d94:	613b      	str	r3, [r7, #16]
	tab = &(cword->child);
20003d96:	68fb      	ldr	r3, [r7, #12]
20003d98:	3304      	adds	r3, #4
20003d9a:	617b      	str	r3, [r7, #20]
	if (idx >= cmd->argc) break;
20003d9c:	683b      	ldr	r3, [r7, #0]
20003d9e:	681b      	ldr	r3, [r3, #0]
20003da0:	693a      	ldr	r2, [r7, #16]
20003da2:	429a      	cmp	r2, r3
20003da4:	da04      	bge.n	20003db0 <cmd_lookup+0x7c>
	cword = cmd_findword(*tab,cmd->argv[idx]);
20003da6:	e7e1      	b.n	20003d6c <cmd_lookup+0x38>
	if (!cword) break;
20003da8:	bf00      	nop
20003daa:	e002      	b.n	20003db2 <cmd_lookup+0x7e>
	if (cword->func != NULL) break;
20003dac:	bf00      	nop
20003dae:	e000      	b.n	20003db2 <cmd_lookup+0x7e>
	if (idx >= cmd->argc) break;
20003db0:	bf00      	nop
	}

    cmd->argidx = idx;
20003db2:	683b      	ldr	r3, [r7, #0]
20003db4:	693a      	ldr	r2, [r7, #16]
20003db6:	f8c3 21cc 	str.w	r2, [r3, #460]	@ 0x1cc

/* XXX - Must fix this... the error needs to walk the tree! */

    if (cword == NULL) {
20003dba:	68fb      	ldr	r3, [r7, #12]
20003dbc:	2b00      	cmp	r3, #0
20003dbe:	d114      	bne.n	20003dea <cmd_lookup+0xb6>
	printf("Invalid command: \"%s\"\n", cmd->argv[idx]);
20003dc0:	683a      	ldr	r2, [r7, #0]
20003dc2:	693b      	ldr	r3, [r7, #16]
20003dc4:	009b      	lsls	r3, r3, #2
20003dc6:	4413      	add	r3, r2
20003dc8:	685b      	ldr	r3, [r3, #4]
20003dca:	4619      	mov	r1, r3
20003dcc:	4827      	ldr	r0, [pc, #156]	@ (20003e6c <cmd_lookup+0x138>)
20003dce:	f7fc ff2b 	bl	20000c28 <printf>
	_showpossible(cmd,*tab);
20003dd2:	697b      	ldr	r3, [r7, #20]
20003dd4:	681b      	ldr	r3, [r3, #0]
20003dd6:	4619      	mov	r1, r3
20003dd8:	6838      	ldr	r0, [r7, #0]
20003dda:	f7ff ff51 	bl	20003c80 <_showpossible>
	printf("\n");
20003dde:	200a      	movs	r0, #10
20003de0:	f7fc ff84 	bl	20000cec <putchar>
	return CMD_ERR_INVALID;
20003de4:	f04f 33ff 	mov.w	r3, #4294967295	@ 0xffffffff
20003de8:	e03a      	b.n	20003e60 <cmd_lookup+0x12c>
	}

    if (!cword->func && (idx >= cmd->argc)) {
20003dea:	68fb      	ldr	r3, [r7, #12]
20003dec:	68db      	ldr	r3, [r3, #12]
20003dee:	2b00      	cmp	r3, #0
20003df0:	d11a      	bne.n	20003e28 <cmd_lookup+0xf4>
20003df2:	683b      	ldr	r3, [r7, #0]
20003df4:	681b      	ldr	r3, [r3, #0]
20003df6:	693a      	ldr	r2, [r7, #16]
20003df8:	429a      	cmp	r2, r3
20003dfa:	db15      	blt.n	20003e28 <cmd_lookup+0xf4>
	printf("Incomplete command: \"%s\"\n",cmd->argv[idx-1]);
20003dfc:	693b      	ldr	r3, [r7, #16]
20003dfe:	3b01      	subs	r3, #1
20003e00:	683a      	ldr	r2, [r7, #0]
20003e02:	009b      	lsls	r3, r3, #2
20003e04:	4413      	add	r3, r2
20003e06:	685b      	ldr	r3, [r3, #4]
20003e08:	4619      	mov	r1, r3
20003e0a:	4819      	ldr	r0, [pc, #100]	@ (20003e70 <cmd_lookup+0x13c>)
20003e0c:	f7fc ff0c 	bl	20000c28 <printf>
	_showpossible(cmd,*tab);
20003e10:	697b      	ldr	r3, [r7, #20]
20003e12:	681b      	ldr	r3, [r3, #0]
20003e14:	4619      	mov	r1, r3
20003e16:	6838      	ldr	r0, [r7, #0]
20003e18:	f7ff ff32 	bl	20003c80 <_showpossible>
	printf("\n");
20003e1c:	200a      	movs	r0, #10
20003e1e:	f7fc ff65 	bl	20000cec <putchar>
	return CMD_ERR_AMBIGUOUS;
20003e22:	f06f 0301 	mvn.w	r3, #1
20003e26:	e01b      	b.n	20003e60 <cmd_lookup+0x12c>
	}

    cmd->argidx++;
20003e28:	683b      	ldr	r3, [r7, #0]
20003e2a:	f8d3 31cc 	ldr.w	r3, [r3, #460]	@ 0x1cc
20003e2e:	1c5a      	adds	r2, r3, #1
20003e30:	683b      	ldr	r3, [r7, #0]
20003e32:	f8c3 21cc 	str.w	r2, [r3, #460]	@ 0x1cc
    cmd->ref = cword->ref;
20003e36:	68fb      	ldr	r3, [r7, #12]
20003e38:	691a      	ldr	r2, [r3, #16]
20003e3a:	683b      	ldr	r3, [r7, #0]
20003e3c:	f8c3 21d0 	str.w	r2, [r3, #464]	@ 0x1d0
    cmd->usage = cword->usage;
20003e40:	68fb      	ldr	r3, [r7, #12]
20003e42:	699a      	ldr	r2, [r3, #24]
20003e44:	683b      	ldr	r3, [r7, #0]
20003e46:	f8c3 21d4 	str.w	r2, [r3, #468]	@ 0x1d4
    cmd->switches = cword->switches;
20003e4a:	68fb      	ldr	r3, [r7, #12]
20003e4c:	69da      	ldr	r2, [r3, #28]
20003e4e:	683b      	ldr	r3, [r7, #0]
20003e50:	f8c3 21d8 	str.w	r2, [r3, #472]	@ 0x1d8
    cmd->func = cword->func;
20003e54:	68fb      	ldr	r3, [r7, #12]
20003e56:	68da      	ldr	r2, [r3, #12]
20003e58:	683b      	ldr	r3, [r7, #0]
20003e5a:	f8c3 21c8 	str.w	r2, [r3, #456]	@ 0x1c8

    return 0;
20003e5e:	2300      	movs	r3, #0
}
20003e60:	4618      	mov	r0, r3
20003e62:	3718      	adds	r7, #24
20003e64:	46bd      	mov	sp, r7
20003e66:	bd80      	pop	{r7, pc}
20003e68:	20004d1c 	.word	0x20004d1c
20003e6c:	20004868 	.word	0x20004868
20003e70:	20004880 	.word	0x20004880

20003e74 <cmd_eat_leading_white>:
	}
}


static void cmd_eat_leading_white(queue_t *head)
{
20003e74:	b580      	push	{r7, lr}
20003e76:	b084      	sub	sp, #16
20003e78:	af00      	add	r7, sp, #0
20003e7a:	6078      	str	r0, [r7, #4]
    ui_token_t *t;

    while (!q_isempty(head)) {
20003e7c:	e010      	b.n	20003ea0 <cmd_eat_leading_white+0x2c>
	t = (ui_token_t *) q_getfirst(head);
20003e7e:	687b      	ldr	r3, [r7, #4]
20003e80:	681b      	ldr	r3, [r3, #0]
20003e82:	60fb      	str	r3, [r7, #12]
	if (is_white_space(t)) {
20003e84:	68f8      	ldr	r0, [r7, #12]
20003e86:	f7ff fd11 	bl	200038ac <is_white_space>
20003e8a:	4603      	mov	r3, r0
20003e8c:	2b00      	cmp	r3, #0
20003e8e:	d00d      	beq.n	20003eac <cmd_eat_leading_white+0x38>
	    q_dequeue(&(t->qb));
20003e90:	68fb      	ldr	r3, [r7, #12]
20003e92:	4618      	mov	r0, r3
20003e94:	f7fd f967 	bl	20001166 <q_dequeue>
	    KFREE(t);
20003e98:	68f9      	ldr	r1, [r7, #12]
20003e9a:	4807      	ldr	r0, [pc, #28]	@ (20003eb8 <cmd_eat_leading_white+0x44>)
20003e9c:	f7fd f856 	bl	20000f4c <kfree>
    while (!q_isempty(head)) {
20003ea0:	687b      	ldr	r3, [r7, #4]
20003ea2:	681b      	ldr	r3, [r3, #0]
20003ea4:	687a      	ldr	r2, [r7, #4]
20003ea6:	429a      	cmp	r2, r3
20003ea8:	d1e9      	bne.n	20003e7e <cmd_eat_leading_white+0xa>
	    }
	else break;
	}
}
20003eaa:	e000      	b.n	20003eae <cmd_eat_leading_white+0x3a>
	else break;
20003eac:	bf00      	nop
}
20003eae:	bf00      	nop
20003eb0:	3710      	adds	r7, #16
20003eb2:	46bd      	mov	sp, r7
20003eb4:	bd80      	pop	{r7, pc}
20003eb6:	bf00      	nop
20003eb8:	20004ab4 	.word	0x20004ab4

20003ebc <cmd_readcommand>:

ui_command_t *cmd_readcommand(queue_t *head)
{
20003ebc:	b580      	push	{r7, lr}
20003ebe:	b088      	sub	sp, #32
20003ec0:	af00      	add	r7, sp, #0
20003ec2:	6078      	str	r0, [r7, #4]
    char *ptr;
    int insquote = FALSE;
20003ec4:	2300      	movs	r3, #0
20003ec6:	61fb      	str	r3, [r7, #28]
    int indquote = FALSE;
20003ec8:	2300      	movs	r3, #0
20003eca:	61bb      	str	r3, [r7, #24]
    ui_command_t *cmd;
    int term = CMD_TERM_EOL;
20003ecc:	2300      	movs	r3, #0
20003ece:	617b      	str	r3, [r7, #20]
    ui_token_t *t;

    cmd_eat_leading_white(head);
20003ed0:	6878      	ldr	r0, [r7, #4]
20003ed2:	f7ff ffcf 	bl	20003e74 <cmd_eat_leading_white>

    if (q_isempty(head)) return NULL;
20003ed6:	687b      	ldr	r3, [r7, #4]
20003ed8:	681b      	ldr	r3, [r3, #0]
20003eda:	687a      	ldr	r2, [r7, #4]
20003edc:	429a      	cmp	r2, r3
20003ede:	d101      	bne.n	20003ee4 <cmd_readcommand+0x28>
20003ee0:	2300      	movs	r3, #0
20003ee2:	e06e      	b.n	20003fc2 <cmd_readcommand+0x106>

    cmd = (ui_command_t *) KMALLOC(sizeof(ui_command_t),0);
20003ee4:	2200      	movs	r2, #0
20003ee6:	2118      	movs	r1, #24
20003ee8:	4838      	ldr	r0, [pc, #224]	@ (20003fcc <cmd_readcommand+0x110>)
20003eea:	f7fd f863 	bl	20000fb4 <kmalloc>
20003eee:	6138      	str	r0, [r7, #16]
    q_init(&(cmd->head));
20003ef0:	693b      	ldr	r3, [r7, #16]
20003ef2:	f103 0210 	add.w	r2, r3, #16
20003ef6:	693b      	ldr	r3, [r7, #16]
20003ef8:	615a      	str	r2, [r3, #20]
20003efa:	693b      	ldr	r3, [r7, #16]
20003efc:	f103 0210 	add.w	r2, r3, #16
20003f00:	693b      	ldr	r3, [r7, #16]
20003f02:	611a      	str	r2, [r3, #16]

    while ((t = (ui_token_t *) q_deqnext(head))) {
20003f04:	e04b      	b.n	20003f9e <cmd_readcommand+0xe2>

	ptr = &(t->token);
20003f06:	68fb      	ldr	r3, [r7, #12]
20003f08:	3308      	adds	r3, #8
20003f0a:	60bb      	str	r3, [r7, #8]

	if (!insquote && !indquote) {
20003f0c:	69fb      	ldr	r3, [r7, #28]
20003f0e:	2b00      	cmp	r3, #0
20003f10:	d125      	bne.n	20003f5e <cmd_readcommand+0xa2>
20003f12:	69bb      	ldr	r3, [r7, #24]
20003f14:	2b00      	cmp	r3, #0
20003f16:	d122      	bne.n	20003f5e <cmd_readcommand+0xa2>
	    if ((*ptr == ';') || (*ptr == '\n')) {
20003f18:	68bb      	ldr	r3, [r7, #8]
20003f1a:	781b      	ldrb	r3, [r3, #0]
20003f1c:	2b3b      	cmp	r3, #59	@ 0x3b
20003f1e:	d003      	beq.n	20003f28 <cmd_readcommand+0x6c>
20003f20:	68bb      	ldr	r3, [r7, #8]
20003f22:	781b      	ldrb	r3, [r3, #0]
20003f24:	2b0a      	cmp	r3, #10
20003f26:	d102      	bne.n	20003f2e <cmd_readcommand+0x72>
		term = CMD_TERM_SEMI;
20003f28:	2301      	movs	r3, #1
20003f2a:	617b      	str	r3, [r7, #20]
		break;
20003f2c:	e03e      	b.n	20003fac <cmd_readcommand+0xf0>
		}	
	    if ((*ptr == '&') && (*(ptr+1) == '&')) {
20003f2e:	68bb      	ldr	r3, [r7, #8]
20003f30:	781b      	ldrb	r3, [r3, #0]
20003f32:	2b26      	cmp	r3, #38	@ 0x26
20003f34:	d107      	bne.n	20003f46 <cmd_readcommand+0x8a>
20003f36:	68bb      	ldr	r3, [r7, #8]
20003f38:	3301      	adds	r3, #1
20003f3a:	781b      	ldrb	r3, [r3, #0]
20003f3c:	2b26      	cmp	r3, #38	@ 0x26
20003f3e:	d102      	bne.n	20003f46 <cmd_readcommand+0x8a>
		term = CMD_TERM_AND;
20003f40:	2302      	movs	r3, #2
20003f42:	617b      	str	r3, [r7, #20]
		break;
20003f44:	e032      	b.n	20003fac <cmd_readcommand+0xf0>
		}
	    if ((*ptr == '|') && (*(ptr+1) == '|')) {
20003f46:	68bb      	ldr	r3, [r7, #8]
20003f48:	781b      	ldrb	r3, [r3, #0]
20003f4a:	2b7c      	cmp	r3, #124	@ 0x7c
20003f4c:	d107      	bne.n	20003f5e <cmd_readcommand+0xa2>
20003f4e:	68bb      	ldr	r3, [r7, #8]
20003f50:	3301      	adds	r3, #1
20003f52:	781b      	ldrb	r3, [r3, #0]
20003f54:	2b7c      	cmp	r3, #124	@ 0x7c
20003f56:	d102      	bne.n	20003f5e <cmd_readcommand+0xa2>
		term = CMD_TERM_OR;
20003f58:	2303      	movs	r3, #3
20003f5a:	617b      	str	r3, [r7, #20]
		break;
20003f5c:	e026      	b.n	20003fac <cmd_readcommand+0xf0>
		}
	    }

	if (*ptr == '\'') {
20003f5e:	68bb      	ldr	r3, [r7, #8]
20003f60:	781b      	ldrb	r3, [r3, #0]
20003f62:	2b27      	cmp	r3, #39	@ 0x27
20003f64:	d106      	bne.n	20003f74 <cmd_readcommand+0xb8>
	    insquote = !insquote;
20003f66:	69fb      	ldr	r3, [r7, #28]
20003f68:	2b00      	cmp	r3, #0
20003f6a:	bf0c      	ite	eq
20003f6c:	2301      	moveq	r3, #1
20003f6e:	2300      	movne	r3, #0
20003f70:	b2db      	uxtb	r3, r3
20003f72:	61fb      	str	r3, [r7, #28]
	    }

	if (!insquote) {
20003f74:	69fb      	ldr	r3, [r7, #28]
20003f76:	2b00      	cmp	r3, #0
20003f78:	d10a      	bne.n	20003f90 <cmd_readcommand+0xd4>
	    if (*ptr == '"') {
20003f7a:	68bb      	ldr	r3, [r7, #8]
20003f7c:	781b      	ldrb	r3, [r3, #0]
20003f7e:	2b22      	cmp	r3, #34	@ 0x22
20003f80:	d106      	bne.n	20003f90 <cmd_readcommand+0xd4>
		indquote = !indquote;
20003f82:	69bb      	ldr	r3, [r7, #24]
20003f84:	2b00      	cmp	r3, #0
20003f86:	bf0c      	ite	eq
20003f88:	2301      	moveq	r3, #1
20003f8a:	2300      	movne	r3, #0
20003f8c:	b2db      	uxtb	r3, r3
20003f8e:	61bb      	str	r3, [r7, #24]
		}
	    }

	q_enqueue(&(cmd->head),&(t->qb));
20003f90:	693b      	ldr	r3, [r7, #16]
20003f92:	3310      	adds	r3, #16
20003f94:	68fa      	ldr	r2, [r7, #12]
20003f96:	4611      	mov	r1, r2
20003f98:	4618      	mov	r0, r3
20003f9a:	f7fd f8cb 	bl	20001134 <q_enqueue>
    while ((t = (ui_token_t *) q_deqnext(head))) {
20003f9e:	6878      	ldr	r0, [r7, #4]
20003fa0:	f7fd f8f5 	bl	2000118e <q_deqnext>
20003fa4:	60f8      	str	r0, [r7, #12]
20003fa6:	68fb      	ldr	r3, [r7, #12]
20003fa8:	2b00      	cmp	r3, #0
20003faa:	d1ac      	bne.n	20003f06 <cmd_readcommand+0x4a>
		
	}

    cmd->term = term;
20003fac:	693b      	ldr	r3, [r7, #16]
20003fae:	697a      	ldr	r2, [r7, #20]
20003fb0:	609a      	str	r2, [r3, #8]

    /* If we got out by finding a command separator, eat the separator */
    if (term != CMD_TERM_EOL) {
20003fb2:	697b      	ldr	r3, [r7, #20]
20003fb4:	2b00      	cmp	r3, #0
20003fb6:	d003      	beq.n	20003fc0 <cmd_readcommand+0x104>
	KFREE(t);
20003fb8:	68f9      	ldr	r1, [r7, #12]
20003fba:	4804      	ldr	r0, [pc, #16]	@ (20003fcc <cmd_readcommand+0x110>)
20003fbc:	f7fc ffc6 	bl	20000f4c <kfree>
	}

    return cmd;
20003fc0:	693b      	ldr	r3, [r7, #16]
}
20003fc2:	4618      	mov	r0, r3
20003fc4:	3720      	adds	r7, #32
20003fc6:	46bd      	mov	sp, r7
20003fc8:	bd80      	pop	{r7, pc}
20003fca:	bf00      	nop
20003fcc:	20004ab4 	.word	0x20004ab4

20003fd0 <make_token>:



static ui_token_t *make_token(char *str,int len)
{
20003fd0:	b580      	push	{r7, lr}
20003fd2:	b084      	sub	sp, #16
20003fd4:	af00      	add	r7, sp, #0
20003fd6:	6078      	str	r0, [r7, #4]
20003fd8:	6039      	str	r1, [r7, #0]
    ui_token_t *t = (ui_token_t *) KMALLOC(sizeof(ui_token_t) + len,0);
20003fda:	683b      	ldr	r3, [r7, #0]
20003fdc:	330c      	adds	r3, #12
20003fde:	2200      	movs	r2, #0
20003fe0:	4619      	mov	r1, r3
20003fe2:	480b      	ldr	r0, [pc, #44]	@ (20004010 <make_token+0x40>)
20003fe4:	f7fc ffe6 	bl	20000fb4 <kmalloc>
20003fe8:	60f8      	str	r0, [r7, #12]

    memcpy(&(t->token),str,len);
20003fea:	68fb      	ldr	r3, [r7, #12]
20003fec:	3308      	adds	r3, #8
20003fee:	683a      	ldr	r2, [r7, #0]
20003ff0:	6879      	ldr	r1, [r7, #4]
20003ff2:	4618      	mov	r0, r3
20003ff4:	f7fd f9c2 	bl	2000137c <lib_memcpy>
    (&(t->token))[len] = 0;
20003ff8:	68fb      	ldr	r3, [r7, #12]
20003ffa:	f103 0208 	add.w	r2, r3, #8
20003ffe:	683b      	ldr	r3, [r7, #0]
20004000:	4413      	add	r3, r2
20004002:	2200      	movs	r2, #0
20004004:	701a      	strb	r2, [r3, #0]

    return t;
20004006:	68fb      	ldr	r3, [r7, #12]
}
20004008:	4618      	mov	r0, r3
2000400a:	3710      	adds	r7, #16
2000400c:	46bd      	mov	sp, r7
2000400e:	bd80      	pop	{r7, pc}
20004010:	20004ab4 	.word	0x20004ab4

20004014 <cmd_build_list>:

void cmd_build_list(queue_t *qb,char *buf)
{
20004014:	b580      	push	{r7, lr}
20004016:	b086      	sub	sp, #24
20004018:	af00      	add	r7, sp, #0
2000401a:	6078      	str	r0, [r7, #4]
2000401c:	6039      	str	r1, [r7, #0]
    char *cur = buf, *start = NULL, *fin = NULL;
2000401e:	683b      	ldr	r3, [r7, #0]
20004020:	617b      	str	r3, [r7, #20]
20004022:	2300      	movs	r3, #0
20004024:	613b      	str	r3, [r7, #16]
20004026:	2300      	movs	r3, #0
20004028:	60fb      	str	r3, [r7, #12]
    ui_token_t *t;

    q_init(qb);
2000402a:	687b      	ldr	r3, [r7, #4]
2000402c:	687a      	ldr	r2, [r7, #4]
2000402e:	605a      	str	r2, [r3, #4]
20004030:	687b      	ldr	r3, [r7, #4]
20004032:	687a      	ldr	r2, [r7, #4]
20004034:	601a      	str	r2, [r3, #0]

    start = cur;
20004036:	697b      	ldr	r3, [r7, #20]
20004038:	613b      	str	r3, [r7, #16]
    while(*cur != '\0'){
2000403a:	e06a      	b.n	20004112 <cmd_build_list+0xfe>
	if (*cur == '&' && *(cur + 1) != '&') {
2000403c:	697b      	ldr	r3, [r7, #20]
2000403e:	781b      	ldrb	r3, [r3, #0]
20004040:	2b26      	cmp	r3, #38	@ 0x26
20004042:	d104      	bne.n	2000404e <cmd_build_list+0x3a>
20004044:	697b      	ldr	r3, [r7, #20]
20004046:	3301      	adds	r3, #1
20004048:	781b      	ldrb	r3, [r3, #0]
2000404a:	2b26      	cmp	r3, #38	@ 0x26
2000404c:	d15e      	bne.n	2000410c <cmd_build_list+0xf8>
	    /* Do nothing if we have only one & */
	    }
	else if (*cur == '|' && *(cur + 1) != '|') {
2000404e:	697b      	ldr	r3, [r7, #20]
20004050:	781b      	ldrb	r3, [r3, #0]
20004052:	2b7c      	cmp	r3, #124	@ 0x7c
20004054:	d104      	bne.n	20004060 <cmd_build_list+0x4c>
20004056:	697b      	ldr	r3, [r7, #20]
20004058:	3301      	adds	r3, #1
2000405a:	781b      	ldrb	r3, [r3, #0]
2000405c:	2b7c      	cmp	r3, #124	@ 0x7c
2000405e:	d155      	bne.n	2000410c <cmd_build_list+0xf8>
	    /* Do nothing if we have only one | */
	    }
	else if (((*cur == ' ')||(*cur == '\t')) &&
20004060:	697b      	ldr	r3, [r7, #20]
20004062:	781b      	ldrb	r3, [r3, #0]
20004064:	2b20      	cmp	r3, #32
20004066:	d003      	beq.n	20004070 <cmd_build_list+0x5c>
20004068:	697b      	ldr	r3, [r7, #20]
2000406a:	781b      	ldrb	r3, [r3, #0]
2000406c:	2b09      	cmp	r3, #9
2000406e:	d109      	bne.n	20004084 <cmd_build_list+0x70>
		 ((*(cur - 1) == ' ')||(*(cur - 1) == '\t'))) {
20004070:	697b      	ldr	r3, [r7, #20]
20004072:	3b01      	subs	r3, #1
20004074:	781b      	ldrb	r3, [r3, #0]
	else if (((*cur == ' ')||(*cur == '\t')) &&
20004076:	2b20      	cmp	r3, #32
20004078:	d047      	beq.n	2000410a <cmd_build_list+0xf6>
		 ((*(cur - 1) == ' ')||(*(cur - 1) == '\t'))) {
2000407a:	697b      	ldr	r3, [r7, #20]
2000407c:	3b01      	subs	r3, #1
2000407e:	781b      	ldrb	r3, [r3, #0]
20004080:	2b09      	cmp	r3, #9
20004082:	d042      	beq.n	2000410a <cmd_build_list+0xf6>
	    /* Make one big token for white space */
	    }
	else {

	    if (strchr(tokenbreaks,*cur)) {
20004084:	4b31      	ldr	r3, [pc, #196]	@ (2000414c <cmd_build_list+0x138>)
20004086:	681a      	ldr	r2, [r3, #0]
20004088:	697b      	ldr	r3, [r7, #20]
2000408a:	781b      	ldrb	r3, [r3, #0]
2000408c:	4619      	mov	r1, r3
2000408e:	4610      	mov	r0, r2
20004090:	f7fd f958 	bl	20001344 <lib_strchr>
20004094:	4603      	mov	r3, r0
20004096:	2b00      	cmp	r3, #0
20004098:	d015      	beq.n	200040c6 <cmd_build_list+0xb2>
		if (cur != buf) {
2000409a:	697a      	ldr	r2, [r7, #20]
2000409c:	683b      	ldr	r3, [r7, #0]
2000409e:	429a      	cmp	r2, r3
200040a0:	d034      	beq.n	2000410c <cmd_build_list+0xf8>
		    fin = cur;
200040a2:	697b      	ldr	r3, [r7, #20]
200040a4:	60fb      	str	r3, [r7, #12]
		    t = make_token(start,fin-start);
200040a6:	68fa      	ldr	r2, [r7, #12]
200040a8:	693b      	ldr	r3, [r7, #16]
200040aa:	1ad3      	subs	r3, r2, r3
200040ac:	4619      	mov	r1, r3
200040ae:	6938      	ldr	r0, [r7, #16]
200040b0:	f7ff ff8e 	bl	20003fd0 <make_token>
200040b4:	60b8      	str	r0, [r7, #8]
		    q_enqueue(qb,&(t->qb));
200040b6:	68bb      	ldr	r3, [r7, #8]
200040b8:	4619      	mov	r1, r3
200040ba:	6878      	ldr	r0, [r7, #4]
200040bc:	f7fd f83a 	bl	20001134 <q_enqueue>
		    start = cur; /* Start new token */
200040c0:	697b      	ldr	r3, [r7, #20]
200040c2:	613b      	str	r3, [r7, #16]
200040c4:	e022      	b.n	2000410c <cmd_build_list+0xf8>
		}
	    else {
		/* If we are on a normal character but the last character was */
		/* a special char we need to start a new token */

		if ((cur > buf) && strchr(tokenbreaks,*(cur-1))) {
200040c6:	697a      	ldr	r2, [r7, #20]
200040c8:	683b      	ldr	r3, [r7, #0]
200040ca:	429a      	cmp	r2, r3
200040cc:	d91e      	bls.n	2000410c <cmd_build_list+0xf8>
200040ce:	4b1f      	ldr	r3, [pc, #124]	@ (2000414c <cmd_build_list+0x138>)
200040d0:	681a      	ldr	r2, [r3, #0]
200040d2:	697b      	ldr	r3, [r7, #20]
200040d4:	3b01      	subs	r3, #1
200040d6:	781b      	ldrb	r3, [r3, #0]
200040d8:	4619      	mov	r1, r3
200040da:	4610      	mov	r0, r2
200040dc:	f7fd f932 	bl	20001344 <lib_strchr>
200040e0:	4603      	mov	r3, r0
200040e2:	2b00      	cmp	r3, #0
200040e4:	d012      	beq.n	2000410c <cmd_build_list+0xf8>
		    fin = cur;
200040e6:	697b      	ldr	r3, [r7, #20]
200040e8:	60fb      	str	r3, [r7, #12]
		    t = make_token(start,fin-start);
200040ea:	68fa      	ldr	r2, [r7, #12]
200040ec:	693b      	ldr	r3, [r7, #16]
200040ee:	1ad3      	subs	r3, r2, r3
200040f0:	4619      	mov	r1, r3
200040f2:	6938      	ldr	r0, [r7, #16]
200040f4:	f7ff ff6c 	bl	20003fd0 <make_token>
200040f8:	60b8      	str	r0, [r7, #8]
		    q_enqueue(qb,&(t->qb));
200040fa:	68bb      	ldr	r3, [r7, #8]
200040fc:	4619      	mov	r1, r3
200040fe:	6878      	ldr	r0, [r7, #4]
20004100:	f7fd f818 	bl	20001134 <q_enqueue>
		    start = cur; /* Start new token */
20004104:	697b      	ldr	r3, [r7, #20]
20004106:	613b      	str	r3, [r7, #16]
20004108:	e000      	b.n	2000410c <cmd_build_list+0xf8>
	else if (((*cur == ' ')||(*cur == '\t')) &&
2000410a:	bf00      	nop


		}

	    }
	cur++;
2000410c:	697b      	ldr	r3, [r7, #20]
2000410e:	3301      	adds	r3, #1
20004110:	617b      	str	r3, [r7, #20]
    while(*cur != '\0'){
20004112:	697b      	ldr	r3, [r7, #20]
20004114:	781b      	ldrb	r3, [r3, #0]
20004116:	2b00      	cmp	r3, #0
20004118:	d190      	bne.n	2000403c <cmd_build_list+0x28>
	}

    fin = cur;
2000411a:	697b      	ldr	r3, [r7, #20]
2000411c:	60fb      	str	r3, [r7, #12]

    if (fin-start > 0) {
2000411e:	68fa      	ldr	r2, [r7, #12]
20004120:	693b      	ldr	r3, [r7, #16]
20004122:	1ad3      	subs	r3, r2, r3
20004124:	2b00      	cmp	r3, #0
20004126:	dd0d      	ble.n	20004144 <cmd_build_list+0x130>
	t = make_token(start,fin-start);
20004128:	68fa      	ldr	r2, [r7, #12]
2000412a:	693b      	ldr	r3, [r7, #16]
2000412c:	1ad3      	subs	r3, r2, r3
2000412e:	4619      	mov	r1, r3
20004130:	6938      	ldr	r0, [r7, #16]
20004132:	f7ff ff4d 	bl	20003fd0 <make_token>
20004136:	60b8      	str	r0, [r7, #8]
	q_enqueue(qb,&(t->qb));
20004138:	68bb      	ldr	r3, [r7, #8]
2000413a:	4619      	mov	r1, r3
2000413c:	6878      	ldr	r0, [r7, #4]
2000413e:	f7fc fff9 	bl	20001134 <q_enqueue>
	}

    return;
20004142:	bf00      	nop
20004144:	bf00      	nop
}
20004146:	3718      	adds	r7, #24
20004148:	46bd      	mov	sp, r7
2000414a:	bd80      	pop	{r7, pc}
2000414c:	20004aa4 	.word	0x20004aa4

20004150 <is_command_separator>:

static int is_command_separator(ui_token_t *t)
{
20004150:	b480      	push	{r7}
20004152:	b085      	sub	sp, #20
20004154:	af00      	add	r7, sp, #0
20004156:	6078      	str	r0, [r7, #4]
    char *string = &(t->token);
20004158:	687b      	ldr	r3, [r7, #4]
2000415a:	3308      	adds	r3, #8
2000415c:	60bb      	str	r3, [r7, #8]
    int sep = 0;
2000415e:	2300      	movs	r3, #0
20004160:	60fb      	str	r3, [r7, #12]

    switch(*string){
20004162:	68bb      	ldr	r3, [r7, #8]
20004164:	781b      	ldrb	r3, [r3, #0]
20004166:	2b7c      	cmp	r3, #124	@ 0x7c
20004168:	d010      	beq.n	2000418c <is_command_separator+0x3c>
2000416a:	2b7c      	cmp	r3, #124	@ 0x7c
2000416c:	dc15      	bgt.n	2000419a <is_command_separator+0x4a>
2000416e:	2b26      	cmp	r3, #38	@ 0x26
20004170:	d004      	beq.n	2000417c <is_command_separator+0x2c>
20004172:	2b3b      	cmp	r3, #59	@ 0x3b
20004174:	d111      	bne.n	2000419a <is_command_separator+0x4a>
	case ';':
	    sep = 1;
20004176:	2301      	movs	r3, #1
20004178:	60fb      	str	r3, [r7, #12]
	    break;
2000417a:	e011      	b.n	200041a0 <is_command_separator+0x50>
	case '&':
	    if(*(string + 1) == '&')
2000417c:	68bb      	ldr	r3, [r7, #8]
2000417e:	3301      	adds	r3, #1
20004180:	781b      	ldrb	r3, [r3, #0]
20004182:	2b26      	cmp	r3, #38	@ 0x26
20004184:	d10b      	bne.n	2000419e <is_command_separator+0x4e>
		sep = 1;
20004186:	2301      	movs	r3, #1
20004188:	60fb      	str	r3, [r7, #12]
	    break;
2000418a:	e008      	b.n	2000419e <is_command_separator+0x4e>
	case '|':
	    if(*(string + 1) == '|')
2000418c:	68bb      	ldr	r3, [r7, #8]
2000418e:	3301      	adds	r3, #1
20004190:	781b      	ldrb	r3, [r3, #0]
20004192:	2b7c      	cmp	r3, #124	@ 0x7c
20004194:	d101      	bne.n	2000419a <is_command_separator+0x4a>
		sep = 1;
20004196:	2301      	movs	r3, #1
20004198:	60fb      	str	r3, [r7, #12]
	default:
	    break;
2000419a:	bf00      	nop
2000419c:	e000      	b.n	200041a0 <is_command_separator+0x50>
	    break;
2000419e:	bf00      	nop
	}

    return(sep);
200041a0:	68fb      	ldr	r3, [r7, #12]
}
200041a2:	4618      	mov	r0, r3
200041a4:	3714      	adds	r7, #20
200041a6:	46bd      	mov	sp, r7
200041a8:	f85d 7b04 	ldr.w	r7, [sp], #4
200041ac:	4770      	bx	lr
	...

200041b0 <cmd_eat_quoted_arg>:

static char *cmd_eat_quoted_arg(queue_t *head,ui_token_t *t)
{
200041b0:	b580      	push	{r7, lr}
200041b2:	b08a      	sub	sp, #40	@ 0x28
200041b4:	af00      	add	r7, sp, #0
200041b6:	6078      	str	r0, [r7, #4]
200041b8:	6039      	str	r1, [r7, #0]
    int dquote = 0;
200041ba:	2300      	movs	r3, #0
200041bc:	627b      	str	r3, [r7, #36]	@ 0x24
    int squote = 0;
200041be:	2300      	movs	r3, #0
200041c0:	623b      	str	r3, [r7, #32]
    queue_t qlist;
    queue_t *q;
    char *dest;
    int maxlen = 0;
200041c2:	2300      	movs	r3, #0
200041c4:	61bb      	str	r3, [r7, #24]

    /*
     * If it's not a quoted string, just return this token.
     */

    if (!myisquote(t->token)) {
200041c6:	683b      	ldr	r3, [r7, #0]
200041c8:	7a1b      	ldrb	r3, [r3, #8]
200041ca:	2b27      	cmp	r3, #39	@ 0x27
200041cc:	d00b      	beq.n	200041e6 <cmd_eat_quoted_arg+0x36>
200041ce:	683b      	ldr	r3, [r7, #0]
200041d0:	7a1b      	ldrb	r3, [r3, #8]
200041d2:	2b22      	cmp	r3, #34	@ 0x22
200041d4:	d007      	beq.n	200041e6 <cmd_eat_quoted_arg+0x36>
	dest = lib_strdup(&(t->token));
200041d6:	683b      	ldr	r3, [r7, #0]
200041d8:	3308      	adds	r3, #8
200041da:	4618      	mov	r0, r3
200041dc:	f7fd f930 	bl	20001440 <lib_strdup>
200041e0:	6178      	str	r0, [r7, #20]
	/* Note: caller deletes original token */
	return dest;
200041e2:	697b      	ldr	r3, [r7, #20]
200041e4:	e074      	b.n	200042d0 <cmd_eat_quoted_arg+0x120>

    /*
     * Otherwise, eat tokens in the quotes.
     */

    q_init(&qlist);
200041e6:	f107 030c 	add.w	r3, r7, #12
200041ea:	613b      	str	r3, [r7, #16]
200041ec:	f107 030c 	add.w	r3, r7, #12
200041f0:	60fb      	str	r3, [r7, #12]

    if (t->token == '"') dquote = 1;
200041f2:	683b      	ldr	r3, [r7, #0]
200041f4:	7a1b      	ldrb	r3, [r3, #8]
200041f6:	2b22      	cmp	r3, #34	@ 0x22
200041f8:	d102      	bne.n	20004200 <cmd_eat_quoted_arg+0x50>
200041fa:	2301      	movs	r3, #1
200041fc:	627b      	str	r3, [r7, #36]	@ 0x24
200041fe:	e001      	b.n	20004204 <cmd_eat_quoted_arg+0x54>
    else squote = 1;			/* must be one or the other */
20004200:	2301      	movs	r3, #1
20004202:	623b      	str	r3, [r7, #32]

    t = (ui_token_t *) q_deqnext(head);
20004204:	6878      	ldr	r0, [r7, #4]
20004206:	f7fc ffc2 	bl	2000118e <q_deqnext>
2000420a:	6038      	str	r0, [r7, #0]
    while (t != NULL) {
2000420c:	e024      	b.n	20004258 <cmd_eat_quoted_arg+0xa8>
	/* A single quote can only be terminated by another single quote */
	if (squote && (t->token == '\'')) {
2000420e:	6a3b      	ldr	r3, [r7, #32]
20004210:	2b00      	cmp	r3, #0
20004212:	d008      	beq.n	20004226 <cmd_eat_quoted_arg+0x76>
20004214:	683b      	ldr	r3, [r7, #0]
20004216:	7a1b      	ldrb	r3, [r3, #8]
20004218:	2b27      	cmp	r3, #39	@ 0x27
2000421a:	d104      	bne.n	20004226 <cmd_eat_quoted_arg+0x76>
	    KFREE(t);
2000421c:	6839      	ldr	r1, [r7, #0]
2000421e:	482e      	ldr	r0, [pc, #184]	@ (200042d8 <cmd_eat_quoted_arg+0x128>)
20004220:	f7fc fe94 	bl	20000f4c <kfree>
	    break;
20004224:	e01b      	b.n	2000425e <cmd_eat_quoted_arg+0xae>
	    }
	/* A double quote is only honored if not in a single quote */
	if (dquote && !squote && (t->token == '\"')) {
20004226:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
20004228:	2b00      	cmp	r3, #0
2000422a:	d00b      	beq.n	20004244 <cmd_eat_quoted_arg+0x94>
2000422c:	6a3b      	ldr	r3, [r7, #32]
2000422e:	2b00      	cmp	r3, #0
20004230:	d108      	bne.n	20004244 <cmd_eat_quoted_arg+0x94>
20004232:	683b      	ldr	r3, [r7, #0]
20004234:	7a1b      	ldrb	r3, [r3, #8]
20004236:	2b22      	cmp	r3, #34	@ 0x22
20004238:	d104      	bne.n	20004244 <cmd_eat_quoted_arg+0x94>
	    KFREE(t);
2000423a:	6839      	ldr	r1, [r7, #0]
2000423c:	4826      	ldr	r0, [pc, #152]	@ (200042d8 <cmd_eat_quoted_arg+0x128>)
2000423e:	f7fc fe85 	bl	20000f4c <kfree>
	    break;
20004242:	e00c      	b.n	2000425e <cmd_eat_quoted_arg+0xae>
	    }
	/* Otherwise, keep this token. */
	q_enqueue(&qlist,(queue_t *) t);
20004244:	f107 030c 	add.w	r3, r7, #12
20004248:	6839      	ldr	r1, [r7, #0]
2000424a:	4618      	mov	r0, r3
2000424c:	f7fc ff72 	bl	20001134 <q_enqueue>
	t = (ui_token_t *) q_deqnext(head);
20004250:	6878      	ldr	r0, [r7, #4]
20004252:	f7fc ff9c 	bl	2000118e <q_deqnext>
20004256:	6038      	str	r0, [r7, #0]
    while (t != NULL) {
20004258:	683b      	ldr	r3, [r7, #0]
2000425a:	2b00      	cmp	r3, #0
2000425c:	d1d7      	bne.n	2000420e <cmd_eat_quoted_arg+0x5e>

    /*
     * Go back through what we collected and figure out the string length.
     */

    for (q = qlist.q_next; q != &qlist; q = q->q_next) {
2000425e:	68fb      	ldr	r3, [r7, #12]
20004260:	61fb      	str	r3, [r7, #28]
20004262:	e00b      	b.n	2000427c <cmd_eat_quoted_arg+0xcc>
	maxlen += strlen(&(((ui_token_t *) q)->token));
20004264:	69fb      	ldr	r3, [r7, #28]
20004266:	3308      	adds	r3, #8
20004268:	4618      	mov	r0, r3
2000426a:	f7fd f812 	bl	20001292 <lib_strlen>
2000426e:	4602      	mov	r2, r0
20004270:	69bb      	ldr	r3, [r7, #24]
20004272:	4413      	add	r3, r2
20004274:	61bb      	str	r3, [r7, #24]
    for (q = qlist.q_next; q != &qlist; q = q->q_next) {
20004276:	69fb      	ldr	r3, [r7, #28]
20004278:	681b      	ldr	r3, [r3, #0]
2000427a:	61fb      	str	r3, [r7, #28]
2000427c:	f107 030c 	add.w	r3, r7, #12
20004280:	69fa      	ldr	r2, [r7, #28]
20004282:	429a      	cmp	r2, r3
20004284:	d1ee      	bne.n	20004264 <cmd_eat_quoted_arg+0xb4>
	}

    dest = KMALLOC(maxlen+1,0);
20004286:	69bb      	ldr	r3, [r7, #24]
20004288:	3301      	adds	r3, #1
2000428a:	2200      	movs	r2, #0
2000428c:	4619      	mov	r1, r3
2000428e:	4812      	ldr	r0, [pc, #72]	@ (200042d8 <cmd_eat_quoted_arg+0x128>)
20004290:	f7fc fe90 	bl	20000fb4 <kmalloc>
20004294:	6178      	str	r0, [r7, #20]
    if (!dest) return NULL;
20004296:	697b      	ldr	r3, [r7, #20]
20004298:	2b00      	cmp	r3, #0
2000429a:	d101      	bne.n	200042a0 <cmd_eat_quoted_arg+0xf0>
2000429c:	2300      	movs	r3, #0
2000429e:	e017      	b.n	200042d0 <cmd_eat_quoted_arg+0x120>

    *dest = '\0';
200042a0:	697b      	ldr	r3, [r7, #20]
200042a2:	2200      	movs	r2, #0
200042a4:	701a      	strb	r2, [r3, #0]

    while ((t = (ui_token_t *) q_deqnext(&qlist))) {
200042a6:	e009      	b.n	200042bc <cmd_eat_quoted_arg+0x10c>
	strcat(dest,&(t->token));
200042a8:	683b      	ldr	r3, [r7, #0]
200042aa:	3308      	adds	r3, #8
200042ac:	4619      	mov	r1, r3
200042ae:	6978      	ldr	r0, [r7, #20]
200042b0:	f7fd f8a0 	bl	200013f4 <lib_strcat>
	KFREE(t);
200042b4:	6839      	ldr	r1, [r7, #0]
200042b6:	4808      	ldr	r0, [pc, #32]	@ (200042d8 <cmd_eat_quoted_arg+0x128>)
200042b8:	f7fc fe48 	bl	20000f4c <kfree>
    while ((t = (ui_token_t *) q_deqnext(&qlist))) {
200042bc:	f107 030c 	add.w	r3, r7, #12
200042c0:	4618      	mov	r0, r3
200042c2:	f7fc ff64 	bl	2000118e <q_deqnext>
200042c6:	6038      	str	r0, [r7, #0]
200042c8:	683b      	ldr	r3, [r7, #0]
200042ca:	2b00      	cmp	r3, #0
200042cc:	d1ec      	bne.n	200042a8 <cmd_eat_quoted_arg+0xf8>
	}

    return dest;
200042ce:	697b      	ldr	r3, [r7, #20]
}
200042d0:	4618      	mov	r0, r3
200042d2:	3728      	adds	r7, #40	@ 0x28
200042d4:	46bd      	mov	sp, r7
200042d6:	bd80      	pop	{r7, pc}
200042d8:	20004ab4 	.word	0x20004ab4

200042dc <cmd_append_tokens>:

static void cmd_append_tokens(queue_t *qb,char *str)
{
200042dc:	b580      	push	{r7, lr}
200042de:	b086      	sub	sp, #24
200042e0:	af00      	add	r7, sp, #0
200042e2:	6078      	str	r0, [r7, #4]
200042e4:	6039      	str	r1, [r7, #0]
    queue_t *qq;
    queue_t explist;

    cmd_build_list(&explist,str);
200042e6:	f107 030c 	add.w	r3, r7, #12
200042ea:	6839      	ldr	r1, [r7, #0]
200042ec:	4618      	mov	r0, r3
200042ee:	f7ff fe91 	bl	20004014 <cmd_build_list>

    while ((qq = q_deqnext(&explist))) {
200042f2:	e003      	b.n	200042fc <cmd_append_tokens+0x20>
	q_enqueue(qb,qq);
200042f4:	6979      	ldr	r1, [r7, #20]
200042f6:	6878      	ldr	r0, [r7, #4]
200042f8:	f7fc ff1c 	bl	20001134 <q_enqueue>
    while ((qq = q_deqnext(&explist))) {
200042fc:	f107 030c 	add.w	r3, r7, #12
20004300:	4618      	mov	r0, r3
20004302:	f7fc ff44 	bl	2000118e <q_deqnext>
20004306:	6178      	str	r0, [r7, #20]
20004308:	697b      	ldr	r3, [r7, #20]
2000430a:	2b00      	cmp	r3, #0
2000430c:	d1f2      	bne.n	200042f4 <cmd_append_tokens+0x18>
	}
}
2000430e:	bf00      	nop
20004310:	bf00      	nop
20004312:	3718      	adds	r7, #24
20004314:	46bd      	mov	sp, r7
20004316:	bd80      	pop	{r7, pc}

20004318 <cmd_walk_and_expand>:
    printf("\n");
}
#endif

void cmd_walk_and_expand (queue_t *qb)
{
20004318:	b580      	push	{r7, lr}
2000431a:	b08a      	sub	sp, #40	@ 0x28
2000431c:	af00      	add	r7, sp, #0
2000431e:	6078      	str	r0, [r7, #4]
    queue_t *q;
    queue_t newq;
    ui_token_t *t;
    int alias_check = TRUE;
20004320:	2301      	movs	r3, #1
20004322:	623b      	str	r3, [r7, #32]
    int insquote = FALSE;
20004324:	2300      	movs	r3, #0
20004326:	61fb      	str	r3, [r7, #28]
    char *envstr;

    q_init(&newq);
20004328:	f107 030c 	add.w	r3, r7, #12
2000432c:	613b      	str	r3, [r7, #16]
2000432e:	f107 030c 	add.w	r3, r7, #12
20004332:	60fb      	str	r3, [r7, #12]

    while ((t = (ui_token_t *) q_deqnext(qb))) {
20004334:	e05c      	b.n	200043f0 <cmd_walk_and_expand+0xd8>
	if (t->token == '\'') {
20004336:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
20004338:	7a1b      	ldrb	r3, [r3, #8]
2000433a:	2b27      	cmp	r3, #39	@ 0x27
2000433c:	d109      	bne.n	20004352 <cmd_walk_and_expand+0x3a>
	    alias_check = FALSE;
2000433e:	2300      	movs	r3, #0
20004340:	623b      	str	r3, [r7, #32]
	    insquote = !insquote;
20004342:	69fb      	ldr	r3, [r7, #28]
20004344:	2b00      	cmp	r3, #0
20004346:	bf0c      	ite	eq
20004348:	2301      	moveq	r3, #1
2000434a:	2300      	movne	r3, #0
2000434c:	b2db      	uxtb	r3, r3
2000434e:	61fb      	str	r3, [r7, #28]
20004350:	e040      	b.n	200043d4 <cmd_walk_and_expand+0xbc>
	    /* Check to see if we should try to expand this token */
	    }
	else if (!insquote) {
20004352:	69fb      	ldr	r3, [r7, #28]
20004354:	2b00      	cmp	r3, #0
20004356:	d13d      	bne.n	200043d4 <cmd_walk_and_expand+0xbc>
	    if (alias_check && !strchr(tokenbreaks,t->token) && 
20004358:	6a3b      	ldr	r3, [r7, #32]
2000435a:	2b00      	cmp	r3, #0
2000435c:	d020      	beq.n	200043a0 <cmd_walk_and_expand+0x88>
2000435e:	4b31      	ldr	r3, [pc, #196]	@ (20004424 <cmd_walk_and_expand+0x10c>)
20004360:	681a      	ldr	r2, [r3, #0]
20004362:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
20004364:	7a1b      	ldrb	r3, [r3, #8]
20004366:	4619      	mov	r1, r3
20004368:	4610      	mov	r0, r2
2000436a:	f7fc ffeb 	bl	20001344 <lib_strchr>
2000436e:	4603      	mov	r3, r0
20004370:	2b00      	cmp	r3, #0
20004372:	d115      	bne.n	200043a0 <cmd_walk_and_expand+0x88>
		(envstr = env_getenv(&(t->token)))) {
20004374:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
20004376:	3308      	adds	r3, #8
20004378:	4618      	mov	r0, r3
2000437a:	f7ff f923 	bl	200035c4 <env_getenv>
2000437e:	6178      	str	r0, [r7, #20]
	    if (alias_check && !strchr(tokenbreaks,t->token) && 
20004380:	697b      	ldr	r3, [r7, #20]
20004382:	2b00      	cmp	r3, #0
20004384:	d00c      	beq.n	200043a0 <cmd_walk_and_expand+0x88>
		/* Aliases: stick into token stream if no environment found */
		cmd_append_tokens(&newq,envstr);
20004386:	f107 030c 	add.w	r3, r7, #12
2000438a:	6979      	ldr	r1, [r7, #20]
2000438c:	4618      	mov	r0, r3
2000438e:	f7ff ffa5 	bl	200042dc <cmd_append_tokens>
		KFREE(t);
20004392:	6a79      	ldr	r1, [r7, #36]	@ 0x24
20004394:	4824      	ldr	r0, [pc, #144]	@ (20004428 <cmd_walk_and_expand+0x110>)
20004396:	f7fc fdd9 	bl	20000f4c <kfree>
		t = NULL;
2000439a:	2300      	movs	r3, #0
2000439c:	627b      	str	r3, [r7, #36]	@ 0x24
2000439e:	e019      	b.n	200043d4 <cmd_walk_and_expand+0xbc>
		}
	    else if (t->token == '$') {
200043a0:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
200043a2:	7a1b      	ldrb	r3, [r3, #8]
200043a4:	2b24      	cmp	r3, #36	@ 0x24
200043a6:	d115      	bne.n	200043d4 <cmd_walk_and_expand+0xbc>
		/* non-aliases: remove from token stream if no env found */
		envstr = env_getenv(&(t->token)+1);
200043a8:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
200043aa:	3308      	adds	r3, #8
200043ac:	3301      	adds	r3, #1
200043ae:	4618      	mov	r0, r3
200043b0:	f7ff f908 	bl	200035c4 <env_getenv>
200043b4:	6178      	str	r0, [r7, #20]
		if (envstr) cmd_append_tokens(&newq,envstr);
200043b6:	697b      	ldr	r3, [r7, #20]
200043b8:	2b00      	cmp	r3, #0
200043ba:	d005      	beq.n	200043c8 <cmd_walk_and_expand+0xb0>
200043bc:	f107 030c 	add.w	r3, r7, #12
200043c0:	6979      	ldr	r1, [r7, #20]
200043c2:	4618      	mov	r0, r3
200043c4:	f7ff ff8a 	bl	200042dc <cmd_append_tokens>
		KFREE(t);
200043c8:	6a79      	ldr	r1, [r7, #36]	@ 0x24
200043ca:	4817      	ldr	r0, [pc, #92]	@ (20004428 <cmd_walk_and_expand+0x110>)
200043cc:	f7fc fdbe 	bl	20000f4c <kfree>
		t = NULL;
200043d0:	2300      	movs	r3, #0
200043d2:	627b      	str	r3, [r7, #36]	@ 0x24

	/*
	 * If token was not removed, add it to the new queue
	 */

	if (t) {
200043d4:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
200043d6:	2b00      	cmp	r3, #0
200043d8:	d00a      	beq.n	200043f0 <cmd_walk_and_expand+0xd8>
	    q_enqueue(&newq,&(t->qb));
200043da:	6a7a      	ldr	r2, [r7, #36]	@ 0x24
200043dc:	f107 030c 	add.w	r3, r7, #12
200043e0:	4611      	mov	r1, r2
200043e2:	4618      	mov	r0, r3
200043e4:	f7fc fea6 	bl	20001134 <q_enqueue>
	    alias_check = is_command_separator(t);
200043e8:	6a78      	ldr	r0, [r7, #36]	@ 0x24
200043ea:	f7ff feb1 	bl	20004150 <is_command_separator>
200043ee:	6238      	str	r0, [r7, #32]
    while ((t = (ui_token_t *) q_deqnext(qb))) {
200043f0:	6878      	ldr	r0, [r7, #4]
200043f2:	f7fc fecc 	bl	2000118e <q_deqnext>
200043f6:	6278      	str	r0, [r7, #36]	@ 0x24
200043f8:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
200043fa:	2b00      	cmp	r3, #0
200043fc:	d19b      	bne.n	20004336 <cmd_walk_and_expand+0x1e>

    /*
     * Put everything back on the original list. 
     */

    while ((q = q_deqnext(&newq))) {
200043fe:	e003      	b.n	20004408 <cmd_walk_and_expand+0xf0>
	q_enqueue(qb,q);
20004400:	69b9      	ldr	r1, [r7, #24]
20004402:	6878      	ldr	r0, [r7, #4]
20004404:	f7fc fe96 	bl	20001134 <q_enqueue>
    while ((q = q_deqnext(&newq))) {
20004408:	f107 030c 	add.w	r3, r7, #12
2000440c:	4618      	mov	r0, r3
2000440e:	f7fc febe 	bl	2000118e <q_deqnext>
20004412:	61b8      	str	r0, [r7, #24]
20004414:	69bb      	ldr	r3, [r7, #24]
20004416:	2b00      	cmp	r3, #0
20004418:	d1f2      	bne.n	20004400 <cmd_walk_and_expand+0xe8>
	}

}
2000441a:	bf00      	nop
2000441c:	bf00      	nop
2000441e:	3728      	adds	r7, #40	@ 0x28
20004420:	46bd      	mov	sp, r7
20004422:	bd80      	pop	{r7, pc}
20004424:	20004aa4 	.word	0x20004aa4
20004428:	20004ab4 	.word	0x20004ab4

2000442c <cmd_free_tokens>:

void cmd_free_tokens(queue_t *list)
{
2000442c:	b580      	push	{r7, lr}
2000442e:	b084      	sub	sp, #16
20004430:	af00      	add	r7, sp, #0
20004432:	6078      	str	r0, [r7, #4]
    queue_t *q;

    while ((q = q_deqnext(list))) {
20004434:	e003      	b.n	2000443e <cmd_free_tokens+0x12>
	KFREE(q);
20004436:	68f9      	ldr	r1, [r7, #12]
20004438:	4807      	ldr	r0, [pc, #28]	@ (20004458 <cmd_free_tokens+0x2c>)
2000443a:	f7fc fd87 	bl	20000f4c <kfree>
    while ((q = q_deqnext(list))) {
2000443e:	6878      	ldr	r0, [r7, #4]
20004440:	f7fc fea5 	bl	2000118e <q_deqnext>
20004444:	60f8      	str	r0, [r7, #12]
20004446:	68fb      	ldr	r3, [r7, #12]
20004448:	2b00      	cmp	r3, #0
2000444a:	d1f4      	bne.n	20004436 <cmd_free_tokens+0xa>
	}
}
2000444c:	bf00      	nop
2000444e:	bf00      	nop
20004450:	3710      	adds	r7, #16
20004452:	46bd      	mov	sp, r7
20004454:	bd80      	pop	{r7, pc}
20004456:	bf00      	nop
20004458:	20004ab4 	.word	0x20004ab4

Disassembly of section .init:

2000445c <_init>:
2000445c:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
2000445e:	bf00      	nop

Disassembly of section .fini:

20004460 <_fini>:
20004460:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
20004462:	bf00      	nop

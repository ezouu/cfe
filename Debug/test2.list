
test2.elf:     file format elf32-littlearm

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .isr_vector   00000010  20000000  20000000  00001000  2**0
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  1 .text         000053c8  20000010  20000010  00001010  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  2 .init         00000004  200053d8  200053d8  000063d8  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  3 .fini         00000004  200053dc  200053dc  000063dc  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  4 .rodata       00000a64  200053e0  200053e0  000063e0  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  5 .ARM.exidx    00000008  20005e44  20005e44  00006e44  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  6 .data         00000040  20005e4c  20005e4c  00006e4c  2**2
                  CONTENTS, ALLOC, LOAD, DATA
  7 .bss          00000270  20005e90  20005e90  00006e8c  2**3
                  ALLOC
  8 ._user_heap_stack 00000600  20006100  20006100  00006e8c  2**0
                  ALLOC
  9 .ARM.attributes 00000030  00000000  00000000  00006e8c  2**0
                  CONTENTS, READONLY
 10 .comment      00000043  00000000  00000000  00006ebc  2**0
                  CONTENTS, READONLY
 11 .debug_line   000062c6  00000000  00000000  00006eff  2**0
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 12 .debug_line_str 00000055  00000000  00000000  0000d1c5  2**0
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 13 .debug_info   00007119  00000000  00000000  0000d21a  2**0
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 14 .debug_abbrev 000022b0  00000000  00000000  00014333  2**0
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 15 .debug_aranges 00000828  00000000  00000000  000165e8  2**3
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 16 .debug_str    0000878a  00000000  00000000  00016e10  2**0
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 17 .debug_rnglists 000005f7  00000000  00000000  0001f59a  2**0
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 18 .debug_macro  00001a51  00000000  00000000  0001fb91  2**0
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 19 .debug_frame  00001f44  00000000  00000000  000215e4  2**2
                  CONTENTS, READONLY, DEBUGGING, OCTETS

Disassembly of section .text:

20000010 <__aeabi_uldivmod>:
20000010:	b953      	cbnz	r3, 20000028 <__aeabi_uldivmod+0x18>
20000012:	b94a      	cbnz	r2, 20000028 <__aeabi_uldivmod+0x18>
20000014:	2900      	cmp	r1, #0
20000016:	bf08      	it	eq
20000018:	2800      	cmpeq	r0, #0
2000001a:	bf1c      	itt	ne
2000001c:	f04f 31ff 	movne.w	r1, #4294967295	@ 0xffffffff
20000020:	f04f 30ff 	movne.w	r0, #4294967295	@ 0xffffffff
20000024:	f000 b96a 	b.w	200002fc <__aeabi_idiv0>
20000028:	f1ad 0c08 	sub.w	ip, sp, #8
2000002c:	e96d ce04 	strd	ip, lr, [sp, #-16]!
20000030:	f000 f806 	bl	20000040 <__udivmoddi4>
20000034:	f8dd e004 	ldr.w	lr, [sp, #4]
20000038:	e9dd 2302 	ldrd	r2, r3, [sp, #8]
2000003c:	b004      	add	sp, #16
2000003e:	4770      	bx	lr

20000040 <__udivmoddi4>:
20000040:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
20000044:	9d08      	ldr	r5, [sp, #32]
20000046:	460c      	mov	r4, r1
20000048:	2b00      	cmp	r3, #0
2000004a:	d14e      	bne.n	200000ea <__udivmoddi4+0xaa>
2000004c:	4694      	mov	ip, r2
2000004e:	458c      	cmp	ip, r1
20000050:	4686      	mov	lr, r0
20000052:	fab2 f282 	clz	r2, r2
20000056:	d962      	bls.n	2000011e <__udivmoddi4+0xde>
20000058:	b14a      	cbz	r2, 2000006e <__udivmoddi4+0x2e>
2000005a:	f1c2 0320 	rsb	r3, r2, #32
2000005e:	4091      	lsls	r1, r2
20000060:	fa20 f303 	lsr.w	r3, r0, r3
20000064:	fa0c fc02 	lsl.w	ip, ip, r2
20000068:	4319      	orrs	r1, r3
2000006a:	fa00 fe02 	lsl.w	lr, r0, r2
2000006e:	ea4f 471c 	mov.w	r7, ip, lsr #16
20000072:	fa1f f68c 	uxth.w	r6, ip
20000076:	fbb1 f4f7 	udiv	r4, r1, r7
2000007a:	ea4f 431e 	mov.w	r3, lr, lsr #16
2000007e:	fb07 1114 	mls	r1, r7, r4, r1
20000082:	ea43 4301 	orr.w	r3, r3, r1, lsl #16
20000086:	fb04 f106 	mul.w	r1, r4, r6
2000008a:	4299      	cmp	r1, r3
2000008c:	d90a      	bls.n	200000a4 <__udivmoddi4+0x64>
2000008e:	eb1c 0303 	adds.w	r3, ip, r3
20000092:	f104 30ff 	add.w	r0, r4, #4294967295	@ 0xffffffff
20000096:	f080 8112 	bcs.w	200002be <__udivmoddi4+0x27e>
2000009a:	4299      	cmp	r1, r3
2000009c:	f240 810f 	bls.w	200002be <__udivmoddi4+0x27e>
200000a0:	3c02      	subs	r4, #2
200000a2:	4463      	add	r3, ip
200000a4:	1a59      	subs	r1, r3, r1
200000a6:	fa1f f38e 	uxth.w	r3, lr
200000aa:	fbb1 f0f7 	udiv	r0, r1, r7
200000ae:	fb07 1110 	mls	r1, r7, r0, r1
200000b2:	ea43 4301 	orr.w	r3, r3, r1, lsl #16
200000b6:	fb00 f606 	mul.w	r6, r0, r6
200000ba:	429e      	cmp	r6, r3
200000bc:	d90a      	bls.n	200000d4 <__udivmoddi4+0x94>
200000be:	eb1c 0303 	adds.w	r3, ip, r3
200000c2:	f100 31ff 	add.w	r1, r0, #4294967295	@ 0xffffffff
200000c6:	f080 80fc 	bcs.w	200002c2 <__udivmoddi4+0x282>
200000ca:	429e      	cmp	r6, r3
200000cc:	f240 80f9 	bls.w	200002c2 <__udivmoddi4+0x282>
200000d0:	4463      	add	r3, ip
200000d2:	3802      	subs	r0, #2
200000d4:	1b9b      	subs	r3, r3, r6
200000d6:	ea40 4004 	orr.w	r0, r0, r4, lsl #16
200000da:	2100      	movs	r1, #0
200000dc:	b11d      	cbz	r5, 200000e6 <__udivmoddi4+0xa6>
200000de:	40d3      	lsrs	r3, r2
200000e0:	2200      	movs	r2, #0
200000e2:	e9c5 3200 	strd	r3, r2, [r5]
200000e6:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
200000ea:	428b      	cmp	r3, r1
200000ec:	d905      	bls.n	200000fa <__udivmoddi4+0xba>
200000ee:	b10d      	cbz	r5, 200000f4 <__udivmoddi4+0xb4>
200000f0:	e9c5 0100 	strd	r0, r1, [r5]
200000f4:	2100      	movs	r1, #0
200000f6:	4608      	mov	r0, r1
200000f8:	e7f5      	b.n	200000e6 <__udivmoddi4+0xa6>
200000fa:	fab3 f183 	clz	r1, r3
200000fe:	2900      	cmp	r1, #0
20000100:	d146      	bne.n	20000190 <__udivmoddi4+0x150>
20000102:	42a3      	cmp	r3, r4
20000104:	d302      	bcc.n	2000010c <__udivmoddi4+0xcc>
20000106:	4290      	cmp	r0, r2
20000108:	f0c0 80f0 	bcc.w	200002ec <__udivmoddi4+0x2ac>
2000010c:	1a86      	subs	r6, r0, r2
2000010e:	eb64 0303 	sbc.w	r3, r4, r3
20000112:	2001      	movs	r0, #1
20000114:	2d00      	cmp	r5, #0
20000116:	d0e6      	beq.n	200000e6 <__udivmoddi4+0xa6>
20000118:	e9c5 6300 	strd	r6, r3, [r5]
2000011c:	e7e3      	b.n	200000e6 <__udivmoddi4+0xa6>
2000011e:	2a00      	cmp	r2, #0
20000120:	f040 8090 	bne.w	20000244 <__udivmoddi4+0x204>
20000124:	eba1 040c 	sub.w	r4, r1, ip
20000128:	ea4f 481c 	mov.w	r8, ip, lsr #16
2000012c:	fa1f f78c 	uxth.w	r7, ip
20000130:	2101      	movs	r1, #1
20000132:	fbb4 f6f8 	udiv	r6, r4, r8
20000136:	ea4f 431e 	mov.w	r3, lr, lsr #16
2000013a:	fb08 4416 	mls	r4, r8, r6, r4
2000013e:	ea43 4304 	orr.w	r3, r3, r4, lsl #16
20000142:	fb07 f006 	mul.w	r0, r7, r6
20000146:	4298      	cmp	r0, r3
20000148:	d908      	bls.n	2000015c <__udivmoddi4+0x11c>
2000014a:	eb1c 0303 	adds.w	r3, ip, r3
2000014e:	f106 34ff 	add.w	r4, r6, #4294967295	@ 0xffffffff
20000152:	d202      	bcs.n	2000015a <__udivmoddi4+0x11a>
20000154:	4298      	cmp	r0, r3
20000156:	f200 80cd 	bhi.w	200002f4 <__udivmoddi4+0x2b4>
2000015a:	4626      	mov	r6, r4
2000015c:	1a1c      	subs	r4, r3, r0
2000015e:	fa1f f38e 	uxth.w	r3, lr
20000162:	fbb4 f0f8 	udiv	r0, r4, r8
20000166:	fb08 4410 	mls	r4, r8, r0, r4
2000016a:	ea43 4304 	orr.w	r3, r3, r4, lsl #16
2000016e:	fb00 f707 	mul.w	r7, r0, r7
20000172:	429f      	cmp	r7, r3
20000174:	d908      	bls.n	20000188 <__udivmoddi4+0x148>
20000176:	eb1c 0303 	adds.w	r3, ip, r3
2000017a:	f100 34ff 	add.w	r4, r0, #4294967295	@ 0xffffffff
2000017e:	d202      	bcs.n	20000186 <__udivmoddi4+0x146>
20000180:	429f      	cmp	r7, r3
20000182:	f200 80b0 	bhi.w	200002e6 <__udivmoddi4+0x2a6>
20000186:	4620      	mov	r0, r4
20000188:	1bdb      	subs	r3, r3, r7
2000018a:	ea40 4006 	orr.w	r0, r0, r6, lsl #16
2000018e:	e7a5      	b.n	200000dc <__udivmoddi4+0x9c>
20000190:	f1c1 0620 	rsb	r6, r1, #32
20000194:	408b      	lsls	r3, r1
20000196:	fa22 f706 	lsr.w	r7, r2, r6
2000019a:	431f      	orrs	r7, r3
2000019c:	fa20 fc06 	lsr.w	ip, r0, r6
200001a0:	fa04 f301 	lsl.w	r3, r4, r1
200001a4:	ea43 030c 	orr.w	r3, r3, ip
200001a8:	40f4      	lsrs	r4, r6
200001aa:	fa00 f801 	lsl.w	r8, r0, r1
200001ae:	0c38      	lsrs	r0, r7, #16
200001b0:	ea4f 4913 	mov.w	r9, r3, lsr #16
200001b4:	fbb4 fef0 	udiv	lr, r4, r0
200001b8:	fa1f fc87 	uxth.w	ip, r7
200001bc:	fb00 441e 	mls	r4, r0, lr, r4
200001c0:	ea49 4404 	orr.w	r4, r9, r4, lsl #16
200001c4:	fb0e f90c 	mul.w	r9, lr, ip
200001c8:	45a1      	cmp	r9, r4
200001ca:	fa02 f201 	lsl.w	r2, r2, r1
200001ce:	d90a      	bls.n	200001e6 <__udivmoddi4+0x1a6>
200001d0:	193c      	adds	r4, r7, r4
200001d2:	f10e 3aff 	add.w	sl, lr, #4294967295	@ 0xffffffff
200001d6:	f080 8084 	bcs.w	200002e2 <__udivmoddi4+0x2a2>
200001da:	45a1      	cmp	r9, r4
200001dc:	f240 8081 	bls.w	200002e2 <__udivmoddi4+0x2a2>
200001e0:	f1ae 0e02 	sub.w	lr, lr, #2
200001e4:	443c      	add	r4, r7
200001e6:	eba4 0409 	sub.w	r4, r4, r9
200001ea:	fa1f f983 	uxth.w	r9, r3
200001ee:	fbb4 f3f0 	udiv	r3, r4, r0
200001f2:	fb00 4413 	mls	r4, r0, r3, r4
200001f6:	ea49 4404 	orr.w	r4, r9, r4, lsl #16
200001fa:	fb03 fc0c 	mul.w	ip, r3, ip
200001fe:	45a4      	cmp	ip, r4
20000200:	d907      	bls.n	20000212 <__udivmoddi4+0x1d2>
20000202:	193c      	adds	r4, r7, r4
20000204:	f103 30ff 	add.w	r0, r3, #4294967295	@ 0xffffffff
20000208:	d267      	bcs.n	200002da <__udivmoddi4+0x29a>
2000020a:	45a4      	cmp	ip, r4
2000020c:	d965      	bls.n	200002da <__udivmoddi4+0x29a>
2000020e:	3b02      	subs	r3, #2
20000210:	443c      	add	r4, r7
20000212:	ea43 400e 	orr.w	r0, r3, lr, lsl #16
20000216:	fba0 9302 	umull	r9, r3, r0, r2
2000021a:	eba4 040c 	sub.w	r4, r4, ip
2000021e:	429c      	cmp	r4, r3
20000220:	46ce      	mov	lr, r9
20000222:	469c      	mov	ip, r3
20000224:	d351      	bcc.n	200002ca <__udivmoddi4+0x28a>
20000226:	d04e      	beq.n	200002c6 <__udivmoddi4+0x286>
20000228:	b155      	cbz	r5, 20000240 <__udivmoddi4+0x200>
2000022a:	ebb8 030e 	subs.w	r3, r8, lr
2000022e:	eb64 040c 	sbc.w	r4, r4, ip
20000232:	fa04 f606 	lsl.w	r6, r4, r6
20000236:	40cb      	lsrs	r3, r1
20000238:	431e      	orrs	r6, r3
2000023a:	40cc      	lsrs	r4, r1
2000023c:	e9c5 6400 	strd	r6, r4, [r5]
20000240:	2100      	movs	r1, #0
20000242:	e750      	b.n	200000e6 <__udivmoddi4+0xa6>
20000244:	f1c2 0320 	rsb	r3, r2, #32
20000248:	fa20 f103 	lsr.w	r1, r0, r3
2000024c:	fa0c fc02 	lsl.w	ip, ip, r2
20000250:	fa24 f303 	lsr.w	r3, r4, r3
20000254:	4094      	lsls	r4, r2
20000256:	430c      	orrs	r4, r1
20000258:	ea4f 481c 	mov.w	r8, ip, lsr #16
2000025c:	fa00 fe02 	lsl.w	lr, r0, r2
20000260:	fa1f f78c 	uxth.w	r7, ip
20000264:	fbb3 f0f8 	udiv	r0, r3, r8
20000268:	fb08 3110 	mls	r1, r8, r0, r3
2000026c:	0c23      	lsrs	r3, r4, #16
2000026e:	ea43 4301 	orr.w	r3, r3, r1, lsl #16
20000272:	fb00 f107 	mul.w	r1, r0, r7
20000276:	4299      	cmp	r1, r3
20000278:	d908      	bls.n	2000028c <__udivmoddi4+0x24c>
2000027a:	eb1c 0303 	adds.w	r3, ip, r3
2000027e:	f100 36ff 	add.w	r6, r0, #4294967295	@ 0xffffffff
20000282:	d22c      	bcs.n	200002de <__udivmoddi4+0x29e>
20000284:	4299      	cmp	r1, r3
20000286:	d92a      	bls.n	200002de <__udivmoddi4+0x29e>
20000288:	3802      	subs	r0, #2
2000028a:	4463      	add	r3, ip
2000028c:	1a5b      	subs	r3, r3, r1
2000028e:	b2a4      	uxth	r4, r4
20000290:	fbb3 f1f8 	udiv	r1, r3, r8
20000294:	fb08 3311 	mls	r3, r8, r1, r3
20000298:	ea44 4403 	orr.w	r4, r4, r3, lsl #16
2000029c:	fb01 f307 	mul.w	r3, r1, r7
200002a0:	42a3      	cmp	r3, r4
200002a2:	d908      	bls.n	200002b6 <__udivmoddi4+0x276>
200002a4:	eb1c 0404 	adds.w	r4, ip, r4
200002a8:	f101 36ff 	add.w	r6, r1, #4294967295	@ 0xffffffff
200002ac:	d213      	bcs.n	200002d6 <__udivmoddi4+0x296>
200002ae:	42a3      	cmp	r3, r4
200002b0:	d911      	bls.n	200002d6 <__udivmoddi4+0x296>
200002b2:	3902      	subs	r1, #2
200002b4:	4464      	add	r4, ip
200002b6:	1ae4      	subs	r4, r4, r3
200002b8:	ea41 4100 	orr.w	r1, r1, r0, lsl #16
200002bc:	e739      	b.n	20000132 <__udivmoddi4+0xf2>
200002be:	4604      	mov	r4, r0
200002c0:	e6f0      	b.n	200000a4 <__udivmoddi4+0x64>
200002c2:	4608      	mov	r0, r1
200002c4:	e706      	b.n	200000d4 <__udivmoddi4+0x94>
200002c6:	45c8      	cmp	r8, r9
200002c8:	d2ae      	bcs.n	20000228 <__udivmoddi4+0x1e8>
200002ca:	ebb9 0e02 	subs.w	lr, r9, r2
200002ce:	eb63 0c07 	sbc.w	ip, r3, r7
200002d2:	3801      	subs	r0, #1
200002d4:	e7a8      	b.n	20000228 <__udivmoddi4+0x1e8>
200002d6:	4631      	mov	r1, r6
200002d8:	e7ed      	b.n	200002b6 <__udivmoddi4+0x276>
200002da:	4603      	mov	r3, r0
200002dc:	e799      	b.n	20000212 <__udivmoddi4+0x1d2>
200002de:	4630      	mov	r0, r6
200002e0:	e7d4      	b.n	2000028c <__udivmoddi4+0x24c>
200002e2:	46d6      	mov	lr, sl
200002e4:	e77f      	b.n	200001e6 <__udivmoddi4+0x1a6>
200002e6:	4463      	add	r3, ip
200002e8:	3802      	subs	r0, #2
200002ea:	e74d      	b.n	20000188 <__udivmoddi4+0x148>
200002ec:	4606      	mov	r6, r0
200002ee:	4623      	mov	r3, r4
200002f0:	4608      	mov	r0, r1
200002f2:	e70f      	b.n	20000114 <__udivmoddi4+0xd4>
200002f4:	3e02      	subs	r6, #2
200002f6:	4463      	add	r3, ip
200002f8:	e730      	b.n	2000015c <__udivmoddi4+0x11c>
200002fa:	bf00      	nop

200002fc <__aeabi_idiv0>:
200002fc:	4770      	bx	lr
200002fe:	bf00      	nop

20000300 <Reset_Handler>:
   .section	.text.Reset_Handler
	.weak	Reset_Handler
	.type	Reset_Handler, %function
Reset_Handler:

 ldr   sp, =_estack    /* Set stack pointer */
20000300:	f8df d0e8 	ldr.w	sp, [pc, #232]	@ 200003ec <L__usart_tdr+0x4>

/* Zero fill the bss segment. */
  ldr r2, =_sbss
20000304:	4a3a      	ldr	r2, [pc, #232]	@ (200003f0 <L__usart_tdr+0x8>)
  ldr r4, =_ebss
20000306:	4c3b      	ldr	r4, [pc, #236]	@ (200003f4 <L__usart_tdr+0xc>)
  movs r3, #0
20000308:	2300      	movs	r3, #0

1:
  cmp r2, r4
2000030a:	42a2      	cmp	r2, r4
  beq 2f
2000030c:	d002      	beq.n	20000314 <Reset_Handler+0x14>

  str  r3, [r2]
2000030e:	6013      	str	r3, [r2, #0]
  adds r2, r2, #4
20000310:	3204      	adds	r2, #4
  b  1b
20000312:	e7fa      	b.n	2000030a <Reset_Handler+0xa>

2:

  /* enable gpio clk from bus */
  ldr   r0, L__rcc_ahb2enr
20000314:	f8df 00a4 	ldr.w	r0, [pc, #164]	@ 200003bc <L__rcc_ahb2enr>
  mov   r1, 0x2
20000318:	f04f 0102 	mov.w	r1, #2
  str   r1, [r0]
2000031c:	6001      	str	r1, [r0, #0]

  /* enable hsi 16M OSC */
  ldr   r0, L__rcc_cr
2000031e:	4826      	ldr	r0, [pc, #152]	@ (200003b8 <L__rcc_cr>)
  mov   r1, 0xf00
20000320:	f44f 6170 	mov.w	r1, #3840	@ 0xf00
  str   r1, [r0]
20000324:	6001      	str	r1, [r0, #0]

  /* choose uart clk source as hsi 16Mhz */
  ldr   r0, L__rcc_ccipr
20000326:	4826      	ldr	r0, [pc, #152]	@ (200003c0 <L__rcc_ccipr>)
  mov   r1, 0x2
20000328:	f04f 0102 	mov.w	r1, #2
  str   r1, [r0]
2000032c:	6001      	str	r1, [r0, #0]


  /* enable uart clk from bus */
  ldr   r0, L__rcc_apb2enr
2000032e:	4825      	ldr	r0, [pc, #148]	@ (200003c4 <L__rcc_apb2enr>)
  mov   r1, 0x4000
20000330:	f44f 4180 	mov.w	r1, #16384	@ 0x4000
  str   r1, [r0]
20000334:	6001      	str	r1, [r0, #0]


  /*gpio, set as alt */
  ldr   r0, L__gpio_moder
20000336:	4824      	ldr	r0, [pc, #144]	@ (200003c8 <L__gpio_moder>)
  mov   r1, 0xa000
20000338:	f44f 4120 	mov.w	r1, #40960	@ 0xa000
  str   r1, [r0]
2000033c:	6001      	str	r1, [r0, #0]

   /*gpio, set as alt 7 */
  ldr   r0, L__gpio_afrl
2000033e:	4823      	ldr	r0, [pc, #140]	@ (200003cc <L__gpio_afrl>)
  mov   r1, 0x77000000
20000340:	f04f 41ee 	mov.w	r1, #1996488704	@ 0x77000000
  str   r1, [r0]
20000344:	6001      	str	r1, [r0, #0]


    /*uart, control, enable */
  ldr   r0, L__usart_cr1
20000346:	4824      	ldr	r0, [pc, #144]	@ (200003d8 <L__usart_cr1>)
  mov   r1, 0xd
20000348:	f04f 010d 	mov.w	r1, #13
  str   r1, [r0]
2000034c:	6001      	str	r1, [r0, #0]

   /*uart, baudrate */
  ldr   r0, L__usart_brr
2000034e:	4824      	ldr	r0, [pc, #144]	@ (200003e0 <L__usart_brr>)
  mov   r1, 0x8b
20000350:	f04f 018b 	mov.w	r1, #139	@ 0x8b
  str   r1, [r0]
20000354:	6001      	str	r1, [r0, #0]

  ldr   r0, L__usart_isr
20000356:	4823      	ldr	r0, [pc, #140]	@ (200003e4 <L__usart_isr>)
1:
  ldr   r1, [r0]
20000358:	6801      	ldr	r1, [r0, #0]
  and   r1,  1<<7
2000035a:	f001 0180 	and.w	r1, r1, #128	@ 0x80
  cmp   r1,  1<<7
2000035e:	2980      	cmp	r1, #128	@ 0x80
  bne   1b
20000360:	d1fa      	bne.n	20000358 <Reset_Handler+0x58>


     /*uart, tx data */
  ldr   r0, L__usart_tdr
20000362:	4821      	ldr	r0, [pc, #132]	@ (200003e8 <L__usart_tdr>)
  mov   r1, 0x59
20000364:	f04f 0159 	mov.w	r1, #89	@ 0x59
  str   r1, [r0]
20000368:	6001      	str	r1, [r0, #0]



  ldr   r0, L__usart_isr
2000036a:	481e      	ldr	r0, [pc, #120]	@ (200003e4 <L__usart_isr>)
1:
  ldr   r1, [r0]
2000036c:	6801      	ldr	r1, [r0, #0]
  and   r1, 1<<7
2000036e:	f001 0180 	and.w	r1, r1, #128	@ 0x80
  cmp   r1, 1<<7
20000372:	2980      	cmp	r1, #128	@ 0x80
  bne   1b
20000374:	d1fa      	bne.n	2000036c <Reset_Handler+0x6c>

  ldr   r0, L__usart_tdr
20000376:	481c      	ldr	r0, [pc, #112]	@ (200003e8 <L__usart_tdr>)
  mov   r1, 0x58
20000378:	f04f 0158 	mov.w	r1, #88	@ 0x58
  str   r1, [r0]
2000037c:	6001      	str	r1, [r0, #0]
  mov r0, #1
2000037e:	f04f 0001 	mov.w	r0, #1
  mov r1, #2
20000382:	f04f 0102 	mov.w	r1, #2

20000386 <compute>:


compute:
  add r2, r1, r0
20000386:	eb01 0200 	add.w	r2, r1, r0
  mov r0, r2
2000038a:	4610      	mov	r0, r2
  add r1, r1, #1
2000038c:	f101 0101 	add.w	r1, r1, #1

  cmp r1, #101
20000390:	2965      	cmp	r1, #101	@ 0x65
  bne compute
20000392:	d1f8      	bne.n	20000386 <compute>

//mov  r2, 0x8800
//bl start


bl cfe_main
20000394:	f002 ff9c 	bl	200032d0 <cfe_main>

20000398 <start>:

start:
    ldr   r1, [r0]
20000398:	6801      	ldr	r1, [r0, #0]
    ands  r1, r1, 1<<7
2000039a:	f011 0180 	ands.w	r1, r1, #128	@ 0x80
    beq   start
2000039e:	d0fb      	beq.n	20000398 <start>
    ldr   r0, L__usart_tdr
200003a0:	4811      	ldr	r0, [pc, #68]	@ (200003e8 <L__usart_tdr>)
    mov   r1, #48
200003a2:	f04f 0130 	mov.w	r1, #48	@ 0x30
    str   r1, [r0]
200003a6:	6001      	str	r1, [r0, #0]

200003a8 <stop>:


stop:
    ldr   r1, [r0]
200003a8:	6801      	ldr	r1, [r0, #0]
    ands  r1, r1, 1<<7
200003aa:	f011 0180 	ands.w	r1, r1, #128	@ 0x80
    beq   stop
200003ae:	d0fb      	beq.n	200003a8 <stop>
    ldr   r0, L__usart_tdr
200003b0:	480d      	ldr	r0, [pc, #52]	@ (200003e8 <L__usart_tdr>)
    mov   r1, #49
200003b2:	f04f 0131 	mov.w	r1, #49	@ 0x31
    str   r1, [r0]
200003b6:	6001      	str	r1, [r0, #0]

200003b8 <L__rcc_cr>:
200003b8:	40021000 	.word	0x40021000

200003bc <L__rcc_ahb2enr>:
200003bc:	4002104c 	.word	0x4002104c

200003c0 <L__rcc_ccipr>:
200003c0:	40021088 	.word	0x40021088

200003c4 <L__rcc_apb2enr>:
200003c4:	40021060 	.word	0x40021060

200003c8 <L__gpio_moder>:
200003c8:	48000400 	.word	0x48000400

200003cc <L__gpio_afrl>:
200003cc:	48000420 	.word	0x48000420

200003d0 <L__gpio_ospeedr>:
200003d0:	48000408 	.word	0x48000408

200003d4 <L__gpio_pupdr>:
200003d4:	4800040c 	.word	0x4800040c

200003d8 <L__usart_cr1>:
200003d8:	40013800 	.word	0x40013800

200003dc <L__usart_otyper>:
200003dc:	40013804 	.word	0x40013804

200003e0 <L__usart_brr>:
200003e0:	4001380c 	.word	0x4001380c

200003e4 <L__usart_isr>:
200003e4:	4001381c 	.word	0x4001381c

200003e8 <L__usart_tdr>:
200003e8:	40013828 	.word	0x40013828
 ldr   sp, =_estack    /* Set stack pointer */
200003ec:	20018000 	.word	0x20018000
  ldr r2, =_sbss
200003f0:	20005e90 	.word	0x20005e90
  ldr r4, =_ebss
200003f4:	20006100 	.word	0x20006100

200003f8 <__atox>:
    *  Return Value:
    *      number of digits placed in output buffer
    ********************************************************************* */
static int __atox(char *buf,unsigned int num,unsigned int radix,int width,
		     const char *digits)
{
200003f8:	b480      	push	{r7}
200003fa:	b08b      	sub	sp, #44	@ 0x2c
200003fc:	af00      	add	r7, sp, #0
200003fe:	60f8      	str	r0, [r7, #12]
20000400:	60b9      	str	r1, [r7, #8]
20000402:	607a      	str	r2, [r7, #4]
20000404:	603b      	str	r3, [r7, #0]
    char buffer[16];
    char *op;
    int retval;

    op = &buffer[0];
20000406:	f107 0310 	add.w	r3, r7, #16
2000040a:	627b      	str	r3, [r7, #36]	@ 0x24
    retval = 0;
2000040c:	2300      	movs	r3, #0
2000040e:	623b      	str	r3, [r7, #32]

    do {
	*op++ = digits[num % radix];
20000410:	68bb      	ldr	r3, [r7, #8]
20000412:	687a      	ldr	r2, [r7, #4]
20000414:	fbb3 f2f2 	udiv	r2, r3, r2
20000418:	6879      	ldr	r1, [r7, #4]
2000041a:	fb01 f202 	mul.w	r2, r1, r2
2000041e:	1a9b      	subs	r3, r3, r2
20000420:	6b3a      	ldr	r2, [r7, #48]	@ 0x30
20000422:	441a      	add	r2, r3
20000424:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
20000426:	1c59      	adds	r1, r3, #1
20000428:	6279      	str	r1, [r7, #36]	@ 0x24
2000042a:	7812      	ldrb	r2, [r2, #0]
2000042c:	701a      	strb	r2, [r3, #0]
	retval++;
2000042e:	6a3b      	ldr	r3, [r7, #32]
20000430:	3301      	adds	r3, #1
20000432:	623b      	str	r3, [r7, #32]
	num /= radix;
20000434:	68ba      	ldr	r2, [r7, #8]
20000436:	687b      	ldr	r3, [r7, #4]
20000438:	fbb2 f3f3 	udiv	r3, r2, r3
2000043c:	60bb      	str	r3, [r7, #8]
	} while (num != 0);
2000043e:	68bb      	ldr	r3, [r7, #8]
20000440:	2b00      	cmp	r3, #0
20000442:	d1e5      	bne.n	20000410 <__atox+0x18>

    if (width && (width > retval)) {
20000444:	683b      	ldr	r3, [r7, #0]
20000446:	2b00      	cmp	r3, #0
20000448:	d020      	beq.n	2000048c <__atox+0x94>
2000044a:	683a      	ldr	r2, [r7, #0]
2000044c:	6a3b      	ldr	r3, [r7, #32]
2000044e:	429a      	cmp	r2, r3
20000450:	dd1c      	ble.n	2000048c <__atox+0x94>
	width = width - retval;
20000452:	683a      	ldr	r2, [r7, #0]
20000454:	6a3b      	ldr	r3, [r7, #32]
20000456:	1ad3      	subs	r3, r2, r3
20000458:	603b      	str	r3, [r7, #0]
	while (width) {
2000045a:	e00a      	b.n	20000472 <__atox+0x7a>
	    *op++ = '0';
2000045c:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
2000045e:	1c5a      	adds	r2, r3, #1
20000460:	627a      	str	r2, [r7, #36]	@ 0x24
20000462:	2230      	movs	r2, #48	@ 0x30
20000464:	701a      	strb	r2, [r3, #0]
	    retval++;
20000466:	6a3b      	ldr	r3, [r7, #32]
20000468:	3301      	adds	r3, #1
2000046a:	623b      	str	r3, [r7, #32]
	    width--;
2000046c:	683b      	ldr	r3, [r7, #0]
2000046e:	3b01      	subs	r3, #1
20000470:	603b      	str	r3, [r7, #0]
	while (width) {
20000472:	683b      	ldr	r3, [r7, #0]
20000474:	2b00      	cmp	r3, #0
20000476:	d1f1      	bne.n	2000045c <__atox+0x64>
	    }
	}

    while (op != buffer) {
20000478:	e008      	b.n	2000048c <__atox+0x94>
	op--;
2000047a:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
2000047c:	3b01      	subs	r3, #1
2000047e:	627b      	str	r3, [r7, #36]	@ 0x24
	*buf++ = *op;
20000480:	68fb      	ldr	r3, [r7, #12]
20000482:	1c5a      	adds	r2, r3, #1
20000484:	60fa      	str	r2, [r7, #12]
20000486:	6a7a      	ldr	r2, [r7, #36]	@ 0x24
20000488:	7812      	ldrb	r2, [r2, #0]
2000048a:	701a      	strb	r2, [r3, #0]
    while (op != buffer) {
2000048c:	f107 0310 	add.w	r3, r7, #16
20000490:	6a7a      	ldr	r2, [r7, #36]	@ 0x24
20000492:	429a      	cmp	r2, r3
20000494:	d1f1      	bne.n	2000047a <__atox+0x82>
	}

    return retval;
20000496:	6a3b      	ldr	r3, [r7, #32]
}
20000498:	4618      	mov	r0, r3
2000049a:	372c      	adds	r7, #44	@ 0x2c
2000049c:	46bd      	mov	sp, r7
2000049e:	f85d 7b04 	ldr.w	r7, [sp], #4
200004a2:	4770      	bx	lr

200004a4 <__llatox>:
    *  Return Value:
    *      number of digits placed in output buffer
    ********************************************************************* */
static int __llatox(char *buf,unsigned long long num,unsigned int radix,
		    int width,const char *digits)
{
200004a4:	e92d 43b0 	stmdb	sp!, {r4, r5, r7, r8, r9, lr}
200004a8:	b08a      	sub	sp, #40	@ 0x28
200004aa:	af00      	add	r7, sp, #0
200004ac:	60f8      	str	r0, [r7, #12]
200004ae:	e9c7 2300 	strd	r2, r3, [r7]
    char buffer[16];
    char *op;
    int retval;

    op = &buffer[0];
200004b2:	f107 0310 	add.w	r3, r7, #16
200004b6:	627b      	str	r3, [r7, #36]	@ 0x24
    retval = 0;
200004b8:	2300      	movs	r3, #0
200004ba:	623b      	str	r3, [r7, #32]
	retval++;
	num >>= 4;
	} while (num != 0);
#else
    do {
	*op++ = digits[num % radix];
200004bc:	6c3b      	ldr	r3, [r7, #64]	@ 0x40
200004be:	2200      	movs	r2, #0
200004c0:	4698      	mov	r8, r3
200004c2:	4691      	mov	r9, r2
200004c4:	e9d7 0100 	ldrd	r0, r1, [r7]
200004c8:	4642      	mov	r2, r8
200004ca:	464b      	mov	r3, r9
200004cc:	f7ff fda0 	bl	20000010 <__aeabi_uldivmod>
200004d0:	6cbb      	ldr	r3, [r7, #72]	@ 0x48
200004d2:	441a      	add	r2, r3
200004d4:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
200004d6:	1c59      	adds	r1, r3, #1
200004d8:	6279      	str	r1, [r7, #36]	@ 0x24
200004da:	7812      	ldrb	r2, [r2, #0]
200004dc:	701a      	strb	r2, [r3, #0]
	retval++;
200004de:	6a3b      	ldr	r3, [r7, #32]
200004e0:	3301      	adds	r3, #1
200004e2:	623b      	str	r3, [r7, #32]
	num /= radix;
200004e4:	6c3b      	ldr	r3, [r7, #64]	@ 0x40
200004e6:	2200      	movs	r2, #0
200004e8:	461c      	mov	r4, r3
200004ea:	4615      	mov	r5, r2
200004ec:	4622      	mov	r2, r4
200004ee:	462b      	mov	r3, r5
200004f0:	e9d7 0100 	ldrd	r0, r1, [r7]
200004f4:	f7ff fd8c 	bl	20000010 <__aeabi_uldivmod>
200004f8:	4602      	mov	r2, r0
200004fa:	460b      	mov	r3, r1
200004fc:	e9c7 2300 	strd	r2, r3, [r7]
	} while (num != 0);
20000500:	e9d7 2300 	ldrd	r2, r3, [r7]
20000504:	4313      	orrs	r3, r2
20000506:	d1d9      	bne.n	200004bc <__llatox+0x18>
#endif

    if (width && (width > retval)) {
20000508:	6c7b      	ldr	r3, [r7, #68]	@ 0x44
2000050a:	2b00      	cmp	r3, #0
2000050c:	d020      	beq.n	20000550 <__llatox+0xac>
2000050e:	6c7a      	ldr	r2, [r7, #68]	@ 0x44
20000510:	6a3b      	ldr	r3, [r7, #32]
20000512:	429a      	cmp	r2, r3
20000514:	dd1c      	ble.n	20000550 <__llatox+0xac>
	width = width - retval;
20000516:	6c7a      	ldr	r2, [r7, #68]	@ 0x44
20000518:	6a3b      	ldr	r3, [r7, #32]
2000051a:	1ad3      	subs	r3, r2, r3
2000051c:	647b      	str	r3, [r7, #68]	@ 0x44
	while (width) {
2000051e:	e00a      	b.n	20000536 <__llatox+0x92>
	    *op++ = '0';
20000520:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
20000522:	1c5a      	adds	r2, r3, #1
20000524:	627a      	str	r2, [r7, #36]	@ 0x24
20000526:	2230      	movs	r2, #48	@ 0x30
20000528:	701a      	strb	r2, [r3, #0]
	    retval++;
2000052a:	6a3b      	ldr	r3, [r7, #32]
2000052c:	3301      	adds	r3, #1
2000052e:	623b      	str	r3, [r7, #32]
	    width--;
20000530:	6c7b      	ldr	r3, [r7, #68]	@ 0x44
20000532:	3b01      	subs	r3, #1
20000534:	647b      	str	r3, [r7, #68]	@ 0x44
	while (width) {
20000536:	6c7b      	ldr	r3, [r7, #68]	@ 0x44
20000538:	2b00      	cmp	r3, #0
2000053a:	d1f1      	bne.n	20000520 <__llatox+0x7c>
	    }
	}

    while (op != buffer) {
2000053c:	e008      	b.n	20000550 <__llatox+0xac>
	op--;
2000053e:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
20000540:	3b01      	subs	r3, #1
20000542:	627b      	str	r3, [r7, #36]	@ 0x24
	*buf++ = *op;
20000544:	68fb      	ldr	r3, [r7, #12]
20000546:	1c5a      	adds	r2, r3, #1
20000548:	60fa      	str	r2, [r7, #12]
2000054a:	6a7a      	ldr	r2, [r7, #36]	@ 0x24
2000054c:	7812      	ldrb	r2, [r2, #0]
2000054e:	701a      	strb	r2, [r3, #0]
    while (op != buffer) {
20000550:	f107 0310 	add.w	r3, r7, #16
20000554:	6a7a      	ldr	r2, [r7, #36]	@ 0x24
20000556:	429a      	cmp	r2, r3
20000558:	d1f1      	bne.n	2000053e <__llatox+0x9a>
	}

    return retval;
2000055a:	6a3b      	ldr	r3, [r7, #32]
}
2000055c:	4618      	mov	r0, r3
2000055e:	3728      	adds	r7, #40	@ 0x28
20000560:	46bd      	mov	sp, r7
20000562:	e8bd 83b0 	ldmia.w	sp!, {r4, r5, r7, r8, r9, pc}
	...

20000568 <xvsprintf>:
    *  Return Value:
    *      number of characters copied
    ********************************************************************* */
#define isdigit(x) (((x) >= '0') && ((x) <= '9'))
int xvsprintf(char *outbuf,const char *templat,va_list marker)
{
20000568:	b5b0      	push	{r4, r5, r7, lr}
2000056a:	b09a      	sub	sp, #104	@ 0x68
2000056c:	af04      	add	r7, sp, #16
2000056e:	60f8      	str	r0, [r7, #12]
20000570:	60b9      	str	r1, [r7, #8]
20000572:	607a      	str	r2, [r7, #4]
    long long ll;
    int leadingzero;
    int leadingnegsign;
    int islong;
    int width;
    int width2 = 0;
20000574:	2300      	movs	r3, #0
20000576:	62fb      	str	r3, [r7, #44]	@ 0x2c
    int hashash = 0;
20000578:	2300      	movs	r3, #0
2000057a:	62bb      	str	r3, [r7, #40]	@ 0x28

    optr = outbuf;
2000057c:	68fb      	ldr	r3, [r7, #12]
2000057e:	657b      	str	r3, [r7, #84]	@ 0x54
    iptr = templat;
20000580:	68bb      	ldr	r3, [r7, #8]
20000582:	653b      	str	r3, [r7, #80]	@ 0x50

    while (*iptr) {
20000584:	e326      	b.n	20000bd4 <xvsprintf+0x66c>
	if (*iptr != '%') {*optr++ = *iptr++; continue;}
20000586:	6d3b      	ldr	r3, [r7, #80]	@ 0x50
20000588:	781b      	ldrb	r3, [r3, #0]
2000058a:	2b25      	cmp	r3, #37	@ 0x25
2000058c:	d008      	beq.n	200005a0 <xvsprintf+0x38>
2000058e:	6d3a      	ldr	r2, [r7, #80]	@ 0x50
20000590:	1c53      	adds	r3, r2, #1
20000592:	653b      	str	r3, [r7, #80]	@ 0x50
20000594:	6d7b      	ldr	r3, [r7, #84]	@ 0x54
20000596:	1c59      	adds	r1, r3, #1
20000598:	6579      	str	r1, [r7, #84]	@ 0x54
2000059a:	7812      	ldrb	r2, [r2, #0]
2000059c:	701a      	strb	r2, [r3, #0]
2000059e:	e319      	b.n	20000bd4 <xvsprintf+0x66c>

	iptr++;
200005a0:	6d3b      	ldr	r3, [r7, #80]	@ 0x50
200005a2:	3301      	adds	r3, #1
200005a4:	653b      	str	r3, [r7, #80]	@ 0x50

	if (*iptr == '#') { hashash = 1; iptr++; }
200005a6:	6d3b      	ldr	r3, [r7, #80]	@ 0x50
200005a8:	781b      	ldrb	r3, [r3, #0]
200005aa:	2b23      	cmp	r3, #35	@ 0x23
200005ac:	d104      	bne.n	200005b8 <xvsprintf+0x50>
200005ae:	2301      	movs	r3, #1
200005b0:	62bb      	str	r3, [r7, #40]	@ 0x28
200005b2:	6d3b      	ldr	r3, [r7, #80]	@ 0x50
200005b4:	3301      	adds	r3, #1
200005b6:	653b      	str	r3, [r7, #80]	@ 0x50
	if (*iptr == '-') {
200005b8:	6d3b      	ldr	r3, [r7, #80]	@ 0x50
200005ba:	781b      	ldrb	r3, [r3, #0]
200005bc:	2b2d      	cmp	r3, #45	@ 0x2d
200005be:	d105      	bne.n	200005cc <xvsprintf+0x64>
	    leadingnegsign = 1;
200005c0:	2301      	movs	r3, #1
200005c2:	627b      	str	r3, [r7, #36]	@ 0x24
	    iptr++;
200005c4:	6d3b      	ldr	r3, [r7, #80]	@ 0x50
200005c6:	3301      	adds	r3, #1
200005c8:	653b      	str	r3, [r7, #80]	@ 0x50
200005ca:	e001      	b.n	200005d0 <xvsprintf+0x68>
	    }
	else leadingnegsign = 0;
200005cc:	2300      	movs	r3, #0
200005ce:	627b      	str	r3, [r7, #36]	@ 0x24

	if (*iptr == '0') leadingzero = 1;
200005d0:	6d3b      	ldr	r3, [r7, #80]	@ 0x50
200005d2:	781b      	ldrb	r3, [r3, #0]
200005d4:	2b30      	cmp	r3, #48	@ 0x30
200005d6:	d102      	bne.n	200005de <xvsprintf+0x76>
200005d8:	2301      	movs	r3, #1
200005da:	623b      	str	r3, [r7, #32]
200005dc:	e001      	b.n	200005e2 <xvsprintf+0x7a>
	else leadingzero = 0;
200005de:	2300      	movs	r3, #0
200005e0:	623b      	str	r3, [r7, #32]

	width = 0;
200005e2:	2300      	movs	r3, #0
200005e4:	633b      	str	r3, [r7, #48]	@ 0x30
	while (*iptr && isdigit(*iptr)) {
200005e6:	e016      	b.n	20000616 <xvsprintf+0xae>
	    width += (*iptr - '0');
200005e8:	6d3b      	ldr	r3, [r7, #80]	@ 0x50
200005ea:	781b      	ldrb	r3, [r3, #0]
200005ec:	3b30      	subs	r3, #48	@ 0x30
200005ee:	6b3a      	ldr	r2, [r7, #48]	@ 0x30
200005f0:	4413      	add	r3, r2
200005f2:	633b      	str	r3, [r7, #48]	@ 0x30
	    iptr++;
200005f4:	6d3b      	ldr	r3, [r7, #80]	@ 0x50
200005f6:	3301      	adds	r3, #1
200005f8:	653b      	str	r3, [r7, #80]	@ 0x50
	    if (isdigit(*iptr)) width *= 10;
200005fa:	6d3b      	ldr	r3, [r7, #80]	@ 0x50
200005fc:	781b      	ldrb	r3, [r3, #0]
200005fe:	2b2f      	cmp	r3, #47	@ 0x2f
20000600:	d909      	bls.n	20000616 <xvsprintf+0xae>
20000602:	6d3b      	ldr	r3, [r7, #80]	@ 0x50
20000604:	781b      	ldrb	r3, [r3, #0]
20000606:	2b39      	cmp	r3, #57	@ 0x39
20000608:	d805      	bhi.n	20000616 <xvsprintf+0xae>
2000060a:	6b3a      	ldr	r2, [r7, #48]	@ 0x30
2000060c:	4613      	mov	r3, r2
2000060e:	009b      	lsls	r3, r3, #2
20000610:	4413      	add	r3, r2
20000612:	005b      	lsls	r3, r3, #1
20000614:	633b      	str	r3, [r7, #48]	@ 0x30
	while (*iptr && isdigit(*iptr)) {
20000616:	6d3b      	ldr	r3, [r7, #80]	@ 0x50
20000618:	781b      	ldrb	r3, [r3, #0]
2000061a:	2b00      	cmp	r3, #0
2000061c:	d007      	beq.n	2000062e <xvsprintf+0xc6>
2000061e:	6d3b      	ldr	r3, [r7, #80]	@ 0x50
20000620:	781b      	ldrb	r3, [r3, #0]
20000622:	2b2f      	cmp	r3, #47	@ 0x2f
20000624:	d903      	bls.n	2000062e <xvsprintf+0xc6>
20000626:	6d3b      	ldr	r3, [r7, #80]	@ 0x50
20000628:	781b      	ldrb	r3, [r3, #0]
2000062a:	2b39      	cmp	r3, #57	@ 0x39
2000062c:	d9dc      	bls.n	200005e8 <xvsprintf+0x80>
	    }
	if (*iptr == '.') {
2000062e:	6d3b      	ldr	r3, [r7, #80]	@ 0x50
20000630:	781b      	ldrb	r3, [r3, #0]
20000632:	2b2e      	cmp	r3, #46	@ 0x2e
20000634:	d128      	bne.n	20000688 <xvsprintf+0x120>
	    iptr++;
20000636:	6d3b      	ldr	r3, [r7, #80]	@ 0x50
20000638:	3301      	adds	r3, #1
2000063a:	653b      	str	r3, [r7, #80]	@ 0x50
	    width2 = 0;
2000063c:	2300      	movs	r3, #0
2000063e:	62fb      	str	r3, [r7, #44]	@ 0x2c
	    while (*iptr && isdigit(*iptr)) {
20000640:	e016      	b.n	20000670 <xvsprintf+0x108>
		width2 += (*iptr - '0');
20000642:	6d3b      	ldr	r3, [r7, #80]	@ 0x50
20000644:	781b      	ldrb	r3, [r3, #0]
20000646:	3b30      	subs	r3, #48	@ 0x30
20000648:	6afa      	ldr	r2, [r7, #44]	@ 0x2c
2000064a:	4413      	add	r3, r2
2000064c:	62fb      	str	r3, [r7, #44]	@ 0x2c
		iptr++;
2000064e:	6d3b      	ldr	r3, [r7, #80]	@ 0x50
20000650:	3301      	adds	r3, #1
20000652:	653b      	str	r3, [r7, #80]	@ 0x50
		if (isdigit(*iptr)) width2 *= 10;
20000654:	6d3b      	ldr	r3, [r7, #80]	@ 0x50
20000656:	781b      	ldrb	r3, [r3, #0]
20000658:	2b2f      	cmp	r3, #47	@ 0x2f
2000065a:	d909      	bls.n	20000670 <xvsprintf+0x108>
2000065c:	6d3b      	ldr	r3, [r7, #80]	@ 0x50
2000065e:	781b      	ldrb	r3, [r3, #0]
20000660:	2b39      	cmp	r3, #57	@ 0x39
20000662:	d805      	bhi.n	20000670 <xvsprintf+0x108>
20000664:	6afa      	ldr	r2, [r7, #44]	@ 0x2c
20000666:	4613      	mov	r3, r2
20000668:	009b      	lsls	r3, r3, #2
2000066a:	4413      	add	r3, r2
2000066c:	005b      	lsls	r3, r3, #1
2000066e:	62fb      	str	r3, [r7, #44]	@ 0x2c
	    while (*iptr && isdigit(*iptr)) {
20000670:	6d3b      	ldr	r3, [r7, #80]	@ 0x50
20000672:	781b      	ldrb	r3, [r3, #0]
20000674:	2b00      	cmp	r3, #0
20000676:	d007      	beq.n	20000688 <xvsprintf+0x120>
20000678:	6d3b      	ldr	r3, [r7, #80]	@ 0x50
2000067a:	781b      	ldrb	r3, [r3, #0]
2000067c:	2b2f      	cmp	r3, #47	@ 0x2f
2000067e:	d903      	bls.n	20000688 <xvsprintf+0x120>
20000680:	6d3b      	ldr	r3, [r7, #80]	@ 0x50
20000682:	781b      	ldrb	r3, [r3, #0]
20000684:	2b39      	cmp	r3, #57	@ 0x39
20000686:	d9dc      	bls.n	20000642 <xvsprintf+0xda>
		}
	    }

	islong = 0;
20000688:	2300      	movs	r3, #0
2000068a:	637b      	str	r3, [r7, #52]	@ 0x34
	if (*iptr == 'l') { islong++; iptr++; }
2000068c:	6d3b      	ldr	r3, [r7, #80]	@ 0x50
2000068e:	781b      	ldrb	r3, [r3, #0]
20000690:	2b6c      	cmp	r3, #108	@ 0x6c
20000692:	d105      	bne.n	200006a0 <xvsprintf+0x138>
20000694:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
20000696:	3301      	adds	r3, #1
20000698:	637b      	str	r3, [r7, #52]	@ 0x34
2000069a:	6d3b      	ldr	r3, [r7, #80]	@ 0x50
2000069c:	3301      	adds	r3, #1
2000069e:	653b      	str	r3, [r7, #80]	@ 0x50
	if (*iptr == 'l') { islong++; iptr++; }
200006a0:	6d3b      	ldr	r3, [r7, #80]	@ 0x50
200006a2:	781b      	ldrb	r3, [r3, #0]
200006a4:	2b6c      	cmp	r3, #108	@ 0x6c
200006a6:	d105      	bne.n	200006b4 <xvsprintf+0x14c>
200006a8:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
200006aa:	3301      	adds	r3, #1
200006ac:	637b      	str	r3, [r7, #52]	@ 0x34
200006ae:	6d3b      	ldr	r3, [r7, #80]	@ 0x50
200006b0:	3301      	adds	r3, #1
200006b2:	653b      	str	r3, [r7, #80]	@ 0x50

	switch (*iptr) {
200006b4:	6d3b      	ldr	r3, [r7, #80]	@ 0x50
200006b6:	781b      	ldrb	r3, [r3, #0]
200006b8:	3b49      	subs	r3, #73	@ 0x49
200006ba:	2b2f      	cmp	r3, #47	@ 0x2f
200006bc:	f200 8280 	bhi.w	20000bc0 <xvsprintf+0x658>
200006c0:	a201      	add	r2, pc, #4	@ (adr r2, 200006c8 <xvsprintf+0x160>)
200006c2:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
200006c6:	bf00      	nop
200006c8:	20000789 	.word	0x20000789
200006cc:	20000bc1 	.word	0x20000bc1
200006d0:	20000bc1 	.word	0x20000bc1
200006d4:	20000bc1 	.word	0x20000bc1
200006d8:	20000bc1 	.word	0x20000bc1
200006dc:	20000bc1 	.word	0x20000bc1
200006e0:	20000bc1 	.word	0x20000bc1
200006e4:	20000ad9 	.word	0x20000ad9
200006e8:	20000bc1 	.word	0x20000bc1
200006ec:	20000bc1 	.word	0x20000bc1
200006f0:	20000bc1 	.word	0x20000bc1
200006f4:	20000bc1 	.word	0x20000bc1
200006f8:	20000bc1 	.word	0x20000bc1
200006fc:	20000bc1 	.word	0x20000bc1
20000700:	20000bc1 	.word	0x20000bc1
20000704:	20000a4b 	.word	0x20000a4b
20000708:	20000bc1 	.word	0x20000bc1
2000070c:	20000b63 	.word	0x20000b63
20000710:	20000bc1 	.word	0x20000bc1
20000714:	20000bc1 	.word	0x20000bc1
20000718:	20000bc1 	.word	0x20000bc1
2000071c:	20000bc1 	.word	0x20000bc1
20000720:	20000bc1 	.word	0x20000bc1
20000724:	20000bc1 	.word	0x20000bc1
20000728:	200008b3 	.word	0x200008b3
2000072c:	20000b37 	.word	0x20000b37
20000730:	20000ba9 	.word	0x20000ba9
20000734:	2000091f 	.word	0x2000091f
20000738:	20000bc1 	.word	0x20000bc1
2000073c:	20000bc1 	.word	0x20000bc1
20000740:	20000bc1 	.word	0x20000bc1
20000744:	20000bc1 	.word	0x20000bc1
20000748:	20000bc1 	.word	0x20000bc1
2000074c:	20000bc1 	.word	0x20000bc1
20000750:	20000bc1 	.word	0x20000bc1
20000754:	20000bc1 	.word	0x20000bc1
20000758:	20000bc1 	.word	0x20000bc1
2000075c:	20000bc1 	.word	0x20000bc1
20000760:	20000bc1 	.word	0x20000bc1
20000764:	20000ad9 	.word	0x20000ad9
20000768:	20000bc1 	.word	0x20000bc1
2000076c:	20000bc1 	.word	0x20000bc1
20000770:	2000083b 	.word	0x2000083b
20000774:	20000bc1 	.word	0x20000bc1
20000778:	200009cd 	.word	0x200009cd
2000077c:	20000bc1 	.word	0x20000bc1
20000780:	20000b0b 	.word	0x20000b0b
20000784:	20000a4b 	.word	0x20000a4b
	    case 'I':
		tmpptr = (unsigned char *) va_arg(marker,unsigned char *);
20000788:	687b      	ldr	r3, [r7, #4]
2000078a:	1d1a      	adds	r2, r3, #4
2000078c:	607a      	str	r2, [r7, #4]
2000078e:	681b      	ldr	r3, [r3, #0]
20000790:	64fb      	str	r3, [r7, #76]	@ 0x4c
		optr += __atox(optr,*tmpptr++,10,0,digits);
20000792:	6cfb      	ldr	r3, [r7, #76]	@ 0x4c
20000794:	1c5a      	adds	r2, r3, #1
20000796:	64fa      	str	r2, [r7, #76]	@ 0x4c
20000798:	781b      	ldrb	r3, [r3, #0]
2000079a:	4619      	mov	r1, r3
2000079c:	4b9a      	ldr	r3, [pc, #616]	@ (20000a08 <xvsprintf+0x4a0>)
2000079e:	9300      	str	r3, [sp, #0]
200007a0:	2300      	movs	r3, #0
200007a2:	220a      	movs	r2, #10
200007a4:	6d78      	ldr	r0, [r7, #84]	@ 0x54
200007a6:	f7ff fe27 	bl	200003f8 <__atox>
200007aa:	4603      	mov	r3, r0
200007ac:	461a      	mov	r2, r3
200007ae:	6d7b      	ldr	r3, [r7, #84]	@ 0x54
200007b0:	4413      	add	r3, r2
200007b2:	657b      	str	r3, [r7, #84]	@ 0x54
		*optr++ = '.';
200007b4:	6d7b      	ldr	r3, [r7, #84]	@ 0x54
200007b6:	1c5a      	adds	r2, r3, #1
200007b8:	657a      	str	r2, [r7, #84]	@ 0x54
200007ba:	222e      	movs	r2, #46	@ 0x2e
200007bc:	701a      	strb	r2, [r3, #0]
		optr += __atox(optr,*tmpptr++,10,0,digits);
200007be:	6cfb      	ldr	r3, [r7, #76]	@ 0x4c
200007c0:	1c5a      	adds	r2, r3, #1
200007c2:	64fa      	str	r2, [r7, #76]	@ 0x4c
200007c4:	781b      	ldrb	r3, [r3, #0]
200007c6:	4619      	mov	r1, r3
200007c8:	4b8f      	ldr	r3, [pc, #572]	@ (20000a08 <xvsprintf+0x4a0>)
200007ca:	9300      	str	r3, [sp, #0]
200007cc:	2300      	movs	r3, #0
200007ce:	220a      	movs	r2, #10
200007d0:	6d78      	ldr	r0, [r7, #84]	@ 0x54
200007d2:	f7ff fe11 	bl	200003f8 <__atox>
200007d6:	4603      	mov	r3, r0
200007d8:	461a      	mov	r2, r3
200007da:	6d7b      	ldr	r3, [r7, #84]	@ 0x54
200007dc:	4413      	add	r3, r2
200007de:	657b      	str	r3, [r7, #84]	@ 0x54
		*optr++ = '.';
200007e0:	6d7b      	ldr	r3, [r7, #84]	@ 0x54
200007e2:	1c5a      	adds	r2, r3, #1
200007e4:	657a      	str	r2, [r7, #84]	@ 0x54
200007e6:	222e      	movs	r2, #46	@ 0x2e
200007e8:	701a      	strb	r2, [r3, #0]
		optr += __atox(optr,*tmpptr++,10,0,digits);
200007ea:	6cfb      	ldr	r3, [r7, #76]	@ 0x4c
200007ec:	1c5a      	adds	r2, r3, #1
200007ee:	64fa      	str	r2, [r7, #76]	@ 0x4c
200007f0:	781b      	ldrb	r3, [r3, #0]
200007f2:	4619      	mov	r1, r3
200007f4:	4b84      	ldr	r3, [pc, #528]	@ (20000a08 <xvsprintf+0x4a0>)
200007f6:	9300      	str	r3, [sp, #0]
200007f8:	2300      	movs	r3, #0
200007fa:	220a      	movs	r2, #10
200007fc:	6d78      	ldr	r0, [r7, #84]	@ 0x54
200007fe:	f7ff fdfb 	bl	200003f8 <__atox>
20000802:	4603      	mov	r3, r0
20000804:	461a      	mov	r2, r3
20000806:	6d7b      	ldr	r3, [r7, #84]	@ 0x54
20000808:	4413      	add	r3, r2
2000080a:	657b      	str	r3, [r7, #84]	@ 0x54
		*optr++ = '.';
2000080c:	6d7b      	ldr	r3, [r7, #84]	@ 0x54
2000080e:	1c5a      	adds	r2, r3, #1
20000810:	657a      	str	r2, [r7, #84]	@ 0x54
20000812:	222e      	movs	r2, #46	@ 0x2e
20000814:	701a      	strb	r2, [r3, #0]
		optr += __atox(optr,*tmpptr++,10,0,digits);
20000816:	6cfb      	ldr	r3, [r7, #76]	@ 0x4c
20000818:	1c5a      	adds	r2, r3, #1
2000081a:	64fa      	str	r2, [r7, #76]	@ 0x4c
2000081c:	781b      	ldrb	r3, [r3, #0]
2000081e:	4619      	mov	r1, r3
20000820:	4b79      	ldr	r3, [pc, #484]	@ (20000a08 <xvsprintf+0x4a0>)
20000822:	9300      	str	r3, [sp, #0]
20000824:	2300      	movs	r3, #0
20000826:	220a      	movs	r2, #10
20000828:	6d78      	ldr	r0, [r7, #84]	@ 0x54
2000082a:	f7ff fde5 	bl	200003f8 <__atox>
2000082e:	4603      	mov	r3, r0
20000830:	461a      	mov	r2, r3
20000832:	6d7b      	ldr	r3, [r7, #84]	@ 0x54
20000834:	4413      	add	r3, r2
20000836:	657b      	str	r3, [r7, #84]	@ 0x54
		break;
20000838:	e1c9      	b.n	20000bce <xvsprintf+0x666>
	    case 's':
		tmpptr = (unsigned char *) va_arg(marker,unsigned char *);
2000083a:	687b      	ldr	r3, [r7, #4]
2000083c:	1d1a      	adds	r2, r3, #4
2000083e:	607a      	str	r2, [r7, #4]
20000840:	681b      	ldr	r3, [r3, #0]
20000842:	64fb      	str	r3, [r7, #76]	@ 0x4c
		if (!tmpptr) tmpptr = (unsigned char *) "(null)";
20000844:	6cfb      	ldr	r3, [r7, #76]	@ 0x4c
20000846:	2b00      	cmp	r3, #0
20000848:	d101      	bne.n	2000084e <xvsprintf+0x2e6>
2000084a:	4b70      	ldr	r3, [pc, #448]	@ (20000a0c <xvsprintf+0x4a4>)
2000084c:	64fb      	str	r3, [r7, #76]	@ 0x4c
		if ((width == 0) & (width2 == 0)) {
2000084e:	6b3a      	ldr	r2, [r7, #48]	@ 0x30
20000850:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
20000852:	4313      	orrs	r3, r2
20000854:	2b00      	cmp	r3, #0
20000856:	d118      	bne.n	2000088a <xvsprintf+0x322>
		    while (*tmpptr) *optr++ = *tmpptr++;
20000858:	e007      	b.n	2000086a <xvsprintf+0x302>
2000085a:	6cfa      	ldr	r2, [r7, #76]	@ 0x4c
2000085c:	1c53      	adds	r3, r2, #1
2000085e:	64fb      	str	r3, [r7, #76]	@ 0x4c
20000860:	6d7b      	ldr	r3, [r7, #84]	@ 0x54
20000862:	1c59      	adds	r1, r3, #1
20000864:	6579      	str	r1, [r7, #84]	@ 0x54
20000866:	7812      	ldrb	r2, [r2, #0]
20000868:	701a      	strb	r2, [r3, #0]
2000086a:	6cfb      	ldr	r3, [r7, #76]	@ 0x4c
2000086c:	781b      	ldrb	r3, [r3, #0]
2000086e:	2b00      	cmp	r3, #0
20000870:	d1f3      	bne.n	2000085a <xvsprintf+0x2f2>
		    break;
20000872:	e1ac      	b.n	20000bce <xvsprintf+0x666>
		    }
		while (width && *tmpptr) {
		    *optr++ = *tmpptr++;
20000874:	6cfa      	ldr	r2, [r7, #76]	@ 0x4c
20000876:	1c53      	adds	r3, r2, #1
20000878:	64fb      	str	r3, [r7, #76]	@ 0x4c
2000087a:	6d7b      	ldr	r3, [r7, #84]	@ 0x54
2000087c:	1c59      	adds	r1, r3, #1
2000087e:	6579      	str	r1, [r7, #84]	@ 0x54
20000880:	7812      	ldrb	r2, [r2, #0]
20000882:	701a      	strb	r2, [r3, #0]
		    width--;
20000884:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
20000886:	3b01      	subs	r3, #1
20000888:	633b      	str	r3, [r7, #48]	@ 0x30
		while (width && *tmpptr) {
2000088a:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
2000088c:	2b00      	cmp	r3, #0
2000088e:	d00c      	beq.n	200008aa <xvsprintf+0x342>
20000890:	6cfb      	ldr	r3, [r7, #76]	@ 0x4c
20000892:	781b      	ldrb	r3, [r3, #0]
20000894:	2b00      	cmp	r3, #0
20000896:	d1ed      	bne.n	20000874 <xvsprintf+0x30c>
		    }
		while (width) {
20000898:	e007      	b.n	200008aa <xvsprintf+0x342>
		    *optr++ = ' ';
2000089a:	6d7b      	ldr	r3, [r7, #84]	@ 0x54
2000089c:	1c5a      	adds	r2, r3, #1
2000089e:	657a      	str	r2, [r7, #84]	@ 0x54
200008a0:	2220      	movs	r2, #32
200008a2:	701a      	strb	r2, [r3, #0]
		    width--;
200008a4:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
200008a6:	3b01      	subs	r3, #1
200008a8:	633b      	str	r3, [r7, #48]	@ 0x30
		while (width) {
200008aa:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
200008ac:	2b00      	cmp	r3, #0
200008ae:	d1f4      	bne.n	2000089a <xvsprintf+0x332>
		    }
		break;
200008b0:	e18d      	b.n	20000bce <xvsprintf+0x666>
	    case 'a':
		tmpptr = (unsigned char *) va_arg(marker,unsigned char *);
200008b2:	687b      	ldr	r3, [r7, #4]
200008b4:	1d1a      	adds	r2, r3, #4
200008b6:	607a      	str	r2, [r7, #4]
200008b8:	681b      	ldr	r3, [r3, #0]
200008ba:	64fb      	str	r3, [r7, #76]	@ 0x4c
		for (x = 0; x < 5; x++) {
200008bc:	2300      	movs	r3, #0
200008be:	64bb      	str	r3, [r7, #72]	@ 0x48
200008c0:	e018      	b.n	200008f4 <xvsprintf+0x38c>
		    optr += __atox(optr,*tmpptr++,16,2,digits);
200008c2:	6cfb      	ldr	r3, [r7, #76]	@ 0x4c
200008c4:	1c5a      	adds	r2, r3, #1
200008c6:	64fa      	str	r2, [r7, #76]	@ 0x4c
200008c8:	781b      	ldrb	r3, [r3, #0]
200008ca:	4619      	mov	r1, r3
200008cc:	4b4e      	ldr	r3, [pc, #312]	@ (20000a08 <xvsprintf+0x4a0>)
200008ce:	9300      	str	r3, [sp, #0]
200008d0:	2302      	movs	r3, #2
200008d2:	2210      	movs	r2, #16
200008d4:	6d78      	ldr	r0, [r7, #84]	@ 0x54
200008d6:	f7ff fd8f 	bl	200003f8 <__atox>
200008da:	4603      	mov	r3, r0
200008dc:	461a      	mov	r2, r3
200008de:	6d7b      	ldr	r3, [r7, #84]	@ 0x54
200008e0:	4413      	add	r3, r2
200008e2:	657b      	str	r3, [r7, #84]	@ 0x54
		    *optr++ = '-';
200008e4:	6d7b      	ldr	r3, [r7, #84]	@ 0x54
200008e6:	1c5a      	adds	r2, r3, #1
200008e8:	657a      	str	r2, [r7, #84]	@ 0x54
200008ea:	222d      	movs	r2, #45	@ 0x2d
200008ec:	701a      	strb	r2, [r3, #0]
		for (x = 0; x < 5; x++) {
200008ee:	6cbb      	ldr	r3, [r7, #72]	@ 0x48
200008f0:	3301      	adds	r3, #1
200008f2:	64bb      	str	r3, [r7, #72]	@ 0x48
200008f4:	6cbb      	ldr	r3, [r7, #72]	@ 0x48
200008f6:	2b04      	cmp	r3, #4
200008f8:	dde3      	ble.n	200008c2 <xvsprintf+0x35a>
		    }
		optr += __atox(optr,*tmpptr++,16,2,digits);
200008fa:	6cfb      	ldr	r3, [r7, #76]	@ 0x4c
200008fc:	1c5a      	adds	r2, r3, #1
200008fe:	64fa      	str	r2, [r7, #76]	@ 0x4c
20000900:	781b      	ldrb	r3, [r3, #0]
20000902:	4619      	mov	r1, r3
20000904:	4b40      	ldr	r3, [pc, #256]	@ (20000a08 <xvsprintf+0x4a0>)
20000906:	9300      	str	r3, [sp, #0]
20000908:	2302      	movs	r3, #2
2000090a:	2210      	movs	r2, #16
2000090c:	6d78      	ldr	r0, [r7, #84]	@ 0x54
2000090e:	f7ff fd73 	bl	200003f8 <__atox>
20000912:	4603      	mov	r3, r0
20000914:	461a      	mov	r2, r3
20000916:	6d7b      	ldr	r3, [r7, #84]	@ 0x54
20000918:	4413      	add	r3, r2
2000091a:	657b      	str	r3, [r7, #84]	@ 0x54
		break;
2000091c:	e157      	b.n	20000bce <xvsprintf+0x666>
2000091e:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
20000920:	2b01      	cmp	r3, #1
20000922:	dc03      	bgt.n	2000092c <xvsprintf+0x3c4>
20000924:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
20000926:	2b00      	cmp	r3, #0
20000928:	da04      	bge.n	20000934 <xvsprintf+0x3cc>
			ll = va_arg(marker,long long int);
			if (ll < 0) { *optr++='-'; ll = -ll;}
			optr += __llatox(optr,ll,10,width,digits);
			break;
		    }
		break;
2000092a:	e150      	b.n	20000bce <xvsprintf+0x666>
2000092c:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
2000092e:	2b02      	cmp	r3, #2
20000930:	d01e      	beq.n	20000970 <xvsprintf+0x408>
20000932:	e14c      	b.n	20000bce <xvsprintf+0x666>
			i = va_arg(marker,int);
20000934:	687b      	ldr	r3, [r7, #4]
20000936:	1d1a      	adds	r2, r3, #4
20000938:	607a      	str	r2, [r7, #4]
2000093a:	681b      	ldr	r3, [r3, #0]
2000093c:	647b      	str	r3, [r7, #68]	@ 0x44
			if (i < 0) { *optr++='-'; i = -i;}
2000093e:	6c7b      	ldr	r3, [r7, #68]	@ 0x44
20000940:	2b00      	cmp	r3, #0
20000942:	da07      	bge.n	20000954 <xvsprintf+0x3ec>
20000944:	6d7b      	ldr	r3, [r7, #84]	@ 0x54
20000946:	1c5a      	adds	r2, r3, #1
20000948:	657a      	str	r2, [r7, #84]	@ 0x54
2000094a:	222d      	movs	r2, #45	@ 0x2d
2000094c:	701a      	strb	r2, [r3, #0]
2000094e:	6c7b      	ldr	r3, [r7, #68]	@ 0x44
20000950:	425b      	negs	r3, r3
20000952:	647b      	str	r3, [r7, #68]	@ 0x44
			optr += __atox(optr,i,10,width,digits);
20000954:	6c79      	ldr	r1, [r7, #68]	@ 0x44
20000956:	4b2c      	ldr	r3, [pc, #176]	@ (20000a08 <xvsprintf+0x4a0>)
20000958:	9300      	str	r3, [sp, #0]
2000095a:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
2000095c:	220a      	movs	r2, #10
2000095e:	6d78      	ldr	r0, [r7, #84]	@ 0x54
20000960:	f7ff fd4a 	bl	200003f8 <__atox>
20000964:	4603      	mov	r3, r0
20000966:	461a      	mov	r2, r3
20000968:	6d7b      	ldr	r3, [r7, #84]	@ 0x54
2000096a:	4413      	add	r3, r2
2000096c:	657b      	str	r3, [r7, #84]	@ 0x54
			break;
2000096e:	e02c      	b.n	200009ca <xvsprintf+0x462>
			ll = va_arg(marker,long long int);
20000970:	687b      	ldr	r3, [r7, #4]
20000972:	3307      	adds	r3, #7
20000974:	f023 0307 	bic.w	r3, r3, #7
20000978:	f103 0208 	add.w	r2, r3, #8
2000097c:	607a      	str	r2, [r7, #4]
2000097e:	e9d3 2300 	ldrd	r2, r3, [r3]
20000982:	e9c7 230e 	strd	r2, r3, [r7, #56]	@ 0x38
			if (ll < 0) { *optr++='-'; ll = -ll;}
20000986:	e9d7 230e 	ldrd	r2, r3, [r7, #56]	@ 0x38
2000098a:	2b00      	cmp	r3, #0
2000098c:	da0c      	bge.n	200009a8 <xvsprintf+0x440>
2000098e:	6d7b      	ldr	r3, [r7, #84]	@ 0x54
20000990:	1c5a      	adds	r2, r3, #1
20000992:	657a      	str	r2, [r7, #84]	@ 0x54
20000994:	222d      	movs	r2, #45	@ 0x2d
20000996:	701a      	strb	r2, [r3, #0]
20000998:	e9d7 230e 	ldrd	r2, r3, [r7, #56]	@ 0x38
2000099c:	2100      	movs	r1, #0
2000099e:	4254      	negs	r4, r2
200009a0:	eb61 0503 	sbc.w	r5, r1, r3
200009a4:	e9c7 450e 	strd	r4, r5, [r7, #56]	@ 0x38
			optr += __llatox(optr,ll,10,width,digits);
200009a8:	e9d7 230e 	ldrd	r2, r3, [r7, #56]	@ 0x38
200009ac:	4916      	ldr	r1, [pc, #88]	@ (20000a08 <xvsprintf+0x4a0>)
200009ae:	9102      	str	r1, [sp, #8]
200009b0:	6b39      	ldr	r1, [r7, #48]	@ 0x30
200009b2:	9101      	str	r1, [sp, #4]
200009b4:	210a      	movs	r1, #10
200009b6:	9100      	str	r1, [sp, #0]
200009b8:	6d78      	ldr	r0, [r7, #84]	@ 0x54
200009ba:	f7ff fd73 	bl	200004a4 <__llatox>
200009be:	4603      	mov	r3, r0
200009c0:	461a      	mov	r2, r3
200009c2:	6d7b      	ldr	r3, [r7, #84]	@ 0x54
200009c4:	4413      	add	r3, r2
200009c6:	657b      	str	r3, [r7, #84]	@ 0x54
			break;
200009c8:	bf00      	nop
		break;
200009ca:	e100      	b.n	20000bce <xvsprintf+0x666>
200009cc:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
200009ce:	2b01      	cmp	r3, #1
200009d0:	dc03      	bgt.n	200009da <xvsprintf+0x472>
200009d2:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
200009d4:	2b00      	cmp	r3, #0
200009d6:	da04      	bge.n	200009e2 <xvsprintf+0x47a>
		    case 2:
			ulx = va_arg(marker,unsigned long long);
			optr += __llatox(optr,ulx,10,width,digits);
			break;
		    }
		break;
200009d8:	e0f9      	b.n	20000bce <xvsprintf+0x666>
200009da:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
200009dc:	2b02      	cmp	r3, #2
200009de:	d017      	beq.n	20000a10 <xvsprintf+0x4a8>
200009e0:	e0f5      	b.n	20000bce <xvsprintf+0x666>
			ux = va_arg(marker,unsigned int);
200009e2:	687b      	ldr	r3, [r7, #4]
200009e4:	1d1a      	adds	r2, r3, #4
200009e6:	607a      	str	r2, [r7, #4]
200009e8:	681b      	ldr	r3, [r3, #0]
200009ea:	617b      	str	r3, [r7, #20]
			optr += __atox(optr,ux,10,width,digits);
200009ec:	4b06      	ldr	r3, [pc, #24]	@ (20000a08 <xvsprintf+0x4a0>)
200009ee:	9300      	str	r3, [sp, #0]
200009f0:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
200009f2:	220a      	movs	r2, #10
200009f4:	6979      	ldr	r1, [r7, #20]
200009f6:	6d78      	ldr	r0, [r7, #84]	@ 0x54
200009f8:	f7ff fcfe 	bl	200003f8 <__atox>
200009fc:	4603      	mov	r3, r0
200009fe:	461a      	mov	r2, r3
20000a00:	6d7b      	ldr	r3, [r7, #84]	@ 0x54
20000a02:	4413      	add	r3, r2
20000a04:	657b      	str	r3, [r7, #84]	@ 0x54
			break;
20000a06:	e01f      	b.n	20000a48 <xvsprintf+0x4e0>
20000a08:	20005c7c 	.word	0x20005c7c
20000a0c:	200053e0 	.word	0x200053e0
			ulx = va_arg(marker,unsigned long long);
20000a10:	687b      	ldr	r3, [r7, #4]
20000a12:	3307      	adds	r3, #7
20000a14:	f023 0307 	bic.w	r3, r3, #7
20000a18:	f103 0208 	add.w	r2, r3, #8
20000a1c:	607a      	str	r2, [r7, #4]
20000a1e:	e9d3 2300 	ldrd	r2, r3, [r3]
20000a22:	e9c7 2306 	strd	r2, r3, [r7, #24]
			optr += __llatox(optr,ulx,10,width,digits);
20000a26:	4b73      	ldr	r3, [pc, #460]	@ (20000bf4 <xvsprintf+0x68c>)
20000a28:	9302      	str	r3, [sp, #8]
20000a2a:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
20000a2c:	9301      	str	r3, [sp, #4]
20000a2e:	230a      	movs	r3, #10
20000a30:	9300      	str	r3, [sp, #0]
20000a32:	e9d7 2306 	ldrd	r2, r3, [r7, #24]
20000a36:	6d78      	ldr	r0, [r7, #84]	@ 0x54
20000a38:	f7ff fd34 	bl	200004a4 <__llatox>
20000a3c:	4603      	mov	r3, r0
20000a3e:	461a      	mov	r2, r3
20000a40:	6d7b      	ldr	r3, [r7, #84]	@ 0x54
20000a42:	4413      	add	r3, r2
20000a44:	657b      	str	r3, [r7, #84]	@ 0x54
			break;
20000a46:	bf00      	nop
		break;
20000a48:	e0c1      	b.n	20000bce <xvsprintf+0x666>
20000a4a:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
20000a4c:	2b01      	cmp	r3, #1
20000a4e:	dc03      	bgt.n	20000a58 <xvsprintf+0x4f0>
20000a50:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
20000a52:	2b00      	cmp	r3, #0
20000a54:	da04      	bge.n	20000a60 <xvsprintf+0x4f8>
			ulx = va_arg(marker,unsigned long long);
			optr += __llatox(optr,ulx,16,width,
				       (*iptr == 'X') ? digits : ldigits);
			break;
		    }
		break;
20000a56:	e0ba      	b.n	20000bce <xvsprintf+0x666>
20000a58:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
20000a5a:	2b02      	cmp	r3, #2
20000a5c:	d019      	beq.n	20000a92 <xvsprintf+0x52a>
20000a5e:	e0b6      	b.n	20000bce <xvsprintf+0x666>
			ux = va_arg(marker,unsigned int);
20000a60:	687b      	ldr	r3, [r7, #4]
20000a62:	1d1a      	adds	r2, r3, #4
20000a64:	607a      	str	r2, [r7, #4]
20000a66:	681b      	ldr	r3, [r3, #0]
20000a68:	617b      	str	r3, [r7, #20]
				       (*iptr == 'X') ? digits : ldigits);
20000a6a:	6d3b      	ldr	r3, [r7, #80]	@ 0x50
20000a6c:	781b      	ldrb	r3, [r3, #0]
			optr += __atox(optr,ux,16,width,
20000a6e:	2b58      	cmp	r3, #88	@ 0x58
20000a70:	d101      	bne.n	20000a76 <xvsprintf+0x50e>
20000a72:	4b60      	ldr	r3, [pc, #384]	@ (20000bf4 <xvsprintf+0x68c>)
20000a74:	e000      	b.n	20000a78 <xvsprintf+0x510>
20000a76:	4b60      	ldr	r3, [pc, #384]	@ (20000bf8 <xvsprintf+0x690>)
20000a78:	9300      	str	r3, [sp, #0]
20000a7a:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
20000a7c:	2210      	movs	r2, #16
20000a7e:	6979      	ldr	r1, [r7, #20]
20000a80:	6d78      	ldr	r0, [r7, #84]	@ 0x54
20000a82:	f7ff fcb9 	bl	200003f8 <__atox>
20000a86:	4603      	mov	r3, r0
20000a88:	461a      	mov	r2, r3
20000a8a:	6d7b      	ldr	r3, [r7, #84]	@ 0x54
20000a8c:	4413      	add	r3, r2
20000a8e:	657b      	str	r3, [r7, #84]	@ 0x54
			break;
20000a90:	e021      	b.n	20000ad6 <xvsprintf+0x56e>
			ulx = va_arg(marker,unsigned long long);
20000a92:	687b      	ldr	r3, [r7, #4]
20000a94:	3307      	adds	r3, #7
20000a96:	f023 0307 	bic.w	r3, r3, #7
20000a9a:	f103 0208 	add.w	r2, r3, #8
20000a9e:	607a      	str	r2, [r7, #4]
20000aa0:	e9d3 2300 	ldrd	r2, r3, [r3]
20000aa4:	e9c7 2306 	strd	r2, r3, [r7, #24]
				       (*iptr == 'X') ? digits : ldigits);
20000aa8:	6d3b      	ldr	r3, [r7, #80]	@ 0x50
20000aaa:	781b      	ldrb	r3, [r3, #0]
			optr += __llatox(optr,ulx,16,width,
20000aac:	2b58      	cmp	r3, #88	@ 0x58
20000aae:	d101      	bne.n	20000ab4 <xvsprintf+0x54c>
20000ab0:	4b50      	ldr	r3, [pc, #320]	@ (20000bf4 <xvsprintf+0x68c>)
20000ab2:	e000      	b.n	20000ab6 <xvsprintf+0x54e>
20000ab4:	4b50      	ldr	r3, [pc, #320]	@ (20000bf8 <xvsprintf+0x690>)
20000ab6:	9302      	str	r3, [sp, #8]
20000ab8:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
20000aba:	9301      	str	r3, [sp, #4]
20000abc:	2310      	movs	r3, #16
20000abe:	9300      	str	r3, [sp, #0]
20000ac0:	e9d7 2306 	ldrd	r2, r3, [r7, #24]
20000ac4:	6d78      	ldr	r0, [r7, #84]	@ 0x54
20000ac6:	f7ff fced 	bl	200004a4 <__llatox>
20000aca:	4603      	mov	r3, r0
20000acc:	461a      	mov	r2, r3
20000ace:	6d7b      	ldr	r3, [r7, #84]	@ 0x54
20000ad0:	4413      	add	r3, r2
20000ad2:	657b      	str	r3, [r7, #84]	@ 0x54
			break;
20000ad4:	bf00      	nop
		break;
20000ad6:	e07a      	b.n	20000bce <xvsprintf+0x666>
#ifdef __long64
		lx = va_arg(marker,long long);
		optr += __llatox(optr,lx,16,16,
				 (*iptr == 'P') ? digits : ldigits);
#else
		x = va_arg(marker,long);
20000ad8:	687b      	ldr	r3, [r7, #4]
20000ada:	1d1a      	adds	r2, r3, #4
20000adc:	607a      	str	r2, [r7, #4]
20000ade:	681b      	ldr	r3, [r3, #0]
20000ae0:	64bb      	str	r3, [r7, #72]	@ 0x48
		optr += __atox(optr,x,16,8,
20000ae2:	6cb9      	ldr	r1, [r7, #72]	@ 0x48
			       (*iptr == 'P') ? digits : ldigits);
20000ae4:	6d3b      	ldr	r3, [r7, #80]	@ 0x50
20000ae6:	781b      	ldrb	r3, [r3, #0]
		optr += __atox(optr,x,16,8,
20000ae8:	2b50      	cmp	r3, #80	@ 0x50
20000aea:	d101      	bne.n	20000af0 <xvsprintf+0x588>
20000aec:	4b41      	ldr	r3, [pc, #260]	@ (20000bf4 <xvsprintf+0x68c>)
20000aee:	e000      	b.n	20000af2 <xvsprintf+0x58a>
20000af0:	4b41      	ldr	r3, [pc, #260]	@ (20000bf8 <xvsprintf+0x690>)
20000af2:	9300      	str	r3, [sp, #0]
20000af4:	2308      	movs	r3, #8
20000af6:	2210      	movs	r2, #16
20000af8:	6d78      	ldr	r0, [r7, #84]	@ 0x54
20000afa:	f7ff fc7d 	bl	200003f8 <__atox>
20000afe:	4603      	mov	r3, r0
20000b00:	461a      	mov	r2, r3
20000b02:	6d7b      	ldr	r3, [r7, #84]	@ 0x54
20000b04:	4413      	add	r3, r2
20000b06:	657b      	str	r3, [r7, #84]	@ 0x54
#endif
		break;
20000b08:	e061      	b.n	20000bce <xvsprintf+0x666>
	    case 'w':
		x = va_arg(marker,unsigned int);
20000b0a:	687b      	ldr	r3, [r7, #4]
20000b0c:	1d1a      	adds	r2, r3, #4
20000b0e:	607a      	str	r2, [r7, #4]
20000b10:	681b      	ldr	r3, [r3, #0]
20000b12:	64bb      	str	r3, [r7, #72]	@ 0x48
	        x &= 0x0000FFFF;
20000b14:	6cbb      	ldr	r3, [r7, #72]	@ 0x48
20000b16:	b29b      	uxth	r3, r3
20000b18:	64bb      	str	r3, [r7, #72]	@ 0x48
		optr += __atox(optr,x,16,4,digits);
20000b1a:	6cb9      	ldr	r1, [r7, #72]	@ 0x48
20000b1c:	4b35      	ldr	r3, [pc, #212]	@ (20000bf4 <xvsprintf+0x68c>)
20000b1e:	9300      	str	r3, [sp, #0]
20000b20:	2304      	movs	r3, #4
20000b22:	2210      	movs	r2, #16
20000b24:	6d78      	ldr	r0, [r7, #84]	@ 0x54
20000b26:	f7ff fc67 	bl	200003f8 <__atox>
20000b2a:	4603      	mov	r3, r0
20000b2c:	461a      	mov	r2, r3
20000b2e:	6d7b      	ldr	r3, [r7, #84]	@ 0x54
20000b30:	4413      	add	r3, r2
20000b32:	657b      	str	r3, [r7, #84]	@ 0x54
		break;
20000b34:	e04b      	b.n	20000bce <xvsprintf+0x666>
	    case 'b':
		x = va_arg(marker,unsigned int);
20000b36:	687b      	ldr	r3, [r7, #4]
20000b38:	1d1a      	adds	r2, r3, #4
20000b3a:	607a      	str	r2, [r7, #4]
20000b3c:	681b      	ldr	r3, [r3, #0]
20000b3e:	64bb      	str	r3, [r7, #72]	@ 0x48
	        x &= 0x0000FF;
20000b40:	6cbb      	ldr	r3, [r7, #72]	@ 0x48
20000b42:	b2db      	uxtb	r3, r3
20000b44:	64bb      	str	r3, [r7, #72]	@ 0x48
		optr += __atox(optr,x,16,2,digits);
20000b46:	6cb9      	ldr	r1, [r7, #72]	@ 0x48
20000b48:	4b2a      	ldr	r3, [pc, #168]	@ (20000bf4 <xvsprintf+0x68c>)
20000b4a:	9300      	str	r3, [sp, #0]
20000b4c:	2302      	movs	r3, #2
20000b4e:	2210      	movs	r2, #16
20000b50:	6d78      	ldr	r0, [r7, #84]	@ 0x54
20000b52:	f7ff fc51 	bl	200003f8 <__atox>
20000b56:	4603      	mov	r3, r0
20000b58:	461a      	mov	r2, r3
20000b5a:	6d7b      	ldr	r3, [r7, #84]	@ 0x54
20000b5c:	4413      	add	r3, r2
20000b5e:	657b      	str	r3, [r7, #84]	@ 0x54
		break;
20000b60:	e035      	b.n	20000bce <xvsprintf+0x666>
	    case 'Z':
		x = va_arg(marker,unsigned int);
20000b62:	687b      	ldr	r3, [r7, #4]
20000b64:	1d1a      	adds	r2, r3, #4
20000b66:	607a      	str	r2, [r7, #4]
20000b68:	681b      	ldr	r3, [r3, #0]
20000b6a:	64bb      	str	r3, [r7, #72]	@ 0x48
		tmpptr = va_arg(marker,unsigned char *);
20000b6c:	687b      	ldr	r3, [r7, #4]
20000b6e:	1d1a      	adds	r2, r3, #4
20000b70:	607a      	str	r2, [r7, #4]
20000b72:	681b      	ldr	r3, [r3, #0]
20000b74:	64fb      	str	r3, [r7, #76]	@ 0x4c
		while (x) {
20000b76:	e013      	b.n	20000ba0 <xvsprintf+0x638>
		    optr += __atox(optr,*tmpptr++,16,2,digits);
20000b78:	6cfb      	ldr	r3, [r7, #76]	@ 0x4c
20000b7a:	1c5a      	adds	r2, r3, #1
20000b7c:	64fa      	str	r2, [r7, #76]	@ 0x4c
20000b7e:	781b      	ldrb	r3, [r3, #0]
20000b80:	4619      	mov	r1, r3
20000b82:	4b1c      	ldr	r3, [pc, #112]	@ (20000bf4 <xvsprintf+0x68c>)
20000b84:	9300      	str	r3, [sp, #0]
20000b86:	2302      	movs	r3, #2
20000b88:	2210      	movs	r2, #16
20000b8a:	6d78      	ldr	r0, [r7, #84]	@ 0x54
20000b8c:	f7ff fc34 	bl	200003f8 <__atox>
20000b90:	4603      	mov	r3, r0
20000b92:	461a      	mov	r2, r3
20000b94:	6d7b      	ldr	r3, [r7, #84]	@ 0x54
20000b96:	4413      	add	r3, r2
20000b98:	657b      	str	r3, [r7, #84]	@ 0x54
		    x--;
20000b9a:	6cbb      	ldr	r3, [r7, #72]	@ 0x48
20000b9c:	3b01      	subs	r3, #1
20000b9e:	64bb      	str	r3, [r7, #72]	@ 0x48
		while (x) {
20000ba0:	6cbb      	ldr	r3, [r7, #72]	@ 0x48
20000ba2:	2b00      	cmp	r3, #0
20000ba4:	d1e8      	bne.n	20000b78 <xvsprintf+0x610>
		    }
		break;
20000ba6:	e012      	b.n	20000bce <xvsprintf+0x666>
	    case 'c':
		x = va_arg(marker, int);
20000ba8:	687b      	ldr	r3, [r7, #4]
20000baa:	1d1a      	adds	r2, r3, #4
20000bac:	607a      	str	r2, [r7, #4]
20000bae:	681b      	ldr	r3, [r3, #0]
20000bb0:	64bb      	str	r3, [r7, #72]	@ 0x48
		*optr++ = x & 0xff;
20000bb2:	6d7b      	ldr	r3, [r7, #84]	@ 0x54
20000bb4:	1c5a      	adds	r2, r3, #1
20000bb6:	657a      	str	r2, [r7, #84]	@ 0x54
20000bb8:	6cba      	ldr	r2, [r7, #72]	@ 0x48
20000bba:	b2d2      	uxtb	r2, r2
20000bbc:	701a      	strb	r2, [r3, #0]
		break;
20000bbe:	e006      	b.n	20000bce <xvsprintf+0x666>

	    default:
		*optr++ = *iptr;
20000bc0:	6d7b      	ldr	r3, [r7, #84]	@ 0x54
20000bc2:	1c5a      	adds	r2, r3, #1
20000bc4:	657a      	str	r2, [r7, #84]	@ 0x54
20000bc6:	6d3a      	ldr	r2, [r7, #80]	@ 0x50
20000bc8:	7812      	ldrb	r2, [r2, #0]
20000bca:	701a      	strb	r2, [r3, #0]
		break;
20000bcc:	bf00      	nop
	    }
	iptr++;
20000bce:	6d3b      	ldr	r3, [r7, #80]	@ 0x50
20000bd0:	3301      	adds	r3, #1
20000bd2:	653b      	str	r3, [r7, #80]	@ 0x50
    while (*iptr) {
20000bd4:	6d3b      	ldr	r3, [r7, #80]	@ 0x50
20000bd6:	781b      	ldrb	r3, [r3, #0]
20000bd8:	2b00      	cmp	r3, #0
20000bda:	f47f acd4 	bne.w	20000586 <xvsprintf+0x1e>
	}

 //   *optr++ = '\r';
 //   *optr++ = '\n';
    *optr = '\0';
20000bde:	6d7b      	ldr	r3, [r7, #84]	@ 0x54
20000be0:	2200      	movs	r2, #0
20000be2:	701a      	strb	r2, [r3, #0]

    return (optr - outbuf);
20000be4:	6d7a      	ldr	r2, [r7, #84]	@ 0x54
20000be6:	68fb      	ldr	r3, [r7, #12]
20000be8:	1ad3      	subs	r3, r2, r3
}
20000bea:	4618      	mov	r0, r3
20000bec:	3758      	adds	r7, #88	@ 0x58
20000bee:	46bd      	mov	sp, r7
20000bf0:	bdb0      	pop	{r4, r5, r7, pc}
20000bf2:	bf00      	nop
20000bf4:	20005c7c 	.word	0x20005c7c
20000bf8:	20005c90 	.word	0x20005c90

20000bfc <xsprintf>:
    *
    *  Return Value:
    *      number of bytes copied to buffer
    ********************************************************************* */
int xsprintf(char *buf,const char *templat,...)
{
20000bfc:	b40e      	push	{r1, r2, r3}
20000bfe:	b580      	push	{r7, lr}
20000c00:	b085      	sub	sp, #20
20000c02:	af00      	add	r7, sp, #0
20000c04:	6078      	str	r0, [r7, #4]
    va_list marker;
    int count;

    va_start(marker,templat);
20000c06:	f107 0320 	add.w	r3, r7, #32
20000c0a:	60bb      	str	r3, [r7, #8]
    count = xvsprintf(buf,templat,marker);
20000c0c:	68ba      	ldr	r2, [r7, #8]
20000c0e:	69f9      	ldr	r1, [r7, #28]
20000c10:	6878      	ldr	r0, [r7, #4]
20000c12:	f7ff fca9 	bl	20000568 <xvsprintf>
20000c16:	60f8      	str	r0, [r7, #12]
    va_end(marker);

    return count;
20000c18:	68fb      	ldr	r3, [r7, #12]
}
20000c1a:	4618      	mov	r0, r3
20000c1c:	3714      	adds	r7, #20
20000c1e:	46bd      	mov	sp, r7
20000c20:	e8bd 4080 	ldmia.w	sp!, {r7, lr}
20000c24:	b003      	add	sp, #12
20000c26:	4770      	bx	lr

20000c28 <printf>:
    *  Return value:
    *  	   number of bytes written
    ********************************************************************* */

int printf(const char *templat,...)
{
20000c28:	b40f      	push	{r0, r1, r2, r3}
20000c2a:	b580      	push	{r7, lr}
20000c2c:	f5ad 7d04 	sub.w	sp, sp, #528	@ 0x210
20000c30:	af00      	add	r7, sp, #0
    va_list marker;
    int count;
    char buffer[512];

    va_start(marker,templat);
20000c32:	f507 7307 	add.w	r3, r7, #540	@ 0x21c
20000c36:	f8c7 3204 	str.w	r3, [r7, #516]	@ 0x204
    count = xvsprintf(buffer,templat,marker);
20000c3a:	1d3b      	adds	r3, r7, #4
20000c3c:	f8d7 2204 	ldr.w	r2, [r7, #516]	@ 0x204
20000c40:	f8d7 1218 	ldr.w	r1, [r7, #536]	@ 0x218
20000c44:	4618      	mov	r0, r3
20000c46:	f7ff fc8f 	bl	20000568 <xvsprintf>
20000c4a:	f8c7 0208 	str.w	r0, [r7, #520]	@ 0x208
    va_end(marker);


    for(int i = 0; i< count; i++){
20000c4e:	2300      	movs	r3, #0
20000c50:	f8c7 320c 	str.w	r3, [r7, #524]	@ 0x20c
20000c54:	e00f      	b.n	20000c76 <printf+0x4e>
    	putc(buffer[i]);
20000c56:	f507 7304 	add.w	r3, r7, #528	@ 0x210
20000c5a:	f5a3 7203 	sub.w	r2, r3, #524	@ 0x20c
20000c5e:	f8d7 320c 	ldr.w	r3, [r7, #524]	@ 0x20c
20000c62:	4413      	add	r3, r2
20000c64:	781b      	ldrb	r3, [r3, #0]
20000c66:	4618      	mov	r0, r3
20000c68:	f000 f81c 	bl	20000ca4 <putc>
    for(int i = 0; i< count; i++){
20000c6c:	f8d7 320c 	ldr.w	r3, [r7, #524]	@ 0x20c
20000c70:	3301      	adds	r3, #1
20000c72:	f8c7 320c 	str.w	r3, [r7, #524]	@ 0x20c
20000c76:	f8d7 220c 	ldr.w	r2, [r7, #524]	@ 0x20c
20000c7a:	f8d7 3208 	ldr.w	r3, [r7, #520]	@ 0x208
20000c7e:	429a      	cmp	r2, r3
20000c80:	dbe9      	blt.n	20000c56 <printf+0x2e>
    }

    putc('\r');
20000c82:	200d      	movs	r0, #13
20000c84:	f000 f80e 	bl	20000ca4 <putc>
    putc('\n');
20000c88:	200a      	movs	r0, #10
20000c8a:	f000 f80b 	bl	20000ca4 <putc>

    return count;
20000c8e:	f8d7 3208 	ldr.w	r3, [r7, #520]	@ 0x208
}
20000c92:	4618      	mov	r0, r3
20000c94:	f507 7704 	add.w	r7, r7, #528	@ 0x210
20000c98:	46bd      	mov	sp, r7
20000c9a:	e8bd 4080 	ldmia.w	sp!, {r7, lr}
20000c9e:	b004      	add	sp, #16
20000ca0:	4770      	bx	lr
	...

20000ca4 <putc>:
	for(int i = 0; i< strlen(str); i++)
		putc(*str++);
}


void putc(char c) {
20000ca4:	b480      	push	{r7}
20000ca6:	b085      	sub	sp, #20
20000ca8:	af00      	add	r7, sp, #0
20000caa:	4603      	mov	r3, r0
20000cac:	71fb      	strb	r3, [r7, #7]
    volatile uint32_t *usart_isr = (volatile uint32_t *)(0x40013800 + 0x1C);
20000cae:	4b0a      	ldr	r3, [pc, #40]	@ (20000cd8 <putc+0x34>)
20000cb0:	60fb      	str	r3, [r7, #12]
    volatile uint32_t *usart_tdr = (volatile uint32_t *)(0x40013800 + 0x28);
20000cb2:	4b0a      	ldr	r3, [pc, #40]	@ (20000cdc <putc+0x38>)
20000cb4:	60bb      	str	r3, [r7, #8]

    while((*usart_isr & (1 << 7)) == 0);
20000cb6:	bf00      	nop
20000cb8:	68fb      	ldr	r3, [r7, #12]
20000cba:	681b      	ldr	r3, [r3, #0]
20000cbc:	f003 0380 	and.w	r3, r3, #128	@ 0x80
20000cc0:	2b00      	cmp	r3, #0
20000cc2:	d0f9      	beq.n	20000cb8 <putc+0x14>


    *usart_tdr = c;
20000cc4:	79fa      	ldrb	r2, [r7, #7]
20000cc6:	68bb      	ldr	r3, [r7, #8]
20000cc8:	601a      	str	r2, [r3, #0]
}
20000cca:	bf00      	nop
20000ccc:	3714      	adds	r7, #20
20000cce:	46bd      	mov	sp, r7
20000cd0:	f85d 7b04 	ldr.w	r7, [sp], #4
20000cd4:	4770      	bx	lr
20000cd6:	bf00      	nop
20000cd8:	4001381c 	.word	0x4001381c
20000cdc:	40013828 	.word	0x40013828

20000ce0 <puts>:

void puts(const char *templat,...) {
20000ce0:	b40f      	push	{r0, r1, r2, r3}
20000ce2:	b580      	push	{r7, lr}
20000ce4:	af00      	add	r7, sp, #0
    printf(templat);
20000ce6:	68b8      	ldr	r0, [r7, #8]
20000ce8:	f7ff ff9e 	bl	20000c28 <printf>
}
20000cec:	bf00      	nop
20000cee:	46bd      	mov	sp, r7
20000cf0:	e8bd 4080 	ldmia.w	sp!, {r7, lr}
20000cf4:	b004      	add	sp, #16
20000cf6:	4770      	bx	lr

20000cf8 <putchar>:

void putchar(char c) {
20000cf8:	b480      	push	{r7}
20000cfa:	b085      	sub	sp, #20
20000cfc:	af00      	add	r7, sp, #0
20000cfe:	4603      	mov	r3, r0
20000d00:	71fb      	strb	r3, [r7, #7]
    volatile uint32_t *usart_isr = (volatile uint32_t *)(0x40013800 + 0x1C);
20000d02:	4b0a      	ldr	r3, [pc, #40]	@ (20000d2c <putchar+0x34>)
20000d04:	60fb      	str	r3, [r7, #12]
    volatile uint32_t *usart_tdr = (volatile uint32_t *)(0x40013800 + 0x28);
20000d06:	4b0a      	ldr	r3, [pc, #40]	@ (20000d30 <putchar+0x38>)
20000d08:	60bb      	str	r3, [r7, #8]

    while((*usart_isr & (1 << 7)) == 0);
20000d0a:	bf00      	nop
20000d0c:	68fb      	ldr	r3, [r7, #12]
20000d0e:	681b      	ldr	r3, [r3, #0]
20000d10:	f003 0380 	and.w	r3, r3, #128	@ 0x80
20000d14:	2b00      	cmp	r3, #0
20000d16:	d0f9      	beq.n	20000d0c <putchar+0x14>


    *usart_tdr = c;
20000d18:	79fa      	ldrb	r2, [r7, #7]
20000d1a:	68bb      	ldr	r3, [r7, #8]
20000d1c:	601a      	str	r2, [r3, #0]
}
20000d1e:	bf00      	nop
20000d20:	3714      	adds	r7, #20
20000d22:	46bd      	mov	sp, r7
20000d24:	f85d 7b04 	ldr.w	r7, [sp], #4
20000d28:	4770      	bx	lr
20000d2a:	bf00      	nop
20000d2c:	4001381c 	.word	0x4001381c
20000d30:	40013828 	.word	0x40013828

20000d34 <stm32_uart_probe>:

static void
stm32_uart_probe(cfe_driver_t *drv,
		    unsigned long probe_a, unsigned long probe_b,
		    void *probe_ptr)
{
20000d34:	b580      	push	{r7, lr}
20000d36:	b084      	sub	sp, #16
20000d38:	af00      	add	r7, sp, #0
20000d3a:	60f8      	str	r0, [r7, #12]
20000d3c:	60b9      	str	r1, [r7, #8]
20000d3e:	607a      	str	r2, [r7, #4]
20000d40:	603b      	str	r3, [r7, #0]
    cfe_attach(drv, NULL, NULL, NULL);
20000d42:	2300      	movs	r3, #0
20000d44:	2200      	movs	r2, #0
20000d46:	2100      	movs	r1, #0
20000d48:	68f8      	ldr	r0, [r7, #12]
20000d4a:	f000 fce5 	bl	20001718 <cfe_attach>
}
20000d4e:	bf00      	nop
20000d50:	3710      	adds	r7, #16
20000d52:	46bd      	mov	sp, r7
20000d54:	bd80      	pop	{r7, pc}

20000d56 <stm32_uart_open>:

static int
stm32_uart_open(cfe_devctx_t *ctx) {
20000d56:	b480      	push	{r7}
20000d58:	b083      	sub	sp, #12
20000d5a:	af00      	add	r7, sp, #0
20000d5c:	6078      	str	r0, [r7, #4]

   return 0;
20000d5e:	2300      	movs	r3, #0
}
20000d60:	4618      	mov	r0, r3
20000d62:	370c      	adds	r7, #12
20000d64:	46bd      	mov	sp, r7
20000d66:	f85d 7b04 	ldr.w	r7, [sp], #4
20000d6a:	4770      	bx	lr

20000d6c <stm32_uart_read>:


static int
stm32_uart_read(cfe_devctx_t *ctx, iocb_buffer_t *buffer)
{
20000d6c:	b480      	push	{r7}
20000d6e:	b089      	sub	sp, #36	@ 0x24
20000d70:	af00      	add	r7, sp, #0
20000d72:	6078      	str	r0, [r7, #4]
20000d74:	6039      	str	r1, [r7, #0]
    volatile uint32_t *LPUART_ISR = (uint32_t *)(0x40013800 + 0x1C);
20000d76:	4b15      	ldr	r3, [pc, #84]	@ (20000dcc <stm32_uart_read+0x60>)
20000d78:	61bb      	str	r3, [r7, #24]
    volatile uint32_t *LPUART_RDR = (uint32_t *)(0x40013800 + 0x24);
20000d7a:	4b15      	ldr	r3, [pc, #84]	@ (20000dd0 <stm32_uart_read+0x64>)
20000d7c:	617b      	str	r3, [r7, #20]
    char *ptr = buffer->buf_ptr;
20000d7e:	683b      	ldr	r3, [r7, #0]
20000d80:	689b      	ldr	r3, [r3, #8]
20000d82:	613b      	str	r3, [r7, #16]
    uint32_t len = buffer->buf_length;
20000d84:	683b      	ldr	r3, [r7, #0]
20000d86:	68db      	ldr	r3, [r3, #12]
20000d88:	61fb      	str	r3, [r7, #28]
    uint32_t read_len = 0;
20000d8a:	2300      	movs	r3, #0
20000d8c:	60fb      	str	r3, [r7, #12]

    while (len > 0)
20000d8e:	e00d      	b.n	20000dac <stm32_uart_read+0x40>
    {
        if (*LPUART_ISR & (1 << 5) )
20000d90:	69bb      	ldr	r3, [r7, #24]
20000d92:	681b      	ldr	r3, [r3, #0]
20000d94:	f003 0320 	and.w	r3, r3, #32
20000d98:	2b00      	cmp	r3, #0
20000d9a:	d00b      	beq.n	20000db4 <stm32_uart_read+0x48>
        {
        	*ptr = (*LPUART_RDR);
20000d9c:	697b      	ldr	r3, [r7, #20]
20000d9e:	681b      	ldr	r3, [r3, #0]
20000da0:	b2da      	uxtb	r2, r3
20000da2:	693b      	ldr	r3, [r7, #16]
20000da4:	701a      	strb	r2, [r3, #0]
        	len--;
20000da6:	69fb      	ldr	r3, [r7, #28]
20000da8:	3b01      	subs	r3, #1
20000daa:	61fb      	str	r3, [r7, #28]
    while (len > 0)
20000dac:	69fb      	ldr	r3, [r7, #28]
20000dae:	2b00      	cmp	r3, #0
20000db0:	d1ee      	bne.n	20000d90 <stm32_uart_read+0x24>
20000db2:	e000      	b.n	20000db6 <stm32_uart_read+0x4a>

        }
        else
        {
            break;
20000db4:	bf00      	nop
        }
    }
    buffer-> buf_retlen =  buffer->buf_length;
20000db6:	683b      	ldr	r3, [r7, #0]
20000db8:	68da      	ldr	r2, [r3, #12]
20000dba:	683b      	ldr	r3, [r7, #0]
20000dbc:	611a      	str	r2, [r3, #16]


    return 0;
20000dbe:	2300      	movs	r3, #0
}
20000dc0:	4618      	mov	r0, r3
20000dc2:	3724      	adds	r7, #36	@ 0x24
20000dc4:	46bd      	mov	sp, r7
20000dc6:	f85d 7b04 	ldr.w	r7, [sp], #4
20000dca:	4770      	bx	lr
20000dcc:	4001381c 	.word	0x4001381c
20000dd0:	40013824 	.word	0x40013824

20000dd4 <stm32_uart_inpstat>:
static int
stm32_uart_inpstat(cfe_devctx_t *ctx, iocb_inpstat_t *inpstat)
{
20000dd4:	b480      	push	{r7}
20000dd6:	b085      	sub	sp, #20
20000dd8:	af00      	add	r7, sp, #0
20000dda:	6078      	str	r0, [r7, #4]
20000ddc:	6039      	str	r1, [r7, #0]

	volatile uint32_t *LPUART_ISR  = (volatile uint32_t *)(0x40013800 + 0x1C);
20000dde:	4b0b      	ldr	r3, [pc, #44]	@ (20000e0c <stm32_uart_inpstat+0x38>)
20000de0:	60fb      	str	r3, [r7, #12]


	if (*LPUART_ISR & (1 << 5))
20000de2:	68fb      	ldr	r3, [r7, #12]
20000de4:	681b      	ldr	r3, [r3, #0]
20000de6:	f003 0320 	and.w	r3, r3, #32
20000dea:	2b00      	cmp	r3, #0
20000dec:	d003      	beq.n	20000df6 <stm32_uart_inpstat+0x22>
	{
		inpstat->inp_status = 1;
20000dee:	683b      	ldr	r3, [r7, #0]
20000df0:	2201      	movs	r2, #1
20000df2:	601a      	str	r2, [r3, #0]
20000df4:	e002      	b.n	20000dfc <stm32_uart_inpstat+0x28>
	}
	else
	{
		inpstat->inp_status = 0;
20000df6:	683b      	ldr	r3, [r7, #0]
20000df8:	2200      	movs	r2, #0
20000dfa:	601a      	str	r2, [r3, #0]
	}

	return 0;
20000dfc:	2300      	movs	r3, #0
}
20000dfe:	4618      	mov	r0, r3
20000e00:	3714      	adds	r7, #20
20000e02:	46bd      	mov	sp, r7
20000e04:	f85d 7b04 	ldr.w	r7, [sp], #4
20000e08:	4770      	bx	lr
20000e0a:	bf00      	nop
20000e0c:	4001381c 	.word	0x4001381c

20000e10 <stm32_uart_write>:

static int
stm32_uart_write(cfe_devctx_t *ctx, iocb_buffer_t *buffer)
{
20000e10:	b580      	push	{r7, lr}
20000e12:	b086      	sub	sp, #24
20000e14:	af00      	add	r7, sp, #0
20000e16:	6078      	str	r0, [r7, #4]
20000e18:	6039      	str	r1, [r7, #0]
    char* ptr = buffer->buf_ptr;
20000e1a:	683b      	ldr	r3, [r7, #0]
20000e1c:	689b      	ldr	r3, [r3, #8]
20000e1e:	617b      	str	r3, [r7, #20]
    uint32_t len = buffer->buf_length;
20000e20:	683b      	ldr	r3, [r7, #0]
20000e22:	68db      	ldr	r3, [r3, #12]
20000e24:	60fb      	str	r3, [r7, #12]
    for(int i =0; i< len; i++)
20000e26:	2300      	movs	r3, #0
20000e28:	613b      	str	r3, [r7, #16]
20000e2a:	e009      	b.n	20000e40 <stm32_uart_write+0x30>
    	putchar(*ptr++);
20000e2c:	697b      	ldr	r3, [r7, #20]
20000e2e:	1c5a      	adds	r2, r3, #1
20000e30:	617a      	str	r2, [r7, #20]
20000e32:	781b      	ldrb	r3, [r3, #0]
20000e34:	4618      	mov	r0, r3
20000e36:	f7ff ff5f 	bl	20000cf8 <putchar>
    for(int i =0; i< len; i++)
20000e3a:	693b      	ldr	r3, [r7, #16]
20000e3c:	3301      	adds	r3, #1
20000e3e:	613b      	str	r3, [r7, #16]
20000e40:	693b      	ldr	r3, [r7, #16]
20000e42:	68fa      	ldr	r2, [r7, #12]
20000e44:	429a      	cmp	r2, r3
20000e46:	d8f1      	bhi.n	20000e2c <stm32_uart_write+0x1c>

    buffer->buf_retlen = len;
20000e48:	683b      	ldr	r3, [r7, #0]
20000e4a:	68fa      	ldr	r2, [r7, #12]
20000e4c:	611a      	str	r2, [r3, #16]
    return 0;
20000e4e:	2300      	movs	r3, #0
}
20000e50:	4618      	mov	r0, r3
20000e52:	3718      	adds	r7, #24
20000e54:	46bd      	mov	sp, r7
20000e56:	bd80      	pop	{r7, pc}

20000e58 <board_init>:

void board_init() {
20000e58:	b598      	push	{r3, r4, r7, lr}
20000e5a:	af00      	add	r7, sp, #0
	cfe_add_device(&stm32_uart, 0, 0, 0);
20000e5c:	4b05      	ldr	r3, [pc, #20]	@ (20000e74 <board_init+0x1c>)
20000e5e:	691c      	ldr	r4, [r3, #16]
20000e60:	2300      	movs	r3, #0
20000e62:	2200      	movs	r2, #0
20000e64:	2100      	movs	r1, #0
20000e66:	4803      	ldr	r0, [pc, #12]	@ (20000e74 <board_init+0x1c>)
20000e68:	47a0      	blx	r4
	cfe_set_console("uart0");
20000e6a:	4803      	ldr	r0, [pc, #12]	@ (20000e78 <board_init+0x20>)
20000e6c:	f000 fdd6 	bl	20001a1c <cfe_set_console>
}
20000e70:	bf00      	nop
20000e72:	bd98      	pop	{r3, r4, r7, pc}
20000e74:	20005e4c 	.word	0x20005e4c
20000e78:	200053fc 	.word	0x200053fc

20000e7c <kmeminit>:
    *  	   nothing
    ********************************************************************* */


void kmeminit(mempool_t *pool,unsigned char *buffer,int length)
{
20000e7c:	b480      	push	{r7}
20000e7e:	b085      	sub	sp, #20
20000e80:	af00      	add	r7, sp, #0
20000e82:	60f8      	str	r0, [r7, #12]
20000e84:	60b9      	str	r1, [r7, #8]
20000e86:	607a      	str	r2, [r7, #4]
    pool->root = (memnode_t *) buffer;
20000e88:	68fb      	ldr	r3, [r7, #12]
20000e8a:	68ba      	ldr	r2, [r7, #8]
20000e8c:	601a      	str	r2, [r3, #0]
    pool->root->seal = MEMNODE_SEAL;
20000e8e:	68fb      	ldr	r3, [r7, #12]
20000e90:	681b      	ldr	r3, [r3, #0]
20000e92:	4a10      	ldr	r2, [pc, #64]	@ (20000ed4 <kmeminit+0x58>)
20000e94:	601a      	str	r2, [r3, #0]
    pool->root->length = length - sizeof(memnode_t);
20000e96:	687a      	ldr	r2, [r7, #4]
20000e98:	68fb      	ldr	r3, [r7, #12]
20000e9a:	681b      	ldr	r3, [r3, #0]
20000e9c:	3a18      	subs	r2, #24
20000e9e:	609a      	str	r2, [r3, #8]
    pool->root->data = memnode_data(unsigned char *,pool->root);
20000ea0:	68fb      	ldr	r3, [r7, #12]
20000ea2:	681a      	ldr	r2, [r3, #0]
20000ea4:	68fb      	ldr	r3, [r7, #12]
20000ea6:	681b      	ldr	r3, [r3, #0]
20000ea8:	3218      	adds	r2, #24
20000eaa:	611a      	str	r2, [r3, #16]
    pool->root->status = memnode_free;
20000eac:	68fb      	ldr	r3, [r7, #12]
20000eae:	681b      	ldr	r3, [r3, #0]
20000eb0:	2200      	movs	r2, #0
20000eb2:	731a      	strb	r2, [r3, #12]
    pool->root->next = NULL;
20000eb4:	68fb      	ldr	r3, [r7, #12]
20000eb6:	681b      	ldr	r3, [r3, #0]
20000eb8:	2200      	movs	r2, #0
20000eba:	605a      	str	r2, [r3, #4]

    pool->base = buffer;
20000ebc:	68fb      	ldr	r3, [r7, #12]
20000ebe:	68ba      	ldr	r2, [r7, #8]
20000ec0:	605a      	str	r2, [r3, #4]
    pool->length = length;
20000ec2:	687a      	ldr	r2, [r7, #4]
20000ec4:	68fb      	ldr	r3, [r7, #12]
20000ec6:	609a      	str	r2, [r3, #8]
}
20000ec8:	bf00      	nop
20000eca:	3714      	adds	r7, #20
20000ecc:	46bd      	mov	sp, r7
20000ece:	f85d 7b04 	ldr.w	r7, [sp], #4
20000ed2:	4770      	bx	lr
20000ed4:	faafa123 	.word	0xfaafa123

20000ed8 <kmemcompact>:
    *  Return value:
    *  	   nothing
    ********************************************************************* */

static void kmemcompact(mempool_t *pool)
{
20000ed8:	b480      	push	{r7}
20000eda:	b085      	sub	sp, #20
20000edc:	af00      	add	r7, sp, #0
20000ede:	6078      	str	r0, [r7, #4]
    memnode_t *m;
    int compacted;

    do {
	compacted = 0;
20000ee0:	2300      	movs	r3, #0
20000ee2:	60bb      	str	r3, [r7, #8]

	for (m = pool->root; m; m = m->next) {
20000ee4:	687b      	ldr	r3, [r7, #4]
20000ee6:	681b      	ldr	r3, [r3, #0]
20000ee8:	60fb      	str	r3, [r7, #12]
20000eea:	e02a      	b.n	20000f42 <kmemcompact+0x6a>

	    /* Check seal to be sure that we're doing ok */

	    if (m->seal != MEMNODE_SEAL) {
20000eec:	68fb      	ldr	r3, [r7, #12]
20000eee:	681b      	ldr	r3, [r3, #0]
20000ef0:	4a1a      	ldr	r2, [pc, #104]	@ (20000f5c <kmemcompact+0x84>)
20000ef2:	4293      	cmp	r3, r2
20000ef4:	d12c      	bne.n	20000f50 <kmemcompact+0x78>
	    /* 
	     * If we're not on the last block and both this
	     * block and the next one are free, combine them
	     */

	    if (m->next && 
20000ef6:	68fb      	ldr	r3, [r7, #12]
20000ef8:	685b      	ldr	r3, [r3, #4]
20000efa:	2b00      	cmp	r3, #0
20000efc:	d01e      	beq.n	20000f3c <kmemcompact+0x64>
		(m->status == memnode_free) &&
20000efe:	68fb      	ldr	r3, [r7, #12]
20000f00:	7b1b      	ldrb	r3, [r3, #12]
	    if (m->next && 
20000f02:	2b00      	cmp	r3, #0
20000f04:	d11a      	bne.n	20000f3c <kmemcompact+0x64>
		(m->next->status == memnode_free)) {
20000f06:	68fb      	ldr	r3, [r7, #12]
20000f08:	685b      	ldr	r3, [r3, #4]
20000f0a:	7b1b      	ldrb	r3, [r3, #12]
		(m->status == memnode_free) &&
20000f0c:	2b00      	cmp	r3, #0
20000f0e:	d115      	bne.n	20000f3c <kmemcompact+0x64>
		m->length += sizeof(memnode_t) + m->next->length;
20000f10:	68fb      	ldr	r3, [r7, #12]
20000f12:	689a      	ldr	r2, [r3, #8]
20000f14:	68fb      	ldr	r3, [r7, #12]
20000f16:	685b      	ldr	r3, [r3, #4]
20000f18:	689b      	ldr	r3, [r3, #8]
20000f1a:	4413      	add	r3, r2
20000f1c:	f103 0218 	add.w	r2, r3, #24
20000f20:	68fb      	ldr	r3, [r7, #12]
20000f22:	609a      	str	r2, [r3, #8]
		m->next->seal = 0;
20000f24:	68fb      	ldr	r3, [r7, #12]
20000f26:	685b      	ldr	r3, [r3, #4]
20000f28:	2200      	movs	r2, #0
20000f2a:	601a      	str	r2, [r3, #0]
		m->next = m->next->next;
20000f2c:	68fb      	ldr	r3, [r7, #12]
20000f2e:	685b      	ldr	r3, [r3, #4]
20000f30:	685a      	ldr	r2, [r3, #4]
20000f32:	68fb      	ldr	r3, [r7, #12]
20000f34:	605a      	str	r2, [r3, #4]
		compacted++;
20000f36:	68bb      	ldr	r3, [r7, #8]
20000f38:	3301      	adds	r3, #1
20000f3a:	60bb      	str	r3, [r7, #8]
	for (m = pool->root; m; m = m->next) {
20000f3c:	68fb      	ldr	r3, [r7, #12]
20000f3e:	685b      	ldr	r3, [r3, #4]
20000f40:	60fb      	str	r3, [r7, #12]
20000f42:	68fb      	ldr	r3, [r7, #12]
20000f44:	2b00      	cmp	r3, #0
20000f46:	d1d1      	bne.n	20000eec <kmemcompact+0x14>
		}

	    /* Keep going till we make a pass without doing anything. */
	    }
	} while (compacted > 0);
20000f48:	68bb      	ldr	r3, [r7, #8]
20000f4a:	2b00      	cmp	r3, #0
20000f4c:	dcc8      	bgt.n	20000ee0 <kmemcompact+0x8>
20000f4e:	e000      	b.n	20000f52 <kmemcompact+0x7a>
		return;
20000f50:	bf00      	nop
}
20000f52:	3714      	adds	r7, #20
20000f54:	46bd      	mov	sp, r7
20000f56:	f85d 7b04 	ldr.w	r7, [sp], #4
20000f5a:	4770      	bx	lr
20000f5c:	faafa123 	.word	0xfaafa123

20000f60 <kfree>:
    *  Return value:
    *  	   nothing
    ********************************************************************* */

void kfree(mempool_t *pool,void *ptr)
{
20000f60:	b580      	push	{r7, lr}
20000f62:	b084      	sub	sp, #16
20000f64:	af00      	add	r7, sp, #0
20000f66:	6078      	str	r0, [r7, #4]
20000f68:	6039      	str	r1, [r7, #0]
    memnode_t **backptr;
    memnode_t *m;

    if (((unsigned char *) ptr < pool->base) ||
20000f6a:	687b      	ldr	r3, [r7, #4]
20000f6c:	685b      	ldr	r3, [r3, #4]
20000f6e:	683a      	ldr	r2, [r7, #0]
20000f70:	429a      	cmp	r2, r3
20000f72:	d319      	bcc.n	20000fa8 <kfree+0x48>
	((unsigned char *) ptr >= (pool->base+pool->length))) {
20000f74:	687b      	ldr	r3, [r7, #4]
20000f76:	685a      	ldr	r2, [r3, #4]
20000f78:	687b      	ldr	r3, [r7, #4]
20000f7a:	689b      	ldr	r3, [r3, #8]
20000f7c:	4413      	add	r3, r2
    if (((unsigned char *) ptr < pool->base) ||
20000f7e:	683a      	ldr	r2, [r7, #0]
20000f80:	429a      	cmp	r2, r3
20000f82:	d211      	bcs.n	20000fa8 <kfree+0x48>
	printf("Pointer %08X does not belong to pool %08X\n",ptr,pool);
#endif
	return;
	}

    backptr = (memnode_t **) (((unsigned char *) ptr) - sizeof(memnode_t *));
20000f84:	683b      	ldr	r3, [r7, #0]
20000f86:	3b04      	subs	r3, #4
20000f88:	60fb      	str	r3, [r7, #12]
    m = *backptr;
20000f8a:	68fb      	ldr	r3, [r7, #12]
20000f8c:	681b      	ldr	r3, [r3, #0]
20000f8e:	60bb      	str	r3, [r7, #8]

    if (m->seal != MEMNODE_SEAL) {
20000f90:	68bb      	ldr	r3, [r7, #8]
20000f92:	681b      	ldr	r3, [r3, #0]
20000f94:	4a07      	ldr	r2, [pc, #28]	@ (20000fb4 <kfree+0x54>)
20000f96:	4293      	cmp	r3, r2
20000f98:	d108      	bne.n	20000fac <kfree+0x4c>
	printf("Invalid node freed: %08X\n",m);
#endif
	return;
	}

    m->status = memnode_free;
20000f9a:	68bb      	ldr	r3, [r7, #8]
20000f9c:	2200      	movs	r2, #0
20000f9e:	731a      	strb	r2, [r3, #12]

    kmemcompact(pool);
20000fa0:	6878      	ldr	r0, [r7, #4]
20000fa2:	f7ff ff99 	bl	20000ed8 <kmemcompact>
20000fa6:	e002      	b.n	20000fae <kfree+0x4e>
	return;
20000fa8:	bf00      	nop
20000faa:	e000      	b.n	20000fae <kfree+0x4e>
	return;
20000fac:	bf00      	nop
}
20000fae:	3710      	adds	r7, #16
20000fb0:	46bd      	mov	sp, r7
20000fb2:	bd80      	pop	{r7, pc}
20000fb4:	faafa123 	.word	0xfaafa123

20000fb8 <lib_outofmemory>:
    *  	   nothing
    ********************************************************************* */

void lib_outofmemory(void);
void lib_outofmemory(void)
{
20000fb8:	b480      	push	{r7}
20000fba:	af00      	add	r7, sp, #0
    //xprintf("PANIC: out of memory!\n");
}
20000fbc:	bf00      	nop
20000fbe:	46bd      	mov	sp, r7
20000fc0:	f85d 7b04 	ldr.w	r7, [sp], #4
20000fc4:	4770      	bx	lr
	...

20000fc8 <kmalloc>:
    *  Return value:
    *  	   pointer to data, or NULL if no memory left
    ********************************************************************* */

void *kmalloc(mempool_t *pool,unsigned int size,unsigned int align)
{
20000fc8:	b580      	push	{r7, lr}
20000fca:	b08c      	sub	sp, #48	@ 0x30
20000fcc:	af00      	add	r7, sp, #0
20000fce:	60f8      	str	r0, [r7, #12]
20000fd0:	60b9      	str	r1, [r7, #8]
20000fd2:	607a      	str	r2, [r7, #4]
    memnode_t *m;
    memnode_t *newm;
    memnode_t **backptr;
    uintptr_t daddr = 0;
20000fd4:	2300      	movs	r3, #0
20000fd6:	62bb      	str	r3, [r7, #40]	@ 0x28
    uintptr_t realsize = 0;
20000fd8:	2300      	movs	r3, #0
20000fda:	627b      	str	r3, [r7, #36]	@ 0x24
    /*
     * Everything should be aligned by at least the
     * size of an int64
     */

    ptralign = (uintptr_t) align;
20000fdc:	687b      	ldr	r3, [r7, #4]
20000fde:	61fb      	str	r3, [r7, #28]
    if (ptralign < sizeof(void *)) ptralign = sizeof(uint64_t);
20000fe0:	69fb      	ldr	r3, [r7, #28]
20000fe2:	2b03      	cmp	r3, #3
20000fe4:	d801      	bhi.n	20000fea <kmalloc+0x22>
20000fe6:	2308      	movs	r3, #8
20000fe8:	61fb      	str	r3, [r7, #28]
    /*	
     * Everything should be at least a multiple of the 
     * size of a pointer.
     */

    if (size == 0) size = sizeof(void *);
20000fea:	68bb      	ldr	r3, [r7, #8]
20000fec:	2b00      	cmp	r3, #0
20000fee:	d101      	bne.n	20000ff4 <kmalloc+0x2c>
20000ff0:	2304      	movs	r3, #4
20000ff2:	60bb      	str	r3, [r7, #8]
    if (size & (sizeof(void *)-1)) {
20000ff4:	68bb      	ldr	r3, [r7, #8]
20000ff6:	f003 0303 	and.w	r3, r3, #3
20000ffa:	2b00      	cmp	r3, #0
20000ffc:	d006      	beq.n	2000100c <kmalloc+0x44>
	size += sizeof(void *);
20000ffe:	68bb      	ldr	r3, [r7, #8]
20001000:	3304      	adds	r3, #4
20001002:	60bb      	str	r3, [r7, #8]
	size &= ~(sizeof(void *)-1);
20001004:	68bb      	ldr	r3, [r7, #8]
20001006:	f023 0303 	bic.w	r3, r3, #3
2000100a:	60bb      	str	r3, [r7, #8]
    /*
     * Find a memnode at least big enough to hold the storage we
     * want.
     */

    for (m = pool->root; m; m = m->next) {
2000100c:	68fb      	ldr	r3, [r7, #12]
2000100e:	681b      	ldr	r3, [r3, #0]
20001010:	62fb      	str	r3, [r7, #44]	@ 0x2c
20001012:	e025      	b.n	20001060 <kmalloc+0x98>

	if (m->status == memnode_alloc) continue;
20001014:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
20001016:	7b1b      	ldrb	r3, [r3, #12]
20001018:	2b01      	cmp	r3, #1
2000101a:	d01d      	beq.n	20001058 <kmalloc+0x90>
	/*
	 * If we wanted a particular alignment, we will
	 * need to adjust the size.
	 */

	daddr = memnode_data(uintptr_t,m);
2000101c:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
2000101e:	3318      	adds	r3, #24
20001020:	62bb      	str	r3, [r7, #40]	@ 0x28
	extra = 0;
20001022:	2300      	movs	r3, #0
20001024:	623b      	str	r3, [r7, #32]
	if (daddr & (ptralign-1)) {
20001026:	69fb      	ldr	r3, [r7, #28]
20001028:	1e5a      	subs	r2, r3, #1
2000102a:	6abb      	ldr	r3, [r7, #40]	@ 0x28
2000102c:	4013      	ands	r3, r2
2000102e:	2b00      	cmp	r3, #0
20001030:	d008      	beq.n	20001044 <kmalloc+0x7c>
	    extra = size + (ptralign - (daddr & (ptralign-1)));
20001032:	69fb      	ldr	r3, [r7, #28]
20001034:	1e5a      	subs	r2, r3, #1
20001036:	6abb      	ldr	r3, [r7, #40]	@ 0x28
20001038:	4013      	ands	r3, r2
2000103a:	69fa      	ldr	r2, [r7, #28]
2000103c:	1ad3      	subs	r3, r2, r3
2000103e:	68ba      	ldr	r2, [r7, #8]
20001040:	4413      	add	r3, r2
20001042:	623b      	str	r3, [r7, #32]
	    }
	realsize = size + extra;
20001044:	68ba      	ldr	r2, [r7, #8]
20001046:	6a3b      	ldr	r3, [r7, #32]
20001048:	4413      	add	r3, r2
2000104a:	627b      	str	r3, [r7, #36]	@ 0x24

	if (m->length < realsize) continue;
2000104c:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
2000104e:	689b      	ldr	r3, [r3, #8]
20001050:	6a7a      	ldr	r2, [r7, #36]	@ 0x24
20001052:	429a      	cmp	r2, r3
20001054:	d908      	bls.n	20001068 <kmalloc+0xa0>
20001056:	e000      	b.n	2000105a <kmalloc+0x92>
	if (m->status == memnode_alloc) continue;
20001058:	bf00      	nop
    for (m = pool->root; m; m = m->next) {
2000105a:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
2000105c:	685b      	ldr	r3, [r3, #4]
2000105e:	62fb      	str	r3, [r7, #44]	@ 0x2c
20001060:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
20001062:	2b00      	cmp	r3, #0
20001064:	d1d6      	bne.n	20001014 <kmalloc+0x4c>
20001066:	e000      	b.n	2000106a <kmalloc+0xa2>
	break;
20001068:	bf00      	nop

    /*
     * If m is null, there's no memory left.
     */

    if (m == NULL) {
2000106a:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
2000106c:	2b00      	cmp	r3, #0
2000106e:	d103      	bne.n	20001078 <kmalloc+0xb0>
	lib_outofmemory();
20001070:	f7ff ffa2 	bl	20000fb8 <lib_outofmemory>
	return NULL;
20001074:	2300      	movs	r3, #0
20001076:	e061      	b.n	2000113c <kmalloc+0x174>
    /*
     * Otherwise, use this block.  Calculate the address of the data
     * to preserve the alignment.
     */

    if (daddr & (ptralign-1)) {
20001078:	69fb      	ldr	r3, [r7, #28]
2000107a:	1e5a      	subs	r2, r3, #1
2000107c:	6abb      	ldr	r3, [r7, #40]	@ 0x28
2000107e:	4013      	ands	r3, r2
20001080:	2b00      	cmp	r3, #0
20001082:	d008      	beq.n	20001096 <kmalloc+0xce>
	daddr += ptralign;
20001084:	6aba      	ldr	r2, [r7, #40]	@ 0x28
20001086:	69fb      	ldr	r3, [r7, #28]
20001088:	4413      	add	r3, r2
2000108a:	62bb      	str	r3, [r7, #40]	@ 0x28
	daddr &= ~(ptralign-1);
2000108c:	69fb      	ldr	r3, [r7, #28]
2000108e:	425b      	negs	r3, r3
20001090:	6aba      	ldr	r2, [r7, #40]	@ 0x28
20001092:	4013      	ands	r3, r2
20001094:	62bb      	str	r3, [r7, #40]	@ 0x28
	}

    /* Mark this node as allocated. */

    m->data   = (unsigned char *) daddr;
20001096:	6aba      	ldr	r2, [r7, #40]	@ 0x28
20001098:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
2000109a:	611a      	str	r2, [r3, #16]
    m->status = memnode_alloc;
2000109c:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
2000109e:	2201      	movs	r2, #1
200010a0:	731a      	strb	r2, [r3, #12]
     * aligned, backing up will put us inside the memnode
     * structure itself... that's why the memnodeptr field
     * is there, as a placeholder for this eventuality.
     */

    backptr   = (memnode_t **) (m->data - sizeof(memnode_t *));
200010a2:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
200010a4:	691b      	ldr	r3, [r3, #16]
200010a6:	3b04      	subs	r3, #4
200010a8:	61bb      	str	r3, [r7, #24]
    *backptr  = m;
200010aa:	69bb      	ldr	r3, [r7, #24]
200010ac:	6afa      	ldr	r2, [r7, #44]	@ 0x2c
200010ae:	601a      	str	r2, [r3, #0]
     * See if we need to split it.
     * Don't bother to split if the resulting size will be 
     * less than MINBLKSIZE bytes
     */

    if (m->length - realsize < MINBLKSIZE) {
200010b0:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
200010b2:	689a      	ldr	r2, [r3, #8]
200010b4:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
200010b6:	1ad3      	subs	r3, r2, r3
200010b8:	2b3f      	cmp	r3, #63	@ 0x3f
200010ba:	d802      	bhi.n	200010c2 <kmalloc+0xfa>
	return m->data;
200010bc:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
200010be:	691b      	ldr	r3, [r3, #16]
200010c0:	e03c      	b.n	2000113c <kmalloc+0x174>
    /*
     * Split this block.  Align the address on a pointer-size
     * boundary.
     */

    daddr += size;
200010c2:	6aba      	ldr	r2, [r7, #40]	@ 0x28
200010c4:	68bb      	ldr	r3, [r7, #8]
200010c6:	4413      	add	r3, r2
200010c8:	62bb      	str	r3, [r7, #40]	@ 0x28
    if (daddr & (uintptr_t)(sizeof(void *)-1)) {
200010ca:	6abb      	ldr	r3, [r7, #40]	@ 0x28
200010cc:	f003 0303 	and.w	r3, r3, #3
200010d0:	2b00      	cmp	r3, #0
200010d2:	d006      	beq.n	200010e2 <kmalloc+0x11a>
	daddr += (uintptr_t)sizeof(void *);
200010d4:	6abb      	ldr	r3, [r7, #40]	@ 0x28
200010d6:	3304      	adds	r3, #4
200010d8:	62bb      	str	r3, [r7, #40]	@ 0x28
	daddr &= ~(uintptr_t)(sizeof(void *)-1);
200010da:	6abb      	ldr	r3, [r7, #40]	@ 0x28
200010dc:	f023 0303 	bic.w	r3, r3, #3
200010e0:	62bb      	str	r3, [r7, #40]	@ 0x28
	}

    blkend = memnode_data(uintptr_t,m) + (uintptr_t)(m->length);
200010e2:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
200010e4:	689a      	ldr	r2, [r3, #8]
200010e6:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
200010e8:	4413      	add	r3, r2
200010ea:	3318      	adds	r3, #24
200010ec:	617b      	str	r3, [r7, #20]

    newm = (memnode_t *) daddr;
200010ee:	6abb      	ldr	r3, [r7, #40]	@ 0x28
200010f0:	613b      	str	r3, [r7, #16]

    newm->next   = m->next;
200010f2:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
200010f4:	685a      	ldr	r2, [r3, #4]
200010f6:	693b      	ldr	r3, [r7, #16]
200010f8:	605a      	str	r2, [r3, #4]
    m->length    = (unsigned int) (daddr - memnode_data(uintptr_t,m));
200010fa:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
200010fc:	6aba      	ldr	r2, [r7, #40]	@ 0x28
200010fe:	1ad3      	subs	r3, r2, r3
20001100:	f1a3 0218 	sub.w	r2, r3, #24
20001104:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
20001106:	609a      	str	r2, [r3, #8]
    m->next      = newm;
20001108:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
2000110a:	693a      	ldr	r2, [r7, #16]
2000110c:	605a      	str	r2, [r3, #4]
    m->status    = memnode_alloc;
2000110e:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
20001110:	2201      	movs	r2, #1
20001112:	731a      	strb	r2, [r3, #12]
    newm->seal   = MEMNODE_SEAL;
20001114:	693b      	ldr	r3, [r7, #16]
20001116:	4a0b      	ldr	r2, [pc, #44]	@ (20001144 <kmalloc+0x17c>)
20001118:	601a      	str	r2, [r3, #0]
    newm->data    = memnode_data(unsigned char *,newm);
2000111a:	693b      	ldr	r3, [r7, #16]
2000111c:	f103 0218 	add.w	r2, r3, #24
20001120:	693b      	ldr	r3, [r7, #16]
20001122:	611a      	str	r2, [r3, #16]
    newm->length = (unsigned int) (blkend - memnode_data(uintptr_t,newm));
20001124:	693b      	ldr	r3, [r7, #16]
20001126:	697a      	ldr	r2, [r7, #20]
20001128:	1ad3      	subs	r3, r2, r3
2000112a:	f1a3 0218 	sub.w	r2, r3, #24
2000112e:	693b      	ldr	r3, [r7, #16]
20001130:	609a      	str	r2, [r3, #8]
    newm->status = memnode_free;
20001132:	693b      	ldr	r3, [r7, #16]
20001134:	2200      	movs	r2, #0
20001136:	731a      	strb	r2, [r3, #12]

    return m->data;    
20001138:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
2000113a:	691b      	ldr	r3, [r3, #16]
}
2000113c:	4618      	mov	r0, r3
2000113e:	3730      	adds	r7, #48	@ 0x30
20001140:	46bd      	mov	sp, r7
20001142:	bd80      	pop	{r7, pc}
20001144:	faafa123 	.word	0xfaafa123

20001148 <q_enqueue>:
    *  Return Value:		
    *      Nothing.		
    ********************************************************************* */

void q_enqueue(queue_t *qb,queue_t *item)
{
20001148:	b480      	push	{r7}
2000114a:	b083      	sub	sp, #12
2000114c:	af00      	add	r7, sp, #0
2000114e:	6078      	str	r0, [r7, #4]
20001150:	6039      	str	r1, [r7, #0]
    qb->q_prev->q_next = item;
20001152:	687b      	ldr	r3, [r7, #4]
20001154:	685b      	ldr	r3, [r3, #4]
20001156:	683a      	ldr	r2, [r7, #0]
20001158:	601a      	str	r2, [r3, #0]
    item->q_next = qb;
2000115a:	683b      	ldr	r3, [r7, #0]
2000115c:	687a      	ldr	r2, [r7, #4]
2000115e:	601a      	str	r2, [r3, #0]
    item->q_prev = qb->q_prev;
20001160:	687b      	ldr	r3, [r7, #4]
20001162:	685a      	ldr	r2, [r3, #4]
20001164:	683b      	ldr	r3, [r7, #0]
20001166:	605a      	str	r2, [r3, #4]
    qb->q_prev = item;
20001168:	687b      	ldr	r3, [r7, #4]
2000116a:	683a      	ldr	r2, [r7, #0]
2000116c:	605a      	str	r2, [r3, #4]
}
2000116e:	bf00      	nop
20001170:	370c      	adds	r7, #12
20001172:	46bd      	mov	sp, r7
20001174:	f85d 7b04 	ldr.w	r7, [sp], #4
20001178:	4770      	bx	lr

2000117a <q_dequeue>:
    *  Return Value:			
    *      Nothing.			
    ********************************************************************* */

void q_dequeue(queue_t *item)
{
2000117a:	b480      	push	{r7}
2000117c:	b083      	sub	sp, #12
2000117e:	af00      	add	r7, sp, #0
20001180:	6078      	str	r0, [r7, #4]
    item->q_prev->q_next = item->q_next;
20001182:	687b      	ldr	r3, [r7, #4]
20001184:	685b      	ldr	r3, [r3, #4]
20001186:	687a      	ldr	r2, [r7, #4]
20001188:	6812      	ldr	r2, [r2, #0]
2000118a:	601a      	str	r2, [r3, #0]
    item->q_next->q_prev = item->q_prev;
2000118c:	687b      	ldr	r3, [r7, #4]
2000118e:	681b      	ldr	r3, [r3, #0]
20001190:	687a      	ldr	r2, [r7, #4]
20001192:	6852      	ldr	r2, [r2, #4]
20001194:	605a      	str	r2, [r3, #4]
}
20001196:	bf00      	nop
20001198:	370c      	adds	r7, #12
2000119a:	46bd      	mov	sp, r7
2000119c:	f85d 7b04 	ldr.w	r7, [sp], #4
200011a0:	4770      	bx	lr

200011a2 <q_deqnext>:
    *  Return Value:		
    *      next element, or NULL
    ********************************************************************* */

queue_t *q_deqnext(queue_t *qb)
{
200011a2:	b480      	push	{r7}
200011a4:	b083      	sub	sp, #12
200011a6:	af00      	add	r7, sp, #0
200011a8:	6078      	str	r0, [r7, #4]
    if (qb->q_next == qb) {
200011aa:	687b      	ldr	r3, [r7, #4]
200011ac:	681b      	ldr	r3, [r3, #0]
200011ae:	687a      	ldr	r2, [r7, #4]
200011b0:	429a      	cmp	r2, r3
200011b2:	d101      	bne.n	200011b8 <q_deqnext+0x16>
	return NULL;
200011b4:	2300      	movs	r3, #0
200011b6:	e00d      	b.n	200011d4 <q_deqnext+0x32>
	}

    qb = qb->q_next;
200011b8:	687b      	ldr	r3, [r7, #4]
200011ba:	681b      	ldr	r3, [r3, #0]
200011bc:	607b      	str	r3, [r7, #4]

    qb->q_prev->q_next = qb->q_next;
200011be:	687b      	ldr	r3, [r7, #4]
200011c0:	685b      	ldr	r3, [r3, #4]
200011c2:	687a      	ldr	r2, [r7, #4]
200011c4:	6812      	ldr	r2, [r2, #0]
200011c6:	601a      	str	r2, [r3, #0]
    qb->q_next->q_prev = qb->q_prev;
200011c8:	687b      	ldr	r3, [r7, #4]
200011ca:	681b      	ldr	r3, [r3, #0]
200011cc:	687a      	ldr	r2, [r7, #4]
200011ce:	6852      	ldr	r2, [r2, #4]
200011d0:	605a      	str	r2, [r3, #4]

    return qb;
200011d2:	687b      	ldr	r3, [r7, #4]
}
200011d4:	4618      	mov	r0, r3
200011d6:	370c      	adds	r7, #12
200011d8:	46bd      	mov	sp, r7
200011da:	f85d 7b04 	ldr.w	r7, [sp], #4
200011de:	4770      	bx	lr

200011e0 <q_count>:
    *      								*
    *  Return Value:							*
    *      number of elements						*
    ********************************************************************* */
int q_count(queue_t *qb)
{
200011e0:	b480      	push	{r7}
200011e2:	b085      	sub	sp, #20
200011e4:	af00      	add	r7, sp, #0
200011e6:	6078      	str	r0, [r7, #4]
    queue_t *qe;
    int res = 0;
200011e8:	2300      	movs	r3, #0
200011ea:	60bb      	str	r3, [r7, #8]

    qe = qb;
200011ec:	687b      	ldr	r3, [r7, #4]
200011ee:	60fb      	str	r3, [r7, #12]

    while (qe->q_next != qb) {
200011f0:	e005      	b.n	200011fe <q_count+0x1e>
	qe = qe->q_next;
200011f2:	68fb      	ldr	r3, [r7, #12]
200011f4:	681b      	ldr	r3, [r3, #0]
200011f6:	60fb      	str	r3, [r7, #12]
	res++;
200011f8:	68bb      	ldr	r3, [r7, #8]
200011fa:	3301      	adds	r3, #1
200011fc:	60bb      	str	r3, [r7, #8]
    while (qe->q_next != qb) {
200011fe:	68fb      	ldr	r3, [r7, #12]
20001200:	681b      	ldr	r3, [r3, #0]
20001202:	687a      	ldr	r2, [r7, #4]
20001204:	429a      	cmp	r2, r3
20001206:	d1f4      	bne.n	200011f2 <q_count+0x12>
	}

    return res;
20001208:	68bb      	ldr	r3, [r7, #8]
}
2000120a:	4618      	mov	r0, r3
2000120c:	3714      	adds	r7, #20
2000120e:	46bd      	mov	sp, r7
20001210:	f85d 7b04 	ldr.w	r7, [sp], #4
20001214:	4770      	bx	lr

20001216 <lib_strcpy>:
#include "lib_types.h"
#define _LIB_NO_MACROS_
#include "lib_string.h"

char *lib_strcpy(char *dest,const char *src)
{
20001216:	b480      	push	{r7}
20001218:	b085      	sub	sp, #20
2000121a:	af00      	add	r7, sp, #0
2000121c:	6078      	str	r0, [r7, #4]
2000121e:	6039      	str	r1, [r7, #0]
    char *ptr = dest;
20001220:	687b      	ldr	r3, [r7, #4]
20001222:	60fb      	str	r3, [r7, #12]

    while (*src) *ptr++ = *src++;
20001224:	e007      	b.n	20001236 <lib_strcpy+0x20>
20001226:	683a      	ldr	r2, [r7, #0]
20001228:	1c53      	adds	r3, r2, #1
2000122a:	603b      	str	r3, [r7, #0]
2000122c:	68fb      	ldr	r3, [r7, #12]
2000122e:	1c59      	adds	r1, r3, #1
20001230:	60f9      	str	r1, [r7, #12]
20001232:	7812      	ldrb	r2, [r2, #0]
20001234:	701a      	strb	r2, [r3, #0]
20001236:	683b      	ldr	r3, [r7, #0]
20001238:	781b      	ldrb	r3, [r3, #0]
2000123a:	2b00      	cmp	r3, #0
2000123c:	d1f3      	bne.n	20001226 <lib_strcpy+0x10>
    *ptr = '\0';
2000123e:	68fb      	ldr	r3, [r7, #12]
20001240:	2200      	movs	r2, #0
20001242:	701a      	strb	r2, [r3, #0]

    return dest;
20001244:	687b      	ldr	r3, [r7, #4]
}
20001246:	4618      	mov	r0, r3
20001248:	3714      	adds	r7, #20
2000124a:	46bd      	mov	sp, r7
2000124c:	f85d 7b04 	ldr.w	r7, [sp], #4
20001250:	4770      	bx	lr

20001252 <lib_xstrncpy>:
    return dest;
}


size_t lib_xstrncpy(char *dest,const char *src,size_t cnt)
{
20001252:	b480      	push	{r7}
20001254:	b087      	sub	sp, #28
20001256:	af00      	add	r7, sp, #0
20001258:	60f8      	str	r0, [r7, #12]
2000125a:	60b9      	str	r1, [r7, #8]
2000125c:	607a      	str	r2, [r7, #4]
    char *ptr = dest;
2000125e:	68fb      	ldr	r3, [r7, #12]
20001260:	617b      	str	r3, [r7, #20]
    size_t copied = 0;
20001262:	2300      	movs	r3, #0
20001264:	613b      	str	r3, [r7, #16]

    while (*src && (cnt > 1)) {
20001266:	e00d      	b.n	20001284 <lib_xstrncpy+0x32>
	*ptr++ = *src++;
20001268:	68ba      	ldr	r2, [r7, #8]
2000126a:	1c53      	adds	r3, r2, #1
2000126c:	60bb      	str	r3, [r7, #8]
2000126e:	697b      	ldr	r3, [r7, #20]
20001270:	1c59      	adds	r1, r3, #1
20001272:	6179      	str	r1, [r7, #20]
20001274:	7812      	ldrb	r2, [r2, #0]
20001276:	701a      	strb	r2, [r3, #0]
	cnt--;
20001278:	687b      	ldr	r3, [r7, #4]
2000127a:	3b01      	subs	r3, #1
2000127c:	607b      	str	r3, [r7, #4]
	copied++;
2000127e:	693b      	ldr	r3, [r7, #16]
20001280:	3301      	adds	r3, #1
20001282:	613b      	str	r3, [r7, #16]
    while (*src && (cnt > 1)) {
20001284:	68bb      	ldr	r3, [r7, #8]
20001286:	781b      	ldrb	r3, [r3, #0]
20001288:	2b00      	cmp	r3, #0
2000128a:	d002      	beq.n	20001292 <lib_xstrncpy+0x40>
2000128c:	687b      	ldr	r3, [r7, #4]
2000128e:	2b01      	cmp	r3, #1
20001290:	dcea      	bgt.n	20001268 <lib_xstrncpy+0x16>
	}
    *ptr = '\0';
20001292:	697b      	ldr	r3, [r7, #20]
20001294:	2200      	movs	r2, #0
20001296:	701a      	strb	r2, [r3, #0]

    return copied;
20001298:	693b      	ldr	r3, [r7, #16]
}
2000129a:	4618      	mov	r0, r3
2000129c:	371c      	adds	r7, #28
2000129e:	46bd      	mov	sp, r7
200012a0:	f85d 7b04 	ldr.w	r7, [sp], #4
200012a4:	4770      	bx	lr

200012a6 <lib_strlen>:

size_t lib_strlen(const char *str)
{
200012a6:	b480      	push	{r7}
200012a8:	b085      	sub	sp, #20
200012aa:	af00      	add	r7, sp, #0
200012ac:	6078      	str	r0, [r7, #4]
    size_t cnt = 0;
200012ae:	2300      	movs	r3, #0
200012b0:	60fb      	str	r3, [r7, #12]

    while (*str) {
200012b2:	e005      	b.n	200012c0 <lib_strlen+0x1a>
	str++;
200012b4:	687b      	ldr	r3, [r7, #4]
200012b6:	3301      	adds	r3, #1
200012b8:	607b      	str	r3, [r7, #4]
	cnt++;
200012ba:	68fb      	ldr	r3, [r7, #12]
200012bc:	3301      	adds	r3, #1
200012be:	60fb      	str	r3, [r7, #12]
    while (*str) {
200012c0:	687b      	ldr	r3, [r7, #4]
200012c2:	781b      	ldrb	r3, [r3, #0]
200012c4:	2b00      	cmp	r3, #0
200012c6:	d1f5      	bne.n	200012b4 <lib_strlen+0xe>
	}

    return cnt;
200012c8:	68fb      	ldr	r3, [r7, #12]
}
200012ca:	4618      	mov	r0, r3
200012cc:	3714      	adds	r7, #20
200012ce:	46bd      	mov	sp, r7
200012d0:	f85d 7b04 	ldr.w	r7, [sp], #4
200012d4:	4770      	bx	lr

200012d6 <lib_strcmp>:


int lib_strcmp(const char *dest,const char *src)
{
200012d6:	b480      	push	{r7}
200012d8:	b083      	sub	sp, #12
200012da:	af00      	add	r7, sp, #0
200012dc:	6078      	str	r0, [r7, #4]
200012de:	6039      	str	r1, [r7, #0]
    while (*src && *dest) {
200012e0:	e016      	b.n	20001310 <lib_strcmp+0x3a>
	if (*dest < *src) return -1;
200012e2:	687b      	ldr	r3, [r7, #4]
200012e4:	781a      	ldrb	r2, [r3, #0]
200012e6:	683b      	ldr	r3, [r7, #0]
200012e8:	781b      	ldrb	r3, [r3, #0]
200012ea:	429a      	cmp	r2, r3
200012ec:	d202      	bcs.n	200012f4 <lib_strcmp+0x1e>
200012ee:	f04f 33ff 	mov.w	r3, #4294967295	@ 0xffffffff
200012f2:	e02b      	b.n	2000134c <lib_strcmp+0x76>
	if (*dest > *src) return 1;
200012f4:	687b      	ldr	r3, [r7, #4]
200012f6:	781a      	ldrb	r2, [r3, #0]
200012f8:	683b      	ldr	r3, [r7, #0]
200012fa:	781b      	ldrb	r3, [r3, #0]
200012fc:	429a      	cmp	r2, r3
200012fe:	d901      	bls.n	20001304 <lib_strcmp+0x2e>
20001300:	2301      	movs	r3, #1
20001302:	e023      	b.n	2000134c <lib_strcmp+0x76>
	dest++;	
20001304:	687b      	ldr	r3, [r7, #4]
20001306:	3301      	adds	r3, #1
20001308:	607b      	str	r3, [r7, #4]
	src++;
2000130a:	683b      	ldr	r3, [r7, #0]
2000130c:	3301      	adds	r3, #1
2000130e:	603b      	str	r3, [r7, #0]
    while (*src && *dest) {
20001310:	683b      	ldr	r3, [r7, #0]
20001312:	781b      	ldrb	r3, [r3, #0]
20001314:	2b00      	cmp	r3, #0
20001316:	d003      	beq.n	20001320 <lib_strcmp+0x4a>
20001318:	687b      	ldr	r3, [r7, #4]
2000131a:	781b      	ldrb	r3, [r3, #0]
2000131c:	2b00      	cmp	r3, #0
2000131e:	d1e0      	bne.n	200012e2 <lib_strcmp+0xc>
	}

    if (*dest && !*src) return 1;
20001320:	687b      	ldr	r3, [r7, #4]
20001322:	781b      	ldrb	r3, [r3, #0]
20001324:	2b00      	cmp	r3, #0
20001326:	d005      	beq.n	20001334 <lib_strcmp+0x5e>
20001328:	683b      	ldr	r3, [r7, #0]
2000132a:	781b      	ldrb	r3, [r3, #0]
2000132c:	2b00      	cmp	r3, #0
2000132e:	d101      	bne.n	20001334 <lib_strcmp+0x5e>
20001330:	2301      	movs	r3, #1
20001332:	e00b      	b.n	2000134c <lib_strcmp+0x76>
    if (!*dest && *src) return -1;
20001334:	687b      	ldr	r3, [r7, #4]
20001336:	781b      	ldrb	r3, [r3, #0]
20001338:	2b00      	cmp	r3, #0
2000133a:	d106      	bne.n	2000134a <lib_strcmp+0x74>
2000133c:	683b      	ldr	r3, [r7, #0]
2000133e:	781b      	ldrb	r3, [r3, #0]
20001340:	2b00      	cmp	r3, #0
20001342:	d002      	beq.n	2000134a <lib_strcmp+0x74>
20001344:	f04f 33ff 	mov.w	r3, #4294967295	@ 0xffffffff
20001348:	e000      	b.n	2000134c <lib_strcmp+0x76>
    return 0;
2000134a:	2300      	movs	r3, #0
}
2000134c:	4618      	mov	r0, r3
2000134e:	370c      	adds	r7, #12
20001350:	46bd      	mov	sp, r7
20001352:	f85d 7b04 	ldr.w	r7, [sp], #4
20001356:	4770      	bx	lr

20001358 <lib_strchr>:
    return 0;
}


char *lib_strchr(const char *dest,int c)
{
20001358:	b480      	push	{r7}
2000135a:	b083      	sub	sp, #12
2000135c:	af00      	add	r7, sp, #0
2000135e:	6078      	str	r0, [r7, #4]
20001360:	6039      	str	r1, [r7, #0]
    while (*dest) {
20001362:	e00a      	b.n	2000137a <lib_strchr+0x22>
	if (*dest == c) return (char *) dest;
20001364:	687b      	ldr	r3, [r7, #4]
20001366:	781b      	ldrb	r3, [r3, #0]
20001368:	461a      	mov	r2, r3
2000136a:	683b      	ldr	r3, [r7, #0]
2000136c:	4293      	cmp	r3, r2
2000136e:	d101      	bne.n	20001374 <lib_strchr+0x1c>
20001370:	687b      	ldr	r3, [r7, #4]
20001372:	e007      	b.n	20001384 <lib_strchr+0x2c>
	dest++;
20001374:	687b      	ldr	r3, [r7, #4]
20001376:	3301      	adds	r3, #1
20001378:	607b      	str	r3, [r7, #4]
    while (*dest) {
2000137a:	687b      	ldr	r3, [r7, #4]
2000137c:	781b      	ldrb	r3, [r3, #0]
2000137e:	2b00      	cmp	r3, #0
20001380:	d1f0      	bne.n	20001364 <lib_strchr+0xc>
	}
    return NULL;
20001382:	2300      	movs	r3, #0
}
20001384:	4618      	mov	r0, r3
20001386:	370c      	adds	r7, #12
20001388:	46bd      	mov	sp, r7
2000138a:	f85d 7b04 	ldr.w	r7, [sp], #4
2000138e:	4770      	bx	lr

20001390 <lib_memcpy>:

    return 0;
}

void *lib_memcpy(void *dest,const void *src,size_t cnt)
{
20001390:	b480      	push	{r7}
20001392:	b087      	sub	sp, #28
20001394:	af00      	add	r7, sp, #0
20001396:	60f8      	str	r0, [r7, #12]
20001398:	60b9      	str	r1, [r7, #8]
2000139a:	607a      	str	r2, [r7, #4]
    unsigned char *d;
    const unsigned char *s;

    d = (unsigned char *) dest;
2000139c:	68fb      	ldr	r3, [r7, #12]
2000139e:	617b      	str	r3, [r7, #20]
    s = (const unsigned char *) src;
200013a0:	68bb      	ldr	r3, [r7, #8]
200013a2:	613b      	str	r3, [r7, #16]

    while (cnt) {
200013a4:	e00a      	b.n	200013bc <lib_memcpy+0x2c>
	*d++ = *s++;
200013a6:	693a      	ldr	r2, [r7, #16]
200013a8:	1c53      	adds	r3, r2, #1
200013aa:	613b      	str	r3, [r7, #16]
200013ac:	697b      	ldr	r3, [r7, #20]
200013ae:	1c59      	adds	r1, r3, #1
200013b0:	6179      	str	r1, [r7, #20]
200013b2:	7812      	ldrb	r2, [r2, #0]
200013b4:	701a      	strb	r2, [r3, #0]
	cnt--;
200013b6:	687b      	ldr	r3, [r7, #4]
200013b8:	3b01      	subs	r3, #1
200013ba:	607b      	str	r3, [r7, #4]
    while (cnt) {
200013bc:	687b      	ldr	r3, [r7, #4]
200013be:	2b00      	cmp	r3, #0
200013c0:	d1f1      	bne.n	200013a6 <lib_memcpy+0x16>
	}

    return dest;
200013c2:	68fb      	ldr	r3, [r7, #12]
}
200013c4:	4618      	mov	r0, r3
200013c6:	371c      	adds	r7, #28
200013c8:	46bd      	mov	sp, r7
200013ca:	f85d 7b04 	ldr.w	r7, [sp], #4
200013ce:	4770      	bx	lr

200013d0 <lib_memset>:

void *lib_memset(void *dest,int c,size_t cnt)
{
200013d0:	b480      	push	{r7}
200013d2:	b087      	sub	sp, #28
200013d4:	af00      	add	r7, sp, #0
200013d6:	60f8      	str	r0, [r7, #12]
200013d8:	60b9      	str	r1, [r7, #8]
200013da:	607a      	str	r2, [r7, #4]
    unsigned char *d;

    d = dest;
200013dc:	68fb      	ldr	r3, [r7, #12]
200013de:	617b      	str	r3, [r7, #20]

    while (cnt) {
200013e0:	e008      	b.n	200013f4 <lib_memset+0x24>
	*d++ = (unsigned char) c;
200013e2:	697b      	ldr	r3, [r7, #20]
200013e4:	1c5a      	adds	r2, r3, #1
200013e6:	617a      	str	r2, [r7, #20]
200013e8:	68ba      	ldr	r2, [r7, #8]
200013ea:	b2d2      	uxtb	r2, r2
200013ec:	701a      	strb	r2, [r3, #0]
	cnt--;
200013ee:	687b      	ldr	r3, [r7, #4]
200013f0:	3b01      	subs	r3, #1
200013f2:	607b      	str	r3, [r7, #4]
    while (cnt) {
200013f4:	687b      	ldr	r3, [r7, #4]
200013f6:	2b00      	cmp	r3, #0
200013f8:	d1f3      	bne.n	200013e2 <lib_memset+0x12>
	}

    return d;
200013fa:	697b      	ldr	r3, [r7, #20]
}
200013fc:	4618      	mov	r0, r3
200013fe:	371c      	adds	r7, #28
20001400:	46bd      	mov	sp, r7
20001402:	f85d 7b04 	ldr.w	r7, [sp], #4
20001406:	4770      	bx	lr

20001408 <lib_strcat>:
	str++;
	}
}

char *lib_strcat(char *dest,const char *src)
{
20001408:	b480      	push	{r7}
2000140a:	b085      	sub	sp, #20
2000140c:	af00      	add	r7, sp, #0
2000140e:	6078      	str	r0, [r7, #4]
20001410:	6039      	str	r1, [r7, #0]
    char *ptr = dest;
20001412:	687b      	ldr	r3, [r7, #4]
20001414:	60fb      	str	r3, [r7, #12]

    while (*ptr) ptr++;
20001416:	e002      	b.n	2000141e <lib_strcat+0x16>
20001418:	68fb      	ldr	r3, [r7, #12]
2000141a:	3301      	adds	r3, #1
2000141c:	60fb      	str	r3, [r7, #12]
2000141e:	68fb      	ldr	r3, [r7, #12]
20001420:	781b      	ldrb	r3, [r3, #0]
20001422:	2b00      	cmp	r3, #0
20001424:	d1f8      	bne.n	20001418 <lib_strcat+0x10>
    while (*src) *ptr++ = *src++;
20001426:	e007      	b.n	20001438 <lib_strcat+0x30>
20001428:	683a      	ldr	r2, [r7, #0]
2000142a:	1c53      	adds	r3, r2, #1
2000142c:	603b      	str	r3, [r7, #0]
2000142e:	68fb      	ldr	r3, [r7, #12]
20001430:	1c59      	adds	r1, r3, #1
20001432:	60f9      	str	r1, [r7, #12]
20001434:	7812      	ldrb	r2, [r2, #0]
20001436:	701a      	strb	r2, [r3, #0]
20001438:	683b      	ldr	r3, [r7, #0]
2000143a:	781b      	ldrb	r3, [r3, #0]
2000143c:	2b00      	cmp	r3, #0
2000143e:	d1f3      	bne.n	20001428 <lib_strcat+0x20>
    *ptr = '\0';
20001440:	68fb      	ldr	r3, [r7, #12]
20001442:	2200      	movs	r2, #0
20001444:	701a      	strb	r2, [r3, #0]

    return dest;
20001446:	687b      	ldr	r3, [r7, #4]
}
20001448:	4618      	mov	r0, r3
2000144a:	3714      	adds	r7, #20
2000144c:	46bd      	mov	sp, r7
2000144e:	f85d 7b04 	ldr.w	r7, [sp], #4
20001452:	4770      	bx	lr

20001454 <lib_atoi>:
    return ret;
}


int lib_atoi(const char *dest)
{
20001454:	b580      	push	{r7, lr}
20001456:	b084      	sub	sp, #16
20001458:	af00      	add	r7, sp, #0
2000145a:	6078      	str	r0, [r7, #4]
    int x = 0;
2000145c:	2300      	movs	r3, #0
2000145e:	60fb      	str	r3, [r7, #12]
    int digit;

    if ((*dest == '0') && (*(dest+1) == 'x')) {
20001460:	687b      	ldr	r3, [r7, #4]
20001462:	781b      	ldrb	r3, [r3, #0]
20001464:	2b30      	cmp	r3, #48	@ 0x30
20001466:	d124      	bne.n	200014b2 <lib_atoi+0x5e>
20001468:	687b      	ldr	r3, [r7, #4]
2000146a:	3301      	adds	r3, #1
2000146c:	781b      	ldrb	r3, [r3, #0]
2000146e:	2b78      	cmp	r3, #120	@ 0x78
20001470:	d11f      	bne.n	200014b2 <lib_atoi+0x5e>
	return lib_xtoi(dest+2);
20001472:	687b      	ldr	r3, [r7, #4]
20001474:	3302      	adds	r3, #2
20001476:	4618      	mov	r0, r3
20001478:	f000 f824 	bl	200014c4 <lib_xtoi>
2000147c:	4603      	mov	r3, r0
2000147e:	e01d      	b.n	200014bc <lib_atoi+0x68>
	}

    while (*dest) {
	if ((*dest >= '0') && (*dest <= '9')) {
20001480:	687b      	ldr	r3, [r7, #4]
20001482:	781b      	ldrb	r3, [r3, #0]
20001484:	2b2f      	cmp	r3, #47	@ 0x2f
20001486:	d918      	bls.n	200014ba <lib_atoi+0x66>
20001488:	687b      	ldr	r3, [r7, #4]
2000148a:	781b      	ldrb	r3, [r3, #0]
2000148c:	2b39      	cmp	r3, #57	@ 0x39
2000148e:	d814      	bhi.n	200014ba <lib_atoi+0x66>
	    digit = *dest - '0';
20001490:	687b      	ldr	r3, [r7, #4]
20001492:	781b      	ldrb	r3, [r3, #0]
20001494:	3b30      	subs	r3, #48	@ 0x30
20001496:	60bb      	str	r3, [r7, #8]
	    }
	else {
	    break;
	    }
	x *= 10;
20001498:	68fa      	ldr	r2, [r7, #12]
2000149a:	4613      	mov	r3, r2
2000149c:	009b      	lsls	r3, r3, #2
2000149e:	4413      	add	r3, r2
200014a0:	005b      	lsls	r3, r3, #1
200014a2:	60fb      	str	r3, [r7, #12]
	x += digit;
200014a4:	68fa      	ldr	r2, [r7, #12]
200014a6:	68bb      	ldr	r3, [r7, #8]
200014a8:	4413      	add	r3, r2
200014aa:	60fb      	str	r3, [r7, #12]
	dest++;
200014ac:	687b      	ldr	r3, [r7, #4]
200014ae:	3301      	adds	r3, #1
200014b0:	607b      	str	r3, [r7, #4]
    while (*dest) {
200014b2:	687b      	ldr	r3, [r7, #4]
200014b4:	781b      	ldrb	r3, [r3, #0]
200014b6:	2b00      	cmp	r3, #0
200014b8:	d1e2      	bne.n	20001480 <lib_atoi+0x2c>
	}

    return x;
200014ba:	68fb      	ldr	r3, [r7, #12]
}
200014bc:	4618      	mov	r0, r3
200014be:	3710      	adds	r7, #16
200014c0:	46bd      	mov	sp, r7
200014c2:	bd80      	pop	{r7, pc}

200014c4 <lib_xtoi>:

    return x;
}

int lib_xtoi(const char *dest)
{
200014c4:	b480      	push	{r7}
200014c6:	b085      	sub	sp, #20
200014c8:	af00      	add	r7, sp, #0
200014ca:	6078      	str	r0, [r7, #4]
    int x = 0;
200014cc:	2300      	movs	r3, #0
200014ce:	60fb      	str	r3, [r7, #12]
    int digit;

    if ((*dest == '0') && (*(dest+1) == 'x')) dest += 2;
200014d0:	687b      	ldr	r3, [r7, #4]
200014d2:	781b      	ldrb	r3, [r3, #0]
200014d4:	2b30      	cmp	r3, #48	@ 0x30
200014d6:	d138      	bne.n	2000154a <lib_xtoi+0x86>
200014d8:	687b      	ldr	r3, [r7, #4]
200014da:	3301      	adds	r3, #1
200014dc:	781b      	ldrb	r3, [r3, #0]
200014de:	2b78      	cmp	r3, #120	@ 0x78
200014e0:	d133      	bne.n	2000154a <lib_xtoi+0x86>
200014e2:	687b      	ldr	r3, [r7, #4]
200014e4:	3302      	adds	r3, #2
200014e6:	607b      	str	r3, [r7, #4]

    while (*dest) {
200014e8:	e02f      	b.n	2000154a <lib_xtoi+0x86>
	if ((*dest >= '0') && (*dest <= '9')) {
200014ea:	687b      	ldr	r3, [r7, #4]
200014ec:	781b      	ldrb	r3, [r3, #0]
200014ee:	2b2f      	cmp	r3, #47	@ 0x2f
200014f0:	d908      	bls.n	20001504 <lib_xtoi+0x40>
200014f2:	687b      	ldr	r3, [r7, #4]
200014f4:	781b      	ldrb	r3, [r3, #0]
200014f6:	2b39      	cmp	r3, #57	@ 0x39
200014f8:	d804      	bhi.n	20001504 <lib_xtoi+0x40>
	    digit = *dest - '0';
200014fa:	687b      	ldr	r3, [r7, #4]
200014fc:	781b      	ldrb	r3, [r3, #0]
200014fe:	3b30      	subs	r3, #48	@ 0x30
20001500:	60bb      	str	r3, [r7, #8]
20001502:	e018      	b.n	20001536 <lib_xtoi+0x72>
	    }
	else if ((*dest >= 'A') && (*dest <= 'F')) {
20001504:	687b      	ldr	r3, [r7, #4]
20001506:	781b      	ldrb	r3, [r3, #0]
20001508:	2b40      	cmp	r3, #64	@ 0x40
2000150a:	d908      	bls.n	2000151e <lib_xtoi+0x5a>
2000150c:	687b      	ldr	r3, [r7, #4]
2000150e:	781b      	ldrb	r3, [r3, #0]
20001510:	2b46      	cmp	r3, #70	@ 0x46
20001512:	d804      	bhi.n	2000151e <lib_xtoi+0x5a>
	    digit = 10 + *dest - 'A';
20001514:	687b      	ldr	r3, [r7, #4]
20001516:	781b      	ldrb	r3, [r3, #0]
20001518:	3b37      	subs	r3, #55	@ 0x37
2000151a:	60bb      	str	r3, [r7, #8]
2000151c:	e00b      	b.n	20001536 <lib_xtoi+0x72>
	    }
	else if ((*dest >= 'a') && (*dest <= 'f')) {
2000151e:	687b      	ldr	r3, [r7, #4]
20001520:	781b      	ldrb	r3, [r3, #0]
20001522:	2b60      	cmp	r3, #96	@ 0x60
20001524:	d915      	bls.n	20001552 <lib_xtoi+0x8e>
20001526:	687b      	ldr	r3, [r7, #4]
20001528:	781b      	ldrb	r3, [r3, #0]
2000152a:	2b66      	cmp	r3, #102	@ 0x66
2000152c:	d811      	bhi.n	20001552 <lib_xtoi+0x8e>
	    digit = 10 + *dest - 'a';
2000152e:	687b      	ldr	r3, [r7, #4]
20001530:	781b      	ldrb	r3, [r3, #0]
20001532:	3b57      	subs	r3, #87	@ 0x57
20001534:	60bb      	str	r3, [r7, #8]
	    }
	else {
	    break;
	    }
	x *= 16;
20001536:	68fb      	ldr	r3, [r7, #12]
20001538:	011b      	lsls	r3, r3, #4
2000153a:	60fb      	str	r3, [r7, #12]
	x += digit;
2000153c:	68fa      	ldr	r2, [r7, #12]
2000153e:	68bb      	ldr	r3, [r7, #8]
20001540:	4413      	add	r3, r2
20001542:	60fb      	str	r3, [r7, #12]
	dest++;
20001544:	687b      	ldr	r3, [r7, #4]
20001546:	3301      	adds	r3, #1
20001548:	607b      	str	r3, [r7, #4]
    while (*dest) {
2000154a:	687b      	ldr	r3, [r7, #4]
2000154c:	781b      	ldrb	r3, [r3, #0]
2000154e:	2b00      	cmp	r3, #0
20001550:	d1cb      	bne.n	200014ea <lib_xtoi+0x26>
	}

    return x;
20001552:	68fb      	ldr	r3, [r7, #12]
}
20001554:	4618      	mov	r0, r3
20001556:	3714      	adds	r7, #20
20001558:	46bd      	mov	sp, r7
2000155a:	f85d 7b04 	ldr.w	r7, [sp], #4
2000155e:	4770      	bx	lr

20001560 <lib_strdup>:
#define _LIB_NO_MACROS_
#include "lib_string.h"


char *lib_strdup(char *str)
{
20001560:	b580      	push	{r7, lr}
20001562:	b084      	sub	sp, #16
20001564:	af00      	add	r7, sp, #0
20001566:	6078      	str	r0, [r7, #4]
    char *buf;

    buf = KMALLOC(lib_strlen(str)+1,0);
20001568:	6878      	ldr	r0, [r7, #4]
2000156a:	f7ff fe9c 	bl	200012a6 <lib_strlen>
2000156e:	4603      	mov	r3, r0
20001570:	3301      	adds	r3, #1
20001572:	2200      	movs	r2, #0
20001574:	4619      	mov	r1, r3
20001576:	4808      	ldr	r0, [pc, #32]	@ (20001598 <lib_strdup+0x38>)
20001578:	f7ff fd26 	bl	20000fc8 <kmalloc>
2000157c:	60f8      	str	r0, [r7, #12]
    if (buf) {
2000157e:	68fb      	ldr	r3, [r7, #12]
20001580:	2b00      	cmp	r3, #0
20001582:	d003      	beq.n	2000158c <lib_strdup+0x2c>
	lib_strcpy(buf,str);
20001584:	6879      	ldr	r1, [r7, #4]
20001586:	68f8      	ldr	r0, [r7, #12]
20001588:	f7ff fe45 	bl	20001216 <lib_strcpy>
	}

    return buf;
2000158c:	68fb      	ldr	r3, [r7, #12]
}
2000158e:	4618      	mov	r0, r3
20001590:	3710      	adds	r7, #16
20001592:	46bd      	mov	sp, r7
20001594:	bd80      	pop	{r7, pc}
20001596:	bf00      	nop
20001598:	20005e94 	.word	0x20005e94

2000159c <cfe_finddev>:
    *  Return value:
    *  	   cfe_device_t pointer or NULL
    ********************************************************************* */

cfe_device_t *cfe_finddev(char *name)
{
2000159c:	b580      	push	{r7, lr}
2000159e:	b084      	sub	sp, #16
200015a0:	af00      	add	r7, sp, #0
200015a2:	6078      	str	r0, [r7, #4]
    queue_t *qb;
    cfe_device_t *dev;

    for (qb = cfe_devices.q_next; qb != &cfe_devices; qb = qb->q_next) {
200015a4:	4b0e      	ldr	r3, [pc, #56]	@ (200015e0 <cfe_finddev+0x44>)
200015a6:	681b      	ldr	r3, [r3, #0]
200015a8:	60fb      	str	r3, [r7, #12]
200015aa:	e00f      	b.n	200015cc <cfe_finddev+0x30>
	dev = (cfe_device_t *) qb;
200015ac:	68fb      	ldr	r3, [r7, #12]
200015ae:	60bb      	str	r3, [r7, #8]
	if (strcmp(dev->dev_fullname,name) == 0) {
200015b0:	68bb      	ldr	r3, [r7, #8]
200015b2:	689b      	ldr	r3, [r3, #8]
200015b4:	6879      	ldr	r1, [r7, #4]
200015b6:	4618      	mov	r0, r3
200015b8:	f7ff fe8d 	bl	200012d6 <lib_strcmp>
200015bc:	4603      	mov	r3, r0
200015be:	2b00      	cmp	r3, #0
200015c0:	d101      	bne.n	200015c6 <cfe_finddev+0x2a>
	    return dev;
200015c2:	68bb      	ldr	r3, [r7, #8]
200015c4:	e007      	b.n	200015d6 <cfe_finddev+0x3a>
    for (qb = cfe_devices.q_next; qb != &cfe_devices; qb = qb->q_next) {
200015c6:	68fb      	ldr	r3, [r7, #12]
200015c8:	681b      	ldr	r3, [r3, #0]
200015ca:	60fb      	str	r3, [r7, #12]
200015cc:	68fb      	ldr	r3, [r7, #12]
200015ce:	4a04      	ldr	r2, [pc, #16]	@ (200015e0 <cfe_finddev+0x44>)
200015d0:	4293      	cmp	r3, r2
200015d2:	d1eb      	bne.n	200015ac <cfe_finddev+0x10>
	    }
	}

    return NULL;
200015d4:	2300      	movs	r3, #0
}
200015d6:	4618      	mov	r0, r3
200015d8:	3710      	adds	r7, #16
200015da:	46bd      	mov	sp, r7
200015dc:	bd80      	pop	{r7, pc}
200015de:	bf00      	nop
200015e0:	20005e60 	.word	0x20005e60

200015e4 <cfe_dev_enum>:
    *  	   0 if ok
    *  	   else -1
    ********************************************************************* */

int cfe_dev_enum(int idx,char *name,int *namelen)
{
200015e4:	b580      	push	{r7, lr}
200015e6:	b086      	sub	sp, #24
200015e8:	af00      	add	r7, sp, #0
200015ea:	60f8      	str	r0, [r7, #12]
200015ec:	60b9      	str	r1, [r7, #8]
200015ee:	607a      	str	r2, [r7, #4]
    queue_t *qb;
    cfe_device_t *dev;

    for (qb = cfe_devices.q_next; qb != &cfe_devices; qb = qb->q_next) {
200015f0:	4b15      	ldr	r3, [pc, #84]	@ (20001648 <cfe_dev_enum+0x64>)
200015f2:	681b      	ldr	r3, [r3, #0]
200015f4:	617b      	str	r3, [r7, #20]
200015f6:	e008      	b.n	2000160a <cfe_dev_enum+0x26>
	if (idx == 0) break;
200015f8:	68fb      	ldr	r3, [r7, #12]
200015fa:	2b00      	cmp	r3, #0
200015fc:	d00a      	beq.n	20001614 <cfe_dev_enum+0x30>
	idx--;
200015fe:	68fb      	ldr	r3, [r7, #12]
20001600:	3b01      	subs	r3, #1
20001602:	60fb      	str	r3, [r7, #12]
    for (qb = cfe_devices.q_next; qb != &cfe_devices; qb = qb->q_next) {
20001604:	697b      	ldr	r3, [r7, #20]
20001606:	681b      	ldr	r3, [r3, #0]
20001608:	617b      	str	r3, [r7, #20]
2000160a:	697b      	ldr	r3, [r7, #20]
2000160c:	4a0e      	ldr	r2, [pc, #56]	@ (20001648 <cfe_dev_enum+0x64>)
2000160e:	4293      	cmp	r3, r2
20001610:	d1f2      	bne.n	200015f8 <cfe_dev_enum+0x14>
20001612:	e000      	b.n	20001616 <cfe_dev_enum+0x32>
	if (idx == 0) break;
20001614:	bf00      	nop
	}

    if (qb == &cfe_devices) return (-1);
20001616:	697b      	ldr	r3, [r7, #20]
20001618:	4a0b      	ldr	r2, [pc, #44]	@ (20001648 <cfe_dev_enum+0x64>)
2000161a:	4293      	cmp	r3, r2
2000161c:	d102      	bne.n	20001624 <cfe_dev_enum+0x40>
2000161e:	f04f 33ff 	mov.w	r3, #4294967295	@ 0xffffffff
20001622:	e00d      	b.n	20001640 <cfe_dev_enum+0x5c>
    dev = (cfe_device_t *) qb;
20001624:	697b      	ldr	r3, [r7, #20]
20001626:	613b      	str	r3, [r7, #16]

    *namelen = xstrncpy(name,dev->dev_fullname,*namelen);
20001628:	693b      	ldr	r3, [r7, #16]
2000162a:	6899      	ldr	r1, [r3, #8]
2000162c:	687b      	ldr	r3, [r7, #4]
2000162e:	681b      	ldr	r3, [r3, #0]
20001630:	461a      	mov	r2, r3
20001632:	68b8      	ldr	r0, [r7, #8]
20001634:	f7ff fe0d 	bl	20001252 <lib_xstrncpy>
20001638:	4602      	mov	r2, r0
2000163a:	687b      	ldr	r3, [r7, #4]
2000163c:	601a      	str	r2, [r3, #0]

    return 0;
2000163e:	2300      	movs	r3, #0

}
20001640:	4618      	mov	r0, r3
20001642:	3718      	adds	r7, #24
20001644:	46bd      	mov	sp, r7
20001646:	bd80      	pop	{r7, pc}
20001648:	20005e60 	.word	0x20005e60

2000164c <cfe_attach_idx>:
    *  	   1 if we were successful.
    ********************************************************************* */

int cfe_attach_idx(cfe_driver_t *drv,int idx,void *softc,
		   char *bootinfo,char *description)
{
2000164c:	b580      	push	{r7, lr}
2000164e:	b096      	sub	sp, #88	@ 0x58
20001650:	af00      	add	r7, sp, #0
20001652:	60f8      	str	r0, [r7, #12]
20001654:	60b9      	str	r1, [r7, #8]
20001656:	607a      	str	r2, [r7, #4]
20001658:	603b      	str	r3, [r7, #0]
    char name[64];
    cfe_device_t *dev;

    xsprintf(name,"%s%d",drv->drv_bootname,idx);
2000165a:	68fb      	ldr	r3, [r7, #12]
2000165c:	685a      	ldr	r2, [r3, #4]
2000165e:	f107 0014 	add.w	r0, r7, #20
20001662:	68bb      	ldr	r3, [r7, #8]
20001664:	4928      	ldr	r1, [pc, #160]	@ (20001708 <cfe_attach_idx+0xbc>)
20001666:	f7ff fac9 	bl	20000bfc <xsprintf>

    if (bootinfo) {
2000166a:	683b      	ldr	r3, [r7, #0]
2000166c:	2b00      	cmp	r3, #0
2000166e:	d00b      	beq.n	20001688 <cfe_attach_idx+0x3c>
	strcat(name,".");
20001670:	f107 0314 	add.w	r3, r7, #20
20001674:	4925      	ldr	r1, [pc, #148]	@ (2000170c <cfe_attach_idx+0xc0>)
20001676:	4618      	mov	r0, r3
20001678:	f7ff fec6 	bl	20001408 <lib_strcat>
	strcat(name,bootinfo);
2000167c:	f107 0314 	add.w	r3, r7, #20
20001680:	6839      	ldr	r1, [r7, #0]
20001682:	4618      	mov	r0, r3
20001684:	f7ff fec0 	bl	20001408 <lib_strcat>
	}

    if (cfe_finddev(name) != NULL) {
20001688:	f107 0314 	add.w	r3, r7, #20
2000168c:	4618      	mov	r0, r3
2000168e:	f7ff ff85 	bl	2000159c <cfe_finddev>
20001692:	4603      	mov	r3, r0
20001694:	2b00      	cmp	r3, #0
20001696:	d001      	beq.n	2000169c <cfe_attach_idx+0x50>
	return 0;
20001698:	2300      	movs	r3, #0
2000169a:	e031      	b.n	20001700 <cfe_attach_idx+0xb4>
	}

    dev = (cfe_device_t *) KMALLOC(sizeof(cfe_device_t),0);
2000169c:	2200      	movs	r2, #0
2000169e:	2120      	movs	r1, #32
200016a0:	481b      	ldr	r0, [pc, #108]	@ (20001710 <cfe_attach_idx+0xc4>)
200016a2:	f7ff fc91 	bl	20000fc8 <kmalloc>
200016a6:	6578      	str	r0, [r7, #84]	@ 0x54
    if (!dev) return -1;
200016a8:	6d7b      	ldr	r3, [r7, #84]	@ 0x54
200016aa:	2b00      	cmp	r3, #0
200016ac:	d102      	bne.n	200016b4 <cfe_attach_idx+0x68>
200016ae:	f04f 33ff 	mov.w	r3, #4294967295	@ 0xffffffff
200016b2:	e025      	b.n	20001700 <cfe_attach_idx+0xb4>

    dev->dev_fullname = strdup(name);
200016b4:	f107 0314 	add.w	r3, r7, #20
200016b8:	4618      	mov	r0, r3
200016ba:	f7ff ff51 	bl	20001560 <lib_strdup>
200016be:	4602      	mov	r2, r0
200016c0:	6d7b      	ldr	r3, [r7, #84]	@ 0x54
200016c2:	609a      	str	r2, [r3, #8]
    dev->dev_softc = softc;
200016c4:	6d7b      	ldr	r3, [r7, #84]	@ 0x54
200016c6:	687a      	ldr	r2, [r7, #4]
200016c8:	60da      	str	r2, [r3, #12]
    dev->dev_class = drv->drv_class;
200016ca:	68fb      	ldr	r3, [r7, #12]
200016cc:	689a      	ldr	r2, [r3, #8]
200016ce:	6d7b      	ldr	r3, [r7, #84]	@ 0x54
200016d0:	611a      	str	r2, [r3, #16]
    dev->dev_dispatch = drv->drv_dispatch;
200016d2:	68fb      	ldr	r3, [r7, #12]
200016d4:	68da      	ldr	r2, [r3, #12]
200016d6:	6d7b      	ldr	r3, [r7, #84]	@ 0x54
200016d8:	615a      	str	r2, [r3, #20]
    dev->dev_description = description ? strdup(description) : NULL;
200016da:	6e3b      	ldr	r3, [r7, #96]	@ 0x60
200016dc:	2b00      	cmp	r3, #0
200016de:	d004      	beq.n	200016ea <cfe_attach_idx+0x9e>
200016e0:	6e38      	ldr	r0, [r7, #96]	@ 0x60
200016e2:	f7ff ff3d 	bl	20001560 <lib_strdup>
200016e6:	4603      	mov	r3, r0
200016e8:	e000      	b.n	200016ec <cfe_attach_idx+0xa0>
200016ea:	2300      	movs	r3, #0
200016ec:	6d7a      	ldr	r2, [r7, #84]	@ 0x54
200016ee:	61d3      	str	r3, [r2, #28]
    dev->dev_opencount = 0;
200016f0:	6d7b      	ldr	r3, [r7, #84]	@ 0x54
200016f2:	2200      	movs	r2, #0
200016f4:	619a      	str	r2, [r3, #24]

    q_enqueue(&cfe_devices,(queue_t *) dev);
200016f6:	6d79      	ldr	r1, [r7, #84]	@ 0x54
200016f8:	4806      	ldr	r0, [pc, #24]	@ (20001714 <cfe_attach_idx+0xc8>)
200016fa:	f7ff fd25 	bl	20001148 <q_enqueue>

    return 1;
200016fe:	2301      	movs	r3, #1

}
20001700:	4618      	mov	r0, r3
20001702:	3758      	adds	r7, #88	@ 0x58
20001704:	46bd      	mov	sp, r7
20001706:	bd80      	pop	{r7, pc}
20001708:	20005404 	.word	0x20005404
2000170c:	2000540c 	.word	0x2000540c
20001710:	20005e94 	.word	0x20005e94
20001714:	20005e60 	.word	0x20005e60

20001718 <cfe_attach>:
    ********************************************************************* */

void cfe_attach(cfe_driver_t *drv,void *softc,
		char *bootinfo,
		char *description)
{
20001718:	b580      	push	{r7, lr}
2000171a:	b088      	sub	sp, #32
2000171c:	af02      	add	r7, sp, #8
2000171e:	60f8      	str	r0, [r7, #12]
20001720:	60b9      	str	r1, [r7, #8]
20001722:	607a      	str	r2, [r7, #4]
20001724:	603b      	str	r3, [r7, #0]
     * Try device indicies 0..CFE_MAX_DEVINST to assign a unique
     * device name for this device.  This is a really braindead way to 
     * do this, but how many devices are we expecting anyway?
     */

    for (idx = 0; idx < CFE_MAX_DEVINST; idx++) {
20001726:	2300      	movs	r3, #0
20001728:	617b      	str	r3, [r7, #20]
2000172a:	e011      	b.n	20001750 <cfe_attach+0x38>

	res = cfe_attach_idx(drv,idx,softc,bootinfo,description);
2000172c:	683b      	ldr	r3, [r7, #0]
2000172e:	9300      	str	r3, [sp, #0]
20001730:	687b      	ldr	r3, [r7, #4]
20001732:	68ba      	ldr	r2, [r7, #8]
20001734:	6979      	ldr	r1, [r7, #20]
20001736:	68f8      	ldr	r0, [r7, #12]
20001738:	f7ff ff88 	bl	2000164c <cfe_attach_idx>
2000173c:	6138      	str	r0, [r7, #16]

	if (res < 0) break;	/* out of memory or other badness */
2000173e:	693b      	ldr	r3, [r7, #16]
20001740:	2b00      	cmp	r3, #0
20001742:	db09      	blt.n	20001758 <cfe_attach+0x40>
	if (res > 0) break;	/* success! */
20001744:	693b      	ldr	r3, [r7, #16]
20001746:	2b00      	cmp	r3, #0
20001748:	dc08      	bgt.n	2000175c <cfe_attach+0x44>
    for (idx = 0; idx < CFE_MAX_DEVINST; idx++) {
2000174a:	697b      	ldr	r3, [r7, #20]
2000174c:	3301      	adds	r3, #1
2000174e:	617b      	str	r3, [r7, #20]
20001750:	697b      	ldr	r3, [r7, #20]
20001752:	2b3f      	cmp	r3, #63	@ 0x3f
20001754:	ddea      	ble.n	2000172c <cfe_attach+0x14>
	/* otherwise, try again, slot is taken */
	}

}
20001756:	e002      	b.n	2000175e <cfe_attach+0x46>
	if (res < 0) break;	/* out of memory or other badness */
20001758:	bf00      	nop
2000175a:	e000      	b.n	2000175e <cfe_attach+0x46>
	if (res > 0) break;	/* success! */
2000175c:	bf00      	nop
}
2000175e:	bf00      	nop
20001760:	3718      	adds	r7, #24
20001762:	46bd      	mov	sp, r7
20001764:	bd80      	pop	{r7, pc}
	...

20001768 <cfe_attach_init>:
    *  	  
    *  Return value:
    *  	   nothing
    ********************************************************************* */
void cfe_attach_init(void)
{
20001768:	b480      	push	{r7}
2000176a:	af00      	add	r7, sp, #0
    q_init(&(cfe_devices));
2000176c:	4b05      	ldr	r3, [pc, #20]	@ (20001784 <cfe_attach_init+0x1c>)
2000176e:	4a05      	ldr	r2, [pc, #20]	@ (20001784 <cfe_attach_init+0x1c>)
20001770:	605a      	str	r2, [r3, #4]
20001772:	4b04      	ldr	r3, [pc, #16]	@ (20001784 <cfe_attach_init+0x1c>)
20001774:	4a03      	ldr	r2, [pc, #12]	@ (20001784 <cfe_attach_init+0x1c>)
20001776:	601a      	str	r2, [r3, #0]
}
20001778:	bf00      	nop
2000177a:	46bd      	mov	sp, r7
2000177c:	f85d 7b04 	ldr.w	r7, [sp], #4
20001780:	4770      	bx	lr
20001782:	bf00      	nop
20001784:	20005e60 	.word	0x20005e60

20001788 <cfe_bg_init>:
    *  Return value:
    *  	   nothing
    ********************************************************************* */

void cfe_bg_init(void)
{
20001788:	b580      	push	{r7, lr}
2000178a:	af00      	add	r7, sp, #0
    memset(cfe_bg_tasklist,0,sizeof(cfe_bg_tasklist));
2000178c:	2240      	movs	r2, #64	@ 0x40
2000178e:	2100      	movs	r1, #0
20001790:	4802      	ldr	r0, [pc, #8]	@ (2000179c <cfe_bg_init+0x14>)
20001792:	f7ff fe1d 	bl	200013d0 <lib_memset>
}
20001796:	bf00      	nop
20001798:	bd80      	pop	{r7, pc}
2000179a:	bf00      	nop
2000179c:	20005ea0 	.word	0x20005ea0

200017a0 <cfe_bg_add>:
    *  Return value:
    *  	   nothing
    ********************************************************************* */

void cfe_bg_add(void (*func)(void *x),void *arg)
{
200017a0:	b480      	push	{r7}
200017a2:	b085      	sub	sp, #20
200017a4:	af00      	add	r7, sp, #0
200017a6:	6078      	str	r0, [r7, #4]
200017a8:	6039      	str	r1, [r7, #0]
    int idx;

    for (idx = 0; idx < MAX_BACKGROUND_TASKS; idx++) {
200017aa:	2300      	movs	r3, #0
200017ac:	60fb      	str	r3, [r7, #12]
200017ae:	e013      	b.n	200017d8 <cfe_bg_add+0x38>
	if (cfe_bg_tasklist[idx] == NULL) {
200017b0:	4a0d      	ldr	r2, [pc, #52]	@ (200017e8 <cfe_bg_add+0x48>)
200017b2:	68fb      	ldr	r3, [r7, #12]
200017b4:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
200017b8:	2b00      	cmp	r3, #0
200017ba:	d10a      	bne.n	200017d2 <cfe_bg_add+0x32>
	    cfe_bg_tasklist[idx] = func;
200017bc:	490a      	ldr	r1, [pc, #40]	@ (200017e8 <cfe_bg_add+0x48>)
200017be:	68fb      	ldr	r3, [r7, #12]
200017c0:	687a      	ldr	r2, [r7, #4]
200017c2:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
	    cfe_bg_args[idx] = arg;
200017c6:	4909      	ldr	r1, [pc, #36]	@ (200017ec <cfe_bg_add+0x4c>)
200017c8:	68fb      	ldr	r3, [r7, #12]
200017ca:	683a      	ldr	r2, [r7, #0]
200017cc:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
	    return;
200017d0:	e005      	b.n	200017de <cfe_bg_add+0x3e>
    for (idx = 0; idx < MAX_BACKGROUND_TASKS; idx++) {
200017d2:	68fb      	ldr	r3, [r7, #12]
200017d4:	3301      	adds	r3, #1
200017d6:	60fb      	str	r3, [r7, #12]
200017d8:	68fb      	ldr	r3, [r7, #12]
200017da:	2b0f      	cmp	r3, #15
200017dc:	dde8      	ble.n	200017b0 <cfe_bg_add+0x10>
	    }
	}
}
200017de:	3714      	adds	r7, #20
200017e0:	46bd      	mov	sp, r7
200017e2:	f85d 7b04 	ldr.w	r7, [sp], #4
200017e6:	4770      	bx	lr
200017e8:	20005ea0 	.word	0x20005ea0
200017ec:	20005ee0 	.word	0x20005ee0

200017f0 <background>:
    *  Return value:
    *  	   nothing
    ********************************************************************* */

void background(void)
{
200017f0:	b580      	push	{r7, lr}
200017f2:	b082      	sub	sp, #8
200017f4:	af00      	add	r7, sp, #0
    int idx;
    void (*func)(void *arg);

    for (idx = 0; idx < MAX_BACKGROUND_TASKS; idx++) {
200017f6:	2300      	movs	r3, #0
200017f8:	607b      	str	r3, [r7, #4]
200017fa:	e011      	b.n	20001820 <background+0x30>
	func = cfe_bg_tasklist[idx];
200017fc:	4a0d      	ldr	r2, [pc, #52]	@ (20001834 <background+0x44>)
200017fe:	687b      	ldr	r3, [r7, #4]
20001800:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
20001804:	603b      	str	r3, [r7, #0]
	if (func == NULL) break;
20001806:	683b      	ldr	r3, [r7, #0]
20001808:	2b00      	cmp	r3, #0
2000180a:	d00d      	beq.n	20001828 <background+0x38>
	(*func)(cfe_bg_args[idx]);
2000180c:	4a0a      	ldr	r2, [pc, #40]	@ (20001838 <background+0x48>)
2000180e:	687b      	ldr	r3, [r7, #4]
20001810:	f852 2023 	ldr.w	r2, [r2, r3, lsl #2]
20001814:	683b      	ldr	r3, [r7, #0]
20001816:	4610      	mov	r0, r2
20001818:	4798      	blx	r3
    for (idx = 0; idx < MAX_BACKGROUND_TASKS; idx++) {
2000181a:	687b      	ldr	r3, [r7, #4]
2000181c:	3301      	adds	r3, #1
2000181e:	607b      	str	r3, [r7, #4]
20001820:	687b      	ldr	r3, [r7, #4]
20001822:	2b0f      	cmp	r3, #15
20001824:	ddea      	ble.n	200017fc <background+0xc>
	}
}
20001826:	e000      	b.n	2000182a <background+0x3a>
	if (func == NULL) break;
20001828:	bf00      	nop
}
2000182a:	bf00      	nop
2000182c:	3708      	adds	r7, #8
2000182e:	46bd      	mov	sp, r7
20001830:	bd80      	pop	{r7, pc}
20001832:	bf00      	nop
20001834:	20005ea0 	.word	0x20005ea0
20001838:	20005ee0 	.word	0x20005ee0

2000183c <console_open>:
    *  	   0 if ok, else return code.  
    *  	   console_handle contains the console's handle
    ********************************************************************* */

int console_open(char *name)
{
2000183c:	b580      	push	{r7, lr}
2000183e:	b084      	sub	sp, #16
20001840:	af00      	add	r7, sp, #0
20001842:	6078      	str	r0, [r7, #4]

#else

    int flushbuf;

    console_name = NULL;
20001844:	4b14      	ldr	r3, [pc, #80]	@ (20001898 <console_open+0x5c>)
20001846:	2200      	movs	r2, #0
20001848:	601a      	str	r2, [r3, #0]

    if (console_handle != -1) {
2000184a:	4b14      	ldr	r3, [pc, #80]	@ (2000189c <console_open+0x60>)
2000184c:	681b      	ldr	r3, [r3, #0]
2000184e:	f1b3 3fff 	cmp.w	r3, #4294967295	@ 0xffffffff
20001852:	d001      	beq.n	20001858 <console_open+0x1c>
	console_close();
20001854:	f000 f826 	bl	200018a4 <console_close>
	}

    flushbuf = console_buffer_flg;
20001858:	4b11      	ldr	r3, [pc, #68]	@ (200018a0 <console_open+0x64>)
2000185a:	681b      	ldr	r3, [r3, #0]
2000185c:	60fb      	str	r3, [r7, #12]
    console_buffer_flg = 0;
2000185e:	4b10      	ldr	r3, [pc, #64]	@ (200018a0 <console_open+0x64>)
20001860:	2200      	movs	r2, #0
20001862:	601a      	str	r2, [r3, #0]

    console_handle = cfe_open(name);
20001864:	6878      	ldr	r0, [r7, #4]
20001866:	f001 f842 	bl	200028ee <cfe_open>
2000186a:	4603      	mov	r3, r0
2000186c:	4a0b      	ldr	r2, [pc, #44]	@ (2000189c <console_open+0x60>)
2000186e:	6013      	str	r3, [r2, #0]
    if (console_handle < 0) return CFE_ERR_DEVNOTFOUND;
20001870:	4b0a      	ldr	r3, [pc, #40]	@ (2000189c <console_open+0x60>)
20001872:	681b      	ldr	r3, [r3, #0]
20001874:	2b00      	cmp	r3, #0
20001876:	da02      	bge.n	2000187e <console_open+0x42>
20001878:	f06f 0305 	mvn.w	r3, #5
2000187c:	e008      	b.n	20001890 <console_open+0x54>

    console_name = name;
2000187e:	4a06      	ldr	r2, [pc, #24]	@ (20001898 <console_open+0x5c>)
20001880:	687b      	ldr	r3, [r7, #4]
20001882:	6013      	str	r3, [r2, #0]
    if (flushbuf) console_flushbuffer();
20001884:	68fb      	ldr	r3, [r7, #12]
20001886:	2b00      	cmp	r3, #0
20001888:	d001      	beq.n	2000188e <console_open+0x52>
2000188a:	f000 f8f9 	bl	20001a80 <console_flushbuffer>
#endif

    return 0;
2000188e:	2300      	movs	r3, #0
}
20001890:	4618      	mov	r0, r3
20001892:	3710      	adds	r7, #16
20001894:	46bd      	mov	sp, r7
20001896:	bd80      	pop	{r7, pc}
20001898:	20005fa8 	.word	0x20005fa8
2000189c:	20005e70 	.word	0x20005e70
200018a0:	20005fa0 	.word	0x20005fa0

200018a4 <console_close>:
    *  Return value:
    *  	   0
    ********************************************************************* */

int console_close(void)
{
200018a4:	b580      	push	{r7, lr}
200018a6:	af00      	add	r7, sp, #0
    if (console_handle != -1) {
200018a8:	4b08      	ldr	r3, [pc, #32]	@ (200018cc <console_close+0x28>)
200018aa:	681b      	ldr	r3, [r3, #0]
200018ac:	f1b3 3fff 	cmp.w	r3, #4294967295	@ 0xffffffff
200018b0:	d004      	beq.n	200018bc <console_close+0x18>
	cfe_close(console_handle);
200018b2:	4b06      	ldr	r3, [pc, #24]	@ (200018cc <console_close+0x28>)
200018b4:	681b      	ldr	r3, [r3, #0]
200018b6:	4618      	mov	r0, r3
200018b8:	f001 f843 	bl	20002942 <cfe_close>
	}

    console_handle = -1;
200018bc:	4b03      	ldr	r3, [pc, #12]	@ (200018cc <console_close+0x28>)
200018be:	f04f 32ff 	mov.w	r2, #4294967295	@ 0xffffffff
200018c2:	601a      	str	r2, [r3, #0]

    return 0;
200018c4:	2300      	movs	r3, #0
}
200018c6:	4618      	mov	r0, r3
200018c8:	bd80      	pop	{r7, pc}
200018ca:	bf00      	nop
200018cc:	20005e70 	.word	0x20005e70

200018d0 <console_read>:
    *  Return value:
    *  	   number of characters received, or <0 if error code
    ********************************************************************* */

int console_read(unsigned char *buffer,int length)
{
200018d0:	b580      	push	{r7, lr}
200018d2:	b082      	sub	sp, #8
200018d4:	af00      	add	r7, sp, #0
200018d6:	6078      	str	r0, [r7, #4]
200018d8:	6039      	str	r1, [r7, #0]
    if (console_handle == -1) return -1;
200018da:	4b0a      	ldr	r3, [pc, #40]	@ (20001904 <console_read+0x34>)
200018dc:	681b      	ldr	r3, [r3, #0]
200018de:	f1b3 3fff 	cmp.w	r3, #4294967295	@ 0xffffffff
200018e2:	d102      	bne.n	200018ea <console_read+0x1a>
200018e4:	f04f 33ff 	mov.w	r3, #4294967295	@ 0xffffffff
200018e8:	e007      	b.n	200018fa <console_read+0x2a>

    return cfe_read(console_handle,PTR2HSADDR(buffer),length);
200018ea:	4b06      	ldr	r3, [pc, #24]	@ (20001904 <console_read+0x34>)
200018ec:	681b      	ldr	r3, [r3, #0]
200018ee:	6879      	ldr	r1, [r7, #4]
200018f0:	683a      	ldr	r2, [r7, #0]
200018f2:	4618      	mov	r0, r3
200018f4:	f001 f866 	bl	200029c4 <cfe_read>
200018f8:	4603      	mov	r3, r0
}
200018fa:	4618      	mov	r0, r3
200018fc:	3708      	adds	r7, #8
200018fe:	46bd      	mov	sp, r7
20001900:	bd80      	pop	{r7, pc}
20001902:	bf00      	nop
20001904:	20005e70 	.word	0x20005e70

20001908 <console_write>:
    *  Return value:
    *  	   number of characters written or <0 if error
    ********************************************************************* */

int console_write(unsigned char *buffer,int length)
{
20001908:	b580      	push	{r7, lr}
2000190a:	b084      	sub	sp, #16
2000190c:	af00      	add	r7, sp, #0
2000190e:	6078      	str	r0, [r7, #4]
20001910:	6039      	str	r1, [r7, #0]

#if !CFG_MINIMAL_SIZE
    /*
     * Buffer text if requested
     */
    if (console_buffer_flg) {
20001912:	4b1b      	ldr	r3, [pc, #108]	@ (20001980 <console_write+0x78>)
20001914:	681b      	ldr	r3, [r3, #0]
20001916:	2b00      	cmp	r3, #0
20001918:	d005      	beq.n	20001926 <console_write+0x1e>
	console_save(buffer,length);
2000191a:	6839      	ldr	r1, [r7, #0]
2000191c:	6878      	ldr	r0, [r7, #4]
2000191e:	f000 f8eb 	bl	20001af8 <console_save>
	return length;
20001922:	683b      	ldr	r3, [r7, #0]
20001924:	e028      	b.n	20001978 <console_write+0x70>

    /*
     * Do nothing if no console
     */

    if (console_handle == -1) return -1;
20001926:	4b17      	ldr	r3, [pc, #92]	@ (20001984 <console_write+0x7c>)
20001928:	681b      	ldr	r3, [r3, #0]
2000192a:	f1b3 3fff 	cmp.w	r3, #4294967295	@ 0xffffffff
2000192e:	d102      	bne.n	20001936 <console_write+0x2e>
20001930:	f04f 33ff 	mov.w	r3, #4294967295	@ 0xffffffff
20001934:	e020      	b.n	20001978 <console_write+0x70>
    /*
     * Write text to device
     */

    for (;;) {
	res = cfe_write(console_handle,PTR2HSADDR(buffer),length);
20001936:	4b13      	ldr	r3, [pc, #76]	@ (20001984 <console_write+0x7c>)
20001938:	681b      	ldr	r3, [r3, #0]
2000193a:	6879      	ldr	r1, [r7, #4]
2000193c:	683a      	ldr	r2, [r7, #0]
2000193e:	4618      	mov	r0, r3
20001940:	f001 f87f 	bl	20002a42 <cfe_write>
20001944:	60f8      	str	r0, [r7, #12]
	if (res < 0) break;
20001946:	68fb      	ldr	r3, [r7, #12]
20001948:	2b00      	cmp	r3, #0
2000194a:	db0b      	blt.n	20001964 <console_write+0x5c>
	buffer += res;
2000194c:	68fb      	ldr	r3, [r7, #12]
2000194e:	687a      	ldr	r2, [r7, #4]
20001950:	4413      	add	r3, r2
20001952:	607b      	str	r3, [r7, #4]
	length -= res;
20001954:	683a      	ldr	r2, [r7, #0]
20001956:	68fb      	ldr	r3, [r7, #12]
20001958:	1ad3      	subs	r3, r2, r3
2000195a:	603b      	str	r3, [r7, #0]
	if (length == 0) break;
2000195c:	683b      	ldr	r3, [r7, #0]
2000195e:	2b00      	cmp	r3, #0
20001960:	d002      	beq.n	20001968 <console_write+0x60>
	res = cfe_write(console_handle,PTR2HSADDR(buffer),length);
20001962:	e7e8      	b.n	20001936 <console_write+0x2e>
	if (res < 0) break;
20001964:	bf00      	nop
20001966:	e000      	b.n	2000196a <console_write+0x62>
	if (length == 0) break;
20001968:	bf00      	nop
	}

    if (res < 0) return -1;
2000196a:	68fb      	ldr	r3, [r7, #12]
2000196c:	2b00      	cmp	r3, #0
2000196e:	da02      	bge.n	20001976 <console_write+0x6e>
20001970:	f04f 33ff 	mov.w	r3, #4294967295	@ 0xffffffff
20001974:	e000      	b.n	20001978 <console_write+0x70>
    return 0;			 
20001976:	2300      	movs	r3, #0
}
20001978:	4618      	mov	r0, r3
2000197a:	3710      	adds	r7, #16
2000197c:	46bd      	mov	sp, r7
2000197e:	bd80      	pop	{r7, pc}
20001980:	20005fa0 	.word	0x20005fa0
20001984:	20005e70 	.word	0x20005e70

20001988 <console_status>:
    *  	   0 if no characters are available
    *  	   1 if characters are available.
    ********************************************************************* */

int console_status(void)
{
20001988:	b580      	push	{r7, lr}
2000198a:	af00      	add	r7, sp, #0
    if (console_handle == -1) return 0;
2000198c:	4b07      	ldr	r3, [pc, #28]	@ (200019ac <console_status+0x24>)
2000198e:	681b      	ldr	r3, [r3, #0]
20001990:	f1b3 3fff 	cmp.w	r3, #4294967295	@ 0xffffffff
20001994:	d101      	bne.n	2000199a <console_status+0x12>
20001996:	2300      	movs	r3, #0
20001998:	e005      	b.n	200019a6 <console_status+0x1e>

    return cfe_inpstat(console_handle);
2000199a:	4b04      	ldr	r3, [pc, #16]	@ (200019ac <console_status+0x24>)
2000199c:	681b      	ldr	r3, [r3, #0]
2000199e:	4618      	mov	r0, r3
200019a0:	f001 f865 	bl	20002a6e <cfe_inpstat>
200019a4:	4603      	mov	r3, r0
}
200019a6:	4618      	mov	r0, r3
200019a8:	bd80      	pop	{r7, pc}
200019aa:	bf00      	nop
200019ac:	20005e70 	.word	0x20005e70

200019b0 <console_xprint>:
    *  Return value:
    *  	   number of characters written
    ********************************************************************* */

static int console_xprint(const char *str)
{
200019b0:	b580      	push	{r7, lr}
200019b2:	b086      	sub	sp, #24
200019b4:	af00      	add	r7, sp, #0
200019b6:	6078      	str	r0, [r7, #4]
    int count = 0;	
200019b8:	2300      	movs	r3, #0
200019ba:	617b      	str	r3, [r7, #20]
    int len;
    const char *p;

    /* Convert CR to CRLF as we write things out */

    while ((p = strchr(str,'\n'))) {
200019bc:	e013      	b.n	200019e6 <console_xprint+0x36>
	console_write((unsigned char *) str,p-str);
200019be:	693a      	ldr	r2, [r7, #16]
200019c0:	687b      	ldr	r3, [r7, #4]
200019c2:	1ad3      	subs	r3, r2, r3
200019c4:	4619      	mov	r1, r3
200019c6:	6878      	ldr	r0, [r7, #4]
200019c8:	f7ff ff9e 	bl	20001908 <console_write>
	console_write((unsigned char *)"\r\n",2);
200019cc:	2102      	movs	r1, #2
200019ce:	4812      	ldr	r0, [pc, #72]	@ (20001a18 <console_xprint+0x68>)
200019d0:	f7ff ff9a 	bl	20001908 <console_write>
	count += (p-str);
200019d4:	693a      	ldr	r2, [r7, #16]
200019d6:	687b      	ldr	r3, [r7, #4]
200019d8:	1ad3      	subs	r3, r2, r3
200019da:	697a      	ldr	r2, [r7, #20]
200019dc:	4413      	add	r3, r2
200019de:	617b      	str	r3, [r7, #20]
	str = p + 1;
200019e0:	693b      	ldr	r3, [r7, #16]
200019e2:	3301      	adds	r3, #1
200019e4:	607b      	str	r3, [r7, #4]
    while ((p = strchr(str,'\n'))) {
200019e6:	210a      	movs	r1, #10
200019e8:	6878      	ldr	r0, [r7, #4]
200019ea:	f7ff fcb5 	bl	20001358 <lib_strchr>
200019ee:	6138      	str	r0, [r7, #16]
200019f0:	693b      	ldr	r3, [r7, #16]
200019f2:	2b00      	cmp	r3, #0
200019f4:	d1e3      	bne.n	200019be <console_xprint+0xe>
	}

    len = strlen(str);
200019f6:	6878      	ldr	r0, [r7, #4]
200019f8:	f7ff fc55 	bl	200012a6 <lib_strlen>
200019fc:	60f8      	str	r0, [r7, #12]
    console_write((unsigned char *) str, len);
200019fe:	68f9      	ldr	r1, [r7, #12]
20001a00:	6878      	ldr	r0, [r7, #4]
20001a02:	f7ff ff81 	bl	20001908 <console_write>
    count += len;
20001a06:	697a      	ldr	r2, [r7, #20]
20001a08:	68fb      	ldr	r3, [r7, #12]
20001a0a:	4413      	add	r3, r2
20001a0c:	617b      	str	r3, [r7, #20]

    return count;
20001a0e:	697b      	ldr	r3, [r7, #20]
}
20001a10:	4618      	mov	r0, r3
20001a12:	3718      	adds	r7, #24
20001a14:	46bd      	mov	sp, r7
20001a16:	bd80      	pop	{r7, pc}
20001a18:	2000541c 	.word	0x2000541c

20001a1c <cfe_set_console>:
    *  	   0 if ok
    *  	   else error code
    ********************************************************************* */

int cfe_set_console(char *name)
{
20001a1c:	b580      	push	{r7, lr}
20001a1e:	b084      	sub	sp, #16
20001a20:	af00      	add	r7, sp, #0
20001a22:	6078      	str	r0, [r7, #4]
    xprinthook = console_xprint;
20001a24:	4b11      	ldr	r3, [pc, #68]	@ (20001a6c <cfe_set_console+0x50>)
20001a26:	4a12      	ldr	r2, [pc, #72]	@ (20001a70 <cfe_set_console+0x54>)
20001a28:	601a      	str	r2, [r3, #0]

#if !CFG_MINIMAL_SIZE
    if (strcmp(name,CFE_BUFFER_CONSOLE) == 0) {
20001a2a:	4912      	ldr	r1, [pc, #72]	@ (20001a74 <cfe_set_console+0x58>)
20001a2c:	6878      	ldr	r0, [r7, #4]
20001a2e:	f7ff fc52 	bl	200012d6 <lib_strcmp>
20001a32:	4603      	mov	r3, r0
20001a34:	2b00      	cmp	r3, #0
20001a36:	d104      	bne.n	20001a42 <cfe_set_console+0x26>
	console_buffer_flg = 1;
20001a38:	4b0f      	ldr	r3, [pc, #60]	@ (20001a78 <cfe_set_console+0x5c>)
20001a3a:	2201      	movs	r2, #1
20001a3c:	601a      	str	r2, [r3, #0]
	return 0;
20001a3e:	2300      	movs	r3, #0
20001a40:	e010      	b.n	20001a64 <cfe_set_console+0x48>
	}
#endif

    if (name) {
20001a42:	687b      	ldr	r3, [r7, #4]
20001a44:	2b00      	cmp	r3, #0
20001a46:	d00b      	beq.n	20001a60 <cfe_set_console+0x44>
	int res;
	res = env_setenv("BOOT_CONSOLE",name,
20001a48:	f240 1203 	movw	r2, #259	@ 0x103
20001a4c:	6879      	ldr	r1, [r7, #4]
20001a4e:	480b      	ldr	r0, [pc, #44]	@ (20001a7c <cfe_set_console+0x60>)
20001a50:	f001 fe90 	bl	20003774 <env_setenv>
20001a54:	60f8      	str	r0, [r7, #12]
		   ENV_FLG_BUILTIN | ENV_FLG_READONLY | ENV_FLG_ADMIN);
	return console_open(name);
20001a56:	6878      	ldr	r0, [r7, #4]
20001a58:	f7ff fef0 	bl	2000183c <console_open>
20001a5c:	4603      	mov	r3, r0
20001a5e:	e001      	b.n	20001a64 <cfe_set_console+0x48>
	}
    return -1;
20001a60:	f04f 33ff 	mov.w	r3, #4294967295	@ 0xffffffff
}
20001a64:	4618      	mov	r0, r3
20001a66:	3710      	adds	r7, #16
20001a68:	46bd      	mov	sp, r7
20001a6a:	bd80      	pop	{r7, pc}
20001a6c:	20005e90 	.word	0x20005e90
20001a70:	200019b1 	.word	0x200019b1
20001a74:	2000542c 	.word	0x2000542c
20001a78:	20005fa0 	.word	0x20005fa0
20001a7c:	20005434 	.word	0x20005434

20001a80 <console_flushbuffer>:
    *  Return value:
    *  	   nothing
    ********************************************************************* */

static void console_flushbuffer(void)
{
20001a80:	b580      	push	{r7, lr}
20001a82:	b084      	sub	sp, #16
20001a84:	af00      	add	r7, sp, #0

    /*
     * Remove console messages from the queue 
     */

    while ((msg = (msgqueue_t *) q_deqnext(&console_msgq))) {
20001a86:	e025      	b.n	20001ad4 <console_flushbuffer+0x54>

	buffer = msg->data;
20001a88:	687b      	ldr	r3, [r7, #4]
20001a8a:	330c      	adds	r3, #12
20001a8c:	60fb      	str	r3, [r7, #12]
	length = msg->len;
20001a8e:	687b      	ldr	r3, [r7, #4]
20001a90:	689b      	ldr	r3, [r3, #8]
20001a92:	60bb      	str	r3, [r7, #8]
	res = 0;
20001a94:	2300      	movs	r3, #0
20001a96:	603b      	str	r3, [r7, #0]
	/*
	 * Write each message to the console 
	 */

	for (;;) {
	    res = cfe_write(console_handle,PTR2HSADDR(buffer),length);
20001a98:	4b14      	ldr	r3, [pc, #80]	@ (20001aec <console_flushbuffer+0x6c>)
20001a9a:	681b      	ldr	r3, [r3, #0]
20001a9c:	68f9      	ldr	r1, [r7, #12]
20001a9e:	68ba      	ldr	r2, [r7, #8]
20001aa0:	4618      	mov	r0, r3
20001aa2:	f000 ffce 	bl	20002a42 <cfe_write>
20001aa6:	6038      	str	r0, [r7, #0]
	    if (res < 0) break;
20001aa8:	683b      	ldr	r3, [r7, #0]
20001aaa:	2b00      	cmp	r3, #0
20001aac:	db0b      	blt.n	20001ac6 <console_flushbuffer+0x46>
	    buffer += res;
20001aae:	683b      	ldr	r3, [r7, #0]
20001ab0:	68fa      	ldr	r2, [r7, #12]
20001ab2:	4413      	add	r3, r2
20001ab4:	60fb      	str	r3, [r7, #12]
	    length -= res;
20001ab6:	68ba      	ldr	r2, [r7, #8]
20001ab8:	683b      	ldr	r3, [r7, #0]
20001aba:	1ad3      	subs	r3, r2, r3
20001abc:	60bb      	str	r3, [r7, #8]
	    if (length == 0) break;
20001abe:	68bb      	ldr	r3, [r7, #8]
20001ac0:	2b00      	cmp	r3, #0
20001ac2:	d002      	beq.n	20001aca <console_flushbuffer+0x4a>
	    res = cfe_write(console_handle,PTR2HSADDR(buffer),length);
20001ac4:	e7e8      	b.n	20001a98 <console_flushbuffer+0x18>
	    if (res < 0) break;
20001ac6:	bf00      	nop
20001ac8:	e000      	b.n	20001acc <console_flushbuffer+0x4c>
	    if (length == 0) break;
20001aca:	bf00      	nop

	/*
	 * Free the storage
	 */

	KFREE(msg);
20001acc:	6879      	ldr	r1, [r7, #4]
20001ace:	4808      	ldr	r0, [pc, #32]	@ (20001af0 <console_flushbuffer+0x70>)
20001ad0:	f7ff fa46 	bl	20000f60 <kfree>
    while ((msg = (msgqueue_t *) q_deqnext(&console_msgq))) {
20001ad4:	4807      	ldr	r0, [pc, #28]	@ (20001af4 <console_flushbuffer+0x74>)
20001ad6:	f7ff fb64 	bl	200011a2 <q_deqnext>
20001ada:	6078      	str	r0, [r7, #4]
20001adc:	687b      	ldr	r3, [r7, #4]
20001ade:	2b00      	cmp	r3, #0
20001ae0:	d1d2      	bne.n	20001a88 <console_flushbuffer+0x8>
	}
}
20001ae2:	bf00      	nop
20001ae4:	bf00      	nop
20001ae6:	3710      	adds	r7, #16
20001ae8:	46bd      	mov	sp, r7
20001aea:	bd80      	pop	{r7, pc}
20001aec:	20005e70 	.word	0x20005e70
20001af0:	20005e94 	.word	0x20005e94
20001af4:	20005e68 	.word	0x20005e68

20001af8 <console_save>:
    *  Return value:
    *  	   nothing
    ********************************************************************* */

static void console_save(unsigned char *buffer,int length)
{
20001af8:	b580      	push	{r7, lr}
20001afa:	b084      	sub	sp, #16
20001afc:	af00      	add	r7, sp, #0
20001afe:	6078      	str	r0, [r7, #4]
20001b00:	6039      	str	r1, [r7, #0]
    /*
     * Get a pointer to the last message in the queue.  If 
     * it's full, preprare to allocate a new one
     */

    msg = (msgqueue_t *) console_msgq.q_prev;
20001b02:	4b2a      	ldr	r3, [pc, #168]	@ (20001bac <console_save+0xb4>)
20001b04:	685b      	ldr	r3, [r3, #4]
20001b06:	60fb      	str	r3, [r7, #12]
    if (q_isempty(&(console_msgq)) || (msg->len == MSGQUEUESIZE)) {
20001b08:	4b28      	ldr	r3, [pc, #160]	@ (20001bac <console_save+0xb4>)
20001b0a:	681b      	ldr	r3, [r3, #0]
20001b0c:	4a27      	ldr	r2, [pc, #156]	@ (20001bac <console_save+0xb4>)
20001b0e:	4293      	cmp	r3, r2
20001b10:	d004      	beq.n	20001b1c <console_save+0x24>
20001b12:	68fb      	ldr	r3, [r7, #12]
20001b14:	689b      	ldr	r3, [r3, #8]
20001b16:	f5b3 7f80 	cmp.w	r3, #256	@ 0x100
20001b1a:	d13f      	bne.n	20001b9c <console_save+0xa4>
	msg = NULL;
20001b1c:	2300      	movs	r3, #0
20001b1e:	60fb      	str	r3, [r7, #12]

    /*
     * Stuff characters into message chunks till we're done
     */

    while (length) {
20001b20:	e03c      	b.n	20001b9c <console_save+0xa4>

	/*
	 * New chunk 
	 */
	if (msg == NULL) {
20001b22:	68fb      	ldr	r3, [r7, #12]
20001b24:	2b00      	cmp	r3, #0
20001b26:	d122      	bne.n	20001b6e <console_save+0x76>

	    msg = (msgqueue_t *) KMALLOC(sizeof(msgqueue_t),0);
20001b28:	2200      	movs	r2, #0
20001b2a:	f44f 7186 	mov.w	r1, #268	@ 0x10c
20001b2e:	4820      	ldr	r0, [pc, #128]	@ (20001bb0 <console_save+0xb8>)
20001b30:	f7ff fa4a 	bl	20000fc8 <kmalloc>
20001b34:	60f8      	str	r0, [r7, #12]
	    if (msg == NULL) return;
20001b36:	68fb      	ldr	r3, [r7, #12]
20001b38:	2b00      	cmp	r3, #0
20001b3a:	d033      	beq.n	20001ba4 <console_save+0xac>
	    msg->len = 0;
20001b3c:	68fb      	ldr	r3, [r7, #12]
20001b3e:	2200      	movs	r2, #0
20001b40:	609a      	str	r2, [r3, #8]
	    q_enqueue(&console_msgq,(queue_t *) msg);
20001b42:	68f9      	ldr	r1, [r7, #12]
20001b44:	4819      	ldr	r0, [pc, #100]	@ (20001bac <console_save+0xb4>)
20001b46:	f7ff faff 	bl	20001148 <q_enqueue>

	    /*
	     * Remove chunks to prevent chewing too much memory
	     */

	    while (q_count(&console_msgq) > MSGQUEUEMAX) {
20001b4a:	e00a      	b.n	20001b62 <console_save+0x6a>
		msgqueue_t *dropmsg;
		dropmsg = (msgqueue_t *) q_deqnext(&console_msgq);
20001b4c:	4817      	ldr	r0, [pc, #92]	@ (20001bac <console_save+0xb4>)
20001b4e:	f7ff fb28 	bl	200011a2 <q_deqnext>
20001b52:	60b8      	str	r0, [r7, #8]
		if (dropmsg) KFREE(dropmsg);
20001b54:	68bb      	ldr	r3, [r7, #8]
20001b56:	2b00      	cmp	r3, #0
20001b58:	d003      	beq.n	20001b62 <console_save+0x6a>
20001b5a:	68b9      	ldr	r1, [r7, #8]
20001b5c:	4814      	ldr	r0, [pc, #80]	@ (20001bb0 <console_save+0xb8>)
20001b5e:	f7ff f9ff 	bl	20000f60 <kfree>
	    while (q_count(&console_msgq) > MSGQUEUEMAX) {
20001b62:	4812      	ldr	r0, [pc, #72]	@ (20001bac <console_save+0xb4>)
20001b64:	f7ff fb3c 	bl	200011e0 <q_count>
20001b68:	4603      	mov	r3, r0
20001b6a:	2b0a      	cmp	r3, #10
20001b6c:	dcee      	bgt.n	20001b4c <console_save+0x54>

	/*
	 * Save text.  If we run off the end of the buffer, prepare
	 * to allocate a new one
	 */
	msg->data[msg->len++] = *buffer++;
20001b6e:	687a      	ldr	r2, [r7, #4]
20001b70:	1c53      	adds	r3, r2, #1
20001b72:	607b      	str	r3, [r7, #4]
20001b74:	68fb      	ldr	r3, [r7, #12]
20001b76:	689b      	ldr	r3, [r3, #8]
20001b78:	1c58      	adds	r0, r3, #1
20001b7a:	68f9      	ldr	r1, [r7, #12]
20001b7c:	6088      	str	r0, [r1, #8]
20001b7e:	7811      	ldrb	r1, [r2, #0]
20001b80:	68fa      	ldr	r2, [r7, #12]
20001b82:	4413      	add	r3, r2
20001b84:	460a      	mov	r2, r1
20001b86:	731a      	strb	r2, [r3, #12]
	length--;
20001b88:	683b      	ldr	r3, [r7, #0]
20001b8a:	3b01      	subs	r3, #1
20001b8c:	603b      	str	r3, [r7, #0]
	if (msg->len == MSGQUEUESIZE) msg = NULL;
20001b8e:	68fb      	ldr	r3, [r7, #12]
20001b90:	689b      	ldr	r3, [r3, #8]
20001b92:	f5b3 7f80 	cmp.w	r3, #256	@ 0x100
20001b96:	d101      	bne.n	20001b9c <console_save+0xa4>
20001b98:	2300      	movs	r3, #0
20001b9a:	60fb      	str	r3, [r7, #12]
    while (length) {
20001b9c:	683b      	ldr	r3, [r7, #0]
20001b9e:	2b00      	cmp	r3, #0
20001ba0:	d1bf      	bne.n	20001b22 <console_save+0x2a>
20001ba2:	e000      	b.n	20001ba6 <console_save+0xae>
	    if (msg == NULL) return;
20001ba4:	bf00      	nop
	}
}
20001ba6:	3710      	adds	r7, #16
20001ba8:	46bd      	mov	sp, r7
20001baa:	bd80      	pop	{r7, pc}
20001bac:	20005e68 	.word	0x20005e68
20001bb0:	20005e94 	.word	0x20005e94

20001bb4 <console_readnum>:
    *  Return value:
    *  	   nothing
    ********************************************************************* */

static void console_readnum(int *num,unsigned char *ch)
{
20001bb4:	b580      	push	{r7, lr}
20001bb6:	b084      	sub	sp, #16
20001bb8:	af00      	add	r7, sp, #0
20001bba:	6078      	str	r0, [r7, #4]
20001bbc:	6039      	str	r1, [r7, #0]
    int total = 0;
20001bbe:	2300      	movs	r3, #0
20001bc0:	60fb      	str	r3, [r7, #12]

    for (;;) {
	total = (total * 10) + (*ch - '0');
20001bc2:	68fa      	ldr	r2, [r7, #12]
20001bc4:	4613      	mov	r3, r2
20001bc6:	009b      	lsls	r3, r3, #2
20001bc8:	4413      	add	r3, r2
20001bca:	005b      	lsls	r3, r3, #1
20001bcc:	461a      	mov	r2, r3
20001bce:	683b      	ldr	r3, [r7, #0]
20001bd0:	781b      	ldrb	r3, [r3, #0]
20001bd2:	3b30      	subs	r3, #48	@ 0x30
20001bd4:	4413      	add	r3, r2
20001bd6:	60fb      	str	r3, [r7, #12]
	while (console_read(ch,1) != 1) { POLL(); }
20001bd8:	e001      	b.n	20001bde <console_readnum+0x2a>
20001bda:	f7ff fe09 	bl	200017f0 <background>
20001bde:	2101      	movs	r1, #1
20001be0:	6838      	ldr	r0, [r7, #0]
20001be2:	f7ff fe75 	bl	200018d0 <console_read>
20001be6:	4603      	mov	r3, r0
20001be8:	2b01      	cmp	r3, #1
20001bea:	d1f6      	bne.n	20001bda <console_readnum+0x26>
	if (!((*ch >= '0') && (*ch <= '9'))) break;
20001bec:	683b      	ldr	r3, [r7, #0]
20001bee:	781b      	ldrb	r3, [r3, #0]
20001bf0:	2b2f      	cmp	r3, #47	@ 0x2f
20001bf2:	d904      	bls.n	20001bfe <console_readnum+0x4a>
20001bf4:	683b      	ldr	r3, [r7, #0]
20001bf6:	781b      	ldrb	r3, [r3, #0]
20001bf8:	2b39      	cmp	r3, #57	@ 0x39
20001bfa:	d800      	bhi.n	20001bfe <console_readnum+0x4a>
	total = (total * 10) + (*ch - '0');
20001bfc:	e7e1      	b.n	20001bc2 <console_readnum+0xe>
	}

    *num = total;
20001bfe:	687b      	ldr	r3, [r7, #4]
20001c00:	68fa      	ldr	r2, [r7, #12]
20001c02:	601a      	str	r2, [r3, #0]
}
20001c04:	bf00      	nop
20001c06:	3710      	adds	r7, #16
20001c08:	46bd      	mov	sp, r7
20001c0a:	bd80      	pop	{r7, pc}

20001c0c <console_readkey>:
    *  Return value:
    *  	   virtual key code
    ********************************************************************* */

int console_readkey(void)
{
20001c0c:	b580      	push	{r7, lr}
20001c0e:	b082      	sub	sp, #8
20001c10:	af00      	add	r7, sp, #0
    unsigned char ch;
    int num;

    GETCHAR(ch);
20001c12:	e001      	b.n	20001c18 <console_readkey+0xc>
20001c14:	f7ff fdec 	bl	200017f0 <background>
20001c18:	1dfb      	adds	r3, r7, #7
20001c1a:	2101      	movs	r1, #1
20001c1c:	4618      	mov	r0, r3
20001c1e:	f7ff fe57 	bl	200018d0 <console_read>
20001c22:	4603      	mov	r3, r0
20001c24:	2b01      	cmp	r3, #1
20001c26:	d1f5      	bne.n	20001c14 <console_readkey+0x8>

    switch (ch) {
20001c28:	79fb      	ldrb	r3, [r7, #7]
20001c2a:	2b1b      	cmp	r3, #27
20001c2c:	f040 80f6 	bne.w	20001e1c <console_readkey+0x210>
	case VKEY_ESC:
	    GETCHAR(ch);
20001c30:	e001      	b.n	20001c36 <console_readkey+0x2a>
20001c32:	f7ff fddd 	bl	200017f0 <background>
20001c36:	1dfb      	adds	r3, r7, #7
20001c38:	2101      	movs	r1, #1
20001c3a:	4618      	mov	r0, r3
20001c3c:	f7ff fe48 	bl	200018d0 <console_read>
20001c40:	4603      	mov	r3, r0
20001c42:	2b01      	cmp	r3, #1
20001c44:	d1f5      	bne.n	20001c32 <console_readkey+0x26>
	    switch (ch) {
20001c46:	79fb      	ldrb	r3, [r7, #7]
20001c48:	2b4f      	cmp	r3, #79	@ 0x4f
20001c4a:	d004      	beq.n	20001c56 <console_readkey+0x4a>
20001c4c:	2b5b      	cmp	r3, #91	@ 0x5b
20001c4e:	d029      	beq.n	20001ca4 <console_readkey+0x98>
20001c50:	e0e2      	b.n	20001e18 <console_readkey+0x20c>
		case 'O':
		    GETCHAR(ch);
20001c52:	f7ff fdcd 	bl	200017f0 <background>
20001c56:	1dfb      	adds	r3, r7, #7
20001c58:	2101      	movs	r1, #1
20001c5a:	4618      	mov	r0, r3
20001c5c:	f7ff fe38 	bl	200018d0 <console_read>
20001c60:	4603      	mov	r3, r0
20001c62:	2b01      	cmp	r3, #1
20001c64:	d1f5      	bne.n	20001c52 <console_readkey+0x46>
		    switch (ch) {
20001c66:	79fb      	ldrb	r3, [r7, #7]
20001c68:	3b50      	subs	r3, #80	@ 0x50
20001c6a:	2b03      	cmp	r3, #3
20001c6c:	d816      	bhi.n	20001c9c <console_readkey+0x90>
20001c6e:	a201      	add	r2, pc, #4	@ (adr r2, 20001c74 <console_readkey+0x68>)
20001c70:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
20001c74:	20001c85 	.word	0x20001c85
20001c78:	20001c8b 	.word	0x20001c8b
20001c7c:	20001c91 	.word	0x20001c91
20001c80:	20001c97 	.word	0x20001c97
			case 'P':
			    return VKEY_F1;
20001c84:	f44f 7388 	mov.w	r3, #272	@ 0x110
20001c88:	e0c9      	b.n	20001e1e <console_readkey+0x212>
			case 'Q':
			    return VKEY_F2;
20001c8a:	f240 1311 	movw	r3, #273	@ 0x111
20001c8e:	e0c6      	b.n	20001e1e <console_readkey+0x212>
			case 'R':
			    return VKEY_F3;
20001c90:	f44f 7389 	mov.w	r3, #274	@ 0x112
20001c94:	e0c3      	b.n	20001e1e <console_readkey+0x212>
			case 'S':
			    return VKEY_F4;
20001c96:	f240 1313 	movw	r3, #275	@ 0x113
20001c9a:	e0c0      	b.n	20001e1e <console_readkey+0x212>
			}
		    return (int)ch;
20001c9c:	79fb      	ldrb	r3, [r7, #7]
20001c9e:	e0be      	b.n	20001e1e <console_readkey+0x212>

		case '[':
		    GETCHAR(ch);
20001ca0:	f7ff fda6 	bl	200017f0 <background>
20001ca4:	1dfb      	adds	r3, r7, #7
20001ca6:	2101      	movs	r1, #1
20001ca8:	4618      	mov	r0, r3
20001caa:	f7ff fe11 	bl	200018d0 <console_read>
20001cae:	4603      	mov	r3, r0
20001cb0:	2b01      	cmp	r3, #1
20001cb2:	d1f5      	bne.n	20001ca0 <console_readkey+0x94>
		    if ((ch >= '0') && (ch <= '9')) {
20001cb4:	79fb      	ldrb	r3, [r7, #7]
20001cb6:	2b2f      	cmp	r3, #47	@ 0x2f
20001cb8:	f240 8082 	bls.w	20001dc0 <console_readkey+0x1b4>
20001cbc:	79fb      	ldrb	r3, [r7, #7]
20001cbe:	2b39      	cmp	r3, #57	@ 0x39
20001cc0:	d87e      	bhi.n	20001dc0 <console_readkey+0x1b4>
			console_readnum(&num,&ch);
20001cc2:	1dfa      	adds	r2, r7, #7
20001cc4:	463b      	mov	r3, r7
20001cc6:	4611      	mov	r1, r2
20001cc8:	4618      	mov	r0, r3
20001cca:	f7ff ff73 	bl	20001bb4 <console_readnum>
			if (ch == '~') {
20001cce:	79fb      	ldrb	r3, [r7, #7]
20001cd0:	2b7e      	cmp	r3, #126	@ 0x7e
20001cd2:	f040 80a1 	bne.w	20001e18 <console_readkey+0x20c>
			    switch (num) {
20001cd6:	683b      	ldr	r3, [r7, #0]
20001cd8:	3b02      	subs	r3, #2
20001cda:	2b16      	cmp	r3, #22
20001cdc:	d86e      	bhi.n	20001dbc <console_readkey+0x1b0>
20001cde:	a201      	add	r2, pc, #4	@ (adr r2, 20001ce4 <console_readkey+0xd8>)
20001ce0:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
20001ce4:	20001d41 	.word	0x20001d41
20001ce8:	20001d47 	.word	0x20001d47
20001cec:	20001dbd 	.word	0x20001dbd
20001cf0:	20001d4d 	.word	0x20001d4d
20001cf4:	20001d61 	.word	0x20001d61
20001cf8:	20001dbd 	.word	0x20001dbd
20001cfc:	20001dbd 	.word	0x20001dbd
20001d00:	20001dbd 	.word	0x20001dbd
20001d04:	20001dbd 	.word	0x20001dbd
20001d08:	20001d75 	.word	0x20001d75
20001d0c:	20001d7b 	.word	0x20001d7b
20001d10:	20001d81 	.word	0x20001d81
20001d14:	20001d87 	.word	0x20001d87
20001d18:	20001d8d 	.word	0x20001d8d
20001d1c:	20001dbd 	.word	0x20001dbd
20001d20:	20001d93 	.word	0x20001d93
20001d24:	20001d99 	.word	0x20001d99
20001d28:	20001d9f 	.word	0x20001d9f
20001d2c:	20001da5 	.word	0x20001da5
20001d30:	20001dab 	.word	0x20001dab
20001d34:	20001dbd 	.word	0x20001dbd
20001d38:	20001db1 	.word	0x20001db1
20001d3c:	20001db7 	.word	0x20001db7
				case 2:
				    return VKEY_HOME;
20001d40:	f240 1307 	movw	r3, #263	@ 0x107
20001d44:	e06b      	b.n	20001e1e <console_readkey+0x212>
				case 3:
				    return VKEY_PGUP;
20001d46:	f240 1305 	movw	r3, #261	@ 0x105
20001d4a:	e068      	b.n	20001e1e <console_readkey+0x212>
				case 5:
				    if (console_mode == XTERM) return VKEY_PGUP;
20001d4c:	4b36      	ldr	r3, [pc, #216]	@ (20001e28 <console_readkey+0x21c>)
20001d4e:	681b      	ldr	r3, [r3, #0]
20001d50:	2b00      	cmp	r3, #0
20001d52:	d102      	bne.n	20001d5a <console_readkey+0x14e>
20001d54:	f240 1305 	movw	r3, #261	@ 0x105
20001d58:	e061      	b.n	20001e1e <console_readkey+0x212>
				    return VKEY_END;
20001d5a:	f44f 7384 	mov.w	r3, #264	@ 0x108
20001d5e:	e05e      	b.n	20001e1e <console_readkey+0x212>
				case 6:
				    if (console_mode == XTERM) return VKEY_PGDN;
20001d60:	4b31      	ldr	r3, [pc, #196]	@ (20001e28 <console_readkey+0x21c>)
20001d62:	681b      	ldr	r3, [r3, #0]
20001d64:	2b00      	cmp	r3, #0
20001d66:	d102      	bne.n	20001d6e <console_readkey+0x162>
20001d68:	f44f 7383 	mov.w	r3, #262	@ 0x106
20001d6c:	e057      	b.n	20001e1e <console_readkey+0x212>
				    return VKEY_PGDN;
20001d6e:	f44f 7383 	mov.w	r3, #262	@ 0x106
20001d72:	e054      	b.n	20001e1e <console_readkey+0x212>
				case 11:
				    return VKEY_F1;
20001d74:	f44f 7388 	mov.w	r3, #272	@ 0x110
20001d78:	e051      	b.n	20001e1e <console_readkey+0x212>
				case 12:
				    return VKEY_F2;
20001d7a:	f240 1311 	movw	r3, #273	@ 0x111
20001d7e:	e04e      	b.n	20001e1e <console_readkey+0x212>
				case 13:
				    return VKEY_F3;
20001d80:	f44f 7389 	mov.w	r3, #274	@ 0x112
20001d84:	e04b      	b.n	20001e1e <console_readkey+0x212>
				case 14:
				    return VKEY_F4;
20001d86:	f240 1313 	movw	r3, #275	@ 0x113
20001d8a:	e048      	b.n	20001e1e <console_readkey+0x212>
				case 15:
				    return VKEY_F5;
20001d8c:	f44f 738a 	mov.w	r3, #276	@ 0x114
20001d90:	e045      	b.n	20001e1e <console_readkey+0x212>
				case 17:
				    return VKEY_F6;
20001d92:	f240 1315 	movw	r3, #277	@ 0x115
20001d96:	e042      	b.n	20001e1e <console_readkey+0x212>
				case 18:
				    return VKEY_F7;
20001d98:	f44f 738b 	mov.w	r3, #278	@ 0x116
20001d9c:	e03f      	b.n	20001e1e <console_readkey+0x212>
				case 19:
				    return VKEY_F8;
20001d9e:	f240 1317 	movw	r3, #279	@ 0x117
20001da2:	e03c      	b.n	20001e1e <console_readkey+0x212>
				case 20:
				    return VKEY_F9;
20001da4:	f44f 738c 	mov.w	r3, #280	@ 0x118
20001da8:	e039      	b.n	20001e1e <console_readkey+0x212>
				case 21:
				    return VKEY_F10;
20001daa:	f240 1319 	movw	r3, #281	@ 0x119
20001dae:	e036      	b.n	20001e1e <console_readkey+0x212>
				case 23:
				    return VKEY_F11;
20001db0:	f44f 738d 	mov.w	r3, #282	@ 0x11a
20001db4:	e033      	b.n	20001e1e <console_readkey+0x212>
				case 24:
				    return VKEY_F12;
20001db6:	f240 131b 	movw	r3, #283	@ 0x11b
20001dba:	e030      	b.n	20001e1e <console_readkey+0x212>
				}
			    return (int)ch;
20001dbc:	79fb      	ldrb	r3, [r7, #7]
20001dbe:	e02e      	b.n	20001e1e <console_readkey+0x212>
			    }
			}
		    else {
			switch (ch) {
20001dc0:	79fb      	ldrb	r3, [r7, #7]
20001dc2:	3b41      	subs	r3, #65	@ 0x41
20001dc4:	2b07      	cmp	r3, #7
20001dc6:	d825      	bhi.n	20001e14 <console_readkey+0x208>
20001dc8:	a201      	add	r2, pc, #4	@ (adr r2, 20001dd0 <console_readkey+0x1c4>)
20001dca:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
20001dce:	bf00      	nop
20001dd0:	20001df1 	.word	0x20001df1
20001dd4:	20001df7 	.word	0x20001df7
20001dd8:	20001dfd 	.word	0x20001dfd
20001ddc:	20001e03 	.word	0x20001e03
20001de0:	20001e15 	.word	0x20001e15
20001de4:	20001e09 	.word	0x20001e09
20001de8:	20001e15 	.word	0x20001e15
20001dec:	20001e0f 	.word	0x20001e0f
			    case 'A':
				return VKEY_UP;
20001df0:	f240 1301 	movw	r3, #257	@ 0x101
20001df4:	e013      	b.n	20001e1e <console_readkey+0x212>
			    case 'B':
				return VKEY_DOWN;
20001df6:	f44f 7381 	mov.w	r3, #258	@ 0x102
20001dfa:	e010      	b.n	20001e1e <console_readkey+0x212>
			    case 'C':
				return VKEY_RIGHT;
20001dfc:	f44f 7382 	mov.w	r3, #260	@ 0x104
20001e00:	e00d      	b.n	20001e1e <console_readkey+0x212>
			    case 'D':
				return VKEY_LEFT;
20001e02:	f240 1303 	movw	r3, #259	@ 0x103
20001e06:	e00a      	b.n	20001e1e <console_readkey+0x212>
			    case 'F':
				return VKEY_HOME;
20001e08:	f240 1307 	movw	r3, #263	@ 0x107
20001e0c:	e007      	b.n	20001e1e <console_readkey+0x212>
			    case 'H':
				return VKEY_END;
20001e0e:	f44f 7384 	mov.w	r3, #264	@ 0x108
20001e12:	e004      	b.n	20001e1e <console_readkey+0x212>
			    default:
				return (int) ch;
20001e14:	79fb      	ldrb	r3, [r7, #7]
20001e16:	e002      	b.n	20001e1e <console_readkey+0x212>
			    }
			}
		default:
		    return (int)ch;
20001e18:	79fb      	ldrb	r3, [r7, #7]
20001e1a:	e000      	b.n	20001e1e <console_readkey+0x212>
	
		}
	default:
	    return (int) ch;
20001e1c:	79fb      	ldrb	r3, [r7, #7]
	}
}
20001e1e:	4618      	mov	r0, r3
20001e20:	3708      	adds	r7, #8
20001e22:	46bd      	mov	sp, r7
20001e24:	bd80      	pop	{r7, pc}
20001e26:	bf00      	nop
20001e28:	20005fa4 	.word	0x20005fa4

20001e2c <console_backspace>:
    *  Return value:
    *  	   nothing
    ********************************************************************* */

static void console_backspace(int n)
{
20001e2c:	b580      	push	{r7, lr}
20001e2e:	b084      	sub	sp, #16
20001e30:	af00      	add	r7, sp, #0
20001e32:	6078      	str	r0, [r7, #4]
    int t;

    for (t = 0; t < n; t++) console_write((unsigned char *)"\b",1);
20001e34:	2300      	movs	r3, #0
20001e36:	60fb      	str	r3, [r7, #12]
20001e38:	e006      	b.n	20001e48 <console_backspace+0x1c>
20001e3a:	2101      	movs	r1, #1
20001e3c:	4807      	ldr	r0, [pc, #28]	@ (20001e5c <console_backspace+0x30>)
20001e3e:	f7ff fd63 	bl	20001908 <console_write>
20001e42:	68fb      	ldr	r3, [r7, #12]
20001e44:	3301      	adds	r3, #1
20001e46:	60fb      	str	r3, [r7, #12]
20001e48:	68fa      	ldr	r2, [r7, #12]
20001e4a:	687b      	ldr	r3, [r7, #4]
20001e4c:	429a      	cmp	r2, r3
20001e4e:	dbf4      	blt.n	20001e3a <console_backspace+0xe>
}
20001e50:	bf00      	nop
20001e52:	bf00      	nop
20001e54:	3710      	adds	r7, #16
20001e56:	46bd      	mov	sp, r7
20001e58:	bd80      	pop	{r7, pc}
20001e5a:	bf00      	nop
20001e5c:	20005444 	.word	0x20005444

20001e60 <console_whiteout>:

static void console_whiteout(int n)
{
20001e60:	b580      	push	{r7, lr}
20001e62:	b084      	sub	sp, #16
20001e64:	af00      	add	r7, sp, #0
20001e66:	6078      	str	r0, [r7, #4]
    int t;

    for (t = 0; t < n; t++) console_write((unsigned char *)" ",1);
20001e68:	2300      	movs	r3, #0
20001e6a:	60fb      	str	r3, [r7, #12]
20001e6c:	e006      	b.n	20001e7c <console_whiteout+0x1c>
20001e6e:	2101      	movs	r1, #1
20001e70:	480e      	ldr	r0, [pc, #56]	@ (20001eac <console_whiteout+0x4c>)
20001e72:	f7ff fd49 	bl	20001908 <console_write>
20001e76:	68fb      	ldr	r3, [r7, #12]
20001e78:	3301      	adds	r3, #1
20001e7a:	60fb      	str	r3, [r7, #12]
20001e7c:	68fa      	ldr	r2, [r7, #12]
20001e7e:	687b      	ldr	r3, [r7, #4]
20001e80:	429a      	cmp	r2, r3
20001e82:	dbf4      	blt.n	20001e6e <console_whiteout+0xe>
    for (t = 0; t < n; t++) console_write((unsigned char *)"\b",1);
20001e84:	2300      	movs	r3, #0
20001e86:	60fb      	str	r3, [r7, #12]
20001e88:	e006      	b.n	20001e98 <console_whiteout+0x38>
20001e8a:	2101      	movs	r1, #1
20001e8c:	4808      	ldr	r0, [pc, #32]	@ (20001eb0 <console_whiteout+0x50>)
20001e8e:	f7ff fd3b 	bl	20001908 <console_write>
20001e92:	68fb      	ldr	r3, [r7, #12]
20001e94:	3301      	adds	r3, #1
20001e96:	60fb      	str	r3, [r7, #12]
20001e98:	68fa      	ldr	r2, [r7, #12]
20001e9a:	687b      	ldr	r3, [r7, #4]
20001e9c:	429a      	cmp	r2, r3
20001e9e:	dbf4      	blt.n	20001e8a <console_whiteout+0x2a>
}
20001ea0:	bf00      	nop
20001ea2:	bf00      	nop
20001ea4:	3710      	adds	r7, #16
20001ea6:	46bd      	mov	sp, r7
20001ea8:	bd80      	pop	{r7, pc}
20001eaa:	bf00      	nop
20001eac:	20005448 	.word	0x20005448
20001eb0:	20005444 	.word	0x20005444

20001eb4 <console_eraseeol>:


static void console_eraseeol(void)
{
20001eb4:	b580      	push	{r7, lr}
20001eb6:	af00      	add	r7, sp, #0
    console_write((unsigned char *)"\033[K",3);
20001eb8:	2103      	movs	r1, #3
20001eba:	4802      	ldr	r0, [pc, #8]	@ (20001ec4 <console_eraseeol+0x10>)
20001ebc:	f7ff fd24 	bl	20001908 <console_write>
}
20001ec0:	bf00      	nop
20001ec2:	bd80      	pop	{r7, pc}
20001ec4:	2000544c 	.word	0x2000544c

20001ec8 <console_crlf>:

static void console_crlf(void)
{
20001ec8:	b580      	push	{r7, lr}
20001eca:	af00      	add	r7, sp, #0
    console_write((unsigned char *)"\r\n",2);
20001ecc:	2102      	movs	r1, #2
20001ece:	4802      	ldr	r0, [pc, #8]	@ (20001ed8 <console_crlf+0x10>)
20001ed0:	f7ff fd1a 	bl	20001908 <console_write>
}
20001ed4:	bf00      	nop
20001ed6:	bd80      	pop	{r7, pc}
20001ed8:	2000541c 	.word	0x2000541c

20001edc <console_readline_default>:
    *  	   number of characters read (terminating newline is not
    *  	   placed in the buffer)
    ********************************************************************* */

int console_readline_default(char *prompt,char *str,int maxlen)
{
20001edc:	b590      	push	{r4, r7, lr}
20001ede:	b091      	sub	sp, #68	@ 0x44
20001ee0:	af00      	add	r7, sp, #0
20001ee2:	60f8      	str	r0, [r7, #12]
20001ee4:	60b9      	str	r1, [r7, #8]
20001ee6:	607a      	str	r2, [r7, #4]
    int reading = 1;
20001ee8:	2301      	movs	r3, #1
20001eea:	63fb      	str	r3, [r7, #60]	@ 0x3c
    int ch;
    int idx = 0;
20001eec:	2300      	movs	r3, #0
20001eee:	63bb      	str	r3, [r7, #56]	@ 0x38
    int len = 0;
20001ef0:	2300      	movs	r3, #0
20001ef2:	637b      	str	r3, [r7, #52]	@ 0x34
    int t;
    int klen;
    int recall;
    int nosave = 0;
20001ef4:	2300      	movs	r3, #0
20001ef6:	62bb      	str	r3, [r7, #40]	@ 0x28
    char *x;
    char env[10];

    console_inreadline++;
20001ef8:	4b5d      	ldr	r3, [pc, #372]	@ (20002070 <console_readline_default+0x194>)
20001efa:	681b      	ldr	r3, [r3, #0]
20001efc:	3301      	adds	r3, #1
20001efe:	4a5c      	ldr	r2, [pc, #368]	@ (20002070 <console_readline_default+0x194>)
20001f00:	6013      	str	r3, [r2, #0]
    recall = console_nextsave;
20001f02:	4b5c      	ldr	r3, [pc, #368]	@ (20002074 <console_readline_default+0x198>)
20001f04:	681b      	ldr	r3, [r3, #0]
20001f06:	62fb      	str	r3, [r7, #44]	@ 0x2c

    if (console_savedlines[console_nextsave]) {
20001f08:	4b5a      	ldr	r3, [pc, #360]	@ (20002074 <console_readline_default+0x198>)
20001f0a:	681b      	ldr	r3, [r3, #0]
20001f0c:	4a5a      	ldr	r2, [pc, #360]	@ (20002078 <console_readline_default+0x19c>)
20001f0e:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
20001f12:	2b00      	cmp	r3, #0
20001f14:	d00e      	beq.n	20001f34 <console_readline_default+0x58>
	KFREE(console_savedlines[console_nextsave]);
20001f16:	4b57      	ldr	r3, [pc, #348]	@ (20002074 <console_readline_default+0x198>)
20001f18:	681b      	ldr	r3, [r3, #0]
20001f1a:	4a57      	ldr	r2, [pc, #348]	@ (20002078 <console_readline_default+0x19c>)
20001f1c:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
20001f20:	4619      	mov	r1, r3
20001f22:	4856      	ldr	r0, [pc, #344]	@ (2000207c <console_readline_default+0x1a0>)
20001f24:	f7ff f81c 	bl	20000f60 <kfree>
	console_savedlines[console_nextsave] = NULL;
20001f28:	4b52      	ldr	r3, [pc, #328]	@ (20002074 <console_readline_default+0x198>)
20001f2a:	681b      	ldr	r3, [r3, #0]
20001f2c:	4a52      	ldr	r2, [pc, #328]	@ (20002078 <console_readline_default+0x19c>)
20001f2e:	2100      	movs	r1, #0
20001f30:	f842 1023 	str.w	r1, [r2, r3, lsl #2]
	}
    console_savedlines[console_nextsave] = strdup("");
20001f34:	4b4f      	ldr	r3, [pc, #316]	@ (20002074 <console_readline_default+0x198>)
20001f36:	681c      	ldr	r4, [r3, #0]
20001f38:	4851      	ldr	r0, [pc, #324]	@ (20002080 <console_readline_default+0x1a4>)
20001f3a:	f7ff fb11 	bl	20001560 <lib_strdup>
20001f3e:	4603      	mov	r3, r0
20001f40:	4a4d      	ldr	r2, [pc, #308]	@ (20002078 <console_readline_default+0x19c>)
20001f42:	f842 3024 	str.w	r3, [r2, r4, lsl #2]

    idx = len = strlen(str);
20001f46:	68b8      	ldr	r0, [r7, #8]
20001f48:	f7ff f9ad 	bl	200012a6 <lib_strlen>
20001f4c:	6378      	str	r0, [r7, #52]	@ 0x34
20001f4e:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
20001f50:	63bb      	str	r3, [r7, #56]	@ 0x38

    if (prompt && *prompt) console_write((unsigned char *)prompt,strlen(prompt));
20001f52:	68fb      	ldr	r3, [r7, #12]
20001f54:	2b00      	cmp	r3, #0
20001f56:	d00b      	beq.n	20001f70 <console_readline_default+0x94>
20001f58:	68fb      	ldr	r3, [r7, #12]
20001f5a:	781b      	ldrb	r3, [r3, #0]
20001f5c:	2b00      	cmp	r3, #0
20001f5e:	d007      	beq.n	20001f70 <console_readline_default+0x94>
20001f60:	68f8      	ldr	r0, [r7, #12]
20001f62:	f7ff f9a0 	bl	200012a6 <lib_strlen>
20001f66:	4603      	mov	r3, r0
20001f68:	4619      	mov	r1, r3
20001f6a:	68f8      	ldr	r0, [r7, #12]
20001f6c:	f7ff fccc 	bl	20001908 <console_write>
    console_write((unsigned char *)str,idx);
20001f70:	6bb9      	ldr	r1, [r7, #56]	@ 0x38
20001f72:	68b8      	ldr	r0, [r7, #8]
20001f74:	f7ff fcc8 	bl	20001908 <console_write>

    POLL();
20001f78:	f7ff fc3a 	bl	200017f0 <background>
    while (reading) {
20001f7c:	f000 bc39 	b.w	200027f2 <console_readline_default+0x916>
	/*
	 * If someone used console_log (above) or hit Control-C (below),
	 * redisplay the prompt and the string we've got so far.
	 */

	if (console_redisplay) {
20001f80:	4b40      	ldr	r3, [pc, #256]	@ (20002084 <console_readline_default+0x1a8>)
20001f82:	681b      	ldr	r3, [r3, #0]
20001f84:	2b00      	cmp	r3, #0
20001f86:	d017      	beq.n	20001fb8 <console_readline_default+0xdc>
	    if (prompt && *prompt) console_write((unsigned char *)prompt,strlen(prompt));
20001f88:	68fb      	ldr	r3, [r7, #12]
20001f8a:	2b00      	cmp	r3, #0
20001f8c:	d00b      	beq.n	20001fa6 <console_readline_default+0xca>
20001f8e:	68fb      	ldr	r3, [r7, #12]
20001f90:	781b      	ldrb	r3, [r3, #0]
20001f92:	2b00      	cmp	r3, #0
20001f94:	d007      	beq.n	20001fa6 <console_readline_default+0xca>
20001f96:	68f8      	ldr	r0, [r7, #12]
20001f98:	f7ff f985 	bl	200012a6 <lib_strlen>
20001f9c:	4603      	mov	r3, r0
20001f9e:	4619      	mov	r1, r3
20001fa0:	68f8      	ldr	r0, [r7, #12]
20001fa2:	f7ff fcb1 	bl	20001908 <console_write>
	    console_write((unsigned char *)str,idx);
20001fa6:	6bb9      	ldr	r1, [r7, #56]	@ 0x38
20001fa8:	68b8      	ldr	r0, [r7, #8]
20001faa:	f7ff fcad 	bl	20001908 <console_write>
	    console_redisplay = 0;
20001fae:	4b35      	ldr	r3, [pc, #212]	@ (20002084 <console_readline_default+0x1a8>)
20001fb0:	2200      	movs	r2, #0
20001fb2:	601a      	str	r2, [r3, #0]
	    continue;
20001fb4:	f000 bc1d 	b.w	200027f2 <console_readline_default+0x916>

	/*
	 * if nobody's typed anything, keep polling
	 */

	if (console_status() == 0) {
20001fb8:	f7ff fce6 	bl	20001988 <console_status>
20001fbc:	4603      	mov	r3, r0
20001fbe:	2b00      	cmp	r3, #0
20001fc0:	d103      	bne.n	20001fca <console_readline_default+0xee>
	    POLL();
20001fc2:	f7ff fc15 	bl	200017f0 <background>
	    continue;
20001fc6:	f000 bc14 	b.w	200027f2 <console_readline_default+0x916>

	/*
	 * Get the char from the keyboard
	 */

	ch = console_readkey();
20001fca:	f7ff fe1f 	bl	20001c0c <console_readkey>
20001fce:	6278      	str	r0, [r7, #36]	@ 0x24
	if (ch < 0) break;
20001fd0:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
20001fd2:	2b00      	cmp	r3, #0
20001fd4:	f2c0 841a 	blt.w	2000280c <console_readline_default+0x930>
	if (ch == 0) continue;
20001fd8:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
20001fda:	2b00      	cmp	r3, #0
20001fdc:	f000 83ee 	beq.w	200027bc <console_readline_default+0x8e0>

	/*
	 * And dispatch it.  Lots of yucky character manipulation follows
	 */

	switch (ch) {
20001fe0:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
20001fe2:	2b7f      	cmp	r3, #127	@ 0x7f
20001fe4:	f300 8156 	bgt.w	20002294 <console_readline_default+0x3b8>
20001fe8:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
20001fea:	2b00      	cmp	r3, #0
20001fec:	dc4c      	bgt.n	20002088 <console_readline_default+0x1ac>
20001fee:	e3a7      	b.n	20002740 <console_readline_default+0x864>
20001ff0:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
20001ff2:	f2a3 1301 	subw	r3, r3, #257	@ 0x101
20001ff6:	2b1a      	cmp	r3, #26
20001ff8:	f200 83a2 	bhi.w	20002740 <console_readline_default+0x864>
20001ffc:	a201      	add	r2, pc, #4	@ (adr r2, 20002004 <console_readline_default+0x128>)
20001ffe:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
20002002:	bf00      	nop
20002004:	20002589 	.word	0x20002589
20002008:	20002613 	.word	0x20002613
2000200c:	200023a7 	.word	0x200023a7
20002010:	200023bd 	.word	0x200023bd
20002014:	20002741 	.word	0x20002741
20002018:	20002741 	.word	0x20002741
2000201c:	20002741 	.word	0x20002741
20002020:	20002741 	.word	0x20002741
20002024:	20002741 	.word	0x20002741
20002028:	20002741 	.word	0x20002741
2000202c:	20002741 	.word	0x20002741
20002030:	20002741 	.word	0x20002741
20002034:	20002741 	.word	0x20002741
20002038:	20002741 	.word	0x20002741
2000203c:	20002741 	.word	0x20002741
20002040:	20002675 	.word	0x20002675
20002044:	20002675 	.word	0x20002675
20002048:	20002675 	.word	0x20002675
2000204c:	20002675 	.word	0x20002675
20002050:	20002675 	.word	0x20002675
20002054:	20002675 	.word	0x20002675
20002058:	20002675 	.word	0x20002675
2000205c:	20002675 	.word	0x20002675
20002060:	20002675 	.word	0x20002675
20002064:	20002675 	.word	0x20002675
20002068:	20002675 	.word	0x20002675
2000206c:	20002675 	.word	0x20002675
20002070:	20005fac 	.word	0x20005fac
20002074:	20005f20 	.word	0x20005f20
20002078:	20005f24 	.word	0x20005f24
2000207c:	20005e94 	.word	0x20005e94
20002080:	20005450 	.word	0x20005450
20002084:	20005fb0 	.word	0x20005fb0
20002088:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
2000208a:	3b01      	subs	r3, #1
2000208c:	2b7e      	cmp	r3, #126	@ 0x7e
2000208e:	f200 8357 	bhi.w	20002740 <console_readline_default+0x864>
20002092:	a201      	add	r2, pc, #4	@ (adr r2, 20002098 <console_readline_default+0x1bc>)
20002094:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
20002098:	200023dd 	.word	0x200023dd
2000209c:	200023a7 	.word	0x200023a7
200020a0:	200022ab 	.word	0x200022ab
200020a4:	2000233f 	.word	0x2000233f
200020a8:	200023e9 	.word	0x200023e9
200020ac:	200023bd 	.word	0x200023bd
200020b0:	20002741 	.word	0x20002741
200020b4:	200022c3 	.word	0x200022c3
200020b8:	20002741 	.word	0x20002741
200020bc:	2000257f 	.word	0x2000257f
200020c0:	2000240b 	.word	0x2000240b
200020c4:	20002741 	.word	0x20002741
200020c8:	2000257f 	.word	0x2000257f
200020cc:	20002613 	.word	0x20002613
200020d0:	20002741 	.word	0x20002741
200020d4:	20002589 	.word	0x20002589
200020d8:	20002741 	.word	0x20002741
200020dc:	2000252d 	.word	0x2000252d
200020e0:	20002741 	.word	0x20002741
200020e4:	20002741 	.word	0x20002741
200020e8:	20002561 	.word	0x20002561
200020ec:	20002741 	.word	0x20002741
200020f0:	20002741 	.word	0x20002741
200020f4:	20002741 	.word	0x20002741
200020f8:	2000245b 	.word	0x2000245b
200020fc:	20002741 	.word	0x20002741
20002100:	20002741 	.word	0x20002741
20002104:	20002741 	.word	0x20002741
20002108:	20002741 	.word	0x20002741
2000210c:	20002741 	.word	0x20002741
20002110:	20002741 	.word	0x20002741
20002114:	20002741 	.word	0x20002741
20002118:	20002741 	.word	0x20002741
2000211c:	20002741 	.word	0x20002741
20002120:	20002741 	.word	0x20002741
20002124:	20002741 	.word	0x20002741
20002128:	20002741 	.word	0x20002741
2000212c:	20002741 	.word	0x20002741
20002130:	20002741 	.word	0x20002741
20002134:	20002741 	.word	0x20002741
20002138:	20002741 	.word	0x20002741
2000213c:	20002741 	.word	0x20002741
20002140:	20002741 	.word	0x20002741
20002144:	20002741 	.word	0x20002741
20002148:	20002741 	.word	0x20002741
2000214c:	20002741 	.word	0x20002741
20002150:	20002741 	.word	0x20002741
20002154:	20002741 	.word	0x20002741
20002158:	20002741 	.word	0x20002741
2000215c:	20002741 	.word	0x20002741
20002160:	20002741 	.word	0x20002741
20002164:	20002741 	.word	0x20002741
20002168:	20002741 	.word	0x20002741
2000216c:	20002741 	.word	0x20002741
20002170:	20002741 	.word	0x20002741
20002174:	20002741 	.word	0x20002741
20002178:	20002741 	.word	0x20002741
2000217c:	20002741 	.word	0x20002741
20002180:	20002741 	.word	0x20002741
20002184:	20002741 	.word	0x20002741
20002188:	20002741 	.word	0x20002741
2000218c:	20002741 	.word	0x20002741
20002190:	20002741 	.word	0x20002741
20002194:	20002741 	.word	0x20002741
20002198:	20002741 	.word	0x20002741
2000219c:	20002741 	.word	0x20002741
200021a0:	20002741 	.word	0x20002741
200021a4:	20002741 	.word	0x20002741
200021a8:	20002741 	.word	0x20002741
200021ac:	20002741 	.word	0x20002741
200021b0:	20002741 	.word	0x20002741
200021b4:	20002741 	.word	0x20002741
200021b8:	20002741 	.word	0x20002741
200021bc:	20002741 	.word	0x20002741
200021c0:	20002741 	.word	0x20002741
200021c4:	20002741 	.word	0x20002741
200021c8:	20002741 	.word	0x20002741
200021cc:	20002741 	.word	0x20002741
200021d0:	20002741 	.word	0x20002741
200021d4:	20002741 	.word	0x20002741
200021d8:	20002741 	.word	0x20002741
200021dc:	20002741 	.word	0x20002741
200021e0:	20002741 	.word	0x20002741
200021e4:	20002741 	.word	0x20002741
200021e8:	20002741 	.word	0x20002741
200021ec:	20002741 	.word	0x20002741
200021f0:	20002741 	.word	0x20002741
200021f4:	20002741 	.word	0x20002741
200021f8:	20002741 	.word	0x20002741
200021fc:	20002741 	.word	0x20002741
20002200:	20002741 	.word	0x20002741
20002204:	20002741 	.word	0x20002741
20002208:	20002741 	.word	0x20002741
2000220c:	20002741 	.word	0x20002741
20002210:	20002741 	.word	0x20002741
20002214:	20002741 	.word	0x20002741
20002218:	20002741 	.word	0x20002741
2000221c:	20002741 	.word	0x20002741
20002220:	20002741 	.word	0x20002741
20002224:	20002741 	.word	0x20002741
20002228:	20002741 	.word	0x20002741
2000222c:	20002741 	.word	0x20002741
20002230:	20002741 	.word	0x20002741
20002234:	20002741 	.word	0x20002741
20002238:	20002741 	.word	0x20002741
2000223c:	20002741 	.word	0x20002741
20002240:	20002741 	.word	0x20002741
20002244:	20002741 	.word	0x20002741
20002248:	20002741 	.word	0x20002741
2000224c:	20002741 	.word	0x20002741
20002250:	20002741 	.word	0x20002741
20002254:	20002741 	.word	0x20002741
20002258:	20002741 	.word	0x20002741
2000225c:	20002741 	.word	0x20002741
20002260:	20002741 	.word	0x20002741
20002264:	20002741 	.word	0x20002741
20002268:	20002741 	.word	0x20002741
2000226c:	20002741 	.word	0x20002741
20002270:	20002741 	.word	0x20002741
20002274:	20002741 	.word	0x20002741
20002278:	20002741 	.word	0x20002741
2000227c:	20002741 	.word	0x20002741
20002280:	20002741 	.word	0x20002741
20002284:	20002741 	.word	0x20002741
20002288:	20002741 	.word	0x20002741
2000228c:	20002741 	.word	0x20002741
20002290:	200022c3 	.word	0x200022c3
20002294:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
20002296:	f5b3 7f8e 	cmp.w	r3, #284	@ 0x11c
2000229a:	f280 8251 	bge.w	20002740 <console_readline_default+0x864>
2000229e:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
200022a0:	f5b3 7f80 	cmp.w	r3, #256	@ 0x100
200022a4:	f73f aea4 	bgt.w	20001ff0 <console_readline_default+0x114>
200022a8:	e24a      	b.n	20002740 <console_readline_default+0x864>

		case CTRL('C'):			/* Ctrl-C - cancel line */
		console_write((unsigned char *)"^C\r\n",4);
200022aa:	2104      	movs	r1, #4
200022ac:	489a      	ldr	r0, [pc, #616]	@ (20002518 <console_readline_default+0x63c>)
200022ae:	f7ff fb2b 	bl	20001908 <console_write>
		console_redisplay = 1;
200022b2:	4b9a      	ldr	r3, [pc, #616]	@ (2000251c <console_readline_default+0x640>)
200022b4:	2201      	movs	r2, #1
200022b6:	601a      	str	r2, [r3, #0]
		nosave = 1;
200022b8:	2301      	movs	r3, #1
200022ba:	62bb      	str	r3, [r7, #40]	@ 0x28
		idx = 0;
200022bc:	2300      	movs	r3, #0
200022be:	63bb      	str	r3, [r7, #56]	@ 0x38
		break;
200022c0:	e297      	b.n	200027f2 <console_readline_default+0x916>

	    case 0x7f:				/* Backspace, Delete */
	    case CTRL('H'):
		if (idx > 0) {
200022c2:	6bbb      	ldr	r3, [r7, #56]	@ 0x38
200022c4:	2b00      	cmp	r3, #0
200022c6:	f340 827b 	ble.w	200027c0 <console_readline_default+0x8e4>
		    nosave = 0;
200022ca:	2300      	movs	r3, #0
200022cc:	62bb      	str	r3, [r7, #40]	@ 0x28
		    len--;
200022ce:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
200022d0:	3b01      	subs	r3, #1
200022d2:	637b      	str	r3, [r7, #52]	@ 0x34
		    idx--;
200022d4:	6bbb      	ldr	r3, [r7, #56]	@ 0x38
200022d6:	3b01      	subs	r3, #1
200022d8:	63bb      	str	r3, [r7, #56]	@ 0x38
		    console_write((unsigned char *)"\b",1);
200022da:	2101      	movs	r1, #1
200022dc:	4890      	ldr	r0, [pc, #576]	@ (20002520 <console_readline_default+0x644>)
200022de:	f7ff fb13 	bl	20001908 <console_write>
		    if (len != idx) {
200022e2:	6b7a      	ldr	r2, [r7, #52]	@ 0x34
200022e4:	6bbb      	ldr	r3, [r7, #56]	@ 0x38
200022e6:	429a      	cmp	r2, r3
200022e8:	d025      	beq.n	20002336 <console_readline_default+0x45a>
			for (t = idx; t < len; t++) str[t] = str[t+1];
200022ea:	6bbb      	ldr	r3, [r7, #56]	@ 0x38
200022ec:	633b      	str	r3, [r7, #48]	@ 0x30
200022ee:	e00b      	b.n	20002308 <console_readline_default+0x42c>
200022f0:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
200022f2:	3301      	adds	r3, #1
200022f4:	68ba      	ldr	r2, [r7, #8]
200022f6:	441a      	add	r2, r3
200022f8:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
200022fa:	68b9      	ldr	r1, [r7, #8]
200022fc:	440b      	add	r3, r1
200022fe:	7812      	ldrb	r2, [r2, #0]
20002300:	701a      	strb	r2, [r3, #0]
20002302:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
20002304:	3301      	adds	r3, #1
20002306:	633b      	str	r3, [r7, #48]	@ 0x30
20002308:	6b3a      	ldr	r2, [r7, #48]	@ 0x30
2000230a:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
2000230c:	429a      	cmp	r2, r3
2000230e:	dbef      	blt.n	200022f0 <console_readline_default+0x414>
			console_write((unsigned char *)&str[idx],len-idx);
20002310:	6bbb      	ldr	r3, [r7, #56]	@ 0x38
20002312:	68ba      	ldr	r2, [r7, #8]
20002314:	18d0      	adds	r0, r2, r3
20002316:	6b7a      	ldr	r2, [r7, #52]	@ 0x34
20002318:	6bbb      	ldr	r3, [r7, #56]	@ 0x38
2000231a:	1ad3      	subs	r3, r2, r3
2000231c:	4619      	mov	r1, r3
2000231e:	f7ff faf3 	bl	20001908 <console_write>
			console_whiteout(1);
20002322:	2001      	movs	r0, #1
20002324:	f7ff fd9c 	bl	20001e60 <console_whiteout>
			console_backspace(len-idx);
20002328:	6b7a      	ldr	r2, [r7, #52]	@ 0x34
2000232a:	6bbb      	ldr	r3, [r7, #56]	@ 0x38
2000232c:	1ad3      	subs	r3, r2, r3
2000232e:	4618      	mov	r0, r3
20002330:	f7ff fd7c 	bl	20001e2c <console_backspace>
			}
		    else {
			console_whiteout(1);
			}
		    }
		break;
20002334:	e244      	b.n	200027c0 <console_readline_default+0x8e4>
			console_whiteout(1);
20002336:	2001      	movs	r0, #1
20002338:	f7ff fd92 	bl	20001e60 <console_whiteout>
		break;
2000233c:	e240      	b.n	200027c0 <console_readline_default+0x8e4>

	    case CTRL('D'):			/* Ctrl-D */
		if ((idx >= 0) && (len != idx)) {
2000233e:	6bbb      	ldr	r3, [r7, #56]	@ 0x38
20002340:	2b00      	cmp	r3, #0
20002342:	f2c0 823f 	blt.w	200027c4 <console_readline_default+0x8e8>
20002346:	6b7a      	ldr	r2, [r7, #52]	@ 0x34
20002348:	6bbb      	ldr	r3, [r7, #56]	@ 0x38
2000234a:	429a      	cmp	r2, r3
2000234c:	f000 823a 	beq.w	200027c4 <console_readline_default+0x8e8>
		    nosave = 0;
20002350:	2300      	movs	r3, #0
20002352:	62bb      	str	r3, [r7, #40]	@ 0x28
		    len--;
20002354:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
20002356:	3b01      	subs	r3, #1
20002358:	637b      	str	r3, [r7, #52]	@ 0x34
		    for (t = idx; t < len; t++) str[t] = str[t+1];
2000235a:	6bbb      	ldr	r3, [r7, #56]	@ 0x38
2000235c:	633b      	str	r3, [r7, #48]	@ 0x30
2000235e:	e00b      	b.n	20002378 <console_readline_default+0x49c>
20002360:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
20002362:	3301      	adds	r3, #1
20002364:	68ba      	ldr	r2, [r7, #8]
20002366:	441a      	add	r2, r3
20002368:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
2000236a:	68b9      	ldr	r1, [r7, #8]
2000236c:	440b      	add	r3, r1
2000236e:	7812      	ldrb	r2, [r2, #0]
20002370:	701a      	strb	r2, [r3, #0]
20002372:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
20002374:	3301      	adds	r3, #1
20002376:	633b      	str	r3, [r7, #48]	@ 0x30
20002378:	6b3a      	ldr	r2, [r7, #48]	@ 0x30
2000237a:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
2000237c:	429a      	cmp	r2, r3
2000237e:	dbef      	blt.n	20002360 <console_readline_default+0x484>
		    console_write((unsigned char *)&str[idx],len-idx);
20002380:	6bbb      	ldr	r3, [r7, #56]	@ 0x38
20002382:	68ba      	ldr	r2, [r7, #8]
20002384:	18d0      	adds	r0, r2, r3
20002386:	6b7a      	ldr	r2, [r7, #52]	@ 0x34
20002388:	6bbb      	ldr	r3, [r7, #56]	@ 0x38
2000238a:	1ad3      	subs	r3, r2, r3
2000238c:	4619      	mov	r1, r3
2000238e:	f7ff fabb 	bl	20001908 <console_write>
		    console_whiteout(1);
20002392:	2001      	movs	r0, #1
20002394:	f7ff fd64 	bl	20001e60 <console_whiteout>
		    console_backspace(len-idx);
20002398:	6b7a      	ldr	r2, [r7, #52]	@ 0x34
2000239a:	6bbb      	ldr	r3, [r7, #56]	@ 0x38
2000239c:	1ad3      	subs	r3, r2, r3
2000239e:	4618      	mov	r0, r3
200023a0:	f7ff fd44 	bl	20001e2c <console_backspace>
		    }
		break;
200023a4:	e20e      	b.n	200027c4 <console_readline_default+0x8e8>

	    case CTRL('B'):			/* cursor left */
	    case VKEY_LEFT:
		if (idx > 0) {
200023a6:	6bbb      	ldr	r3, [r7, #56]	@ 0x38
200023a8:	2b00      	cmp	r3, #0
200023aa:	f340 820d 	ble.w	200027c8 <console_readline_default+0x8ec>
		    idx--;
200023ae:	6bbb      	ldr	r3, [r7, #56]	@ 0x38
200023b0:	3b01      	subs	r3, #1
200023b2:	63bb      	str	r3, [r7, #56]	@ 0x38
		    console_backspace(1);
200023b4:	2001      	movs	r0, #1
200023b6:	f7ff fd39 	bl	20001e2c <console_backspace>
		    }
		break;
200023ba:	e205      	b.n	200027c8 <console_readline_default+0x8ec>

	    case CTRL('F'):			/* cursor right */
	    case VKEY_RIGHT:
		if (idx < len) {
200023bc:	6bba      	ldr	r2, [r7, #56]	@ 0x38
200023be:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
200023c0:	429a      	cmp	r2, r3
200023c2:	f280 8203 	bge.w	200027cc <console_readline_default+0x8f0>
		    console_write((unsigned char *)&str[idx],1);
200023c6:	6bbb      	ldr	r3, [r7, #56]	@ 0x38
200023c8:	68ba      	ldr	r2, [r7, #8]
200023ca:	4413      	add	r3, r2
200023cc:	2101      	movs	r1, #1
200023ce:	4618      	mov	r0, r3
200023d0:	f7ff fa9a 	bl	20001908 <console_write>
		    idx++;
200023d4:	6bbb      	ldr	r3, [r7, #56]	@ 0x38
200023d6:	3301      	adds	r3, #1
200023d8:	63bb      	str	r3, [r7, #56]	@ 0x38
		    }
		break;
200023da:	e1f7      	b.n	200027cc <console_readline_default+0x8f0>

	    case CTRL('A'):			/* cursor to BOL */
		console_backspace(idx);
200023dc:	6bb8      	ldr	r0, [r7, #56]	@ 0x38
200023de:	f7ff fd25 	bl	20001e2c <console_backspace>
		idx = 0;
200023e2:	2300      	movs	r3, #0
200023e4:	63bb      	str	r3, [r7, #56]	@ 0x38
		break;
200023e6:	e204      	b.n	200027f2 <console_readline_default+0x916>

	    case CTRL('E'):			/* cursor to EOL */
		if (len-idx > 0) console_write((unsigned char *)&str[idx],len-idx);
200023e8:	6b7a      	ldr	r2, [r7, #52]	@ 0x34
200023ea:	6bbb      	ldr	r3, [r7, #56]	@ 0x38
200023ec:	1ad3      	subs	r3, r2, r3
200023ee:	2b00      	cmp	r3, #0
200023f0:	dd08      	ble.n	20002404 <console_readline_default+0x528>
200023f2:	6bbb      	ldr	r3, [r7, #56]	@ 0x38
200023f4:	68ba      	ldr	r2, [r7, #8]
200023f6:	18d0      	adds	r0, r2, r3
200023f8:	6b7a      	ldr	r2, [r7, #52]	@ 0x34
200023fa:	6bbb      	ldr	r3, [r7, #56]	@ 0x38
200023fc:	1ad3      	subs	r3, r2, r3
200023fe:	4619      	mov	r1, r3
20002400:	f7ff fa82 	bl	20001908 <console_write>
		idx = len;
20002404:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
20002406:	63bb      	str	r3, [r7, #56]	@ 0x38
		break;
20002408:	e1f3      	b.n	200027f2 <console_readline_default+0x916>

	    case CTRL('K'):			/* Kill to EOL */
		if (idx != len) {
2000240a:	6bba      	ldr	r2, [r7, #56]	@ 0x38
2000240c:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
2000240e:	429a      	cmp	r2, r3
20002410:	f000 81de 	beq.w	200027d0 <console_readline_default+0x8f4>
		    str[len] = '\0';
20002414:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
20002416:	68ba      	ldr	r2, [r7, #8]
20002418:	4413      	add	r3, r2
2000241a:	2200      	movs	r2, #0
2000241c:	701a      	strb	r2, [r3, #0]
		    if (console_killbuffer) KFREE(console_killbuffer);
2000241e:	4b41      	ldr	r3, [pc, #260]	@ (20002524 <console_readline_default+0x648>)
20002420:	681b      	ldr	r3, [r3, #0]
20002422:	2b00      	cmp	r3, #0
20002424:	d005      	beq.n	20002432 <console_readline_default+0x556>
20002426:	4b3f      	ldr	r3, [pc, #252]	@ (20002524 <console_readline_default+0x648>)
20002428:	681b      	ldr	r3, [r3, #0]
2000242a:	4619      	mov	r1, r3
2000242c:	483e      	ldr	r0, [pc, #248]	@ (20002528 <console_readline_default+0x64c>)
2000242e:	f7fe fd97 	bl	20000f60 <kfree>
		    console_killbuffer = strdup(&str[idx]);
20002432:	6bbb      	ldr	r3, [r7, #56]	@ 0x38
20002434:	68ba      	ldr	r2, [r7, #8]
20002436:	4413      	add	r3, r2
20002438:	4618      	mov	r0, r3
2000243a:	f7ff f891 	bl	20001560 <lib_strdup>
2000243e:	4603      	mov	r3, r0
20002440:	4a38      	ldr	r2, [pc, #224]	@ (20002524 <console_readline_default+0x648>)
20002442:	6013      	str	r3, [r2, #0]
		    console_whiteout(len-idx);
20002444:	6b7a      	ldr	r2, [r7, #52]	@ 0x34
20002446:	6bbb      	ldr	r3, [r7, #56]	@ 0x38
20002448:	1ad3      	subs	r3, r2, r3
2000244a:	4618      	mov	r0, r3
2000244c:	f7ff fd08 	bl	20001e60 <console_whiteout>
		    len = idx;
20002450:	6bbb      	ldr	r3, [r7, #56]	@ 0x38
20002452:	637b      	str	r3, [r7, #52]	@ 0x34
		    nosave = 0;
20002454:	2300      	movs	r3, #0
20002456:	62bb      	str	r3, [r7, #40]	@ 0x28
		    }
		break;
20002458:	e1ba      	b.n	200027d0 <console_readline_default+0x8f4>

	    case CTRL('Y'):			/* Yank killed data */
		if (console_killbuffer == NULL) break;
2000245a:	4b32      	ldr	r3, [pc, #200]	@ (20002524 <console_readline_default+0x648>)
2000245c:	681b      	ldr	r3, [r3, #0]
2000245e:	2b00      	cmp	r3, #0
20002460:	f000 81b8 	beq.w	200027d4 <console_readline_default+0x8f8>
		klen = strlen(console_killbuffer);
20002464:	4b2f      	ldr	r3, [pc, #188]	@ (20002524 <console_readline_default+0x648>)
20002466:	681b      	ldr	r3, [r3, #0]
20002468:	4618      	mov	r0, r3
2000246a:	f7fe ff1c 	bl	200012a6 <lib_strlen>
2000246e:	61f8      	str	r0, [r7, #28]
		if (klen == 0) break;
20002470:	69fb      	ldr	r3, [r7, #28]
20002472:	2b00      	cmp	r3, #0
20002474:	f000 81b0 	beq.w	200027d8 <console_readline_default+0x8fc>
		if (len + klen > maxlen) break;
20002478:	6b7a      	ldr	r2, [r7, #52]	@ 0x34
2000247a:	69fb      	ldr	r3, [r7, #28]
2000247c:	4413      	add	r3, r2
2000247e:	687a      	ldr	r2, [r7, #4]
20002480:	429a      	cmp	r2, r3
20002482:	f2c0 81ab 	blt.w	200027dc <console_readline_default+0x900>
		nosave = 0;
20002486:	2300      	movs	r3, #0
20002488:	62bb      	str	r3, [r7, #40]	@ 0x28
		for (t = len + klen; t > idx; t--) {
2000248a:	6b7a      	ldr	r2, [r7, #52]	@ 0x34
2000248c:	69fb      	ldr	r3, [r7, #28]
2000248e:	4413      	add	r3, r2
20002490:	633b      	str	r3, [r7, #48]	@ 0x30
20002492:	e00e      	b.n	200024b2 <console_readline_default+0x5d6>
		    str[t-1] = str[t-klen-1];
20002494:	6b3a      	ldr	r2, [r7, #48]	@ 0x30
20002496:	69fb      	ldr	r3, [r7, #28]
20002498:	1ad3      	subs	r3, r2, r3
2000249a:	3b01      	subs	r3, #1
2000249c:	68ba      	ldr	r2, [r7, #8]
2000249e:	441a      	add	r2, r3
200024a0:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
200024a2:	3b01      	subs	r3, #1
200024a4:	68b9      	ldr	r1, [r7, #8]
200024a6:	440b      	add	r3, r1
200024a8:	7812      	ldrb	r2, [r2, #0]
200024aa:	701a      	strb	r2, [r3, #0]
		for (t = len + klen; t > idx; t--) {
200024ac:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
200024ae:	3b01      	subs	r3, #1
200024b0:	633b      	str	r3, [r7, #48]	@ 0x30
200024b2:	6b3a      	ldr	r2, [r7, #48]	@ 0x30
200024b4:	6bbb      	ldr	r3, [r7, #56]	@ 0x38
200024b6:	429a      	cmp	r2, r3
200024b8:	dcec      	bgt.n	20002494 <console_readline_default+0x5b8>
		    }
		for (t = 0; t < klen; t++) str[t+idx] = console_killbuffer[t];
200024ba:	2300      	movs	r3, #0
200024bc:	633b      	str	r3, [r7, #48]	@ 0x30
200024be:	e00e      	b.n	200024de <console_readline_default+0x602>
200024c0:	4b18      	ldr	r3, [pc, #96]	@ (20002524 <console_readline_default+0x648>)
200024c2:	681a      	ldr	r2, [r3, #0]
200024c4:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
200024c6:	441a      	add	r2, r3
200024c8:	6b39      	ldr	r1, [r7, #48]	@ 0x30
200024ca:	6bbb      	ldr	r3, [r7, #56]	@ 0x38
200024cc:	440b      	add	r3, r1
200024ce:	4619      	mov	r1, r3
200024d0:	68bb      	ldr	r3, [r7, #8]
200024d2:	440b      	add	r3, r1
200024d4:	7812      	ldrb	r2, [r2, #0]
200024d6:	701a      	strb	r2, [r3, #0]
200024d8:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
200024da:	3301      	adds	r3, #1
200024dc:	633b      	str	r3, [r7, #48]	@ 0x30
200024de:	6b3a      	ldr	r2, [r7, #48]	@ 0x30
200024e0:	69fb      	ldr	r3, [r7, #28]
200024e2:	429a      	cmp	r2, r3
200024e4:	dbec      	blt.n	200024c0 <console_readline_default+0x5e4>
		len += klen;
200024e6:	6b7a      	ldr	r2, [r7, #52]	@ 0x34
200024e8:	69fb      	ldr	r3, [r7, #28]
200024ea:	4413      	add	r3, r2
200024ec:	637b      	str	r3, [r7, #52]	@ 0x34
		console_write((unsigned char *)&str[idx],len-idx);
200024ee:	6bbb      	ldr	r3, [r7, #56]	@ 0x38
200024f0:	68ba      	ldr	r2, [r7, #8]
200024f2:	18d0      	adds	r0, r2, r3
200024f4:	6b7a      	ldr	r2, [r7, #52]	@ 0x34
200024f6:	6bbb      	ldr	r3, [r7, #56]	@ 0x38
200024f8:	1ad3      	subs	r3, r2, r3
200024fa:	4619      	mov	r1, r3
200024fc:	f7ff fa04 	bl	20001908 <console_write>
		idx += klen;
20002500:	6bba      	ldr	r2, [r7, #56]	@ 0x38
20002502:	69fb      	ldr	r3, [r7, #28]
20002504:	4413      	add	r3, r2
20002506:	63bb      	str	r3, [r7, #56]	@ 0x38
		console_backspace(len-idx-1);
20002508:	6b7a      	ldr	r2, [r7, #52]	@ 0x34
2000250a:	6bbb      	ldr	r3, [r7, #56]	@ 0x38
2000250c:	1ad3      	subs	r3, r2, r3
2000250e:	3b01      	subs	r3, #1
20002510:	4618      	mov	r0, r3
20002512:	f7ff fc8b 	bl	20001e2c <console_backspace>
		break;
20002516:	e16c      	b.n	200027f2 <console_readline_default+0x916>
20002518:	20005420 	.word	0x20005420
2000251c:	20005fb0 	.word	0x20005fb0
20002520:	20005444 	.word	0x20005444
20002524:	20005f9c 	.word	0x20005f9c
20002528:	20005e94 	.word	0x20005e94

	    case CTRL('R'):			/* Redisplay line */
		str[len] = 0;
2000252c:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
2000252e:	68ba      	ldr	r2, [r7, #8]
20002530:	4413      	add	r3, r2
20002532:	2200      	movs	r2, #0
20002534:	701a      	strb	r2, [r3, #0]
		console_crlf();
20002536:	f7ff fcc7 	bl	20001ec8 <console_crlf>
		console_write((unsigned char *)prompt,strlen(prompt));
2000253a:	68f8      	ldr	r0, [r7, #12]
2000253c:	f7fe feb3 	bl	200012a6 <lib_strlen>
20002540:	4603      	mov	r3, r0
20002542:	4619      	mov	r1, r3
20002544:	68f8      	ldr	r0, [r7, #12]
20002546:	f7ff f9df 	bl	20001908 <console_write>
		console_write((unsigned char *)str,len);
2000254a:	6b79      	ldr	r1, [r7, #52]	@ 0x34
2000254c:	68b8      	ldr	r0, [r7, #8]
2000254e:	f7ff f9db 	bl	20001908 <console_write>
		console_backspace(len-idx);
20002552:	6b7a      	ldr	r2, [r7, #52]	@ 0x34
20002554:	6bbb      	ldr	r3, [r7, #56]	@ 0x38
20002556:	1ad3      	subs	r3, r2, r3
20002558:	4618      	mov	r0, r3
2000255a:	f7ff fc67 	bl	20001e2c <console_backspace>
		break;
2000255e:	e148      	b.n	200027f2 <console_readline_default+0x916>

	    case CTRL('U'):			/* Cancel line */
		console_backspace(idx);
20002560:	6bb8      	ldr	r0, [r7, #56]	@ 0x38
20002562:	f7ff fc63 	bl	20001e2c <console_backspace>
		console_eraseeol();
20002566:	f7ff fca5 	bl	20001eb4 <console_eraseeol>
		if (len > 0) nosave = 1;
2000256a:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
2000256c:	2b00      	cmp	r3, #0
2000256e:	dd01      	ble.n	20002574 <console_readline_default+0x698>
20002570:	2301      	movs	r3, #1
20002572:	62bb      	str	r3, [r7, #40]	@ 0x28
		idx = 0;
20002574:	2300      	movs	r3, #0
20002576:	63bb      	str	r3, [r7, #56]	@ 0x38
		len = 0;
20002578:	2300      	movs	r3, #0
2000257a:	637b      	str	r3, [r7, #52]	@ 0x34
		break;
2000257c:	e139      	b.n	200027f2 <console_readline_default+0x916>

	    case CTRL('M'):			/* terminate */
	    case CTRL('J'):
		console_crlf();
2000257e:	f7ff fca3 	bl	20001ec8 <console_crlf>
		reading = 0;
20002582:	2300      	movs	r3, #0
20002584:	63fb      	str	r3, [r7, #60]	@ 0x3c
		break;
20002586:	e134      	b.n	200027f2 <console_readline_default+0x916>

	    case CTRL('P'):
	    case VKEY_UP:			/* recall previous line */
		t = recall;
20002588:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
2000258a:	633b      	str	r3, [r7, #48]	@ 0x30
		t--;
2000258c:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
2000258e:	3b01      	subs	r3, #1
20002590:	633b      	str	r3, [r7, #48]	@ 0x30
		if (t < 0) t = MAXSAVELINES-1;
20002592:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
20002594:	2b00      	cmp	r3, #0
20002596:	da01      	bge.n	2000259c <console_readline_default+0x6c0>
20002598:	231d      	movs	r3, #29
2000259a:	633b      	str	r3, [r7, #48]	@ 0x30
		if (console_savedlines[t] == NULL) break;
2000259c:	4a97      	ldr	r2, [pc, #604]	@ (200027fc <console_readline_default+0x920>)
2000259e:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
200025a0:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
200025a4:	2b00      	cmp	r3, #0
200025a6:	f000 811b 	beq.w	200027e0 <console_readline_default+0x904>
		recall = t;
200025aa:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
200025ac:	62fb      	str	r3, [r7, #44]	@ 0x2c
		console_backspace(idx);
200025ae:	6bb8      	ldr	r0, [r7, #56]	@ 0x38
200025b0:	f7ff fc3c 	bl	20001e2c <console_backspace>
		strcpy(str,console_savedlines[recall]);
200025b4:	4a91      	ldr	r2, [pc, #580]	@ (200027fc <console_readline_default+0x920>)
200025b6:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
200025b8:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
200025bc:	4619      	mov	r1, r3
200025be:	68b8      	ldr	r0, [r7, #8]
200025c0:	f7fe fe29 	bl	20001216 <lib_strcpy>
		len = idx = strlen(console_savedlines[recall]);
200025c4:	4a8d      	ldr	r2, [pc, #564]	@ (200027fc <console_readline_default+0x920>)
200025c6:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
200025c8:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
200025cc:	4618      	mov	r0, r3
200025ce:	f7fe fe6a 	bl	200012a6 <lib_strlen>
200025d2:	63b8      	str	r0, [r7, #56]	@ 0x38
200025d4:	6bbb      	ldr	r3, [r7, #56]	@ 0x38
200025d6:	637b      	str	r3, [r7, #52]	@ 0x34
		console_eraseeol();
200025d8:	f7ff fc6c 	bl	20001eb4 <console_eraseeol>
		console_write((unsigned char *)str,len);
200025dc:	6b79      	ldr	r1, [r7, #52]	@ 0x34
200025de:	68b8      	ldr	r0, [r7, #8]
200025e0:	f7ff f992 	bl	20001908 <console_write>
		nosave = (t == ((console_nextsave - 1) % MAXSAVELINES));
200025e4:	4b86      	ldr	r3, [pc, #536]	@ (20002800 <console_readline_default+0x924>)
200025e6:	681b      	ldr	r3, [r3, #0]
200025e8:	1e5a      	subs	r2, r3, #1
200025ea:	4b86      	ldr	r3, [pc, #536]	@ (20002804 <console_readline_default+0x928>)
200025ec:	fb83 1302 	smull	r1, r3, r3, r2
200025f0:	4413      	add	r3, r2
200025f2:	1119      	asrs	r1, r3, #4
200025f4:	17d3      	asrs	r3, r2, #31
200025f6:	1ac9      	subs	r1, r1, r3
200025f8:	460b      	mov	r3, r1
200025fa:	011b      	lsls	r3, r3, #4
200025fc:	1a5b      	subs	r3, r3, r1
200025fe:	005b      	lsls	r3, r3, #1
20002600:	1ad1      	subs	r1, r2, r3
20002602:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
20002604:	428b      	cmp	r3, r1
20002606:	bf0c      	ite	eq
20002608:	2301      	moveq	r3, #1
2000260a:	2300      	movne	r3, #0
2000260c:	b2db      	uxtb	r3, r3
2000260e:	62bb      	str	r3, [r7, #40]	@ 0x28
		break;
20002610:	e0ef      	b.n	200027f2 <console_readline_default+0x916>
		
	    case CTRL('N'):
	    case VKEY_DOWN:			/* Recall next line */
		t = recall; 
20002612:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
20002614:	633b      	str	r3, [r7, #48]	@ 0x30
		t++;
20002616:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
20002618:	3301      	adds	r3, #1
2000261a:	633b      	str	r3, [r7, #48]	@ 0x30
		if (t == MAXSAVELINES) t = 0;
2000261c:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
2000261e:	2b1e      	cmp	r3, #30
20002620:	d101      	bne.n	20002626 <console_readline_default+0x74a>
20002622:	2300      	movs	r3, #0
20002624:	633b      	str	r3, [r7, #48]	@ 0x30
		if (console_savedlines[t] == NULL) break;
20002626:	4a75      	ldr	r2, [pc, #468]	@ (200027fc <console_readline_default+0x920>)
20002628:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
2000262a:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
2000262e:	2b00      	cmp	r3, #0
20002630:	f000 80d8 	beq.w	200027e4 <console_readline_default+0x908>
		recall = t;
20002634:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
20002636:	62fb      	str	r3, [r7, #44]	@ 0x2c
		console_backspace(idx);
20002638:	6bb8      	ldr	r0, [r7, #56]	@ 0x38
2000263a:	f7ff fbf7 	bl	20001e2c <console_backspace>
		strcpy(str,console_savedlines[recall]);
2000263e:	4a6f      	ldr	r2, [pc, #444]	@ (200027fc <console_readline_default+0x920>)
20002640:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
20002642:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
20002646:	4619      	mov	r1, r3
20002648:	68b8      	ldr	r0, [r7, #8]
2000264a:	f7fe fde4 	bl	20001216 <lib_strcpy>
		len = idx = strlen(console_savedlines[recall]);
2000264e:	4a6b      	ldr	r2, [pc, #428]	@ (200027fc <console_readline_default+0x920>)
20002650:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
20002652:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
20002656:	4618      	mov	r0, r3
20002658:	f7fe fe25 	bl	200012a6 <lib_strlen>
2000265c:	63b8      	str	r0, [r7, #56]	@ 0x38
2000265e:	6bbb      	ldr	r3, [r7, #56]	@ 0x38
20002660:	637b      	str	r3, [r7, #52]	@ 0x34
		console_eraseeol();
20002662:	f7ff fc27 	bl	20001eb4 <console_eraseeol>
		console_write((unsigned char *)str,len);
20002666:	6b79      	ldr	r1, [r7, #52]	@ 0x34
20002668:	68b8      	ldr	r0, [r7, #8]
2000266a:	f7ff f94d 	bl	20001908 <console_write>
		nosave = 1;
2000266e:	2301      	movs	r3, #1
20002670:	62bb      	str	r3, [r7, #40]	@ 0x28
		break;
20002672:	e0be      	b.n	200027f2 <console_readline_default+0x916>
	    case VKEY_F8:
	    case VKEY_F9:
	    case VKEY_F10:
	    case VKEY_F11:
	    case VKEY_F12:
		sprintf(env,"F%d",ch-VKEY_F1+1);
20002674:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
20002676:	f2a3 120f 	subw	r2, r3, #271	@ 0x10f
2000267a:	f107 0310 	add.w	r3, r7, #16
2000267e:	4962      	ldr	r1, [pc, #392]	@ (20002808 <console_readline_default+0x92c>)
20002680:	4618      	mov	r0, r3
20002682:	f7fe fabb 	bl	20000bfc <xsprintf>
		x = env_getenv(env);
20002686:	f107 0310 	add.w	r3, r7, #16
2000268a:	4618      	mov	r0, r3
2000268c:	f001 f85e 	bl	2000374c <env_getenv>
20002690:	6238      	str	r0, [r7, #32]
		if (x) {
20002692:	6a3b      	ldr	r3, [r7, #32]
20002694:	2b00      	cmp	r3, #0
20002696:	d019      	beq.n	200026cc <console_readline_default+0x7f0>
		    console_backspace(idx);
20002698:	6bb8      	ldr	r0, [r7, #56]	@ 0x38
2000269a:	f7ff fbc7 	bl	20001e2c <console_backspace>
		    strcpy(str,x);
2000269e:	6a39      	ldr	r1, [r7, #32]
200026a0:	68b8      	ldr	r0, [r7, #8]
200026a2:	f7fe fdb8 	bl	20001216 <lib_strcpy>
		    idx = len = strlen(str);
200026a6:	68b8      	ldr	r0, [r7, #8]
200026a8:	f7fe fdfd 	bl	200012a6 <lib_strlen>
200026ac:	6378      	str	r0, [r7, #52]	@ 0x34
200026ae:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
200026b0:	63bb      	str	r3, [r7, #56]	@ 0x38
		    console_eraseeol();
200026b2:	f7ff fbff 	bl	20001eb4 <console_eraseeol>
		    console_write((unsigned char *)str,len);
200026b6:	6b79      	ldr	r1, [r7, #52]	@ 0x34
200026b8:	68b8      	ldr	r0, [r7, #8]
200026ba:	f7ff f925 	bl	20001908 <console_write>
		    console_crlf();
200026be:	f7ff fc03 	bl	20001ec8 <console_crlf>
		    reading = 0;
200026c2:	2300      	movs	r3, #0
200026c4:	63fb      	str	r3, [r7, #60]	@ 0x3c
		    nosave = 1;
200026c6:	2301      	movs	r3, #1
200026c8:	62bb      	str	r3, [r7, #40]	@ 0x28
		    console_write((unsigned char *)str,len);
		    console_crlf();
		    reading = 0;
		    nosave = 1;
		    }
		break;
200026ca:	e08d      	b.n	200027e8 <console_readline_default+0x90c>
		else if (ch == VKEY_F12) {
200026cc:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
200026ce:	f240 121b 	movw	r2, #283	@ 0x11b
200026d2:	4293      	cmp	r3, r2
200026d4:	f040 8088 	bne.w	200027e8 <console_readline_default+0x90c>
		    t = recall;
200026d8:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
200026da:	633b      	str	r3, [r7, #48]	@ 0x30
		    t--;
200026dc:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
200026de:	3b01      	subs	r3, #1
200026e0:	633b      	str	r3, [r7, #48]	@ 0x30
		    if (t < 0) t = MAXSAVELINES-1;
200026e2:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
200026e4:	2b00      	cmp	r3, #0
200026e6:	da01      	bge.n	200026ec <console_readline_default+0x810>
200026e8:	231d      	movs	r3, #29
200026ea:	633b      	str	r3, [r7, #48]	@ 0x30
		    if (console_savedlines[t] == NULL) break;
200026ec:	4a43      	ldr	r2, [pc, #268]	@ (200027fc <console_readline_default+0x920>)
200026ee:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
200026f0:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
200026f4:	2b00      	cmp	r3, #0
200026f6:	d079      	beq.n	200027ec <console_readline_default+0x910>
		    recall = t;
200026f8:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
200026fa:	62fb      	str	r3, [r7, #44]	@ 0x2c
		    console_backspace(idx);
200026fc:	6bb8      	ldr	r0, [r7, #56]	@ 0x38
200026fe:	f7ff fb95 	bl	20001e2c <console_backspace>
		    strcpy(str,console_savedlines[recall]);
20002702:	4a3e      	ldr	r2, [pc, #248]	@ (200027fc <console_readline_default+0x920>)
20002704:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
20002706:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
2000270a:	4619      	mov	r1, r3
2000270c:	68b8      	ldr	r0, [r7, #8]
2000270e:	f7fe fd82 	bl	20001216 <lib_strcpy>
		    len = idx = strlen(console_savedlines[recall]);
20002712:	4a3a      	ldr	r2, [pc, #232]	@ (200027fc <console_readline_default+0x920>)
20002714:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
20002716:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
2000271a:	4618      	mov	r0, r3
2000271c:	f7fe fdc3 	bl	200012a6 <lib_strlen>
20002720:	63b8      	str	r0, [r7, #56]	@ 0x38
20002722:	6bbb      	ldr	r3, [r7, #56]	@ 0x38
20002724:	637b      	str	r3, [r7, #52]	@ 0x34
		    console_eraseeol();
20002726:	f7ff fbc5 	bl	20001eb4 <console_eraseeol>
		    console_write((unsigned char *)str,len);
2000272a:	6b79      	ldr	r1, [r7, #52]	@ 0x34
2000272c:	68b8      	ldr	r0, [r7, #8]
2000272e:	f7ff f8eb 	bl	20001908 <console_write>
		    console_crlf();
20002732:	f7ff fbc9 	bl	20001ec8 <console_crlf>
		    reading = 0;
20002736:	2300      	movs	r3, #0
20002738:	63fb      	str	r3, [r7, #60]	@ 0x3c
		    nosave = 1;
2000273a:	2301      	movs	r3, #1
2000273c:	62bb      	str	r3, [r7, #40]	@ 0x28
		break;
2000273e:	e053      	b.n	200027e8 <console_readline_default+0x90c>

	    default:				/* insert character */
		if (ch >= ' ') {
20002740:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
20002742:	2b1f      	cmp	r3, #31
20002744:	dd54      	ble.n	200027f0 <console_readline_default+0x914>
		    if (idx < (maxlen-1)) {
20002746:	687b      	ldr	r3, [r7, #4]
20002748:	3b01      	subs	r3, #1
2000274a:	6bba      	ldr	r2, [r7, #56]	@ 0x38
2000274c:	429a      	cmp	r2, r3
2000274e:	da4f      	bge.n	200027f0 <console_readline_default+0x914>
			nosave = 0;
20002750:	2300      	movs	r3, #0
20002752:	62bb      	str	r3, [r7, #40]	@ 0x28
			for (t = len; t > idx; t--) {
20002754:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
20002756:	633b      	str	r3, [r7, #48]	@ 0x30
20002758:	e00b      	b.n	20002772 <console_readline_default+0x896>
			    str[t] = str[t-1];
2000275a:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
2000275c:	3b01      	subs	r3, #1
2000275e:	68ba      	ldr	r2, [r7, #8]
20002760:	441a      	add	r2, r3
20002762:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
20002764:	68b9      	ldr	r1, [r7, #8]
20002766:	440b      	add	r3, r1
20002768:	7812      	ldrb	r2, [r2, #0]
2000276a:	701a      	strb	r2, [r3, #0]
			for (t = len; t > idx; t--) {
2000276c:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
2000276e:	3b01      	subs	r3, #1
20002770:	633b      	str	r3, [r7, #48]	@ 0x30
20002772:	6b3a      	ldr	r2, [r7, #48]	@ 0x30
20002774:	6bbb      	ldr	r3, [r7, #56]	@ 0x38
20002776:	429a      	cmp	r2, r3
20002778:	dcef      	bgt.n	2000275a <console_readline_default+0x87e>
			    }
			str[idx] = ch;
2000277a:	6bbb      	ldr	r3, [r7, #56]	@ 0x38
2000277c:	68ba      	ldr	r2, [r7, #8]
2000277e:	4413      	add	r3, r2
20002780:	6a7a      	ldr	r2, [r7, #36]	@ 0x24
20002782:	b2d2      	uxtb	r2, r2
20002784:	701a      	strb	r2, [r3, #0]
			len++;
20002786:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
20002788:	3301      	adds	r3, #1
2000278a:	637b      	str	r3, [r7, #52]	@ 0x34
			if (len != idx) {
2000278c:	6b7a      	ldr	r2, [r7, #52]	@ 0x34
2000278e:	6bbb      	ldr	r3, [r7, #56]	@ 0x38
20002790:	429a      	cmp	r2, r3
20002792:	d00f      	beq.n	200027b4 <console_readline_default+0x8d8>
			    console_write((unsigned char *)&str[idx],len-idx);
20002794:	6bbb      	ldr	r3, [r7, #56]	@ 0x38
20002796:	68ba      	ldr	r2, [r7, #8]
20002798:	18d0      	adds	r0, r2, r3
2000279a:	6b7a      	ldr	r2, [r7, #52]	@ 0x34
2000279c:	6bbb      	ldr	r3, [r7, #56]	@ 0x38
2000279e:	1ad3      	subs	r3, r2, r3
200027a0:	4619      	mov	r1, r3
200027a2:	f7ff f8b1 	bl	20001908 <console_write>
			    console_backspace(len-idx-1);
200027a6:	6b7a      	ldr	r2, [r7, #52]	@ 0x34
200027a8:	6bbb      	ldr	r3, [r7, #56]	@ 0x38
200027aa:	1ad3      	subs	r3, r2, r3
200027ac:	3b01      	subs	r3, #1
200027ae:	4618      	mov	r0, r3
200027b0:	f7ff fb3c 	bl	20001e2c <console_backspace>
			    }
			idx++;
200027b4:	6bbb      	ldr	r3, [r7, #56]	@ 0x38
200027b6:	3301      	adds	r3, #1
200027b8:	63bb      	str	r3, [r7, #56]	@ 0x38
			}
		    }
		break;
200027ba:	e019      	b.n	200027f0 <console_readline_default+0x914>
	if (ch == 0) continue;
200027bc:	bf00      	nop
200027be:	e018      	b.n	200027f2 <console_readline_default+0x916>
		break;
200027c0:	bf00      	nop
200027c2:	e016      	b.n	200027f2 <console_readline_default+0x916>
		break;
200027c4:	bf00      	nop
200027c6:	e014      	b.n	200027f2 <console_readline_default+0x916>
		break;
200027c8:	bf00      	nop
200027ca:	e012      	b.n	200027f2 <console_readline_default+0x916>
		break;
200027cc:	bf00      	nop
200027ce:	e010      	b.n	200027f2 <console_readline_default+0x916>
		break;
200027d0:	bf00      	nop
200027d2:	e00e      	b.n	200027f2 <console_readline_default+0x916>
		if (console_killbuffer == NULL) break;
200027d4:	bf00      	nop
200027d6:	e00c      	b.n	200027f2 <console_readline_default+0x916>
		if (klen == 0) break;
200027d8:	bf00      	nop
200027da:	e00a      	b.n	200027f2 <console_readline_default+0x916>
		if (len + klen > maxlen) break;
200027dc:	bf00      	nop
200027de:	e008      	b.n	200027f2 <console_readline_default+0x916>
		if (console_savedlines[t] == NULL) break;
200027e0:	bf00      	nop
200027e2:	e006      	b.n	200027f2 <console_readline_default+0x916>
		if (console_savedlines[t] == NULL) break;
200027e4:	bf00      	nop
200027e6:	e004      	b.n	200027f2 <console_readline_default+0x916>
		break;
200027e8:	bf00      	nop
200027ea:	e002      	b.n	200027f2 <console_readline_default+0x916>
		    if (console_savedlines[t] == NULL) break;
200027ec:	bf00      	nop
200027ee:	e000      	b.n	200027f2 <console_readline_default+0x916>
		break;
200027f0:	bf00      	nop
    while (reading) {
200027f2:	6bfb      	ldr	r3, [r7, #60]	@ 0x3c
200027f4:	2b00      	cmp	r3, #0
200027f6:	f47f abc3 	bne.w	20001f80 <console_readline_default+0xa4>
200027fa:	e008      	b.n	2000280e <console_readline_default+0x932>
200027fc:	20005f24 	.word	0x20005f24
20002800:	20005f20 	.word	0x20005f20
20002804:	88888889 	.word	0x88888889
20002808:	20005454 	.word	0x20005454
	if (ch < 0) break;
2000280c:	bf00      	nop
	    }
	}
    POLL();
2000280e:	f7fe ffef 	bl	200017f0 <background>

    console_inreadline--;
20002812:	4b1d      	ldr	r3, [pc, #116]	@ (20002888 <console_readline_default+0x9ac>)
20002814:	681b      	ldr	r3, [r3, #0]
20002816:	3b01      	subs	r3, #1
20002818:	4a1b      	ldr	r2, [pc, #108]	@ (20002888 <console_readline_default+0x9ac>)
2000281a:	6013      	str	r3, [r2, #0]

    str[len] = 0;
2000281c:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
2000281e:	68ba      	ldr	r2, [r7, #8]
20002820:	4413      	add	r3, r2
20002822:	2200      	movs	r2, #0
20002824:	701a      	strb	r2, [r3, #0]

    if ((len != 0) && !nosave) {
20002826:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
20002828:	2b00      	cmp	r3, #0
2000282a:	d027      	beq.n	2000287c <console_readline_default+0x9a0>
2000282c:	6abb      	ldr	r3, [r7, #40]	@ 0x28
2000282e:	2b00      	cmp	r3, #0
20002830:	d124      	bne.n	2000287c <console_readline_default+0x9a0>
	if (console_savedlines[console_nextsave]) {
20002832:	4b16      	ldr	r3, [pc, #88]	@ (2000288c <console_readline_default+0x9b0>)
20002834:	681b      	ldr	r3, [r3, #0]
20002836:	4a16      	ldr	r2, [pc, #88]	@ (20002890 <console_readline_default+0x9b4>)
20002838:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
2000283c:	2b00      	cmp	r3, #0
2000283e:	d008      	beq.n	20002852 <console_readline_default+0x976>
	    KFREE(console_savedlines[console_nextsave]);
20002840:	4b12      	ldr	r3, [pc, #72]	@ (2000288c <console_readline_default+0x9b0>)
20002842:	681b      	ldr	r3, [r3, #0]
20002844:	4a12      	ldr	r2, [pc, #72]	@ (20002890 <console_readline_default+0x9b4>)
20002846:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
2000284a:	4619      	mov	r1, r3
2000284c:	4811      	ldr	r0, [pc, #68]	@ (20002894 <console_readline_default+0x9b8>)
2000284e:	f7fe fb87 	bl	20000f60 <kfree>
	    }
	console_savedlines[console_nextsave] = strdup(str);
20002852:	4b0e      	ldr	r3, [pc, #56]	@ (2000288c <console_readline_default+0x9b0>)
20002854:	681c      	ldr	r4, [r3, #0]
20002856:	68b8      	ldr	r0, [r7, #8]
20002858:	f7fe fe82 	bl	20001560 <lib_strdup>
2000285c:	4603      	mov	r3, r0
2000285e:	4a0c      	ldr	r2, [pc, #48]	@ (20002890 <console_readline_default+0x9b4>)
20002860:	f842 3024 	str.w	r3, [r2, r4, lsl #2]
	console_nextsave++;
20002864:	4b09      	ldr	r3, [pc, #36]	@ (2000288c <console_readline_default+0x9b0>)
20002866:	681b      	ldr	r3, [r3, #0]
20002868:	3301      	adds	r3, #1
2000286a:	4a08      	ldr	r2, [pc, #32]	@ (2000288c <console_readline_default+0x9b0>)
2000286c:	6013      	str	r3, [r2, #0]
	if (console_nextsave == MAXSAVELINES) console_nextsave = 0;
2000286e:	4b07      	ldr	r3, [pc, #28]	@ (2000288c <console_readline_default+0x9b0>)
20002870:	681b      	ldr	r3, [r3, #0]
20002872:	2b1e      	cmp	r3, #30
20002874:	d102      	bne.n	2000287c <console_readline_default+0x9a0>
20002876:	4b05      	ldr	r3, [pc, #20]	@ (2000288c <console_readline_default+0x9b0>)
20002878:	2200      	movs	r2, #0
2000287a:	601a      	str	r2, [r3, #0]
	}

    return len;
2000287c:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
}
2000287e:	4618      	mov	r0, r3
20002880:	3744      	adds	r7, #68	@ 0x44
20002882:	46bd      	mov	sp, r7
20002884:	bd90      	pop	{r4, r7, pc}
20002886:	bf00      	nop
20002888:	20005fac 	.word	0x20005fac
2000288c:	20005f20 	.word	0x20005f20
20002890:	20005f24 	.word	0x20005f24
20002894:	20005e94 	.word	0x20005e94

20002898 <console_readline>:

int console_readline(char *prompt,char *str,int maxlen)
{
20002898:	b580      	push	{r7, lr}
2000289a:	b084      	sub	sp, #16
2000289c:	af00      	add	r7, sp, #0
2000289e:	60f8      	str	r0, [r7, #12]
200028a0:	60b9      	str	r1, [r7, #8]
200028a2:	607a      	str	r2, [r7, #4]
    str[0] = '\0';
200028a4:	68bb      	ldr	r3, [r7, #8]
200028a6:	2200      	movs	r2, #0
200028a8:	701a      	strb	r2, [r3, #0]
    return console_readline_default(prompt,str,maxlen);
200028aa:	687a      	ldr	r2, [r7, #4]
200028ac:	68b9      	ldr	r1, [r7, #8]
200028ae:	68f8      	ldr	r0, [r7, #12]
200028b0:	f7ff fb14 	bl	20001edc <console_readline_default>
200028b4:	4603      	mov	r3, r0
}
200028b6:	4618      	mov	r0, r3
200028b8:	3710      	adds	r7, #16
200028ba:	46bd      	mov	sp, r7
200028bc:	bd80      	pop	{r7, pc}

200028be <cfe_strlen>:
#include "cfe.h"

extern int cfe_iocb_dispatch(cfe_iocb_t *iocb);

static int cfe_strlen(char *name)
{
200028be:	b480      	push	{r7}
200028c0:	b085      	sub	sp, #20
200028c2:	af00      	add	r7, sp, #0
200028c4:	6078      	str	r0, [r7, #4]
    int count = 0;
200028c6:	2300      	movs	r3, #0
200028c8:	60fb      	str	r3, [r7, #12]

    while (*name) {
200028ca:	e005      	b.n	200028d8 <cfe_strlen+0x1a>
	count++;
200028cc:	68fb      	ldr	r3, [r7, #12]
200028ce:	3301      	adds	r3, #1
200028d0:	60fb      	str	r3, [r7, #12]
	name++;
200028d2:	687b      	ldr	r3, [r7, #4]
200028d4:	3301      	adds	r3, #1
200028d6:	607b      	str	r3, [r7, #4]
    while (*name) {
200028d8:	687b      	ldr	r3, [r7, #4]
200028da:	781b      	ldrb	r3, [r3, #0]
200028dc:	2b00      	cmp	r3, #0
200028de:	d1f5      	bne.n	200028cc <cfe_strlen+0xe>
	}

    return count;
200028e0:	68fb      	ldr	r3, [r7, #12]
}
200028e2:	4618      	mov	r0, r3
200028e4:	3714      	adds	r7, #20
200028e6:	46bd      	mov	sp, r7
200028e8:	f85d 7b04 	ldr.w	r7, [sp], #4
200028ec:	4770      	bx	lr

200028ee <cfe_open>:

int cfe_open(char *name)
{
200028ee:	b580      	push	{r7, lr}
200028f0:	b09c      	sub	sp, #112	@ 0x70
200028f2:	af00      	add	r7, sp, #0
200028f4:	6078      	str	r0, [r7, #4]
    cfe_iocb_t iocb;

    iocb.iocb_fcode = CFE_CMD_DEV_OPEN;
200028f6:	230b      	movs	r3, #11
200028f8:	60bb      	str	r3, [r7, #8]
    iocb.iocb_status = 0;
200028fa:	2300      	movs	r3, #0
200028fc:	60fb      	str	r3, [r7, #12]
    iocb.iocb_handle = 0;
200028fe:	2300      	movs	r3, #0
20002900:	613b      	str	r3, [r7, #16]
    iocb.iocb_flags = 0;
20002902:	2300      	movs	r3, #0
20002904:	617b      	str	r3, [r7, #20]
    iocb.iocb_psize = sizeof(iocb_buffer_t);
20002906:	2318      	movs	r3, #24
20002908:	61bb      	str	r3, [r7, #24]
    iocb.plist.iocb_buffer.buf_offset = 0;
2000290a:	f04f 0200 	mov.w	r2, #0
2000290e:	f04f 0300 	mov.w	r3, #0
20002912:	e9c7 2308 	strd	r2, r3, [r7, #32]
    iocb.plist.iocb_buffer.buf_ptr = PTR2HSADDR(name);
20002916:	687b      	ldr	r3, [r7, #4]
20002918:	62bb      	str	r3, [r7, #40]	@ 0x28
    iocb.plist.iocb_buffer.buf_length = cfe_strlen(name);
2000291a:	6878      	ldr	r0, [r7, #4]
2000291c:	f7ff ffcf 	bl	200028be <cfe_strlen>
20002920:	4603      	mov	r3, r0
20002922:	62fb      	str	r3, [r7, #44]	@ 0x2c

    cfe_iocb_dispatch(&iocb);
20002924:	f107 0308 	add.w	r3, r7, #8
20002928:	4618      	mov	r0, r3
2000292a:	f000 f90d 	bl	20002b48 <cfe_iocb_dispatch>

    return (iocb.iocb_status < 0) ? iocb.iocb_status : iocb.iocb_handle;
2000292e:	68fb      	ldr	r3, [r7, #12]
20002930:	2b00      	cmp	r3, #0
20002932:	da01      	bge.n	20002938 <cfe_open+0x4a>
20002934:	68fb      	ldr	r3, [r7, #12]
20002936:	e000      	b.n	2000293a <cfe_open+0x4c>
20002938:	693b      	ldr	r3, [r7, #16]
}
2000293a:	4618      	mov	r0, r3
2000293c:	3770      	adds	r7, #112	@ 0x70
2000293e:	46bd      	mov	sp, r7
20002940:	bd80      	pop	{r7, pc}

20002942 <cfe_close>:

int cfe_close(int handle)
{
20002942:	b580      	push	{r7, lr}
20002944:	b09c      	sub	sp, #112	@ 0x70
20002946:	af00      	add	r7, sp, #0
20002948:	6078      	str	r0, [r7, #4]
    cfe_iocb_t iocb;

    iocb.iocb_fcode = CFE_CMD_DEV_CLOSE;
2000294a:	2310      	movs	r3, #16
2000294c:	60bb      	str	r3, [r7, #8]
    iocb.iocb_status = 0;
2000294e:	2300      	movs	r3, #0
20002950:	60fb      	str	r3, [r7, #12]
    iocb.iocb_handle = handle;
20002952:	687b      	ldr	r3, [r7, #4]
20002954:	613b      	str	r3, [r7, #16]
    iocb.iocb_flags = 0;
20002956:	2300      	movs	r3, #0
20002958:	617b      	str	r3, [r7, #20]
    iocb.iocb_psize = 0;
2000295a:	2300      	movs	r3, #0
2000295c:	61bb      	str	r3, [r7, #24]

    cfe_iocb_dispatch(&iocb);
2000295e:	f107 0308 	add.w	r3, r7, #8
20002962:	4618      	mov	r0, r3
20002964:	f000 f8f0 	bl	20002b48 <cfe_iocb_dispatch>

    return (iocb.iocb_status);
20002968:	68fb      	ldr	r3, [r7, #12]

}
2000296a:	4618      	mov	r0, r3
2000296c:	3770      	adds	r7, #112	@ 0x70
2000296e:	46bd      	mov	sp, r7
20002970:	bd80      	pop	{r7, pc}

20002972 <cfe_readblk>:

int cfe_readblk(int handle,cfe_offset_t offset,hsaddr_t buffer,int length)
{
20002972:	b580      	push	{r7, lr}
20002974:	b09e      	sub	sp, #120	@ 0x78
20002976:	af00      	add	r7, sp, #0
20002978:	60f8      	str	r0, [r7, #12]
2000297a:	e9c7 2300 	strd	r2, r3, [r7]
    cfe_iocb_t iocb;

    iocb.iocb_fcode = CFE_CMD_DEV_READ;
2000297e:	230d      	movs	r3, #13
20002980:	613b      	str	r3, [r7, #16]
    iocb.iocb_status = 0;
20002982:	2300      	movs	r3, #0
20002984:	617b      	str	r3, [r7, #20]
    iocb.iocb_handle = handle;
20002986:	68fb      	ldr	r3, [r7, #12]
20002988:	61bb      	str	r3, [r7, #24]
    iocb.iocb_flags = 0;
2000298a:	2300      	movs	r3, #0
2000298c:	61fb      	str	r3, [r7, #28]
    iocb.iocb_psize = sizeof(iocb_buffer_t);
2000298e:	2318      	movs	r3, #24
20002990:	623b      	str	r3, [r7, #32]
    iocb.plist.iocb_buffer.buf_offset = offset;
20002992:	e9d7 2300 	ldrd	r2, r3, [r7]
20002996:	e9c7 230a 	strd	r2, r3, [r7, #40]	@ 0x28
    iocb.plist.iocb_buffer.buf_ptr = buffer;
2000299a:	f8d7 3080 	ldr.w	r3, [r7, #128]	@ 0x80
2000299e:	633b      	str	r3, [r7, #48]	@ 0x30
    iocb.plist.iocb_buffer.buf_length = length;
200029a0:	f8d7 3084 	ldr.w	r3, [r7, #132]	@ 0x84
200029a4:	637b      	str	r3, [r7, #52]	@ 0x34

    cfe_iocb_dispatch(&iocb);
200029a6:	f107 0310 	add.w	r3, r7, #16
200029aa:	4618      	mov	r0, r3
200029ac:	f000 f8cc 	bl	20002b48 <cfe_iocb_dispatch>

    return (iocb.iocb_status < 0) ? iocb.iocb_status : iocb.plist.iocb_buffer.buf_retlen;
200029b0:	697b      	ldr	r3, [r7, #20]
200029b2:	2b00      	cmp	r3, #0
200029b4:	da01      	bge.n	200029ba <cfe_readblk+0x48>
200029b6:	697b      	ldr	r3, [r7, #20]
200029b8:	e000      	b.n	200029bc <cfe_readblk+0x4a>
200029ba:	6bbb      	ldr	r3, [r7, #56]	@ 0x38
}
200029bc:	4618      	mov	r0, r3
200029be:	3778      	adds	r7, #120	@ 0x78
200029c0:	46bd      	mov	sp, r7
200029c2:	bd80      	pop	{r7, pc}

200029c4 <cfe_read>:

int cfe_read(int handle,hsaddr_t buffer,int length)
{
200029c4:	b580      	push	{r7, lr}
200029c6:	b086      	sub	sp, #24
200029c8:	af02      	add	r7, sp, #8
200029ca:	60f8      	str	r0, [r7, #12]
200029cc:	60b9      	str	r1, [r7, #8]
200029ce:	607a      	str	r2, [r7, #4]
    return cfe_readblk(handle,0,buffer,length);
200029d0:	687b      	ldr	r3, [r7, #4]
200029d2:	9301      	str	r3, [sp, #4]
200029d4:	68bb      	ldr	r3, [r7, #8]
200029d6:	9300      	str	r3, [sp, #0]
200029d8:	f04f 0200 	mov.w	r2, #0
200029dc:	f04f 0300 	mov.w	r3, #0
200029e0:	68f8      	ldr	r0, [r7, #12]
200029e2:	f7ff ffc6 	bl	20002972 <cfe_readblk>
200029e6:	4603      	mov	r3, r0
}
200029e8:	4618      	mov	r0, r3
200029ea:	3710      	adds	r7, #16
200029ec:	46bd      	mov	sp, r7
200029ee:	bd80      	pop	{r7, pc}

200029f0 <cfe_writeblk>:


int cfe_writeblk(int handle,cfe_offset_t offset,hsaddr_t buffer,int length)
{
200029f0:	b580      	push	{r7, lr}
200029f2:	b09e      	sub	sp, #120	@ 0x78
200029f4:	af00      	add	r7, sp, #0
200029f6:	60f8      	str	r0, [r7, #12]
200029f8:	e9c7 2300 	strd	r2, r3, [r7]
    cfe_iocb_t iocb;

    iocb.iocb_fcode = CFE_CMD_DEV_WRITE;
200029fc:	230e      	movs	r3, #14
200029fe:	613b      	str	r3, [r7, #16]
    iocb.iocb_status = 0;
20002a00:	2300      	movs	r3, #0
20002a02:	617b      	str	r3, [r7, #20]
    iocb.iocb_handle = handle;
20002a04:	68fb      	ldr	r3, [r7, #12]
20002a06:	61bb      	str	r3, [r7, #24]
    iocb.iocb_flags = 0;
20002a08:	2300      	movs	r3, #0
20002a0a:	61fb      	str	r3, [r7, #28]
    iocb.iocb_psize = sizeof(iocb_buffer_t);
20002a0c:	2318      	movs	r3, #24
20002a0e:	623b      	str	r3, [r7, #32]
    iocb.plist.iocb_buffer.buf_offset = offset;
20002a10:	e9d7 2300 	ldrd	r2, r3, [r7]
20002a14:	e9c7 230a 	strd	r2, r3, [r7, #40]	@ 0x28
    iocb.plist.iocb_buffer.buf_ptr = buffer;
20002a18:	f8d7 3080 	ldr.w	r3, [r7, #128]	@ 0x80
20002a1c:	633b      	str	r3, [r7, #48]	@ 0x30
    iocb.plist.iocb_buffer.buf_length = length;
20002a1e:	f8d7 3084 	ldr.w	r3, [r7, #132]	@ 0x84
20002a22:	637b      	str	r3, [r7, #52]	@ 0x34

    cfe_iocb_dispatch(&iocb);
20002a24:	f107 0310 	add.w	r3, r7, #16
20002a28:	4618      	mov	r0, r3
20002a2a:	f000 f88d 	bl	20002b48 <cfe_iocb_dispatch>

    return (iocb.iocb_status < 0) ? iocb.iocb_status : iocb.plist.iocb_buffer.buf_retlen;
20002a2e:	697b      	ldr	r3, [r7, #20]
20002a30:	2b00      	cmp	r3, #0
20002a32:	da01      	bge.n	20002a38 <cfe_writeblk+0x48>
20002a34:	697b      	ldr	r3, [r7, #20]
20002a36:	e000      	b.n	20002a3a <cfe_writeblk+0x4a>
20002a38:	6bbb      	ldr	r3, [r7, #56]	@ 0x38
}
20002a3a:	4618      	mov	r0, r3
20002a3c:	3778      	adds	r7, #120	@ 0x78
20002a3e:	46bd      	mov	sp, r7
20002a40:	bd80      	pop	{r7, pc}

20002a42 <cfe_write>:

int cfe_write(int handle,hsaddr_t buffer,int length)
{
20002a42:	b580      	push	{r7, lr}
20002a44:	b086      	sub	sp, #24
20002a46:	af02      	add	r7, sp, #8
20002a48:	60f8      	str	r0, [r7, #12]
20002a4a:	60b9      	str	r1, [r7, #8]
20002a4c:	607a      	str	r2, [r7, #4]
    return cfe_writeblk(handle,0,buffer,length);
20002a4e:	687b      	ldr	r3, [r7, #4]
20002a50:	9301      	str	r3, [sp, #4]
20002a52:	68bb      	ldr	r3, [r7, #8]
20002a54:	9300      	str	r3, [sp, #0]
20002a56:	f04f 0200 	mov.w	r2, #0
20002a5a:	f04f 0300 	mov.w	r3, #0
20002a5e:	68f8      	ldr	r0, [r7, #12]
20002a60:	f7ff ffc6 	bl	200029f0 <cfe_writeblk>
20002a64:	4603      	mov	r3, r0
}
20002a66:	4618      	mov	r0, r3
20002a68:	3710      	adds	r7, #16
20002a6a:	46bd      	mov	sp, r7
20002a6c:	bd80      	pop	{r7, pc}

20002a6e <cfe_inpstat>:
    if (retlen) *retlen = iocb.plist.iocb_buffer.buf_retlen;
    return iocb.iocb_status;
}

int cfe_inpstat(int handle)
{
20002a6e:	b580      	push	{r7, lr}
20002a70:	b09c      	sub	sp, #112	@ 0x70
20002a72:	af00      	add	r7, sp, #0
20002a74:	6078      	str	r0, [r7, #4]
    cfe_iocb_t iocb;

    iocb.iocb_fcode = CFE_CMD_DEV_INPSTAT;
20002a76:	230c      	movs	r3, #12
20002a78:	60bb      	str	r3, [r7, #8]
    iocb.iocb_status = 0;
20002a7a:	2300      	movs	r3, #0
20002a7c:	60fb      	str	r3, [r7, #12]
    iocb.iocb_handle = handle;
20002a7e:	687b      	ldr	r3, [r7, #4]
20002a80:	613b      	str	r3, [r7, #16]
    iocb.iocb_flags = 0;
20002a82:	2300      	movs	r3, #0
20002a84:	617b      	str	r3, [r7, #20]
    iocb.iocb_psize = sizeof(iocb_inpstat_t);
20002a86:	2304      	movs	r3, #4
20002a88:	61bb      	str	r3, [r7, #24]
    iocb.plist.iocb_inpstat.inp_status = 0;
20002a8a:	2300      	movs	r3, #0
20002a8c:	623b      	str	r3, [r7, #32]

    cfe_iocb_dispatch(&iocb);
20002a8e:	f107 0308 	add.w	r3, r7, #8
20002a92:	4618      	mov	r0, r3
20002a94:	f000 f858 	bl	20002b48 <cfe_iocb_dispatch>

    if (iocb.iocb_status < 0) return iocb.iocb_status;
20002a98:	68fb      	ldr	r3, [r7, #12]
20002a9a:	2b00      	cmp	r3, #0
20002a9c:	da01      	bge.n	20002aa2 <cfe_inpstat+0x34>
20002a9e:	68fb      	ldr	r3, [r7, #12]
20002aa0:	e000      	b.n	20002aa4 <cfe_inpstat+0x36>

    return iocb.plist.iocb_inpstat.inp_status;
20002aa2:	6a3b      	ldr	r3, [r7, #32]

}
20002aa4:	4618      	mov	r0, r3
20002aa6:	3770      	adds	r7, #112	@ 0x70
20002aa8:	46bd      	mov	sp, r7
20002aaa:	bd80      	pop	{r7, pc}

20002aac <cfe_getdevinfo>:

    return iocb.iocb_status;
}

int cfe_getdevinfo(char *name)
{
20002aac:	b580      	push	{r7, lr}
20002aae:	b09c      	sub	sp, #112	@ 0x70
20002ab0:	af00      	add	r7, sp, #0
20002ab2:	6078      	str	r0, [r7, #4]
    cfe_iocb_t iocb;

    iocb.iocb_fcode = CFE_CMD_DEV_GETINFO;
20002ab4:	2311      	movs	r3, #17
20002ab6:	60bb      	str	r3, [r7, #8]
    iocb.iocb_status = 0;
20002ab8:	2300      	movs	r3, #0
20002aba:	60fb      	str	r3, [r7, #12]
    iocb.iocb_handle = 0;
20002abc:	2300      	movs	r3, #0
20002abe:	613b      	str	r3, [r7, #16]
    iocb.iocb_flags = 0;
20002ac0:	2300      	movs	r3, #0
20002ac2:	617b      	str	r3, [r7, #20]
    iocb.iocb_psize = sizeof(iocb_buffer_t);
20002ac4:	2318      	movs	r3, #24
20002ac6:	61bb      	str	r3, [r7, #24]
    iocb.plist.iocb_buffer.buf_offset = 0;
20002ac8:	f04f 0200 	mov.w	r2, #0
20002acc:	f04f 0300 	mov.w	r3, #0
20002ad0:	e9c7 2308 	strd	r2, r3, [r7, #32]
    iocb.plist.iocb_buffer.buf_ptr = PTR2HSADDR(name);
20002ad4:	687b      	ldr	r3, [r7, #4]
20002ad6:	62bb      	str	r3, [r7, #40]	@ 0x28
    iocb.plist.iocb_buffer.buf_length = cfe_strlen(name);
20002ad8:	6878      	ldr	r0, [r7, #4]
20002ada:	f7ff fef0 	bl	200028be <cfe_strlen>
20002ade:	4603      	mov	r3, r0
20002ae0:	62fb      	str	r3, [r7, #44]	@ 0x2c

    cfe_iocb_dispatch(&iocb);
20002ae2:	f107 0308 	add.w	r3, r7, #8
20002ae6:	4618      	mov	r0, r3
20002ae8:	f000 f82e 	bl	20002b48 <cfe_iocb_dispatch>

    return (iocb.iocb_status < 0) ? iocb.iocb_status : (int)iocb.plist.iocb_buffer.buf_devflags;
20002aec:	68fb      	ldr	r3, [r7, #12]
20002aee:	2b00      	cmp	r3, #0
20002af0:	da01      	bge.n	20002af6 <cfe_getdevinfo+0x4a>
20002af2:	68fb      	ldr	r3, [r7, #12]
20002af4:	e000      	b.n	20002af8 <cfe_getdevinfo+0x4c>
20002af6:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
}
20002af8:	4618      	mov	r0, r3
20002afa:	3770      	adds	r7, #112	@ 0x70
20002afc:	46bd      	mov	sp, r7
20002afe:	bd80      	pop	{r7, pc}

20002b00 <hsgetstr>:
    *  	   nothing
    ********************************************************************* */


static void hsgetstr(char *dest,hsaddr_t src,int len)
{
20002b00:	b480      	push	{r7}
20002b02:	b087      	sub	sp, #28
20002b04:	af00      	add	r7, sp, #0
20002b06:	60f8      	str	r0, [r7, #12]
20002b08:	60b9      	str	r1, [r7, #8]
20002b0a:	607a      	str	r2, [r7, #4]
    char b;

    while (len > 0) {
20002b0c:	e010      	b.n	20002b30 <hsgetstr+0x30>
	b = hs_read8(src);
20002b0e:	68bb      	ldr	r3, [r7, #8]
20002b10:	781b      	ldrb	r3, [r3, #0]
20002b12:	75fb      	strb	r3, [r7, #23]
	src++;
20002b14:	68bb      	ldr	r3, [r7, #8]
20002b16:	3301      	adds	r3, #1
20002b18:	60bb      	str	r3, [r7, #8]
	*dest++ = b;
20002b1a:	68fb      	ldr	r3, [r7, #12]
20002b1c:	1c5a      	adds	r2, r3, #1
20002b1e:	60fa      	str	r2, [r7, #12]
20002b20:	7dfa      	ldrb	r2, [r7, #23]
20002b22:	701a      	strb	r2, [r3, #0]
	if (b == 0) break;
20002b24:	7dfb      	ldrb	r3, [r7, #23]
20002b26:	2b00      	cmp	r3, #0
20002b28:	d006      	beq.n	20002b38 <hsgetstr+0x38>
	len--;
20002b2a:	687b      	ldr	r3, [r7, #4]
20002b2c:	3b01      	subs	r3, #1
20002b2e:	607b      	str	r3, [r7, #4]
    while (len > 0) {
20002b30:	687b      	ldr	r3, [r7, #4]
20002b32:	2b00      	cmp	r3, #0
20002b34:	dceb      	bgt.n	20002b0e <hsgetstr+0xe>
	}
}
20002b36:	e000      	b.n	20002b3a <hsgetstr+0x3a>
	if (b == 0) break;
20002b38:	bf00      	nop
}
20002b3a:	bf00      	nop
20002b3c:	371c      	adds	r7, #28
20002b3e:	46bd      	mov	sp, r7
20002b40:	f85d 7b04 	ldr.w	r7, [sp], #4
20002b44:	4770      	bx	lr
	...

20002b48 <cfe_iocb_dispatch>:
	    }
	}
}

int cfe_iocb_dispatch(cfe_iocb_t *iocb)
{
20002b48:	b580      	push	{r7, lr}
20002b4a:	b086      	sub	sp, #24
20002b4c:	af00      	add	r7, sp, #0
20002b4e:	6078      	str	r0, [r7, #4]

    /*
     * Check for commands codes out of range
     */

    if ((iocb->iocb_fcode < 0) || (iocb->iocb_fcode >= CFE_CMD_MAX)) {
20002b50:	687b      	ldr	r3, [r7, #4]
20002b52:	681b      	ldr	r3, [r3, #0]
20002b54:	2b1f      	cmp	r3, #31
20002b56:	d906      	bls.n	20002b66 <cfe_iocb_dispatch+0x1e>
	iocb->iocb_status = CFE_ERR_INV_COMMAND;
20002b58:	687b      	ldr	r3, [r7, #4]
20002b5a:	f06f 0201 	mvn.w	r2, #1
20002b5e:	605a      	str	r2, [r3, #4]
	return iocb->iocb_status;
20002b60:	687b      	ldr	r3, [r7, #4]
20002b62:	685b      	ldr	r3, [r3, #4]
20002b64:	e04f      	b.n	20002c06 <cfe_iocb_dispatch+0xbe>

    /*
     * Check for command codes in range but invalid
     */

    disp = &cfe_cmd_dispatch_table[iocb->iocb_fcode];
20002b66:	687b      	ldr	r3, [r7, #4]
20002b68:	681a      	ldr	r2, [r3, #0]
20002b6a:	4613      	mov	r3, r2
20002b6c:	005b      	lsls	r3, r3, #1
20002b6e:	4413      	add	r3, r2
20002b70:	009b      	lsls	r3, r3, #2
20002b72:	4a27      	ldr	r2, [pc, #156]	@ (20002c10 <cfe_iocb_dispatch+0xc8>)
20002b74:	4413      	add	r3, r2
20002b76:	613b      	str	r3, [r7, #16]

    if (disp->plistsize < 0) {
20002b78:	693b      	ldr	r3, [r7, #16]
20002b7a:	681b      	ldr	r3, [r3, #0]
20002b7c:	2b00      	cmp	r3, #0
20002b7e:	da06      	bge.n	20002b8e <cfe_iocb_dispatch+0x46>
	iocb->iocb_status = CFE_ERR_INV_COMMAND;
20002b80:	687b      	ldr	r3, [r7, #4]
20002b82:	f06f 0201 	mvn.w	r2, #1
20002b86:	605a      	str	r2, [r3, #4]
	return iocb->iocb_status;
20002b88:	687b      	ldr	r3, [r7, #4]
20002b8a:	685b      	ldr	r3, [r3, #4]
20002b8c:	e03b      	b.n	20002c06 <cfe_iocb_dispatch+0xbe>

    /*
     * Check for invalid parameter list size
     */

    if (disp->plistsize != iocb->iocb_psize) {
20002b8e:	693b      	ldr	r3, [r7, #16]
20002b90:	681b      	ldr	r3, [r3, #0]
20002b92:	461a      	mov	r2, r3
20002b94:	687b      	ldr	r3, [r7, #4]
20002b96:	691b      	ldr	r3, [r3, #16]
20002b98:	429a      	cmp	r2, r3
20002b9a:	d006      	beq.n	20002baa <cfe_iocb_dispatch+0x62>
	iocb->iocb_status = CFE_ERR_INV_PARAM;
20002b9c:	687b      	ldr	r3, [r7, #4]
20002b9e:	f06f 0207 	mvn.w	r2, #7
20002ba2:	605a      	str	r2, [r3, #4]
	return iocb->iocb_status;
20002ba4:	687b      	ldr	r3, [r7, #4]
20002ba6:	685b      	ldr	r3, [r3, #4]
20002ba8:	e02d      	b.n	20002c06 <cfe_iocb_dispatch+0xbe>

    /*
     * Determine handle
     */
    
    ctx = NULL;
20002baa:	2300      	movs	r3, #0
20002bac:	617b      	str	r3, [r7, #20]
    if (disp->flags & HV) {
20002bae:	693b      	ldr	r3, [r7, #16]
20002bb0:	685b      	ldr	r3, [r3, #4]
20002bb2:	f003 0301 	and.w	r3, r3, #1
20002bb6:	2b00      	cmp	r3, #0
20002bb8:	d01b      	beq.n	20002bf2 <cfe_iocb_dispatch+0xaa>
	if ((iocb->iocb_handle >= CFE_MAX_HANDLE) || 
20002bba:	687b      	ldr	r3, [r7, #4]
20002bbc:	689b      	ldr	r3, [r3, #8]
20002bbe:	2b3f      	cmp	r3, #63	@ 0x3f
20002bc0:	dc0a      	bgt.n	20002bd8 <cfe_iocb_dispatch+0x90>
	    (iocb->iocb_handle < 0) ||
20002bc2:	687b      	ldr	r3, [r7, #4]
20002bc4:	689b      	ldr	r3, [r3, #8]
	if ((iocb->iocb_handle >= CFE_MAX_HANDLE) || 
20002bc6:	2b00      	cmp	r3, #0
20002bc8:	db06      	blt.n	20002bd8 <cfe_iocb_dispatch+0x90>
	    (cfe_handle_table[iocb->iocb_handle] == NULL)){
20002bca:	687b      	ldr	r3, [r7, #4]
20002bcc:	689b      	ldr	r3, [r3, #8]
20002bce:	4a11      	ldr	r2, [pc, #68]	@ (20002c14 <cfe_iocb_dispatch+0xcc>)
20002bd0:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
	    (iocb->iocb_handle < 0) ||
20002bd4:	2b00      	cmp	r3, #0
20002bd6:	d106      	bne.n	20002be6 <cfe_iocb_dispatch+0x9e>
	    iocb->iocb_status = CFE_ERR_INV_PARAM;
20002bd8:	687b      	ldr	r3, [r7, #4]
20002bda:	f06f 0207 	mvn.w	r2, #7
20002bde:	605a      	str	r2, [r3, #4]
	    return iocb->iocb_status;
20002be0:	687b      	ldr	r3, [r7, #4]
20002be2:	685b      	ldr	r3, [r3, #4]
20002be4:	e00f      	b.n	20002c06 <cfe_iocb_dispatch+0xbe>
	    }
	ctx = cfe_handle_table[iocb->iocb_handle];
20002be6:	687b      	ldr	r3, [r7, #4]
20002be8:	689b      	ldr	r3, [r3, #8]
20002bea:	4a0a      	ldr	r2, [pc, #40]	@ (20002c14 <cfe_iocb_dispatch+0xcc>)
20002bec:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
20002bf0:	617b      	str	r3, [r7, #20]

    /*
     * Dispatch to handler routine
     */

    res = (*disp->func)(ctx,iocb);
20002bf2:	693b      	ldr	r3, [r7, #16]
20002bf4:	689b      	ldr	r3, [r3, #8]
20002bf6:	6879      	ldr	r1, [r7, #4]
20002bf8:	6978      	ldr	r0, [r7, #20]
20002bfa:	4798      	blx	r3
20002bfc:	60f8      	str	r0, [r7, #12]

    iocb->iocb_status = res;
20002bfe:	687b      	ldr	r3, [r7, #4]
20002c00:	68fa      	ldr	r2, [r7, #12]
20002c02:	605a      	str	r2, [r3, #4]
    return res;
20002c04:	68fb      	ldr	r3, [r7, #12]
}
20002c06:	4618      	mov	r0, r3
20002c08:	3718      	adds	r7, #24
20002c0a:	46bd      	mov	sp, r7
20002c0c:	bd80      	pop	{r7, pc}
20002c0e:	bf00      	nop
20002c10:	20005cc4 	.word	0x20005cc4
20002c14:	20005fb4 	.word	0x20005fb4

20002c18 <cfe_newhandle>:

static int cfe_newhandle(void)
{
20002c18:	b480      	push	{r7}
20002c1a:	b083      	sub	sp, #12
20002c1c:	af00      	add	r7, sp, #0
    int idx;

    for (idx = 0; idx < CFE_MAX_HANDLE; idx++) {
20002c1e:	2300      	movs	r3, #0
20002c20:	607b      	str	r3, [r7, #4]
20002c22:	e008      	b.n	20002c36 <cfe_newhandle+0x1e>
	if (cfe_handle_table[idx] == NULL) break;
20002c24:	4a0d      	ldr	r2, [pc, #52]	@ (20002c5c <cfe_newhandle+0x44>)
20002c26:	687b      	ldr	r3, [r7, #4]
20002c28:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
20002c2c:	2b00      	cmp	r3, #0
20002c2e:	d006      	beq.n	20002c3e <cfe_newhandle+0x26>
    for (idx = 0; idx < CFE_MAX_HANDLE; idx++) {
20002c30:	687b      	ldr	r3, [r7, #4]
20002c32:	3301      	adds	r3, #1
20002c34:	607b      	str	r3, [r7, #4]
20002c36:	687b      	ldr	r3, [r7, #4]
20002c38:	2b3f      	cmp	r3, #63	@ 0x3f
20002c3a:	ddf3      	ble.n	20002c24 <cfe_newhandle+0xc>
20002c3c:	e000      	b.n	20002c40 <cfe_newhandle+0x28>
	if (cfe_handle_table[idx] == NULL) break;
20002c3e:	bf00      	nop
	}

    if (idx == CFE_MAX_HANDLE) return -1;
20002c40:	687b      	ldr	r3, [r7, #4]
20002c42:	2b40      	cmp	r3, #64	@ 0x40
20002c44:	d102      	bne.n	20002c4c <cfe_newhandle+0x34>
20002c46:	f04f 33ff 	mov.w	r3, #4294967295	@ 0xffffffff
20002c4a:	e000      	b.n	20002c4e <cfe_newhandle+0x36>

    return idx;
20002c4c:	687b      	ldr	r3, [r7, #4]
}
20002c4e:	4618      	mov	r0, r3
20002c50:	370c      	adds	r7, #12
20002c52:	46bd      	mov	sp, r7
20002c54:	f85d 7b04 	ldr.w	r7, [sp], #4
20002c58:	4770      	bx	lr
20002c5a:	bf00      	nop
20002c5c:	20005fb4 	.word	0x20005fb4

20002c60 <cfe_cmd_fw_getinfo>:
/*  *********************************************************************
    *  Implementation routines for each IOCB function
    ********************************************************************* */

static int cfe_cmd_fw_getinfo(cfe_devctx_t *ctx,cfe_iocb_t *iocb)
{
20002c60:	e92d 03b0 	stmdb	sp!, {r4, r5, r7, r8, r9}
20002c64:	b085      	sub	sp, #20
20002c66:	af00      	add	r7, sp, #0
20002c68:	6078      	str	r0, [r7, #4]
20002c6a:	6039      	str	r1, [r7, #0]
    iocb_fwinfo_t *info = &iocb->plist.iocb_fwinfo;
20002c6c:	683b      	ldr	r3, [r7, #0]
20002c6e:	3318      	adds	r3, #24
20002c70:	60fb      	str	r3, [r7, #12]

    info->fwi_version = (CFE_VER_MAJOR << 16) |
20002c72:	68f9      	ldr	r1, [r7, #12]
20002c74:	f44f 7281 	mov.w	r2, #258	@ 0x102
20002c78:	f04f 0300 	mov.w	r3, #0
20002c7c:	e9c1 2300 	strd	r2, r3, [r1]
	(CFE_VER_MINOR << 8) |
	(CFE_VER_BUILD);
    //info->fwi_totalmem = ((cfe_int64_t) mem_totalsize) << 20;
    info->fwi_flags = 
20002c80:	68f9      	ldr	r1, [r7, #12]
20002c82:	f04f 020a 	mov.w	r2, #10
20002c86:	f04f 0300 	mov.w	r3, #0
20002c8a:	e9c1 2304 	strd	r2, r3, [r1, #16]
#ifdef _FUNCSIM_
	CFE_FWI_FUNCSIM |
#endif
	0;

    info->fwi_boardid = CFG_BOARD_ID;
20002c8e:	68f9      	ldr	r1, [r7, #12]
20002c90:	f04f 0200 	mov.w	r2, #0
20002c94:	f04f 0300 	mov.w	r3, #0
20002c98:	e9c1 2306 	strd	r2, r3, [r1, #24]
    info->fwi_bootarea_pa = (cfe_int64_t) mem_bootarea_start;
20002c9c:	4b19      	ldr	r3, [pc, #100]	@ (20002d04 <cfe_cmd_fw_getinfo+0xa4>)
20002c9e:	681b      	ldr	r3, [r3, #0]
20002ca0:	2200      	movs	r2, #0
20002ca2:	4698      	mov	r8, r3
20002ca4:	4691      	mov	r9, r2
20002ca6:	68fb      	ldr	r3, [r7, #12]
20002ca8:	e9c3 890a 	strd	r8, r9, [r3, #40]	@ 0x28
    info->fwi_bootarea_va = BOOT_START_ADDRESS;
20002cac:	68f9      	ldr	r1, [r7, #12]
20002cae:	f04f 5200 	mov.w	r2, #536870912	@ 0x20000000
20002cb2:	f04f 0300 	mov.w	r3, #0
20002cb6:	e9c1 2308 	strd	r2, r3, [r1, #32]
    info->fwi_bootarea_size = (cfe_int64_t) mem_bootarea_size;
20002cba:	4b13      	ldr	r3, [pc, #76]	@ (20002d08 <cfe_cmd_fw_getinfo+0xa8>)
20002cbc:	681b      	ldr	r3, [r3, #0]
20002cbe:	2200      	movs	r2, #0
20002cc0:	461c      	mov	r4, r3
20002cc2:	4615      	mov	r5, r2
20002cc4:	68fb      	ldr	r3, [r7, #12]
20002cc6:	e9c3 450c 	strd	r4, r5, [r3, #48]	@ 0x30
    info->fwi_reserved1 = 0;
20002cca:	68f9      	ldr	r1, [r7, #12]
20002ccc:	f04f 0200 	mov.w	r2, #0
20002cd0:	f04f 0300 	mov.w	r3, #0
20002cd4:	e9c1 230e 	strd	r2, r3, [r1, #56]	@ 0x38
    info->fwi_reserved2 = 0;
20002cd8:	68f9      	ldr	r1, [r7, #12]
20002cda:	f04f 0200 	mov.w	r2, #0
20002cde:	f04f 0300 	mov.w	r3, #0
20002ce2:	e9c1 2310 	strd	r2, r3, [r1, #64]	@ 0x40
    info->fwi_reserved3 = 0;
20002ce6:	68f9      	ldr	r1, [r7, #12]
20002ce8:	f04f 0200 	mov.w	r2, #0
20002cec:	f04f 0300 	mov.w	r3, #0
20002cf0:	e9c1 2312 	strd	r2, r3, [r1, #72]	@ 0x48

    return CFE_OK;
20002cf4:	2300      	movs	r3, #0
}
20002cf6:	4618      	mov	r0, r3
20002cf8:	3714      	adds	r7, #20
20002cfa:	46bd      	mov	sp, r7
20002cfc:	e8bd 03b0 	ldmia.w	sp!, {r4, r5, r7, r8, r9}
20002d00:	4770      	bx	lr
20002d02:	bf00      	nop
20002d04:	200060d0 	.word	0x200060d0
20002d08:	200060d4 	.word	0x200060d4

20002d0c <cfe_cmd_fw_restart>:

static int cfe_cmd_fw_restart(cfe_devctx_t *ctx,cfe_iocb_t *iocb)
{
20002d0c:	b480      	push	{r7}
20002d0e:	b083      	sub	sp, #12
20002d10:	af00      	add	r7, sp, #0
20002d12:	6078      	str	r0, [r7, #4]
20002d14:	6039      	str	r1, [r7, #0]

    return CFE_OK;
20002d16:	2300      	movs	r3, #0
}
20002d18:	4618      	mov	r0, r3
20002d1a:	370c      	adds	r7, #12
20002d1c:	46bd      	mov	sp, r7
20002d1e:	f85d 7b04 	ldr.w	r7, [sp], #4
20002d22:	4770      	bx	lr

20002d24 <cfe_cmd_fw_boot>:

static int cfe_cmd_fw_boot(cfe_devctx_t *ctx,cfe_iocb_t *iocb)
{
20002d24:	b480      	push	{r7}
20002d26:	b083      	sub	sp, #12
20002d28:	af00      	add	r7, sp, #0
20002d2a:	6078      	str	r0, [r7, #4]
20002d2c:	6039      	str	r1, [r7, #0]
    return CFE_ERR_INV_COMMAND;		/* not implemented yet */
20002d2e:	f06f 0301 	mvn.w	r3, #1
}
20002d32:	4618      	mov	r0, r3
20002d34:	370c      	adds	r7, #12
20002d36:	46bd      	mov	sp, r7
20002d38:	f85d 7b04 	ldr.w	r7, [sp], #4
20002d3c:	4770      	bx	lr

20002d3e <cfe_cmd_fw_cpuctl>:

static int cfe_cmd_fw_cpuctl(cfe_devctx_t *ctx,cfe_iocb_t *iocb)
{
20002d3e:	b480      	push	{r7}
20002d40:	b083      	sub	sp, #12
20002d42:	af00      	add	r7, sp, #0
20002d44:	6078      	str	r0, [r7, #4]
20002d46:	6039      	str	r1, [r7, #0]
	    res = CFE_ERR_INV_PARAM;
	}

    return res;
#else
    return CFE_ERR_INV_COMMAND;
20002d48:	f06f 0301 	mvn.w	r3, #1
#endif
}
20002d4c:	4618      	mov	r0, r3
20002d4e:	370c      	adds	r7, #12
20002d50:	46bd      	mov	sp, r7
20002d52:	f85d 7b04 	ldr.w	r7, [sp], #4
20002d56:	4770      	bx	lr

20002d58 <cfe_cmd_fw_gettime>:

static int cfe_cmd_fw_gettime(cfe_devctx_t *ctx,cfe_iocb_t *iocb)
{
20002d58:	b580      	push	{r7, lr}
20002d5a:	b082      	sub	sp, #8
20002d5c:	af00      	add	r7, sp, #0
20002d5e:	6078      	str	r0, [r7, #4]
20002d60:	6039      	str	r1, [r7, #0]
    POLL();
20002d62:	f7fe fd45 	bl	200017f0 <background>

    iocb->plist.iocb_time.ticks = cfe_ticks;
20002d66:	4b05      	ldr	r3, [pc, #20]	@ (20002d7c <cfe_cmd_fw_gettime+0x24>)
20002d68:	e9d3 2300 	ldrd	r2, r3, [r3]
20002d6c:	6839      	ldr	r1, [r7, #0]
20002d6e:	e9c1 2306 	strd	r2, r3, [r1, #24]

    return CFE_OK;
20002d72:	2300      	movs	r3, #0
}
20002d74:	4618      	mov	r0, r3
20002d76:	3708      	adds	r7, #8
20002d78:	46bd      	mov	sp, r7
20002d7a:	bd80      	pop	{r7, pc}
20002d7c:	200060d8 	.word	0x200060d8

20002d80 <cfe_cmd_fw_memenum>:

static int cfe_cmd_fw_memenum(cfe_devctx_t *ctx,cfe_iocb_t *iocb)
{
20002d80:	b590      	push	{r4, r7, lr}
20002d82:	b08b      	sub	sp, #44	@ 0x2c
20002d84:	af02      	add	r7, sp, #8
20002d86:	6078      	str	r0, [r7, #4]
20002d88:	6039      	str	r1, [r7, #0]
    int type;
    int res;
    uint64_t addr,size;

    res = cfe_arena_enum(iocb->plist.iocb_meminfo.mi_idx,
20002d8a:	683b      	ldr	r3, [r7, #0]
20002d8c:	6998      	ldr	r0, [r3, #24]
			 &type,
			 &addr,
			 &size,
			 (iocb->iocb_flags & CFE_FLG_FULL_ARENA) ? TRUE : FALSE);
20002d8e:	683b      	ldr	r3, [r7, #0]
20002d90:	68db      	ldr	r3, [r3, #12]
    res = cfe_arena_enum(iocb->plist.iocb_meminfo.mi_idx,
20002d92:	f003 0301 	and.w	r3, r3, #1
20002d96:	f107 0408 	add.w	r4, r7, #8
20002d9a:	f107 0210 	add.w	r2, r7, #16
20002d9e:	f107 0118 	add.w	r1, r7, #24
20002da2:	9300      	str	r3, [sp, #0]
20002da4:	4623      	mov	r3, r4
20002da6:	f000 fb2d 	bl	20003404 <cfe_arena_enum>
20002daa:	61f8      	str	r0, [r7, #28]

    iocb->plist.iocb_meminfo.mi_addr = addr;
20002dac:	e9d7 2304 	ldrd	r2, r3, [r7, #16]
20002db0:	6839      	ldr	r1, [r7, #0]
20002db2:	e9c1 2308 	strd	r2, r3, [r1, #32]
    iocb->plist.iocb_meminfo.mi_size = size;
20002db6:	e9d7 2302 	ldrd	r2, r3, [r7, #8]
20002dba:	6839      	ldr	r1, [r7, #0]
20002dbc:	e9c1 230a 	strd	r2, r3, [r1, #40]	@ 0x28
    iocb->plist.iocb_meminfo.mi_type = type;
20002dc0:	69ba      	ldr	r2, [r7, #24]
20002dc2:	683b      	ldr	r3, [r7, #0]
20002dc4:	61da      	str	r2, [r3, #28]

    if (res == 0) {
20002dc6:	69fb      	ldr	r3, [r7, #28]
20002dc8:	2b00      	cmp	r3, #0
20002dca:	d109      	bne.n	20002de0 <cfe_cmd_fw_memenum+0x60>
	if (type == MEMTYPE_DRAM_AVAILABLE) {
20002dcc:	69bb      	ldr	r3, [r7, #24]
20002dce:	2b01      	cmp	r3, #1
20002dd0:	d103      	bne.n	20002dda <cfe_cmd_fw_memenum+0x5a>
	    iocb->plist.iocb_meminfo.mi_type = CFE_MI_AVAILABLE;
20002dd2:	683b      	ldr	r3, [r7, #0]
20002dd4:	2201      	movs	r2, #1
20002dd6:	61da      	str	r2, [r3, #28]
20002dd8:	e002      	b.n	20002de0 <cfe_cmd_fw_memenum+0x60>
	    }
	else {
	    iocb->plist.iocb_meminfo.mi_type = CFE_MI_RESERVED;
20002dda:	683b      	ldr	r3, [r7, #0]
20002ddc:	2200      	movs	r2, #0
20002dde:	61da      	str	r2, [r3, #28]
	    }
	}

    return res;
20002de0:	69fb      	ldr	r3, [r7, #28]
}
20002de2:	4618      	mov	r0, r3
20002de4:	3724      	adds	r7, #36	@ 0x24
20002de6:	46bd      	mov	sp, r7
20002de8:	bd90      	pop	{r4, r7, pc}

20002dea <cfe_cmd_fw_flushcache>:

static int cfe_cmd_fw_flushcache(cfe_devctx_t *ctx,cfe_iocb_t *iocb)
{
20002dea:	b480      	push	{r7}
20002dec:	b083      	sub	sp, #12
20002dee:	af00      	add	r7, sp, #0
20002df0:	6078      	str	r0, [r7, #4]
20002df2:	6039      	str	r1, [r7, #0]
  //  _cfe_flushcache(iocb->iocb_flags);
    return CFE_OK;
20002df4:	2300      	movs	r3, #0
}
20002df6:	4618      	mov	r0, r3
20002df8:	370c      	adds	r7, #12
20002dfa:	46bd      	mov	sp, r7
20002dfc:	f85d 7b04 	ldr.w	r7, [sp], #4
20002e00:	4770      	bx	lr

20002e02 <cfe_cmd_dev_enum>:

static int cfe_cmd_dev_enum(cfe_devctx_t *ctx,cfe_iocb_t *iocb)
{
20002e02:	b580      	push	{r7, lr}
20002e04:	b084      	sub	sp, #16
20002e06:	af00      	add	r7, sp, #0
20002e08:	6078      	str	r0, [r7, #4]
20002e0a:	6039      	str	r1, [r7, #0]
    int namelen,res;

    namelen = iocb->plist.iocb_envbuf.name_length;
20002e0c:	683b      	ldr	r3, [r7, #0]
20002e0e:	6a1b      	ldr	r3, [r3, #32]
20002e10:	60bb      	str	r3, [r7, #8]

    res = cfe_dev_enum(iocb->plist.iocb_envbuf.enum_idx,
20002e12:	683b      	ldr	r3, [r7, #0]
20002e14:	6998      	ldr	r0, [r3, #24]
		   (char *)iocb->plist.iocb_envbuf.name_ptr,
20002e16:	683b      	ldr	r3, [r7, #0]
20002e18:	69db      	ldr	r3, [r3, #28]
    res = cfe_dev_enum(iocb->plist.iocb_envbuf.enum_idx,
20002e1a:	f107 0208 	add.w	r2, r7, #8
20002e1e:	4619      	mov	r1, r3
20002e20:	f7fe fbe0 	bl	200015e4 <cfe_dev_enum>
20002e24:	60f8      	str	r0, [r7, #12]
		   &namelen);

    if (res < 0) return CFE_ERR_DEVNOTFOUND;
20002e26:	68fb      	ldr	r3, [r7, #12]
20002e28:	2b00      	cmp	r3, #0
20002e2a:	da02      	bge.n	20002e32 <cfe_cmd_dev_enum+0x30>
20002e2c:	f06f 0305 	mvn.w	r3, #5
20002e30:	e003      	b.n	20002e3a <cfe_cmd_dev_enum+0x38>

	iocb->plist.iocb_envbuf.name_length = namelen;
20002e32:	68ba      	ldr	r2, [r7, #8]
20002e34:	683b      	ldr	r3, [r7, #0]
20002e36:	621a      	str	r2, [r3, #32]

    return CFE_OK;
20002e38:	2300      	movs	r3, #0
}
20002e3a:	4618      	mov	r0, r3
20002e3c:	3710      	adds	r7, #16
20002e3e:	46bd      	mov	sp, r7
20002e40:	bd80      	pop	{r7, pc}
	...

20002e44 <cfe_cmd_dev_gethandle>:

static int cfe_cmd_dev_gethandle(cfe_devctx_t *ctx,cfe_iocb_t *iocb)
{
20002e44:	b480      	push	{r7}
20002e46:	b083      	sub	sp, #12
20002e48:	af00      	add	r7, sp, #0
20002e4a:	6078      	str	r0, [r7, #4]
20002e4c:	6039      	str	r1, [r7, #0]
    switch (iocb->iocb_flags) {
20002e4e:	683b      	ldr	r3, [r7, #0]
20002e50:	68db      	ldr	r3, [r3, #12]
20002e52:	2b00      	cmp	r3, #0
20002e54:	d10d      	bne.n	20002e72 <cfe_cmd_dev_gethandle+0x2e>
	case CFE_STDHANDLE_CONSOLE:
	    if (console_handle == -1) return CFE_ERR_DEVNOTFOUND;
20002e56:	4b0b      	ldr	r3, [pc, #44]	@ (20002e84 <cfe_cmd_dev_gethandle+0x40>)
20002e58:	681b      	ldr	r3, [r3, #0]
20002e5a:	f1b3 3fff 	cmp.w	r3, #4294967295	@ 0xffffffff
20002e5e:	d102      	bne.n	20002e66 <cfe_cmd_dev_gethandle+0x22>
20002e60:	f06f 0305 	mvn.w	r3, #5
20002e64:	e007      	b.n	20002e76 <cfe_cmd_dev_gethandle+0x32>
	    iocb->iocb_handle = console_handle;
20002e66:	4b07      	ldr	r3, [pc, #28]	@ (20002e84 <cfe_cmd_dev_gethandle+0x40>)
20002e68:	681a      	ldr	r2, [r3, #0]
20002e6a:	683b      	ldr	r3, [r7, #0]
20002e6c:	609a      	str	r2, [r3, #8]
	    return CFE_OK;
20002e6e:	2300      	movs	r3, #0
20002e70:	e001      	b.n	20002e76 <cfe_cmd_dev_gethandle+0x32>
	    break;
	default:
	    return CFE_ERR_INV_PARAM;
20002e72:	f06f 0307 	mvn.w	r3, #7
	}
}
20002e76:	4618      	mov	r0, r3
20002e78:	370c      	adds	r7, #12
20002e7a:	46bd      	mov	sp, r7
20002e7c:	f85d 7b04 	ldr.w	r7, [sp], #4
20002e80:	4770      	bx	lr
20002e82:	bf00      	nop
20002e84:	20005e70 	.word	0x20005e70

20002e88 <cfe_cmd_dev_open>:

static int cfe_cmd_dev_open(cfe_devctx_t *ctx,cfe_iocb_t *iocb)
{
20002e88:	b580      	push	{r7, lr}
20002e8a:	b096      	sub	sp, #88	@ 0x58
20002e8c:	af00      	add	r7, sp, #0
20002e8e:	6078      	str	r0, [r7, #4]
20002e90:	6039      	str	r1, [r7, #0]

    /*
     * Get device name
     */

    hsgetstr(devname,iocb->plist.iocb_buffer.buf_ptr,sizeof(devname));
20002e92:	683b      	ldr	r3, [r7, #0]
20002e94:	6a19      	ldr	r1, [r3, #32]
20002e96:	f107 030c 	add.w	r3, r7, #12
20002e9a:	2240      	movs	r2, #64	@ 0x40
20002e9c:	4618      	mov	r0, r3
20002e9e:	f7ff fe2f 	bl	20002b00 <hsgetstr>

    /*
     * Find device in device table
     */

    dev = cfe_finddev(devname);
20002ea2:	f107 030c 	add.w	r3, r7, #12
20002ea6:	4618      	mov	r0, r3
20002ea8:	f7fe fb78 	bl	2000159c <cfe_finddev>
20002eac:	6578      	str	r0, [r7, #84]	@ 0x54
    if (!dev) return CFE_ERR_DEVNOTFOUND;
20002eae:	6d7b      	ldr	r3, [r7, #84]	@ 0x54
20002eb0:	2b00      	cmp	r3, #0
20002eb2:	d102      	bne.n	20002eba <cfe_cmd_dev_open+0x32>
20002eb4:	f06f 0305 	mvn.w	r3, #5
20002eb8:	e047      	b.n	20002f4a <cfe_cmd_dev_open+0xc2>

    /*
     * Fail if someone else already has the device open
     */

    if (dev->dev_opencount > 0) return CFE_ERR_DEVOPEN;
20002eba:	6d7b      	ldr	r3, [r7, #84]	@ 0x54
20002ebc:	699b      	ldr	r3, [r3, #24]
20002ebe:	2b00      	cmp	r3, #0
20002ec0:	dd02      	ble.n	20002ec8 <cfe_cmd_dev_open+0x40>
20002ec2:	f06f 0306 	mvn.w	r3, #6
20002ec6:	e040      	b.n	20002f4a <cfe_cmd_dev_open+0xc2>

    /*
     * Generate a new handle
     */

    h = cfe_newhandle();
20002ec8:	f7ff fea6 	bl	20002c18 <cfe_newhandle>
20002ecc:	6538      	str	r0, [r7, #80]	@ 0x50
    if (h < 0) return CFE_ERR_NOMEM;
20002ece:	6d3b      	ldr	r3, [r7, #80]	@ 0x50
20002ed0:	2b00      	cmp	r3, #0
20002ed2:	da02      	bge.n	20002eda <cfe_cmd_dev_open+0x52>
20002ed4:	f06f 0304 	mvn.w	r3, #4
20002ed8:	e037      	b.n	20002f4a <cfe_cmd_dev_open+0xc2>

    /*
     * Allocate a context
     */

    ctx = (cfe_devctx_t *) KMALLOC(sizeof(cfe_devctx_t),0);
20002eda:	2200      	movs	r2, #0
20002edc:	210c      	movs	r1, #12
20002ede:	481d      	ldr	r0, [pc, #116]	@ (20002f54 <cfe_cmd_dev_open+0xcc>)
20002ee0:	f7fe f872 	bl	20000fc8 <kmalloc>
20002ee4:	6078      	str	r0, [r7, #4]
    if (ctx == NULL) return CFE_ERR_NOMEM;
20002ee6:	687b      	ldr	r3, [r7, #4]
20002ee8:	2b00      	cmp	r3, #0
20002eea:	d102      	bne.n	20002ef2 <cfe_cmd_dev_open+0x6a>
20002eec:	f06f 0304 	mvn.w	r3, #4
20002ef0:	e02b      	b.n	20002f4a <cfe_cmd_dev_open+0xc2>

    /*
     * Fill in the context
     */

    ctx->dev_dev = dev;
20002ef2:	687b      	ldr	r3, [r7, #4]
20002ef4:	6d7a      	ldr	r2, [r7, #84]	@ 0x54
20002ef6:	601a      	str	r2, [r3, #0]
    ctx->dev_softc = dev->dev_softc;
20002ef8:	6d7b      	ldr	r3, [r7, #84]	@ 0x54
20002efa:	68da      	ldr	r2, [r3, #12]
20002efc:	687b      	ldr	r3, [r7, #4]
20002efe:	605a      	str	r2, [r3, #4]
    ctx->dev_openinfo = NULL;
20002f00:	687b      	ldr	r3, [r7, #4]
20002f02:	2200      	movs	r2, #0
20002f04:	609a      	str	r2, [r3, #8]
    /*
     * Call driver's open func.  First claim the device number in case
     * the open routine itself calls cfe_newhandle().
     */

    cfe_handle_table[h] = ctx;
20002f06:	4914      	ldr	r1, [pc, #80]	@ (20002f58 <cfe_cmd_dev_open+0xd0>)
20002f08:	6d3b      	ldr	r3, [r7, #80]	@ 0x50
20002f0a:	687a      	ldr	r2, [r7, #4]
20002f0c:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
    res = dev->dev_dispatch->dev_open(ctx);
20002f10:	6d7b      	ldr	r3, [r7, #84]	@ 0x54
20002f12:	695b      	ldr	r3, [r3, #20]
20002f14:	681b      	ldr	r3, [r3, #0]
20002f16:	6878      	ldr	r0, [r7, #4]
20002f18:	4798      	blx	r3
20002f1a:	64f8      	str	r0, [r7, #76]	@ 0x4c

    if (res != 0) {
20002f1c:	6cfb      	ldr	r3, [r7, #76]	@ 0x4c
20002f1e:	2b00      	cmp	r3, #0
20002f20:	d00a      	beq.n	20002f38 <cfe_cmd_dev_open+0xb0>
	cfe_handle_table[h] = NULL;
20002f22:	4a0d      	ldr	r2, [pc, #52]	@ (20002f58 <cfe_cmd_dev_open+0xd0>)
20002f24:	6d3b      	ldr	r3, [r7, #80]	@ 0x50
20002f26:	2100      	movs	r1, #0
20002f28:	f842 1023 	str.w	r1, [r2, r3, lsl #2]
	KFREE(ctx);
20002f2c:	6879      	ldr	r1, [r7, #4]
20002f2e:	4809      	ldr	r0, [pc, #36]	@ (20002f54 <cfe_cmd_dev_open+0xcc>)
20002f30:	f7fe f816 	bl	20000f60 <kfree>
	return res;
20002f34:	6cfb      	ldr	r3, [r7, #76]	@ 0x4c
20002f36:	e008      	b.n	20002f4a <cfe_cmd_dev_open+0xc2>

    /*
     * Increment refcnt
     */

    dev->dev_opencount++;
20002f38:	6d7b      	ldr	r3, [r7, #84]	@ 0x54
20002f3a:	699b      	ldr	r3, [r3, #24]
20002f3c:	1c5a      	adds	r2, r3, #1
20002f3e:	6d7b      	ldr	r3, [r7, #84]	@ 0x54
20002f40:	619a      	str	r2, [r3, #24]
    iocb->iocb_handle = h;
20002f42:	683b      	ldr	r3, [r7, #0]
20002f44:	6d3a      	ldr	r2, [r7, #80]	@ 0x50
20002f46:	609a      	str	r2, [r3, #8]

    /*
     * Success!
     */

    return CFE_OK;
20002f48:	2300      	movs	r3, #0
}
20002f4a:	4618      	mov	r0, r3
20002f4c:	3758      	adds	r7, #88	@ 0x58
20002f4e:	46bd      	mov	sp, r7
20002f50:	bd80      	pop	{r7, pc}
20002f52:	bf00      	nop
20002f54:	20005e94 	.word	0x20005e94
20002f58:	20005fb4 	.word	0x20005fb4

20002f5c <cfe_cmd_dev_inpstat>:

static int cfe_cmd_dev_inpstat(cfe_devctx_t *ctx,cfe_iocb_t *iocb)
{
20002f5c:	b580      	push	{r7, lr}
20002f5e:	b084      	sub	sp, #16
20002f60:	af00      	add	r7, sp, #0
20002f62:	6078      	str	r0, [r7, #4]
20002f64:	6039      	str	r1, [r7, #0]
    int status;

    status = ctx->dev_dev->dev_dispatch->dev_inpstat(ctx,&(iocb->plist.iocb_inpstat));
20002f66:	687b      	ldr	r3, [r7, #4]
20002f68:	681b      	ldr	r3, [r3, #0]
20002f6a:	695b      	ldr	r3, [r3, #20]
20002f6c:	689b      	ldr	r3, [r3, #8]
20002f6e:	683a      	ldr	r2, [r7, #0]
20002f70:	3218      	adds	r2, #24
20002f72:	4611      	mov	r1, r2
20002f74:	6878      	ldr	r0, [r7, #4]
20002f76:	4798      	blx	r3
20002f78:	60f8      	str	r0, [r7, #12]

    return status;
20002f7a:	68fb      	ldr	r3, [r7, #12]
}
20002f7c:	4618      	mov	r0, r3
20002f7e:	3710      	adds	r7, #16
20002f80:	46bd      	mov	sp, r7
20002f82:	bd80      	pop	{r7, pc}

20002f84 <cfe_cmd_dev_read>:

static int cfe_cmd_dev_read(cfe_devctx_t *ctx,cfe_iocb_t *iocb)
{
20002f84:	b580      	push	{r7, lr}
20002f86:	b084      	sub	sp, #16
20002f88:	af00      	add	r7, sp, #0
20002f8a:	6078      	str	r0, [r7, #4]
20002f8c:	6039      	str	r1, [r7, #0]
    int status;

    status = ctx->dev_dev->dev_dispatch->dev_read(ctx,&(iocb->plist.iocb_buffer));
20002f8e:	687b      	ldr	r3, [r7, #4]
20002f90:	681b      	ldr	r3, [r3, #0]
20002f92:	695b      	ldr	r3, [r3, #20]
20002f94:	685b      	ldr	r3, [r3, #4]
20002f96:	683a      	ldr	r2, [r7, #0]
20002f98:	3218      	adds	r2, #24
20002f9a:	4611      	mov	r1, r2
20002f9c:	6878      	ldr	r0, [r7, #4]
20002f9e:	4798      	blx	r3
20002fa0:	60f8      	str	r0, [r7, #12]

    return status;
20002fa2:	68fb      	ldr	r3, [r7, #12]
}
20002fa4:	4618      	mov	r0, r3
20002fa6:	3710      	adds	r7, #16
20002fa8:	46bd      	mov	sp, r7
20002faa:	bd80      	pop	{r7, pc}

20002fac <cfe_cmd_dev_write>:

static int cfe_cmd_dev_write(cfe_devctx_t *ctx,cfe_iocb_t *iocb)
{
20002fac:	b580      	push	{r7, lr}
20002fae:	b084      	sub	sp, #16
20002fb0:	af00      	add	r7, sp, #0
20002fb2:	6078      	str	r0, [r7, #4]
20002fb4:	6039      	str	r1, [r7, #0]
    int status;

    status = ctx->dev_dev->dev_dispatch->dev_write(ctx,&(iocb->plist.iocb_buffer));
20002fb6:	687b      	ldr	r3, [r7, #4]
20002fb8:	681b      	ldr	r3, [r3, #0]
20002fba:	695b      	ldr	r3, [r3, #20]
20002fbc:	68db      	ldr	r3, [r3, #12]
20002fbe:	683a      	ldr	r2, [r7, #0]
20002fc0:	3218      	adds	r2, #24
20002fc2:	4611      	mov	r1, r2
20002fc4:	6878      	ldr	r0, [r7, #4]
20002fc6:	4798      	blx	r3
20002fc8:	60f8      	str	r0, [r7, #12]

    return status;
20002fca:	68fb      	ldr	r3, [r7, #12]
}
20002fcc:	4618      	mov	r0, r3
20002fce:	3710      	adds	r7, #16
20002fd0:	46bd      	mov	sp, r7
20002fd2:	bd80      	pop	{r7, pc}

20002fd4 <cfe_cmd_dev_ioctl>:

static int cfe_cmd_dev_ioctl(cfe_devctx_t *ctx,cfe_iocb_t *iocb)
{
20002fd4:	b580      	push	{r7, lr}
20002fd6:	b084      	sub	sp, #16
20002fd8:	af00      	add	r7, sp, #0
20002fda:	6078      	str	r0, [r7, #4]
20002fdc:	6039      	str	r1, [r7, #0]
    int status;

    status = ctx->dev_dev->dev_dispatch->dev_ioctl(ctx,&(iocb->plist.iocb_buffer));
20002fde:	687b      	ldr	r3, [r7, #4]
20002fe0:	681b      	ldr	r3, [r3, #0]
20002fe2:	695b      	ldr	r3, [r3, #20]
20002fe4:	691b      	ldr	r3, [r3, #16]
20002fe6:	683a      	ldr	r2, [r7, #0]
20002fe8:	3218      	adds	r2, #24
20002fea:	4611      	mov	r1, r2
20002fec:	6878      	ldr	r0, [r7, #4]
20002fee:	4798      	blx	r3
20002ff0:	60f8      	str	r0, [r7, #12]

    return status;
20002ff2:	68fb      	ldr	r3, [r7, #12]
}
20002ff4:	4618      	mov	r0, r3
20002ff6:	3710      	adds	r7, #16
20002ff8:	46bd      	mov	sp, r7
20002ffa:	bd80      	pop	{r7, pc}

20002ffc <cfe_cmd_dev_close>:

static int cfe_cmd_dev_close(cfe_devctx_t *ctx,cfe_iocb_t *iocb)
{
20002ffc:	b580      	push	{r7, lr}
20002ffe:	b082      	sub	sp, #8
20003000:	af00      	add	r7, sp, #0
20003002:	6078      	str	r0, [r7, #4]
20003004:	6039      	str	r1, [r7, #0]
    /*
     * Call device close function
     */

    ctx->dev_dev->dev_dispatch->dev_close(ctx);
20003006:	687b      	ldr	r3, [r7, #4]
20003008:	681b      	ldr	r3, [r3, #0]
2000300a:	695b      	ldr	r3, [r3, #20]
2000300c:	695b      	ldr	r3, [r3, #20]
2000300e:	6878      	ldr	r0, [r7, #4]
20003010:	4798      	blx	r3

    /*
     * Decrement refcnt
     */

    ctx->dev_dev->dev_opencount--;
20003012:	687b      	ldr	r3, [r7, #4]
20003014:	681b      	ldr	r3, [r3, #0]
20003016:	699a      	ldr	r2, [r3, #24]
20003018:	3a01      	subs	r2, #1
2000301a:	619a      	str	r2, [r3, #24]

    /*
     * Wipe out handle
     */

    cfe_handle_table[iocb->iocb_handle] = NULL;
2000301c:	683b      	ldr	r3, [r7, #0]
2000301e:	689b      	ldr	r3, [r3, #8]
20003020:	4a06      	ldr	r2, [pc, #24]	@ (2000303c <cfe_cmd_dev_close+0x40>)
20003022:	2100      	movs	r1, #0
20003024:	f842 1023 	str.w	r1, [r2, r3, lsl #2]

    /*
     * Release device context
     */

    KFREE(ctx);
20003028:	6879      	ldr	r1, [r7, #4]
2000302a:	4805      	ldr	r0, [pc, #20]	@ (20003040 <cfe_cmd_dev_close+0x44>)
2000302c:	f7fd ff98 	bl	20000f60 <kfree>

    return CFE_OK;
20003030:	2300      	movs	r3, #0
}
20003032:	4618      	mov	r0, r3
20003034:	3708      	adds	r7, #8
20003036:	46bd      	mov	sp, r7
20003038:	bd80      	pop	{r7, pc}
2000303a:	bf00      	nop
2000303c:	20005fb4 	.word	0x20005fb4
20003040:	20005e94 	.word	0x20005e94

20003044 <cfe_cmd_dev_getinfo>:

static int cfe_cmd_dev_getinfo(cfe_devctx_t *ctx,cfe_iocb_t *iocb)
{
20003044:	b580      	push	{r7, lr}
20003046:	b094      	sub	sp, #80	@ 0x50
20003048:	af00      	add	r7, sp, #0
2000304a:	6078      	str	r0, [r7, #4]
2000304c:	6039      	str	r1, [r7, #0]

    /*
     * Get device name
     */

    hsgetstr(devname,iocb->plist.iocb_buffer.buf_ptr,sizeof(devname));
2000304e:	683b      	ldr	r3, [r7, #0]
20003050:	6a19      	ldr	r1, [r3, #32]
20003052:	f107 0308 	add.w	r3, r7, #8
20003056:	2240      	movs	r2, #64	@ 0x40
20003058:	4618      	mov	r0, r3
2000305a:	f7ff fd51 	bl	20002b00 <hsgetstr>

    /*
     * Find device in device table
     */

    if ((x = strchr(devname,':'))) *x = '\0';
2000305e:	f107 0308 	add.w	r3, r7, #8
20003062:	213a      	movs	r1, #58	@ 0x3a
20003064:	4618      	mov	r0, r3
20003066:	f7fe f977 	bl	20001358 <lib_strchr>
2000306a:	64f8      	str	r0, [r7, #76]	@ 0x4c
2000306c:	6cfb      	ldr	r3, [r7, #76]	@ 0x4c
2000306e:	2b00      	cmp	r3, #0
20003070:	d002      	beq.n	20003078 <cfe_cmd_dev_getinfo+0x34>
20003072:	6cfb      	ldr	r3, [r7, #76]	@ 0x4c
20003074:	2200      	movs	r2, #0
20003076:	701a      	strb	r2, [r3, #0]
    dev = cfe_finddev(devname);
20003078:	f107 0308 	add.w	r3, r7, #8
2000307c:	4618      	mov	r0, r3
2000307e:	f7fe fa8d 	bl	2000159c <cfe_finddev>
20003082:	64b8      	str	r0, [r7, #72]	@ 0x48
    if (!dev) return CFE_ERR_DEVNOTFOUND;
20003084:	6cbb      	ldr	r3, [r7, #72]	@ 0x48
20003086:	2b00      	cmp	r3, #0
20003088:	d102      	bne.n	20003090 <cfe_cmd_dev_getinfo+0x4c>
2000308a:	f06f 0305 	mvn.w	r3, #5
2000308e:	e005      	b.n	2000309c <cfe_cmd_dev_getinfo+0x58>

    /*
     * Return device class
     */

    iocb->plist.iocb_buffer.buf_devflags = dev->dev_class;
20003090:	6cbb      	ldr	r3, [r7, #72]	@ 0x48
20003092:	691b      	ldr	r3, [r3, #16]
20003094:	461a      	mov	r2, r3
20003096:	683b      	ldr	r3, [r7, #0]
20003098:	62da      	str	r2, [r3, #44]	@ 0x2c

    return CFE_OK;
2000309a:	2300      	movs	r3, #0
}
2000309c:	4618      	mov	r0, r3
2000309e:	3750      	adds	r7, #80	@ 0x50
200030a0:	46bd      	mov	sp, r7
200030a2:	bd80      	pop	{r7, pc}

200030a4 <cfe_cmd_env_enum>:

static int cfe_cmd_env_enum(cfe_devctx_t *ctx,cfe_iocb_t *iocb)
{
200030a4:	b590      	push	{r4, r7, lr}
200030a6:	b089      	sub	sp, #36	@ 0x24
200030a8:	af02      	add	r7, sp, #8
200030aa:	6078      	str	r0, [r7, #4]
200030ac:	6039      	str	r1, [r7, #0]
    int vallen,namelen,res;

    namelen = iocb->plist.iocb_envbuf.name_length;
200030ae:	683b      	ldr	r3, [r7, #0]
200030b0:	6a1b      	ldr	r3, [r3, #32]
200030b2:	60fb      	str	r3, [r7, #12]
    vallen  = iocb->plist.iocb_envbuf.val_length;
200030b4:	683b      	ldr	r3, [r7, #0]
200030b6:	6a9b      	ldr	r3, [r3, #40]	@ 0x28
200030b8:	613b      	str	r3, [r7, #16]

    res = env_enum(iocb->plist.iocb_envbuf.enum_idx,
200030ba:	683b      	ldr	r3, [r7, #0]
200030bc:	6998      	ldr	r0, [r3, #24]
		   (char *)iocb->plist.iocb_envbuf.name_ptr,
200030be:	683b      	ldr	r3, [r7, #0]
200030c0:	69d9      	ldr	r1, [r3, #28]
		   &namelen,
		   (char *)iocb->plist.iocb_envbuf.val_ptr,
200030c2:	683b      	ldr	r3, [r7, #0]
200030c4:	6a5c      	ldr	r4, [r3, #36]	@ 0x24
    res = env_enum(iocb->plist.iocb_envbuf.enum_idx,
200030c6:	f107 020c 	add.w	r2, r7, #12
200030ca:	f107 0310 	add.w	r3, r7, #16
200030ce:	9300      	str	r3, [sp, #0]
200030d0:	4623      	mov	r3, r4
200030d2:	f000 fac3 	bl	2000365c <env_enum>
200030d6:	6178      	str	r0, [r7, #20]
		   &vallen);

    if (res < 0) return CFE_ERR_ENVNOTFOUND;
200030d8:	697b      	ldr	r3, [r7, #20]
200030da:	2b00      	cmp	r3, #0
200030dc:	da02      	bge.n	200030e4 <cfe_cmd_env_enum+0x40>
200030de:	f06f 0308 	mvn.w	r3, #8
200030e2:	e000      	b.n	200030e6 <cfe_cmd_env_enum+0x42>

    return CFE_OK;
200030e4:	2300      	movs	r3, #0
}
200030e6:	4618      	mov	r0, r3
200030e8:	371c      	adds	r7, #28
200030ea:	46bd      	mov	sp, r7
200030ec:	bd90      	pop	{r4, r7, pc}

200030ee <cfe_cmd_env_get>:


static int cfe_cmd_env_get(cfe_devctx_t *ctx,cfe_iocb_t *iocb)
{
200030ee:	b580      	push	{r7, lr}
200030f0:	b084      	sub	sp, #16
200030f2:	af00      	add	r7, sp, #0
200030f4:	6078      	str	r0, [r7, #4]
200030f6:	6039      	str	r1, [r7, #0]
    char *env;

    env = env_getenv((char *)iocb->plist.iocb_envbuf.name_ptr);
200030f8:	683b      	ldr	r3, [r7, #0]
200030fa:	69db      	ldr	r3, [r3, #28]
200030fc:	4618      	mov	r0, r3
200030fe:	f000 fb25 	bl	2000374c <env_getenv>
20003102:	60f8      	str	r0, [r7, #12]

    if (env == NULL) return CFE_ERR_ENVNOTFOUND;
20003104:	68fb      	ldr	r3, [r7, #12]
20003106:	2b00      	cmp	r3, #0
20003108:	d102      	bne.n	20003110 <cfe_cmd_env_get+0x22>
2000310a:	f06f 0308 	mvn.w	r3, #8
2000310e:	e008      	b.n	20003122 <cfe_cmd_env_get+0x34>

    xstrncpy((char *)iocb->plist.iocb_envbuf.val_ptr,
20003110:	683b      	ldr	r3, [r7, #0]
20003112:	6a58      	ldr	r0, [r3, #36]	@ 0x24
20003114:	683b      	ldr	r3, [r7, #0]
20003116:	6a9b      	ldr	r3, [r3, #40]	@ 0x28
20003118:	461a      	mov	r2, r3
2000311a:	68f9      	ldr	r1, [r7, #12]
2000311c:	f7fe f899 	bl	20001252 <lib_xstrncpy>
	     env,
	     iocb->plist.iocb_envbuf.val_length);

    return CFE_OK;
20003120:	2300      	movs	r3, #0
}
20003122:	4618      	mov	r0, r3
20003124:	3710      	adds	r7, #16
20003126:	46bd      	mov	sp, r7
20003128:	bd80      	pop	{r7, pc}

2000312a <cfe_cmd_env_set>:

static int cfe_cmd_env_set(cfe_devctx_t *ctx,cfe_iocb_t *iocb)
{
2000312a:	b580      	push	{r7, lr}
2000312c:	b084      	sub	sp, #16
2000312e:	af00      	add	r7, sp, #0
20003130:	6078      	str	r0, [r7, #4]
20003132:	6039      	str	r1, [r7, #0]
    int res;
    int flg;


    flg = (iocb->iocb_flags & CFE_FLG_ENV_PERMANENT) ? 
20003134:	683b      	ldr	r3, [r7, #0]
20003136:	68db      	ldr	r3, [r3, #12]
20003138:	f003 0301 	and.w	r3, r3, #1
	ENV_FLG_NORMAL : ENV_FLG_BUILTIN;
2000313c:	2b00      	cmp	r3, #0
2000313e:	bf0c      	ite	eq
20003140:	2301      	moveq	r3, #1
20003142:	2300      	movne	r3, #0
20003144:	b2db      	uxtb	r3, r3
    flg = (iocb->iocb_flags & CFE_FLG_ENV_PERMANENT) ? 
20003146:	60bb      	str	r3, [r7, #8]

    res = env_setenv((char *)iocb->plist.iocb_envbuf.name_ptr,
20003148:	683b      	ldr	r3, [r7, #0]
2000314a:	69d8      	ldr	r0, [r3, #28]
		     (char *)iocb->plist.iocb_envbuf.val_ptr,
2000314c:	683b      	ldr	r3, [r7, #0]
2000314e:	6a5b      	ldr	r3, [r3, #36]	@ 0x24
    res = env_setenv((char *)iocb->plist.iocb_envbuf.name_ptr,
20003150:	68ba      	ldr	r2, [r7, #8]
20003152:	4619      	mov	r1, r3
20003154:	f000 fb0e 	bl	20003774 <env_setenv>
20003158:	60f8      	str	r0, [r7, #12]
		     flg);

    if (res == 0) {
2000315a:	68fb      	ldr	r3, [r7, #12]
2000315c:	2b00      	cmp	r3, #0
2000315e:	d108      	bne.n	20003172 <cfe_cmd_env_set+0x48>
	if (iocb->iocb_flags & CFE_FLG_ENV_PERMANENT) res = env_save();
20003160:	683b      	ldr	r3, [r7, #0]
20003162:	68db      	ldr	r3, [r3, #12]
20003164:	f003 0301 	and.w	r3, r3, #1
20003168:	2b00      	cmp	r3, #0
2000316a:	d002      	beq.n	20003172 <cfe_cmd_env_set+0x48>
2000316c:	f000 fb66 	bl	2000383c <env_save>
20003170:	60f8      	str	r0, [r7, #12]
	}

    if (res < 0) return res;
20003172:	68fb      	ldr	r3, [r7, #12]
20003174:	2b00      	cmp	r3, #0
20003176:	da01      	bge.n	2000317c <cfe_cmd_env_set+0x52>
20003178:	68fb      	ldr	r3, [r7, #12]
2000317a:	e000      	b.n	2000317e <cfe_cmd_env_set+0x54>

    return CFE_OK;
2000317c:	2300      	movs	r3, #0
}
2000317e:	4618      	mov	r0, r3
20003180:	3710      	adds	r7, #16
20003182:	46bd      	mov	sp, r7
20003184:	bd80      	pop	{r7, pc}

20003186 <cfe_cmd_env_del>:

static int cfe_cmd_env_del(cfe_devctx_t *ctx,cfe_iocb_t *iocb)
{
20003186:	b580      	push	{r7, lr}
20003188:	b084      	sub	sp, #16
2000318a:	af00      	add	r7, sp, #0
2000318c:	6078      	str	r0, [r7, #4]
2000318e:	6039      	str	r1, [r7, #0]
    int res;
    int type;
    
    type = env_envtype((char *)iocb->plist.iocb_envbuf.name_ptr);
20003190:	683b      	ldr	r3, [r7, #0]
20003192:	69db      	ldr	r3, [r3, #28]
20003194:	4618      	mov	r0, r3
20003196:	f000 faa1 	bl	200036dc <env_envtype>
2000319a:	60f8      	str	r0, [r7, #12]

    /* 
     * Make sure we remove from NVRAM device, if it's there.
     */
    if ((res = env_delenv((char *)iocb->plist.iocb_envbuf.name_ptr)) == 0 ) {
2000319c:	683b      	ldr	r3, [r7, #0]
2000319e:	69db      	ldr	r3, [r3, #28]
200031a0:	4618      	mov	r0, r3
200031a2:	f000 faaf 	bl	20003704 <env_delenv>
200031a6:	60b8      	str	r0, [r7, #8]
200031a8:	68bb      	ldr	r3, [r7, #8]
200031aa:	2b00      	cmp	r3, #0
200031ac:	d107      	bne.n	200031be <cfe_cmd_env_del+0x38>
	if ((type >= 0) && (type != ENV_FLG_BUILTIN)) env_save();
200031ae:	68fb      	ldr	r3, [r7, #12]
200031b0:	2b00      	cmp	r3, #0
200031b2:	db04      	blt.n	200031be <cfe_cmd_env_del+0x38>
200031b4:	68fb      	ldr	r3, [r7, #12]
200031b6:	2b01      	cmp	r3, #1
200031b8:	d001      	beq.n	200031be <cfe_cmd_env_del+0x38>
200031ba:	f000 fb3f 	bl	2000383c <env_save>
	}

    return res;
200031be:	68bb      	ldr	r3, [r7, #8]
}
200031c0:	4618      	mov	r0, r3
200031c2:	3710      	adds	r7, #16
200031c4:	46bd      	mov	sp, r7
200031c6:	bd80      	pop	{r7, pc}

200031c8 <cfe_setup_default_env>:
    ********************************************************************* */

uint32_t mem_totalsize = 0x1000000;

static void cfe_setup_default_env(void)
{
200031c8:	b580      	push	{r7, lr}
200031ca:	b096      	sub	sp, #88	@ 0x58
200031cc:	af02      	add	r7, sp, #8
    char buffer[80];

    xsprintf(buffer,"%s%d.%d.%d",CFE_VER_PREFIX,CFE_VER_MAJOR,CFE_VER_MINOR,CFE_VER_BUILD);
200031ce:	4638      	mov	r0, r7
200031d0:	2302      	movs	r3, #2
200031d2:	9301      	str	r3, [sp, #4]
200031d4:	2301      	movs	r3, #1
200031d6:	9300      	str	r3, [sp, #0]
200031d8:	2300      	movs	r3, #0
200031da:	4a13      	ldr	r2, [pc, #76]	@ (20003228 <cfe_setup_default_env+0x60>)
200031dc:	4913      	ldr	r1, [pc, #76]	@ (2000322c <cfe_setup_default_env+0x64>)
200031de:	f7fd fd0d 	bl	20000bfc <xsprintf>
    env_setenv("CFE_VERSION",buffer,ENV_FLG_BUILTIN | ENV_FLG_READONLY);
200031e2:	463b      	mov	r3, r7
200031e4:	2203      	movs	r2, #3
200031e6:	4619      	mov	r1, r3
200031e8:	4811      	ldr	r0, [pc, #68]	@ (20003230 <cfe_setup_default_env+0x68>)
200031ea:	f000 fac3 	bl	20003774 <env_setenv>

    if (cfe_boardname) {
200031ee:	4b11      	ldr	r3, [pc, #68]	@ (20003234 <cfe_setup_default_env+0x6c>)
200031f0:	681b      	ldr	r3, [r3, #0]
200031f2:	2b00      	cmp	r3, #0
200031f4:	d006      	beq.n	20003204 <cfe_setup_default_env+0x3c>
	env_setenv("CFE_BOARDNAME",(char *) cfe_boardname,
200031f6:	4b0f      	ldr	r3, [pc, #60]	@ (20003234 <cfe_setup_default_env+0x6c>)
200031f8:	681b      	ldr	r3, [r3, #0]
200031fa:	2203      	movs	r2, #3
200031fc:	4619      	mov	r1, r3
200031fe:	480e      	ldr	r0, [pc, #56]	@ (20003238 <cfe_setup_default_env+0x70>)
20003200:	f000 fab8 	bl	20003774 <env_setenv>
		   ENV_FLG_BUILTIN | ENV_FLG_READONLY);
	}

    xsprintf(buffer,"%d",mem_totalsize);
20003204:	4b0d      	ldr	r3, [pc, #52]	@ (2000323c <cfe_setup_default_env+0x74>)
20003206:	681a      	ldr	r2, [r3, #0]
20003208:	463b      	mov	r3, r7
2000320a:	490d      	ldr	r1, [pc, #52]	@ (20003240 <cfe_setup_default_env+0x78>)
2000320c:	4618      	mov	r0, r3
2000320e:	f7fd fcf5 	bl	20000bfc <xsprintf>
    env_setenv("CFE_MEMORYSIZE",buffer,ENV_FLG_BUILTIN | ENV_FLG_READONLY);
20003212:	463b      	mov	r3, r7
20003214:	2203      	movs	r2, #3
20003216:	4619      	mov	r1, r3
20003218:	480a      	ldr	r0, [pc, #40]	@ (20003244 <cfe_setup_default_env+0x7c>)
2000321a:	f000 faab 	bl	20003774 <env_setenv>

}
2000321e:	bf00      	nop
20003220:	3750      	adds	r7, #80	@ 0x50
20003222:	46bd      	mov	sp, r7
20003224:	bd80      	pop	{r7, pc}
20003226:	bf00      	nop
20003228:	2000546c 	.word	0x2000546c
2000322c:	20005470 	.word	0x20005470
20003230:	2000547c 	.word	0x2000547c
20003234:	20005e74 	.word	0x20005e74
20003238:	20005488 	.word	0x20005488
2000323c:	20005e78 	.word	0x20005e78
20003240:	20005498 	.word	0x20005498
20003244:	2000549c 	.word	0x2000549c

20003248 <cfe_init_ui>:
#else
#define OPTIONAL(x) x
#endif

static void cfe_init_ui(void)
{
20003248:	b580      	push	{r7, lr}
2000324a:	af00      	add	r7, sp, #0
    ui_init_cmddisp();
2000324c:	f000 fb6a 	bl	20003924 <ui_init_cmddisp>



  //  OPTIONAL(ui_init_examcmds());

    OPTIONAL(ui_init_misccmds());
20003250:	f001 fcfa 	bl	20004c48 <ui_init_misccmds>
}
20003254:	bf00      	nop
20003256:	bd80      	pop	{r7, pc}

20003258 <cfe_leds>:
    *  Return value:
    *  	   nothing
    ********************************************************************* */

void cfe_leds(unsigned int val)
{
20003258:	b480      	push	{r7}
2000325a:	b083      	sub	sp, #12
2000325c:	af00      	add	r7, sp, #0
2000325e:	6078      	str	r0, [r7, #4]

}
20003260:	bf00      	nop
20003262:	370c      	adds	r7, #12
20003264:	46bd      	mov	sp, r7
20003266:	f85d 7b04 	ldr.w	r7, [sp], #4
2000326a:	4770      	bx	lr

2000326c <cfe_ledstr>:
void cfe_ledstr(const char *leds)
{
2000326c:	b580      	push	{r7, lr}
2000326e:	b084      	sub	sp, #16
20003270:	af00      	add	r7, sp, #0
20003272:	6078      	str	r0, [r7, #4]
    unsigned int val;

    val = ((((unsigned int) leds[0]) << 24) |
20003274:	687b      	ldr	r3, [r7, #4]
20003276:	781b      	ldrb	r3, [r3, #0]
20003278:	061a      	lsls	r2, r3, #24
	   (((unsigned int) leds[1]) << 16) |
2000327a:	687b      	ldr	r3, [r7, #4]
2000327c:	3301      	adds	r3, #1
2000327e:	781b      	ldrb	r3, [r3, #0]
20003280:	041b      	lsls	r3, r3, #16
    val = ((((unsigned int) leds[0]) << 24) |
20003282:	431a      	orrs	r2, r3
	   (((unsigned int) leds[2]) << 8) |
20003284:	687b      	ldr	r3, [r7, #4]
20003286:	3302      	adds	r3, #2
20003288:	781b      	ldrb	r3, [r3, #0]
2000328a:	021b      	lsls	r3, r3, #8
	   (((unsigned int) leds[1]) << 16) |
2000328c:	4313      	orrs	r3, r2
	   ((unsigned int) leds[3]));
2000328e:	687a      	ldr	r2, [r7, #4]
20003290:	3203      	adds	r2, #3
20003292:	7812      	ldrb	r2, [r2, #0]
    val = ((((unsigned int) leds[0]) << 24) |
20003294:	4313      	orrs	r3, r2
20003296:	60fb      	str	r3, [r7, #12]

    cfe_leds(val);
20003298:	68f8      	ldr	r0, [r7, #12]
2000329a:	f7ff ffdd 	bl	20003258 <cfe_leds>
}
2000329e:	bf00      	nop
200032a0:	3710      	adds	r7, #16
200032a2:	46bd      	mov	sp, r7
200032a4:	bd80      	pop	{r7, pc}
	...

200032a8 <cfe_say_hello>:
    *  	   nothing
    ********************************************************************* */


static void cfe_say_hello(void)
{
200032a8:	b580      	push	{r7, lr}
200032aa:	af00      	add	r7, sp, #0

    printf("Copyright (C) 2000,2001,2002,2003,2004,2005 Broadcom Corporation.\n");
200032ac:	4803      	ldr	r0, [pc, #12]	@ (200032bc <cfe_say_hello+0x14>)
200032ae:	f7fd fd17 	bl	20000ce0 <puts>
    printf("\n");
200032b2:	200a      	movs	r0, #10
200032b4:	f7fd fd20 	bl	20000cf8 <putchar>
}
200032b8:	bf00      	nop
200032ba:	bd80      	pop	{r7, pc}
200032bc:	200054ac 	.word	0x200054ac

200032c0 <cfe_startup_info>:
#define RELOCTEXT(x) ((x)-mem_textreloc)
#define RELOCDATA(x) ((x)-mem_datareloc)
#endif

static void cfe_startup_info(void)
{
200032c0:	b480      	push	{r7}
200032c2:	af00      	add	r7, sp, #0

}
200032c4:	bf00      	nop
200032c6:	46bd      	mov	sp, r7
200032c8:	f85d 7b04 	ldr.w	r7, [sp], #4
200032cc:	4770      	bx	lr
	...

200032d0 <cfe_main>:
    *  Return value:
    *  	   does not return
    ********************************************************************* */

void cfe_main(int a,int b)
{
200032d0:	b580      	push	{r7, lr}
200032d2:	b082      	sub	sp, #8
200032d4:	af00      	add	r7, sp, #0
200032d6:	6078      	str	r0, [r7, #4]
200032d8:	6039      	str	r1, [r7, #0]
     * 4. BSS has been zeroed.
     * 5. The data has been moved to R/W space.
     * 6. The "C" Stack has been initialized.
     */

    cfe_cpu_speed = 1000;
200032da:	4b21      	ldr	r3, [pc, #132]	@ (20003360 <cfe_main+0x90>)
200032dc:	f44f 727a 	mov.w	r2, #1000	@ 0x3e8
200032e0:	601a      	str	r2, [r3, #0]
    printf("Initializing Arena.\n");
200032e2:	4820      	ldr	r0, [pc, #128]	@ (20003364 <cfe_main+0x94>)
200032e4:	f7fd fcfc 	bl	20000ce0 <puts>

    cfe_bg_init();		       		/* init background processing */
200032e8:	f7fe fa4e 	bl	20001788 <cfe_bg_init>
    cfe_attach_init();
200032ec:	f7fe fa3c 	bl	20001768 <cfe_attach_init>
    cfe_timer_init(cfe_cpu_speed);		/* Timer process */
200032f0:	4b1b      	ldr	r3, [pc, #108]	@ (20003360 <cfe_main+0x90>)
200032f2:	681b      	ldr	r3, [r3, #0]
200032f4:	4618      	mov	r0, r3
200032f6:	f000 f931 	bl	2000355c <cfe_timer_init>
    /*
     * Initialize the memory allocator
     */

    extern uintptr_t _ebss;
    SETLEDS("KMEM");
200032fa:	481b      	ldr	r0, [pc, #108]	@ (20003368 <cfe_main+0x98>)
200032fc:	f7ff ffb6 	bl	2000326c <cfe_ledstr>
    KMEMINIT((unsigned char *) (uintptr_t) &_ebss,
20003300:	f44f 3280 	mov.w	r2, #65536	@ 0x10000
20003304:	4919      	ldr	r1, [pc, #100]	@ (2000336c <cfe_main+0x9c>)
20003306:	481a      	ldr	r0, [pc, #104]	@ (20003370 <cfe_main+0xa0>)
20003308:	f7fd fdb8 	bl	20000e7c <kmeminit>
     * Initialize the console.  It is done before the other devices
     * get turned on.  The console init also sets the variable that
     * contains the CPU speed.
     */

    SETLEDS("CONS");
2000330c:	4819      	ldr	r0, [pc, #100]	@ (20003374 <cfe_main+0xa4>)
2000330e:	f7ff ffad 	bl	2000326c <cfe_ledstr>

    board_init();
20003312:	f7fd fda1 	bl	20000e58 <board_init>

    /*
     * Say hello.
     */

    SETLEDS("CIOK");
20003316:	4818      	ldr	r0, [pc, #96]	@ (20003378 <cfe_main+0xa8>)
20003318:	f7ff ffa8 	bl	2000326c <cfe_ledstr>
    cfe_say_hello();
2000331c:	f7ff ffc4 	bl	200032a8 <cfe_say_hello>

    /*
     * Initialize the other devices.
     */

    SETLEDS("AREN");
20003320:	4816      	ldr	r0, [pc, #88]	@ (2000337c <cfe_main+0xac>)
20003322:	f7ff ffa3 	bl	2000326c <cfe_ledstr>
    printf("Initializing Arena.\n");
20003326:	480f      	ldr	r0, [pc, #60]	@ (20003364 <cfe_main+0x94>)
20003328:	f7fd fcda 	bl	20000ce0 <puts>
    cfe_arena_init();
2000332c:	f000 f862 	bl	200033f4 <cfe_arena_init>


    SETLEDS("DEVI");
20003330:	4813      	ldr	r0, [pc, #76]	@ (20003380 <cfe_main+0xb0>)
20003332:	f7ff ff9b 	bl	2000326c <cfe_ledstr>
    printf("Initializing Devices.\n");
20003336:	4813      	ldr	r0, [pc, #76]	@ (20003384 <cfe_main+0xb4>)
20003338:	f7fd fcd2 	bl	20000ce0 <puts>
  //  board_device_init();

    cfe_startup_info();
2000333c:	f7ff ffc0 	bl	200032c0 <cfe_startup_info>
    SETLEDS("ENVI");
20003340:	4811      	ldr	r0, [pc, #68]	@ (20003388 <cfe_main+0xb8>)
20003342:	f7ff ff93 	bl	2000326c <cfe_ledstr>
    cfe_setup_default_env();
20003346:	f7ff ff3f 	bl	200031c8 <cfe_setup_default_env>

    printf("\n");
2000334a:	200a      	movs	r0, #10
2000334c:	f7fd fcd4 	bl	20000cf8 <putchar>


    cfe_init_ui();
20003350:	f7ff ff7a 	bl	20003248 <cfe_init_ui>

  //  board_final_init();


   // cfe_autostart();
    cfe_command_loop();
20003354:	f000 f81a 	bl	2000338c <cfe_command_loop>

}
20003358:	bf00      	nop
2000335a:	3708      	adds	r7, #8
2000335c:	46bd      	mov	sp, r7
2000335e:	bd80      	pop	{r7, pc}
20003360:	200060e0 	.word	0x200060e0
20003364:	200054f8 	.word	0x200054f8
20003368:	2000550c 	.word	0x2000550c
2000336c:	20006100 	.word	0x20006100
20003370:	20005e94 	.word	0x20005e94
20003374:	20005514 	.word	0x20005514
20003378:	2000551c 	.word	0x2000551c
2000337c:	20005524 	.word	0x20005524
20003380:	2000552c 	.word	0x2000552c
20003384:	20005534 	.word	0x20005534
20003388:	2000554c 	.word	0x2000554c

2000338c <cfe_command_loop>:
    *  Return value:
    *  	   does not return
    ********************************************************************* */

void cfe_command_loop()
{
2000338c:	b580      	push	{r7, lr}
2000338e:	b0ce      	sub	sp, #312	@ 0x138
20003390:	af00      	add	r7, sp, #0

    char buffer[300];
    int status;
    char *prompt;

    SETLEDS("CFE ");
20003392:	4814      	ldr	r0, [pc, #80]	@ (200033e4 <cfe_command_loop+0x58>)
20003394:	f7ff ff6a 	bl	2000326c <cfe_ledstr>

    for (;;) {
	prompt = env_getenv("PROMPT");
20003398:	4813      	ldr	r0, [pc, #76]	@ (200033e8 <cfe_command_loop+0x5c>)
2000339a:	f000 f9d7 	bl	2000374c <env_getenv>
2000339e:	f8c7 0134 	str.w	r0, [r7, #308]	@ 0x134

	if (!prompt) prompt = "CFE> ";
200033a2:	f8d7 3134 	ldr.w	r3, [r7, #308]	@ 0x134
200033a6:	2b00      	cmp	r3, #0
200033a8:	d102      	bne.n	200033b0 <cfe_command_loop+0x24>
200033aa:	4b10      	ldr	r3, [pc, #64]	@ (200033ec <cfe_command_loop+0x60>)
200033ac:	f8c7 3134 	str.w	r3, [r7, #308]	@ 0x134

	console_readline(prompt,buffer,sizeof(buffer));
200033b0:	1d3b      	adds	r3, r7, #4
200033b2:	f44f 7296 	mov.w	r2, #300	@ 0x12c
200033b6:	4619      	mov	r1, r3
200033b8:	f8d7 0134 	ldr.w	r0, [r7, #308]	@ 0x134
200033bc:	f7ff fa6c 	bl	20002898 <console_readline>

	status = ui_docommands(buffer);
200033c0:	1d3b      	adds	r3, r7, #4
200033c2:	4618      	mov	r0, r3
200033c4:	f000 fb2a 	bl	20003a1c <ui_docommands>
200033c8:	f8c7 0130 	str.w	r0, [r7, #304]	@ 0x130

	if (status != CMD_ERR_BLANK) {
200033cc:	f8d7 3130 	ldr.w	r3, [r7, #304]	@ 0x130
200033d0:	f113 0f03 	cmn.w	r3, #3
200033d4:	d0e0      	beq.n	20003398 <cfe_command_loop+0xc>
	    printf("*** command status = %d\n", status);
200033d6:	f8d7 1130 	ldr.w	r1, [r7, #304]	@ 0x130
200033da:	4805      	ldr	r0, [pc, #20]	@ (200033f0 <cfe_command_loop+0x64>)
200033dc:	f7fd fc24 	bl	20000c28 <printf>
	prompt = env_getenv("PROMPT");
200033e0:	e7da      	b.n	20003398 <cfe_command_loop+0xc>
200033e2:	bf00      	nop
200033e4:	20005574 	.word	0x20005574
200033e8:	2000557c 	.word	0x2000557c
200033ec:	20005584 	.word	0x20005584
200033f0:	2000558c 	.word	0x2000558c

200033f4 <cfe_arena_init>:
    *  Return value:
    *  	   nothing
    ********************************************************************* */

void cfe_arena_init(void)
{
200033f4:	b480      	push	{r7}
200033f6:	af00      	add	r7, sp, #0
    //memlo = PHYSADDR(mem_bottomofmem) & ~4095;




}
200033f8:	bf00      	nop
200033fa:	46bd      	mov	sp, r7
200033fc:	f85d 7b04 	ldr.w	r7, [sp], #4
20003400:	4770      	bx	lr
	...

20003404 <cfe_arena_enum>:
    *  	   0 if ok
    *  	   CFE_ERR_NOMORE if idx is beyond the last entry
    ********************************************************************* */

int cfe_arena_enum(int idx,int *type,uint64_t *start,uint64_t *size,int allrecs)
{
20003404:	b480      	push	{r7}
20003406:	b089      	sub	sp, #36	@ 0x24
20003408:	af00      	add	r7, sp, #0
2000340a:	60f8      	str	r0, [r7, #12]
2000340c:	60b9      	str	r1, [r7, #8]
2000340e:	607a      	str	r2, [r7, #4]
20003410:	603b      	str	r3, [r7, #0]
    arena_node_t *node;
    queue_t *qb;
    arena_t *arena = &cfe_arena;
20003412:	4b1c      	ldr	r3, [pc, #112]	@ (20003484 <cfe_arena_enum+0x80>)
20003414:	61bb      	str	r3, [r7, #24]


    for (qb = (arena->arena_list.q_next); qb != &(arena->arena_list);
20003416:	69bb      	ldr	r3, [r7, #24]
20003418:	681b      	ldr	r3, [r3, #0]
2000341a:	61fb      	str	r3, [r7, #28]
2000341c:	e026      	b.n	2000346c <cfe_arena_enum+0x68>
	 qb = qb->q_next) {
	node = (arena_node_t *) qb;
2000341e:	69fb      	ldr	r3, [r7, #28]
20003420:	617b      	str	r3, [r7, #20]

	if (allrecs || (!allrecs && (node->an_type == MEMTYPE_DRAM_AVAILABLE))) {
20003422:	6abb      	ldr	r3, [r7, #40]	@ 0x28
20003424:	2b00      	cmp	r3, #0
20003426:	d106      	bne.n	20003436 <cfe_arena_enum+0x32>
20003428:	6abb      	ldr	r3, [r7, #40]	@ 0x28
2000342a:	2b00      	cmp	r3, #0
2000342c:	d11b      	bne.n	20003466 <cfe_arena_enum+0x62>
2000342e:	697b      	ldr	r3, [r7, #20]
20003430:	699b      	ldr	r3, [r3, #24]
20003432:	2b01      	cmp	r3, #1
20003434:	d117      	bne.n	20003466 <cfe_arena_enum+0x62>
	    if (idx == 0) {
20003436:	68fb      	ldr	r3, [r7, #12]
20003438:	2b00      	cmp	r3, #0
2000343a:	d111      	bne.n	20003460 <cfe_arena_enum+0x5c>
		*type = node->an_type;
2000343c:	697b      	ldr	r3, [r7, #20]
2000343e:	699a      	ldr	r2, [r3, #24]
20003440:	68bb      	ldr	r3, [r7, #8]
20003442:	601a      	str	r2, [r3, #0]
		*start = node->an_address;
20003444:	697b      	ldr	r3, [r7, #20]
20003446:	e9d3 2302 	ldrd	r2, r3, [r3, #8]
2000344a:	6879      	ldr	r1, [r7, #4]
2000344c:	e9c1 2300 	strd	r2, r3, [r1]
		*size = node->an_length;
20003450:	697b      	ldr	r3, [r7, #20]
20003452:	e9d3 2304 	ldrd	r2, r3, [r3, #16]
20003456:	6839      	ldr	r1, [r7, #0]
20003458:	e9c1 2300 	strd	r2, r3, [r1]
		return 0;
2000345c:	2300      	movs	r3, #0
2000345e:	e00b      	b.n	20003478 <cfe_arena_enum+0x74>
		}
	    idx--;
20003460:	68fb      	ldr	r3, [r7, #12]
20003462:	3b01      	subs	r3, #1
20003464:	60fb      	str	r3, [r7, #12]
	 qb = qb->q_next) {
20003466:	69fb      	ldr	r3, [r7, #28]
20003468:	681b      	ldr	r3, [r3, #0]
2000346a:	61fb      	str	r3, [r7, #28]
    for (qb = (arena->arena_list.q_next); qb != &(arena->arena_list);
2000346c:	69bb      	ldr	r3, [r7, #24]
2000346e:	69fa      	ldr	r2, [r7, #28]
20003470:	429a      	cmp	r2, r3
20003472:	d1d4      	bne.n	2000341e <cfe_arena_enum+0x1a>
	    }
	}

    return CFE_ERR_NOMORE;
20003474:	f06f 031b 	mvn.w	r3, #27

}
20003478:	4618      	mov	r0, r3
2000347a:	3724      	adds	r7, #36	@ 0x24
2000347c:	46bd      	mov	sp, r7
2000347e:	f85d 7b04 	ldr.w	r7, [sp], #4
20003482:	4770      	bx	lr
20003484:	200060b8 	.word	0x200060b8

20003488 <_getticks>:
    *  Return value:
    *  	   nothing
    ********************************************************************* */

uint32_t _getticks()
{
20003488:	b480      	push	{r7}
2000348a:	af00      	add	r7, sp, #0
	return 1000;
2000348c:	f44f 737a 	mov.w	r3, #1000	@ 0x3e8
}
20003490:	4618      	mov	r0, r3
20003492:	46bd      	mov	sp, r7
20003494:	f85d 7b04 	ldr.w	r7, [sp], #4
20003498:	4770      	bx	lr
	...

2000349c <cfe_timer_task>:
static void cfe_timer_task(void *arg)
{
2000349c:	e92d 4fb0 	stmdb	sp!, {r4, r5, r7, r8, r9, sl, fp, lr}
200034a0:	b086      	sub	sp, #24
200034a2:	af00      	add	r7, sp, #0
200034a4:	6078      	str	r0, [r7, #4]
    uint32_t count;
    uint32_t deltaticks;
    uint32_t clockspertick;

    clockspertick = cfe_clocks_per_tick;
200034a6:	4b29      	ldr	r3, [pc, #164]	@ (2000354c <cfe_timer_task+0xb0>)
200034a8:	681b      	ldr	r3, [r3, #0]
200034aa:	617b      	str	r3, [r7, #20]

    count = _getticks();
200034ac:	f7ff ffec 	bl	20003488 <_getticks>
200034b0:	6138      	str	r0, [r7, #16]
    deltaticks    = (count - cfe_oldcount);
200034b2:	4b27      	ldr	r3, [pc, #156]	@ (20003550 <cfe_timer_task+0xb4>)
200034b4:	681b      	ldr	r3, [r3, #0]
200034b6:	693a      	ldr	r2, [r7, #16]
200034b8:	1ad3      	subs	r3, r2, r3
200034ba:	60fb      	str	r3, [r7, #12]
    cfe_remticks += deltaticks;
200034bc:	4b25      	ldr	r3, [pc, #148]	@ (20003554 <cfe_timer_task+0xb8>)
200034be:	681a      	ldr	r2, [r3, #0]
200034c0:	68fb      	ldr	r3, [r7, #12]
200034c2:	4413      	add	r3, r2
200034c4:	4a23      	ldr	r2, [pc, #140]	@ (20003554 <cfe_timer_task+0xb8>)
200034c6:	6013      	str	r3, [r2, #0]
     * assume it only moved by one tick and use a simple
     * loop to update it.  This loop probably will not
     * execute more than once.
     */

    if (cfe_remticks > (clockspertick << 4)) {
200034c8:	697b      	ldr	r3, [r7, #20]
200034ca:	011a      	lsls	r2, r3, #4
200034cc:	4b21      	ldr	r3, [pc, #132]	@ (20003554 <cfe_timer_task+0xb8>)
200034ce:	681b      	ldr	r3, [r3, #0]
200034d0:	429a      	cmp	r2, r3
200034d2:	d22d      	bcs.n	20003530 <cfe_timer_task+0x94>
        cfe_ticks += (cfe_remticks / clockspertick);
200034d4:	4b1f      	ldr	r3, [pc, #124]	@ (20003554 <cfe_timer_task+0xb8>)
200034d6:	681a      	ldr	r2, [r3, #0]
200034d8:	697b      	ldr	r3, [r7, #20]
200034da:	fbb2 f3f3 	udiv	r3, r2, r3
200034de:	2200      	movs	r2, #0
200034e0:	461c      	mov	r4, r3
200034e2:	4615      	mov	r5, r2
200034e4:	4b1c      	ldr	r3, [pc, #112]	@ (20003558 <cfe_timer_task+0xbc>)
200034e6:	e9d3 2300 	ldrd	r2, r3, [r3]
200034ea:	eb14 0a02 	adds.w	sl, r4, r2
200034ee:	eb45 0b03 	adc.w	fp, r5, r3
200034f2:	4b19      	ldr	r3, [pc, #100]	@ (20003558 <cfe_timer_task+0xbc>)
200034f4:	e9c3 ab00 	strd	sl, fp, [r3]
        cfe_remticks %= clockspertick;
200034f8:	4b16      	ldr	r3, [pc, #88]	@ (20003554 <cfe_timer_task+0xb8>)
200034fa:	681b      	ldr	r3, [r3, #0]
200034fc:	697a      	ldr	r2, [r7, #20]
200034fe:	fbb3 f2f2 	udiv	r2, r3, r2
20003502:	6979      	ldr	r1, [r7, #20]
20003504:	fb01 f202 	mul.w	r2, r1, r2
20003508:	1a9b      	subs	r3, r3, r2
2000350a:	4a12      	ldr	r2, [pc, #72]	@ (20003554 <cfe_timer_task+0xb8>)
2000350c:	6013      	str	r3, [r2, #0]
2000350e:	e014      	b.n	2000353a <cfe_timer_task+0x9e>
        }
    else {
        while (cfe_remticks > clockspertick) {
            cfe_remticks -= clockspertick;
20003510:	4b10      	ldr	r3, [pc, #64]	@ (20003554 <cfe_timer_task+0xb8>)
20003512:	681a      	ldr	r2, [r3, #0]
20003514:	697b      	ldr	r3, [r7, #20]
20003516:	1ad3      	subs	r3, r2, r3
20003518:	4a0e      	ldr	r2, [pc, #56]	@ (20003554 <cfe_timer_task+0xb8>)
2000351a:	6013      	str	r3, [r2, #0]
            cfe_ticks++;
2000351c:	4b0e      	ldr	r3, [pc, #56]	@ (20003558 <cfe_timer_task+0xbc>)
2000351e:	e9d3 2300 	ldrd	r2, r3, [r3]
20003522:	f112 0801 	adds.w	r8, r2, #1
20003526:	f143 0900 	adc.w	r9, r3, #0
2000352a:	4b0b      	ldr	r3, [pc, #44]	@ (20003558 <cfe_timer_task+0xbc>)
2000352c:	e9c3 8900 	strd	r8, r9, [r3]
        while (cfe_remticks > clockspertick) {
20003530:	4b08      	ldr	r3, [pc, #32]	@ (20003554 <cfe_timer_task+0xb8>)
20003532:	681b      	ldr	r3, [r3, #0]
20003534:	697a      	ldr	r2, [r7, #20]
20003536:	429a      	cmp	r2, r3
20003538:	d3ea      	bcc.n	20003510 <cfe_timer_task+0x74>
            }
        }

    cfe_oldcount = count;
2000353a:	4a05      	ldr	r2, [pc, #20]	@ (20003550 <cfe_timer_task+0xb4>)
2000353c:	693b      	ldr	r3, [r7, #16]
2000353e:	6013      	str	r3, [r2, #0]
}
20003540:	bf00      	nop
20003542:	3718      	adds	r7, #24
20003544:	46bd      	mov	sp, r7
20003546:	e8bd 8fb0 	ldmia.w	sp!, {r4, r5, r7, r8, r9, sl, fp, pc}
2000354a:	bf00      	nop
2000354c:	200060ec 	.word	0x200060ec
20003550:	200060f0 	.word	0x200060f0
20003554:	200060f4 	.word	0x200060f4
20003558:	200060d8 	.word	0x200060d8

2000355c <cfe_timer_init>:
    *  Return value:
    *  	   nothing
    ********************************************************************* */

void cfe_timer_init(unsigned int cpu_speed)
{
2000355c:	b580      	push	{r7, lr}
2000355e:	b082      	sub	sp, #8
20003560:	af00      	add	r7, sp, #0
20003562:	6078      	str	r0, [r7, #4]
    cfe_clocks_per_tick = CFE_CLOCKSPERTICK(cpu_speed);
20003564:	687b      	ldr	r3, [r7, #4]
20003566:	4a1e      	ldr	r2, [pc, #120]	@ (200035e0 <cfe_timer_init+0x84>)
20003568:	fba2 2303 	umull	r2, r3, r2, r3
2000356c:	08db      	lsrs	r3, r3, #3
2000356e:	4a1d      	ldr	r2, [pc, #116]	@ (200035e4 <cfe_timer_init+0x88>)
20003570:	6013      	str	r3, [r2, #0]
    cfe_clocks_per_Kns = CFE_CLOCKSPERKNS(cpu_speed);
20003572:	687b      	ldr	r3, [r7, #4]
20003574:	4a1c      	ldr	r2, [pc, #112]	@ (200035e8 <cfe_timer_init+0x8c>)
20003576:	fba2 2303 	umull	r2, r3, r2, r3
2000357a:	0cdb      	lsrs	r3, r3, #19
2000357c:	4a1b      	ldr	r2, [pc, #108]	@ (200035ec <cfe_timer_init+0x90>)
2000357e:	6013      	str	r3, [r2, #0]
    if (cfe_clocks_per_Kns == 0)
20003580:	4b1a      	ldr	r3, [pc, #104]	@ (200035ec <cfe_timer_init+0x90>)
20003582:	681b      	ldr	r3, [r3, #0]
20003584:	2b00      	cmp	r3, #0
20003586:	d102      	bne.n	2000358e <cfe_timer_init+0x32>
	cfe_clocks_per_Kns = 1;    /* for the simulator */
20003588:	4b18      	ldr	r3, [pc, #96]	@ (200035ec <cfe_timer_init+0x90>)
2000358a:	2201      	movs	r2, #1
2000358c:	601a      	str	r2, [r3, #0]
    cfe_clocks_per_usec = CFE_CLOCKSPERUSEC(cpu_speed);
2000358e:	687b      	ldr	r3, [r7, #4]
20003590:	4a17      	ldr	r2, [pc, #92]	@ (200035f0 <cfe_timer_init+0x94>)
20003592:	fba2 2303 	umull	r2, r3, r2, r3
20003596:	0c9b      	lsrs	r3, r3, #18
20003598:	4a16      	ldr	r2, [pc, #88]	@ (200035f4 <cfe_timer_init+0x98>)
2000359a:	6013      	str	r3, [r2, #0]
    if (cfe_clocks_per_usec == 0)
2000359c:	4b15      	ldr	r3, [pc, #84]	@ (200035f4 <cfe_timer_init+0x98>)
2000359e:	681b      	ldr	r3, [r3, #0]
200035a0:	2b00      	cmp	r3, #0
200035a2:	d102      	bne.n	200035aa <cfe_timer_init+0x4e>
	cfe_clocks_per_usec = 1;    /* for the simulator */
200035a4:	4b13      	ldr	r3, [pc, #76]	@ (200035f4 <cfe_timer_init+0x98>)
200035a6:	2201      	movs	r2, #1
200035a8:	601a      	str	r2, [r3, #0]

    cfe_oldcount = _getticks();		/* get current COUNT register */
200035aa:	f7ff ff6d 	bl	20003488 <_getticks>
200035ae:	4603      	mov	r3, r0
200035b0:	4a11      	ldr	r2, [pc, #68]	@ (200035f8 <cfe_timer_init+0x9c>)
200035b2:	6013      	str	r3, [r2, #0]
    cfe_ticks = 0;
200035b4:	4911      	ldr	r1, [pc, #68]	@ (200035fc <cfe_timer_init+0xa0>)
200035b6:	f04f 0200 	mov.w	r2, #0
200035ba:	f04f 0300 	mov.w	r3, #0
200035be:	e9c1 2300 	strd	r2, r3, [r1]

    if (!cfe_timer_initflg) {
200035c2:	4b0f      	ldr	r3, [pc, #60]	@ (20003600 <cfe_timer_init+0xa4>)
200035c4:	681b      	ldr	r3, [r3, #0]
200035c6:	2b00      	cmp	r3, #0
200035c8:	d106      	bne.n	200035d8 <cfe_timer_init+0x7c>
	cfe_bg_add(cfe_timer_task,NULL); /* add task for background polling */
200035ca:	2100      	movs	r1, #0
200035cc:	480d      	ldr	r0, [pc, #52]	@ (20003604 <cfe_timer_init+0xa8>)
200035ce:	f7fe f8e7 	bl	200017a0 <cfe_bg_add>
	cfe_timer_initflg = 1;
200035d2:	4b0b      	ldr	r3, [pc, #44]	@ (20003600 <cfe_timer_init+0xa4>)
200035d4:	2201      	movs	r2, #1
200035d6:	601a      	str	r2, [r3, #0]
	}
}
200035d8:	bf00      	nop
200035da:	3708      	adds	r7, #8
200035dc:	46bd      	mov	sp, r7
200035de:	bd80      	pop	{r7, pc}
200035e0:	cccccccd 	.word	0xcccccccd
200035e4:	200060ec 	.word	0x200060ec
200035e8:	89705aa5 	.word	0x89705aa5
200035ec:	200060e4 	.word	0x200060e4
200035f0:	431bde83 	.word	0x431bde83
200035f4:	200060e8 	.word	0x200060e8
200035f8:	200060f0 	.word	0x200060f0
200035fc:	200060d8 	.word	0x200060d8
20003600:	200060f8 	.word	0x200060f8
20003604:	2000349d 	.word	0x2000349d

20003608 <env_findenv>:
    *  Return value:
    *  	   cfe_envvar_t pointer, or NULL if not found
    ********************************************************************* */

static cfe_envvar_t *env_findenv(const char *name)
{
20003608:	b580      	push	{r7, lr}
2000360a:	b084      	sub	sp, #16
2000360c:	af00      	add	r7, sp, #0
2000360e:	6078      	str	r0, [r7, #4]
    queue_t *qb;
    cfe_envvar_t *env;

    for (qb = env_envvars.q_next; qb != &env_envvars; qb = qb->q_next) {
20003610:	4b11      	ldr	r3, [pc, #68]	@ (20003658 <env_findenv+0x50>)
20003612:	681b      	ldr	r3, [r3, #0]
20003614:	60fb      	str	r3, [r7, #12]
20003616:	e00d      	b.n	20003634 <env_findenv+0x2c>
	env = (cfe_envvar_t *) qb;
20003618:	68fb      	ldr	r3, [r7, #12]
2000361a:	60bb      	str	r3, [r7, #8]
	if (strcmp(env->name,name) == 0) break;
2000361c:	68bb      	ldr	r3, [r7, #8]
2000361e:	68db      	ldr	r3, [r3, #12]
20003620:	6879      	ldr	r1, [r7, #4]
20003622:	4618      	mov	r0, r3
20003624:	f7fd fe57 	bl	200012d6 <lib_strcmp>
20003628:	4603      	mov	r3, r0
2000362a:	2b00      	cmp	r3, #0
2000362c:	d007      	beq.n	2000363e <env_findenv+0x36>
    for (qb = env_envvars.q_next; qb != &env_envvars; qb = qb->q_next) {
2000362e:	68fb      	ldr	r3, [r7, #12]
20003630:	681b      	ldr	r3, [r3, #0]
20003632:	60fb      	str	r3, [r7, #12]
20003634:	68fb      	ldr	r3, [r7, #12]
20003636:	4a08      	ldr	r2, [pc, #32]	@ (20003658 <env_findenv+0x50>)
20003638:	4293      	cmp	r3, r2
2000363a:	d1ed      	bne.n	20003618 <env_findenv+0x10>
2000363c:	e000      	b.n	20003640 <env_findenv+0x38>
	if (strcmp(env->name,name) == 0) break;
2000363e:	bf00      	nop
	}

    if (qb == &env_envvars) return NULL;
20003640:	68fb      	ldr	r3, [r7, #12]
20003642:	4a05      	ldr	r2, [pc, #20]	@ (20003658 <env_findenv+0x50>)
20003644:	4293      	cmp	r3, r2
20003646:	d101      	bne.n	2000364c <env_findenv+0x44>
20003648:	2300      	movs	r3, #0
2000364a:	e000      	b.n	2000364e <env_findenv+0x46>

    return (cfe_envvar_t *) qb;
2000364c:	68fb      	ldr	r3, [r7, #12]

}
2000364e:	4618      	mov	r0, r3
20003650:	3710      	adds	r7, #16
20003652:	46bd      	mov	sp, r7
20003654:	bd80      	pop	{r7, pc}
20003656:	bf00      	nop
20003658:	20005e7c 	.word	0x20005e7c

2000365c <env_enum>:
    *  	   0 if ok
    *  	   else error code
    ********************************************************************* */

int env_enum(int idx,char *name,int *namelen,char *val,int *vallen)
{
2000365c:	b580      	push	{r7, lr}
2000365e:	b086      	sub	sp, #24
20003660:	af00      	add	r7, sp, #0
20003662:	60f8      	str	r0, [r7, #12]
20003664:	60b9      	str	r1, [r7, #8]
20003666:	607a      	str	r2, [r7, #4]
20003668:	603b      	str	r3, [r7, #0]
    queue_t *qb;
    cfe_envvar_t *env;

    for (qb = env_envvars.q_next; qb != &env_envvars; qb = qb->q_next) {
2000366a:	4b1b      	ldr	r3, [pc, #108]	@ (200036d8 <env_enum+0x7c>)
2000366c:	681b      	ldr	r3, [r3, #0]
2000366e:	617b      	str	r3, [r7, #20]
20003670:	e008      	b.n	20003684 <env_enum+0x28>
	if (idx == 0) break;
20003672:	68fb      	ldr	r3, [r7, #12]
20003674:	2b00      	cmp	r3, #0
20003676:	d00a      	beq.n	2000368e <env_enum+0x32>
	idx--;
20003678:	68fb      	ldr	r3, [r7, #12]
2000367a:	3b01      	subs	r3, #1
2000367c:	60fb      	str	r3, [r7, #12]
    for (qb = env_envvars.q_next; qb != &env_envvars; qb = qb->q_next) {
2000367e:	697b      	ldr	r3, [r7, #20]
20003680:	681b      	ldr	r3, [r3, #0]
20003682:	617b      	str	r3, [r7, #20]
20003684:	697b      	ldr	r3, [r7, #20]
20003686:	4a14      	ldr	r2, [pc, #80]	@ (200036d8 <env_enum+0x7c>)
20003688:	4293      	cmp	r3, r2
2000368a:	d1f2      	bne.n	20003672 <env_enum+0x16>
2000368c:	e000      	b.n	20003690 <env_enum+0x34>
	if (idx == 0) break;
2000368e:	bf00      	nop
	}

    if (qb == &env_envvars) return CFE_ERR_ENVNOTFOUND;
20003690:	697b      	ldr	r3, [r7, #20]
20003692:	4a11      	ldr	r2, [pc, #68]	@ (200036d8 <env_enum+0x7c>)
20003694:	4293      	cmp	r3, r2
20003696:	d102      	bne.n	2000369e <env_enum+0x42>
20003698:	f06f 0308 	mvn.w	r3, #8
2000369c:	e018      	b.n	200036d0 <env_enum+0x74>
    env = (cfe_envvar_t *) qb;
2000369e:	697b      	ldr	r3, [r7, #20]
200036a0:	613b      	str	r3, [r7, #16]

    *namelen = xstrncpy(name,env->name,*namelen);
200036a2:	693b      	ldr	r3, [r7, #16]
200036a4:	68d9      	ldr	r1, [r3, #12]
200036a6:	687b      	ldr	r3, [r7, #4]
200036a8:	681b      	ldr	r3, [r3, #0]
200036aa:	461a      	mov	r2, r3
200036ac:	68b8      	ldr	r0, [r7, #8]
200036ae:	f7fd fdd0 	bl	20001252 <lib_xstrncpy>
200036b2:	4602      	mov	r2, r0
200036b4:	687b      	ldr	r3, [r7, #4]
200036b6:	601a      	str	r2, [r3, #0]
    *vallen  = xstrncpy(val,env->value,*vallen);
200036b8:	693b      	ldr	r3, [r7, #16]
200036ba:	6919      	ldr	r1, [r3, #16]
200036bc:	6a3b      	ldr	r3, [r7, #32]
200036be:	681b      	ldr	r3, [r3, #0]
200036c0:	461a      	mov	r2, r3
200036c2:	6838      	ldr	r0, [r7, #0]
200036c4:	f7fd fdc5 	bl	20001252 <lib_xstrncpy>
200036c8:	4602      	mov	r2, r0
200036ca:	6a3b      	ldr	r3, [r7, #32]
200036cc:	601a      	str	r2, [r3, #0]

    return 0;
200036ce:	2300      	movs	r3, #0

}
200036d0:	4618      	mov	r0, r3
200036d2:	3718      	adds	r7, #24
200036d4:	46bd      	mov	sp, r7
200036d6:	bd80      	pop	{r7, pc}
200036d8:	20005e7c 	.word	0x20005e7c

200036dc <env_envtype>:
    *  	   
    *  Return value:
    *  	   flags, or <0 if error occured
    ********************************************************************* */
int env_envtype(const char *name)
{
200036dc:	b580      	push	{r7, lr}
200036de:	b084      	sub	sp, #16
200036e0:	af00      	add	r7, sp, #0
200036e2:	6078      	str	r0, [r7, #4]
    cfe_envvar_t *env;

    env = env_findenv(name);
200036e4:	6878      	ldr	r0, [r7, #4]
200036e6:	f7ff ff8f 	bl	20003608 <env_findenv>
200036ea:	60f8      	str	r0, [r7, #12]

    if (env) {
200036ec:	68fb      	ldr	r3, [r7, #12]
200036ee:	2b00      	cmp	r3, #0
200036f0:	d002      	beq.n	200036f8 <env_envtype+0x1c>
	return env->flags;
200036f2:	68fb      	ldr	r3, [r7, #12]
200036f4:	689b      	ldr	r3, [r3, #8]
200036f6:	e001      	b.n	200036fc <env_envtype+0x20>
	}

    return CFE_ERR_ENVNOTFOUND;
200036f8:	f06f 0308 	mvn.w	r3, #8
}
200036fc:	4618      	mov	r0, r3
200036fe:	3710      	adds	r7, #16
20003700:	46bd      	mov	sp, r7
20003702:	bd80      	pop	{r7, pc}

20003704 <env_delenv>:
    *  	   0 if ok
    *  	   else error code
    ********************************************************************* */

int env_delenv(const char *name)
{
20003704:	b580      	push	{r7, lr}
20003706:	b084      	sub	sp, #16
20003708:	af00      	add	r7, sp, #0
2000370a:	6078      	str	r0, [r7, #4]
    cfe_envvar_t *env;

    env = env_findenv(name);
2000370c:	6878      	ldr	r0, [r7, #4]
2000370e:	f7ff ff7b 	bl	20003608 <env_findenv>
20003712:	60f8      	str	r0, [r7, #12]

    if (!env) return 0;
20003714:	68fb      	ldr	r3, [r7, #12]
20003716:	2b00      	cmp	r3, #0
20003718:	d101      	bne.n	2000371e <env_delenv+0x1a>
2000371a:	2300      	movs	r3, #0
2000371c:	e010      	b.n	20003740 <env_delenv+0x3c>

    if (!(env->flags & ENV_FLG_READONLY)) {
2000371e:	68fb      	ldr	r3, [r7, #12]
20003720:	689b      	ldr	r3, [r3, #8]
20003722:	f003 0302 	and.w	r3, r3, #2
20003726:	2b00      	cmp	r3, #0
20003728:	d108      	bne.n	2000373c <env_delenv+0x38>
	q_dequeue((queue_t *) env);
2000372a:	68f8      	ldr	r0, [r7, #12]
2000372c:	f7fd fd25 	bl	2000117a <q_dequeue>
	KFREE(env);
20003730:	68f9      	ldr	r1, [r7, #12]
20003732:	4805      	ldr	r0, [pc, #20]	@ (20003748 <env_delenv+0x44>)
20003734:	f7fd fc14 	bl	20000f60 <kfree>
	return 0;
20003738:	2300      	movs	r3, #0
2000373a:	e001      	b.n	20003740 <env_delenv+0x3c>
	}

    return CFE_ERR_ENVNOTFOUND;
2000373c:	f06f 0308 	mvn.w	r3, #8
}
20003740:	4618      	mov	r0, r3
20003742:	3710      	adds	r7, #16
20003744:	46bd      	mov	sp, r7
20003746:	bd80      	pop	{r7, pc}
20003748:	20005e94 	.word	0x20005e94

2000374c <env_getenv>:
    *  Return value:
    *  	   value, or NULL if variable is not found
    ********************************************************************* */

char *env_getenv(const char *name)
{
2000374c:	b580      	push	{r7, lr}
2000374e:	b084      	sub	sp, #16
20003750:	af00      	add	r7, sp, #0
20003752:	6078      	str	r0, [r7, #4]
    cfe_envvar_t *env;

    env = env_findenv(name);
20003754:	6878      	ldr	r0, [r7, #4]
20003756:	f7ff ff57 	bl	20003608 <env_findenv>
2000375a:	60f8      	str	r0, [r7, #12]

    if (env) {
2000375c:	68fb      	ldr	r3, [r7, #12]
2000375e:	2b00      	cmp	r3, #0
20003760:	d002      	beq.n	20003768 <env_getenv+0x1c>
	return env->value;
20003762:	68fb      	ldr	r3, [r7, #12]
20003764:	691b      	ldr	r3, [r3, #16]
20003766:	e000      	b.n	2000376a <env_getenv+0x1e>
	}

    return NULL;
20003768:	2300      	movs	r3, #0
}
2000376a:	4618      	mov	r0, r3
2000376c:	3710      	adds	r7, #16
2000376e:	46bd      	mov	sp, r7
20003770:	bd80      	pop	{r7, pc}
	...

20003774 <env_setenv>:
    *  	   0 if ok
    *  	   else error code
    ********************************************************************* */

int env_setenv(const char *name,char *value,int flags)
{
20003774:	b580      	push	{r7, lr}
20003776:	b086      	sub	sp, #24
20003778:	af00      	add	r7, sp, #0
2000377a:	60f8      	str	r0, [r7, #12]
2000377c:	60b9      	str	r1, [r7, #8]
2000377e:	607a      	str	r2, [r7, #4]
    cfe_envvar_t *env;
    int namelen;

    env = env_findenv(name);
20003780:	68f8      	ldr	r0, [r7, #12]
20003782:	f7ff ff41 	bl	20003608 <env_findenv>
20003786:	6178      	str	r0, [r7, #20]
    if (env) {
20003788:	697b      	ldr	r3, [r7, #20]
2000378a:	2b00      	cmp	r3, #0
2000378c:	d014      	beq.n	200037b8 <env_setenv+0x44>
	if (!(flags & ENV_FLG_ADMIN)) {
2000378e:	687b      	ldr	r3, [r7, #4]
20003790:	f403 7380 	and.w	r3, r3, #256	@ 0x100
20003794:	2b00      	cmp	r3, #0
20003796:	d108      	bne.n	200037aa <env_setenv+0x36>
	    if (env->flags & ENV_FLG_READONLY) return CFE_ERR_ENVREADONLY;
20003798:	697b      	ldr	r3, [r7, #20]
2000379a:	689b      	ldr	r3, [r3, #8]
2000379c:	f003 0302 	and.w	r3, r3, #2
200037a0:	2b00      	cmp	r3, #0
200037a2:	d002      	beq.n	200037aa <env_setenv+0x36>
200037a4:	f06f 0309 	mvn.w	r3, #9
200037a8:	e03f      	b.n	2000382a <env_setenv+0xb6>
	    }
	q_dequeue((queue_t *) env);
200037aa:	6978      	ldr	r0, [r7, #20]
200037ac:	f7fd fce5 	bl	2000117a <q_dequeue>
	KFREE(env);
200037b0:	6979      	ldr	r1, [r7, #20]
200037b2:	4820      	ldr	r0, [pc, #128]	@ (20003834 <env_setenv+0xc0>)
200037b4:	f7fd fbd4 	bl	20000f60 <kfree>
	}

    namelen = strlen(name);
200037b8:	68f8      	ldr	r0, [r7, #12]
200037ba:	f7fd fd74 	bl	200012a6 <lib_strlen>
200037be:	6138      	str	r0, [r7, #16]

    env = KMALLOC(sizeof(cfe_envvar_t) + namelen + 1 + strlen(value) + 1,0);
200037c0:	68b8      	ldr	r0, [r7, #8]
200037c2:	f7fd fd70 	bl	200012a6 <lib_strlen>
200037c6:	4603      	mov	r3, r0
200037c8:	461a      	mov	r2, r3
200037ca:	693b      	ldr	r3, [r7, #16]
200037cc:	4413      	add	r3, r2
200037ce:	3316      	adds	r3, #22
200037d0:	2200      	movs	r2, #0
200037d2:	4619      	mov	r1, r3
200037d4:	4817      	ldr	r0, [pc, #92]	@ (20003834 <env_setenv+0xc0>)
200037d6:	f7fd fbf7 	bl	20000fc8 <kmalloc>
200037da:	6178      	str	r0, [r7, #20]
    if (!env) return CFE_ERR_NOMEM;
200037dc:	697b      	ldr	r3, [r7, #20]
200037de:	2b00      	cmp	r3, #0
200037e0:	d102      	bne.n	200037e8 <env_setenv+0x74>
200037e2:	f06f 0304 	mvn.w	r3, #4
200037e6:	e020      	b.n	2000382a <env_setenv+0xb6>

    env->name = (char *) (env+1);
200037e8:	697b      	ldr	r3, [r7, #20]
200037ea:	f103 0214 	add.w	r2, r3, #20
200037ee:	697b      	ldr	r3, [r7, #20]
200037f0:	60da      	str	r2, [r3, #12]
    env->value = env->name + namelen + 1;
200037f2:	697b      	ldr	r3, [r7, #20]
200037f4:	68da      	ldr	r2, [r3, #12]
200037f6:	693b      	ldr	r3, [r7, #16]
200037f8:	3301      	adds	r3, #1
200037fa:	441a      	add	r2, r3
200037fc:	697b      	ldr	r3, [r7, #20]
200037fe:	611a      	str	r2, [r3, #16]
    env->flags = (flags & ENV_FLG_MASK);
20003800:	687b      	ldr	r3, [r7, #4]
20003802:	b2da      	uxtb	r2, r3
20003804:	697b      	ldr	r3, [r7, #20]
20003806:	609a      	str	r2, [r3, #8]

    strcpy(env->name,name);
20003808:	697b      	ldr	r3, [r7, #20]
2000380a:	68db      	ldr	r3, [r3, #12]
2000380c:	68f9      	ldr	r1, [r7, #12]
2000380e:	4618      	mov	r0, r3
20003810:	f7fd fd01 	bl	20001216 <lib_strcpy>
    strcpy(env->value,value);
20003814:	697b      	ldr	r3, [r7, #20]
20003816:	691b      	ldr	r3, [r3, #16]
20003818:	68b9      	ldr	r1, [r7, #8]
2000381a:	4618      	mov	r0, r3
2000381c:	f7fd fcfb 	bl	20001216 <lib_strcpy>

    q_enqueue(&env_envvars,(queue_t *) env);
20003820:	6979      	ldr	r1, [r7, #20]
20003822:	4805      	ldr	r0, [pc, #20]	@ (20003838 <env_setenv+0xc4>)
20003824:	f7fd fc90 	bl	20001148 <q_enqueue>

    return 0;
20003828:	2300      	movs	r3, #0
}
2000382a:	4618      	mov	r0, r3
2000382c:	3718      	adds	r7, #24
2000382e:	46bd      	mov	sp, r7
20003830:	bd80      	pop	{r7, pc}
20003832:	bf00      	nop
20003834:	20005e94 	.word	0x20005e94
20003838:	20005e7c 	.word	0x20005e7c

2000383c <env_save>:
    *  Return value:
    *  	   0 if ok, else error code
    ********************************************************************* */

int env_save(void)
{
2000383c:	b480      	push	{r7}
2000383e:	af00      	add	r7, sp, #0
   return 0;
20003840:	2300      	movs	r3, #0

}
20003842:	4618      	mov	r0, r3
20003844:	46bd      	mov	sp, r7
20003846:	f85d 7b04 	ldr.w	r7, [sp], #4
2000384a:	4770      	bx	lr

2000384c <ui_do_one_command>:
    *  	   return value from CFE UI function
    ********************************************************************* */


static int ui_do_one_command(queue_t *head)
{
2000384c:	b590      	push	{r4, r7, lr}
2000384e:	b0fb      	sub	sp, #492	@ 0x1ec
20003850:	af00      	add	r7, sp, #0
20003852:	f507 73f4 	add.w	r3, r7, #488	@ 0x1e8
20003856:	f5a3 73f2 	sub.w	r3, r3, #484	@ 0x1e4
2000385a:	6018      	str	r0, [r3, #0]
    int res;
    ui_cmdline_t cmd;

    res = cmd_lookup(head, &cmd);
2000385c:	f107 0208 	add.w	r2, r7, #8
20003860:	f507 73f4 	add.w	r3, r7, #488	@ 0x1e8
20003864:	f5a3 73f2 	sub.w	r3, r3, #484	@ 0x1e4
20003868:	4611      	mov	r1, r2
2000386a:	6818      	ldr	r0, [r3, #0]
2000386c:	f000 fe34 	bl	200044d8 <cmd_lookup>
20003870:	f8c7 01e4 	str.w	r0, [r7, #484]	@ 0x1e4

    if (res == 0) {
20003874:	f8d7 31e4 	ldr.w	r3, [r7, #484]	@ 0x1e4
20003878:	2b00      	cmp	r3, #0
2000387a:	d144      	bne.n	20003906 <ui_do_one_command+0xba>

	res = cmd_sw_validate(&cmd,cmd.switches);
2000387c:	f507 73f4 	add.w	r3, r7, #488	@ 0x1e8
20003880:	f5a3 73f0 	sub.w	r3, r3, #480	@ 0x1e0
20003884:	f8d3 21d8 	ldr.w	r2, [r3, #472]	@ 0x1d8
20003888:	f107 0308 	add.w	r3, r7, #8
2000388c:	4611      	mov	r1, r2
2000388e:	4618      	mov	r0, r3
20003890:	f000 f9dc 	bl	20003c4c <cmd_sw_validate>
20003894:	f8c7 01e4 	str.w	r0, [r7, #484]	@ 0x1e4
	if (res != -1) {
20003898:	f8d7 31e4 	ldr.w	r3, [r7, #484]	@ 0x1e4
2000389c:	f1b3 3fff 	cmp.w	r3, #4294967295	@ 0xffffffff
200038a0:	d00e      	beq.n	200038c0 <ui_do_one_command+0x74>
	    printf("Invalid switch: %s\n",
200038a2:	f107 0308 	add.w	r3, r7, #8
200038a6:	f8d7 11e4 	ldr.w	r1, [r7, #484]	@ 0x1e4
200038aa:	4618      	mov	r0, r3
200038ac:	f000 f924 	bl	20003af8 <cmd_sw_name>
200038b0:	4603      	mov	r3, r0
200038b2:	4619      	mov	r1, r3
200038b4:	481a      	ldr	r0, [pc, #104]	@ (20003920 <ui_do_one_command+0xd4>)
200038b6:	f7fd f9b7 	bl	20000c28 <printf>
		    cmd_sw_name(&cmd,res));
	    return CFE_ERR_INV_PARAM;
200038ba:	f06f 0307 	mvn.w	r3, #7
200038be:	e029      	b.n	20003914 <ui_do_one_command+0xc8>
	    }

//	if (lib_setjmp(ui_jmpbuf) != 0) return -1;
	res = (*cmd.func)(&cmd,cmd.argc-cmd.argidx,
200038c0:	f507 73f4 	add.w	r3, r7, #488	@ 0x1e8
200038c4:	f5a3 73f0 	sub.w	r3, r3, #480	@ 0x1e0
200038c8:	f8d3 31c8 	ldr.w	r3, [r3, #456]	@ 0x1c8
200038cc:	f507 72f4 	add.w	r2, r7, #488	@ 0x1e8
200038d0:	f5a2 72f0 	sub.w	r2, r2, #480	@ 0x1e0
200038d4:	6811      	ldr	r1, [r2, #0]
200038d6:	f507 72f4 	add.w	r2, r7, #488	@ 0x1e8
200038da:	f5a2 72f0 	sub.w	r2, r2, #480	@ 0x1e0
200038de:	f8d2 21cc 	ldr.w	r2, [r2, #460]	@ 0x1cc
200038e2:	1a8c      	subs	r4, r1, r2
		    &(cmd.argv[cmd.argidx]));
200038e4:	f507 72f4 	add.w	r2, r7, #488	@ 0x1e8
200038e8:	f5a2 72f0 	sub.w	r2, r2, #480	@ 0x1e0
200038ec:	f8d2 21cc 	ldr.w	r2, [r2, #460]	@ 0x1cc
	res = (*cmd.func)(&cmd,cmd.argc-cmd.argidx,
200038f0:	f107 0108 	add.w	r1, r7, #8
200038f4:	0092      	lsls	r2, r2, #2
200038f6:	440a      	add	r2, r1
200038f8:	3204      	adds	r2, #4
200038fa:	f107 0008 	add.w	r0, r7, #8
200038fe:	4621      	mov	r1, r4
20003900:	4798      	blx	r3
20003902:	f8c7 01e4 	str.w	r0, [r7, #484]	@ 0x1e4
	}
    cmd_free(&cmd);
20003906:	f107 0308 	add.w	r3, r7, #8
2000390a:	4618      	mov	r0, r3
2000390c:	f000 f95e 	bl	20003bcc <cmd_free>
    return res;
20003910:	f8d7 31e4 	ldr.w	r3, [r7, #484]	@ 0x1e4
}
20003914:	4618      	mov	r0, r3
20003916:	f507 77f6 	add.w	r7, r7, #492	@ 0x1ec
2000391a:	46bd      	mov	sp, r7
2000391c:	bd90      	pop	{r4, r7, pc}
2000391e:	bf00      	nop
20003920:	200055b0 	.word	0x200055b0

20003924 <ui_init_cmddisp>:
    *  Return value:
    *  	   0
    ********************************************************************* */

int ui_init_cmddisp(void)
{
20003924:	b580      	push	{r7, lr}
20003926:	af00      	add	r7, sp, #0
    cmd_init();
20003928:	f000 fdb6 	bl	20004498 <cmd_init>

    return 0;
2000392c:	2300      	movs	r3, #0
}
2000392e:	4618      	mov	r0, r3
20003930:	bd80      	pop	{r7, pc}

20003932 <ui_showusage>:
    *  Return value:
    *  	   CFE_ERR_INV_COMMAND
    ********************************************************************* */

int ui_showusage(ui_cmdline_t *cmd)
{
20003932:	b580      	push	{r7, lr}
20003934:	b082      	sub	sp, #8
20003936:	af00      	add	r7, sp, #0
20003938:	6078      	str	r0, [r7, #4]
    cmd_showusage(cmd);
2000393a:	6878      	ldr	r0, [r7, #4]
2000393c:	f000 fe6c 	bl	20004618 <cmd_showusage>

    return CFE_ERR_INV_COMMAND;
20003940:	f06f 0301 	mvn.w	r3, #1
}
20003944:	4618      	mov	r0, r3
20003946:	3708      	adds	r7, #8
20003948:	46bd      	mov	sp, r7
2000394a:	bd80      	pop	{r7, pc}

2000394c <ui_docommands_internal>:
    *  	   
    *  Return value:
    *  	   exit status of first command that failed, or null
    ********************************************************************* */
static int ui_docommands_internal(queue_t *head)
{
2000394c:	b580      	push	{r7, lr}
2000394e:	b088      	sub	sp, #32
20003950:	af00      	add	r7, sp, #0
20003952:	6078      	str	r0, [r7, #4]
    queue_t cmdqueue;
    ui_command_t *cmd;
    int status = CMD_ERR_BLANK;
20003954:	f06f 0302 	mvn.w	r3, #2
20003958:	61fb      	str	r3, [r7, #28]
    int term;

    q_init(&cmdqueue);
2000395a:	f107 030c 	add.w	r3, r7, #12
2000395e:	613b      	str	r3, [r7, #16]
20003960:	f107 030c 	add.w	r3, r7, #12
20003964:	60fb      	str	r3, [r7, #12]

    /*
     * Find all the individual commands
     */

    while ((cmd = cmd_readcommand(head))) {
20003966:	e00b      	b.n	20003980 <ui_docommands_internal+0x34>

	if (cmd == NULL) {
20003968:	69bb      	ldr	r3, [r7, #24]
2000396a:	2b00      	cmp	r3, #0
2000396c:	d102      	bne.n	20003974 <ui_docommands_internal+0x28>
	    return CMD_ERR_BLANK;
2000396e:	f06f 0302 	mvn.w	r3, #2
20003972:	e04d      	b.n	20003a10 <ui_docommands_internal+0xc4>
	    }

	q_enqueue(&cmdqueue,(queue_t *) cmd);
20003974:	f107 030c 	add.w	r3, r7, #12
20003978:	69b9      	ldr	r1, [r7, #24]
2000397a:	4618      	mov	r0, r3
2000397c:	f7fd fbe4 	bl	20001148 <q_enqueue>
    while ((cmd = cmd_readcommand(head))) {
20003980:	6878      	ldr	r0, [r7, #4]
20003982:	f000 fe91 	bl	200046a8 <cmd_readcommand>
20003986:	61b8      	str	r0, [r7, #24]
20003988:	69bb      	ldr	r3, [r7, #24]
2000398a:	2b00      	cmp	r3, #0
2000398c:	d1ec      	bne.n	20003968 <ui_docommands_internal+0x1c>

    /*
     * Do each command
     */

    while ((cmd = (ui_command_t *) q_deqnext(&(cmdqueue)))) {
2000398e:	e01e      	b.n	200039ce <ui_docommands_internal+0x82>
	status = ui_do_one_command(&(cmd->head));
20003990:	69bb      	ldr	r3, [r7, #24]
20003992:	3310      	adds	r3, #16
20003994:	4618      	mov	r0, r3
20003996:	f7ff ff59 	bl	2000384c <ui_do_one_command>
2000399a:	61f8      	str	r0, [r7, #28]
	term = cmd->term;
2000399c:	69bb      	ldr	r3, [r7, #24]
2000399e:	689b      	ldr	r3, [r3, #8]
200039a0:	617b      	str	r3, [r7, #20]
	KFREE(cmd);
200039a2:	69b9      	ldr	r1, [r7, #24]
200039a4:	481c      	ldr	r0, [pc, #112]	@ (20003a18 <ui_docommands_internal+0xcc>)
200039a6:	f7fd fadb 	bl	20000f60 <kfree>
	if (status == CMD_ERR_BLANK) continue;
200039aa:	69fb      	ldr	r3, [r7, #28]
200039ac:	f113 0f03 	cmn.w	r3, #3
200039b0:	d00c      	beq.n	200039cc <ui_docommands_internal+0x80>

	/*
	 * And causes us to stop at the first failure.
	 */
	if ((term == CMD_TERM_AND) && (status != 0)) break;
200039b2:	697b      	ldr	r3, [r7, #20]
200039b4:	2b02      	cmp	r3, #2
200039b6:	d102      	bne.n	200039be <ui_docommands_internal+0x72>
200039b8:	69fb      	ldr	r3, [r7, #28]
200039ba:	2b00      	cmp	r3, #0
200039bc:	d111      	bne.n	200039e2 <ui_docommands_internal+0x96>

	/*
	 * OR causes us to stop at the first success.
	 */

	if ((term == CMD_TERM_OR) && (status == 0)) break;
200039be:	697b      	ldr	r3, [r7, #20]
200039c0:	2b03      	cmp	r3, #3
200039c2:	d104      	bne.n	200039ce <ui_docommands_internal+0x82>
200039c4:	69fb      	ldr	r3, [r7, #28]
200039c6:	2b00      	cmp	r3, #0
200039c8:	d00d      	beq.n	200039e6 <ui_docommands_internal+0x9a>
200039ca:	e000      	b.n	200039ce <ui_docommands_internal+0x82>
	if (status == CMD_ERR_BLANK) continue;
200039cc:	bf00      	nop
    while ((cmd = (ui_command_t *) q_deqnext(&(cmdqueue)))) {
200039ce:	f107 030c 	add.w	r3, r7, #12
200039d2:	4618      	mov	r0, r3
200039d4:	f7fd fbe5 	bl	200011a2 <q_deqnext>
200039d8:	61b8      	str	r0, [r7, #24]
200039da:	69bb      	ldr	r3, [r7, #24]
200039dc:	2b00      	cmp	r3, #0
200039de:	d1d7      	bne.n	20003990 <ui_docommands_internal+0x44>
200039e0:	e00c      	b.n	200039fc <ui_docommands_internal+0xb0>
	if ((term == CMD_TERM_AND) && (status != 0)) break;
200039e2:	bf00      	nop
200039e4:	e00a      	b.n	200039fc <ui_docommands_internal+0xb0>
	if ((term == CMD_TERM_OR) && (status == 0)) break;
200039e6:	bf00      	nop

    /*
     * Free any remaining tokens and commands that we did not do
     */

    while ((cmd = (ui_command_t *) q_deqnext(&(cmdqueue)))) {
200039e8:	e008      	b.n	200039fc <ui_docommands_internal+0xb0>
	cmd_free_tokens(&(cmd->head));
200039ea:	69bb      	ldr	r3, [r7, #24]
200039ec:	3310      	adds	r3, #16
200039ee:	4618      	mov	r0, r3
200039f0:	f001 f912 	bl	20004c18 <cmd_free_tokens>
	KFREE(cmd);
200039f4:	69b9      	ldr	r1, [r7, #24]
200039f6:	4808      	ldr	r0, [pc, #32]	@ (20003a18 <ui_docommands_internal+0xcc>)
200039f8:	f7fd fab2 	bl	20000f60 <kfree>
    while ((cmd = (ui_command_t *) q_deqnext(&(cmdqueue)))) {
200039fc:	f107 030c 	add.w	r3, r7, #12
20003a00:	4618      	mov	r0, r3
20003a02:	f7fd fbce 	bl	200011a2 <q_deqnext>
20003a06:	61b8      	str	r0, [r7, #24]
20003a08:	69bb      	ldr	r3, [r7, #24]
20003a0a:	2b00      	cmp	r3, #0
20003a0c:	d1ed      	bne.n	200039ea <ui_docommands_internal+0x9e>
	}

    return status;
20003a0e:	69fb      	ldr	r3, [r7, #28]
}
20003a10:	4618      	mov	r0, r3
20003a12:	3720      	adds	r7, #32
20003a14:	46bd      	mov	sp, r7
20003a16:	bd80      	pop	{r7, pc}
20003a18:	20005e94 	.word	0x20005e94

20003a1c <ui_docommands>:
    *  	   return value of failing command, or 0 if all commands
    *  	   succeeded
    ********************************************************************* */

int ui_docommands(char *str)
{
20003a1c:	b580      	push	{r7, lr}
20003a1e:	b086      	sub	sp, #24
20003a20:	af00      	add	r7, sp, #0
20003a22:	6078      	str	r0, [r7, #4]
    queue_t cmd_list;
    int res;

    /* Convert the command into a token list */
    cmd_build_list(&cmd_list,str);
20003a24:	f107 030c 	add.w	r3, r7, #12
20003a28:	6879      	ldr	r1, [r7, #4]
20003a2a:	4618      	mov	r0, r3
20003a2c:	f000 fee8 	bl	20004800 <cmd_build_list>

    /* Walk the list and expand environment variables */
    cmd_walk_and_expand(&cmd_list);
20003a30:	f107 030c 	add.w	r3, r7, #12
20003a34:	4618      	mov	r0, r3
20003a36:	f001 f865 	bl	20004b04 <cmd_walk_and_expand>

    /* Process each command.  This removes tokens from the list */
    res = ui_docommands_internal(&cmd_list);
20003a3a:	f107 030c 	add.w	r3, r7, #12
20003a3e:	4618      	mov	r0, r3
20003a40:	f7ff ff84 	bl	2000394c <ui_docommands_internal>
20003a44:	6178      	str	r0, [r7, #20]

    /* Free any leftover tokens.  There should not be any. */
    cmd_free_tokens(&cmd_list);
20003a46:	f107 030c 	add.w	r3, r7, #12
20003a4a:	4618      	mov	r0, r3
20003a4c:	f001 f8e4 	bl	20004c18 <cmd_free_tokens>

    return res;
20003a50:	697b      	ldr	r3, [r7, #20]
}
20003a52:	4618      	mov	r0, r3
20003a54:	3718      	adds	r7, #24
20003a56:	46bd      	mov	sp, r7
20003a58:	bd80      	pop	{r7, pc}
	...

20003a5c <is_white_space>:

static char *cmd_eat_quoted_arg(queue_t *head,ui_token_t *t);


static inline int is_white_space(ui_token_t *t) 
{
20003a5c:	b580      	push	{r7, lr}
20003a5e:	b082      	sub	sp, #8
20003a60:	af00      	add	r7, sp, #0
20003a62:	6078      	str	r0, [r7, #4]
    return (strchr(spacechars,t->token) != NULL);
20003a64:	4b08      	ldr	r3, [pc, #32]	@ (20003a88 <is_white_space+0x2c>)
20003a66:	681a      	ldr	r2, [r3, #0]
20003a68:	687b      	ldr	r3, [r7, #4]
20003a6a:	7a1b      	ldrb	r3, [r3, #8]
20003a6c:	4619      	mov	r1, r3
20003a6e:	4610      	mov	r0, r2
20003a70:	f7fd fc72 	bl	20001358 <lib_strchr>
20003a74:	4603      	mov	r3, r0
20003a76:	2b00      	cmp	r3, #0
20003a78:	bf14      	ite	ne
20003a7a:	2301      	movne	r3, #1
20003a7c:	2300      	moveq	r3, #0
20003a7e:	b2db      	uxtb	r3, r3
}
20003a80:	4618      	mov	r0, r3
20003a82:	3708      	adds	r7, #8
20003a84:	46bd      	mov	sp, r7
20003a86:	bd80      	pop	{r7, pc}
20003a88:	20005e88 	.word	0x20005e88

20003a8c <cmd_sw_value>:

int cmd_sw_value(ui_cmdline_t *cmd,char *swname,char **swvalue)
{
20003a8c:	b580      	push	{r7, lr}
20003a8e:	b086      	sub	sp, #24
20003a90:	af00      	add	r7, sp, #0
20003a92:	60f8      	str	r0, [r7, #12]
20003a94:	60b9      	str	r1, [r7, #8]
20003a96:	607a      	str	r2, [r7, #4]
    int idx;

    for (idx = 0; idx < cmd->swc; idx++) {
20003a98:	2300      	movs	r3, #0
20003a9a:	617b      	str	r3, [r7, #20]
20003a9c:	e021      	b.n	20003ae2 <cmd_sw_value+0x56>
	if (strcmp(swname,cmd->swv[idx].swname) == 0) {
20003a9e:	68f9      	ldr	r1, [r7, #12]
20003aa0:	697a      	ldr	r2, [r7, #20]
20003aa2:	4613      	mov	r3, r2
20003aa4:	005b      	lsls	r3, r3, #1
20003aa6:	4413      	add	r3, r2
20003aa8:	009b      	lsls	r3, r3, #2
20003aaa:	440b      	add	r3, r1
20003aac:	f503 7386 	add.w	r3, r3, #268	@ 0x10c
20003ab0:	681b      	ldr	r3, [r3, #0]
20003ab2:	4619      	mov	r1, r3
20003ab4:	68b8      	ldr	r0, [r7, #8]
20003ab6:	f7fd fc0e 	bl	200012d6 <lib_strcmp>
20003aba:	4603      	mov	r3, r0
20003abc:	2b00      	cmp	r3, #0
20003abe:	d10d      	bne.n	20003adc <cmd_sw_value+0x50>
	    *swvalue = cmd->swv[idx].swvalue;
20003ac0:	68f9      	ldr	r1, [r7, #12]
20003ac2:	697a      	ldr	r2, [r7, #20]
20003ac4:	4613      	mov	r3, r2
20003ac6:	005b      	lsls	r3, r3, #1
20003ac8:	4413      	add	r3, r2
20003aca:	009b      	lsls	r3, r3, #2
20003acc:	440b      	add	r3, r1
20003ace:	f503 7388 	add.w	r3, r3, #272	@ 0x110
20003ad2:	681a      	ldr	r2, [r3, #0]
20003ad4:	687b      	ldr	r3, [r7, #4]
20003ad6:	601a      	str	r2, [r3, #0]
	    return 1;
20003ad8:	2301      	movs	r3, #1
20003ada:	e009      	b.n	20003af0 <cmd_sw_value+0x64>
    for (idx = 0; idx < cmd->swc; idx++) {
20003adc:	697b      	ldr	r3, [r7, #20]
20003ade:	3301      	adds	r3, #1
20003ae0:	617b      	str	r3, [r7, #20]
20003ae2:	68fb      	ldr	r3, [r7, #12]
20003ae4:	f8d3 3104 	ldr.w	r3, [r3, #260]	@ 0x104
20003ae8:	697a      	ldr	r2, [r7, #20]
20003aea:	429a      	cmp	r2, r3
20003aec:	dbd7      	blt.n	20003a9e <cmd_sw_value+0x12>
	    }
	}

    return 0;
20003aee:	2300      	movs	r3, #0
}
20003af0:	4618      	mov	r0, r3
20003af2:	3718      	adds	r7, #24
20003af4:	46bd      	mov	sp, r7
20003af6:	bd80      	pop	{r7, pc}

20003af8 <cmd_sw_name>:

    return -1;
}

char *cmd_sw_name(ui_cmdline_t *cmd,int swidx)
{
20003af8:	b480      	push	{r7}
20003afa:	b083      	sub	sp, #12
20003afc:	af00      	add	r7, sp, #0
20003afe:	6078      	str	r0, [r7, #4]
20003b00:	6039      	str	r1, [r7, #0]
    if ((swidx < 0) || (swidx >= cmd->swc)) return NULL;
20003b02:	683b      	ldr	r3, [r7, #0]
20003b04:	2b00      	cmp	r3, #0
20003b06:	db05      	blt.n	20003b14 <cmd_sw_name+0x1c>
20003b08:	687b      	ldr	r3, [r7, #4]
20003b0a:	f8d3 3104 	ldr.w	r3, [r3, #260]	@ 0x104
20003b0e:	683a      	ldr	r2, [r7, #0]
20003b10:	429a      	cmp	r2, r3
20003b12:	db01      	blt.n	20003b18 <cmd_sw_name+0x20>
20003b14:	2300      	movs	r3, #0
20003b16:	e009      	b.n	20003b2c <cmd_sw_name+0x34>

    return cmd->swv[swidx].swname;
20003b18:	6879      	ldr	r1, [r7, #4]
20003b1a:	683a      	ldr	r2, [r7, #0]
20003b1c:	4613      	mov	r3, r2
20003b1e:	005b      	lsls	r3, r3, #1
20003b20:	4413      	add	r3, r2
20003b22:	009b      	lsls	r3, r3, #2
20003b24:	440b      	add	r3, r1
20003b26:	f503 7386 	add.w	r3, r3, #268	@ 0x10c
20003b2a:	681b      	ldr	r3, [r3, #0]
}
20003b2c:	4618      	mov	r0, r3
20003b2e:	370c      	adds	r7, #12
20003b30:	46bd      	mov	sp, r7
20003b32:	f85d 7b04 	ldr.w	r7, [sp], #4
20003b36:	4770      	bx	lr

20003b38 <cmd_sw_isset>:


int cmd_sw_isset(ui_cmdline_t *cmd,char *swname)
{
20003b38:	b580      	push	{r7, lr}
20003b3a:	b084      	sub	sp, #16
20003b3c:	af00      	add	r7, sp, #0
20003b3e:	6078      	str	r0, [r7, #4]
20003b40:	6039      	str	r1, [r7, #0]
    int idx;

    for (idx = 0; idx < cmd->swc; idx++) {
20003b42:	2300      	movs	r3, #0
20003b44:	60fb      	str	r3, [r7, #12]
20003b46:	e015      	b.n	20003b74 <cmd_sw_isset+0x3c>
	if (strcmp(swname,cmd->swv[idx].swname) == 0) {
20003b48:	6879      	ldr	r1, [r7, #4]
20003b4a:	68fa      	ldr	r2, [r7, #12]
20003b4c:	4613      	mov	r3, r2
20003b4e:	005b      	lsls	r3, r3, #1
20003b50:	4413      	add	r3, r2
20003b52:	009b      	lsls	r3, r3, #2
20003b54:	440b      	add	r3, r1
20003b56:	f503 7386 	add.w	r3, r3, #268	@ 0x10c
20003b5a:	681b      	ldr	r3, [r3, #0]
20003b5c:	4619      	mov	r1, r3
20003b5e:	6838      	ldr	r0, [r7, #0]
20003b60:	f7fd fbb9 	bl	200012d6 <lib_strcmp>
20003b64:	4603      	mov	r3, r0
20003b66:	2b00      	cmp	r3, #0
20003b68:	d101      	bne.n	20003b6e <cmd_sw_isset+0x36>
	    return 1;
20003b6a:	2301      	movs	r3, #1
20003b6c:	e009      	b.n	20003b82 <cmd_sw_isset+0x4a>
    for (idx = 0; idx < cmd->swc; idx++) {
20003b6e:	68fb      	ldr	r3, [r7, #12]
20003b70:	3301      	adds	r3, #1
20003b72:	60fb      	str	r3, [r7, #12]
20003b74:	687b      	ldr	r3, [r7, #4]
20003b76:	f8d3 3104 	ldr.w	r3, [r3, #260]	@ 0x104
20003b7a:	68fa      	ldr	r2, [r7, #12]
20003b7c:	429a      	cmp	r2, r3
20003b7e:	dbe3      	blt.n	20003b48 <cmd_sw_isset+0x10>
	    }
	}

    return 0;
20003b80:	2300      	movs	r3, #0
}
20003b82:	4618      	mov	r0, r3
20003b84:	3710      	adds	r7, #16
20003b86:	46bd      	mov	sp, r7
20003b88:	bd80      	pop	{r7, pc}

20003b8a <cmd_getarg>:

char *cmd_getarg(ui_cmdline_t *cmd,int argnum)
{
20003b8a:	b480      	push	{r7}
20003b8c:	b083      	sub	sp, #12
20003b8e:	af00      	add	r7, sp, #0
20003b90:	6078      	str	r0, [r7, #4]
20003b92:	6039      	str	r1, [r7, #0]
    argnum += cmd->argidx;
20003b94:	687b      	ldr	r3, [r7, #4]
20003b96:	f8d3 31cc 	ldr.w	r3, [r3, #460]	@ 0x1cc
20003b9a:	683a      	ldr	r2, [r7, #0]
20003b9c:	4413      	add	r3, r2
20003b9e:	603b      	str	r3, [r7, #0]
    if ((argnum < 0) || (argnum >= cmd->argc)) return NULL;
20003ba0:	683b      	ldr	r3, [r7, #0]
20003ba2:	2b00      	cmp	r3, #0
20003ba4:	db04      	blt.n	20003bb0 <cmd_getarg+0x26>
20003ba6:	687b      	ldr	r3, [r7, #4]
20003ba8:	681b      	ldr	r3, [r3, #0]
20003baa:	683a      	ldr	r2, [r7, #0]
20003bac:	429a      	cmp	r2, r3
20003bae:	db01      	blt.n	20003bb4 <cmd_getarg+0x2a>
20003bb0:	2300      	movs	r3, #0
20003bb2:	e004      	b.n	20003bbe <cmd_getarg+0x34>
    return cmd->argv[argnum];
20003bb4:	687a      	ldr	r2, [r7, #4]
20003bb6:	683b      	ldr	r3, [r7, #0]
20003bb8:	009b      	lsls	r3, r3, #2
20003bba:	4413      	add	r3, r2
20003bbc:	685b      	ldr	r3, [r3, #4]
}
20003bbe:	4618      	mov	r0, r3
20003bc0:	370c      	adds	r7, #12
20003bc2:	46bd      	mov	sp, r7
20003bc4:	f85d 7b04 	ldr.w	r7, [sp], #4
20003bc8:	4770      	bx	lr
	...

20003bcc <cmd_free>:

void cmd_free(ui_cmdline_t *cmd)
{
20003bcc:	b580      	push	{r7, lr}
20003bce:	b084      	sub	sp, #16
20003bd0:	af00      	add	r7, sp, #0
20003bd2:	6078      	str	r0, [r7, #4]
    int idx;

    for (idx = 0; idx < cmd->argc; idx++) {
20003bd4:	2300      	movs	r3, #0
20003bd6:	60fb      	str	r3, [r7, #12]
20003bd8:	e00b      	b.n	20003bf2 <cmd_free+0x26>
	KFREE(cmd->argv[idx]);
20003bda:	687a      	ldr	r2, [r7, #4]
20003bdc:	68fb      	ldr	r3, [r7, #12]
20003bde:	009b      	lsls	r3, r3, #2
20003be0:	4413      	add	r3, r2
20003be2:	685b      	ldr	r3, [r3, #4]
20003be4:	4619      	mov	r1, r3
20003be6:	4818      	ldr	r0, [pc, #96]	@ (20003c48 <cmd_free+0x7c>)
20003be8:	f7fd f9ba 	bl	20000f60 <kfree>
    for (idx = 0; idx < cmd->argc; idx++) {
20003bec:	68fb      	ldr	r3, [r7, #12]
20003bee:	3301      	adds	r3, #1
20003bf0:	60fb      	str	r3, [r7, #12]
20003bf2:	687b      	ldr	r3, [r7, #4]
20003bf4:	681b      	ldr	r3, [r3, #0]
20003bf6:	68fa      	ldr	r2, [r7, #12]
20003bf8:	429a      	cmp	r2, r3
20003bfa:	dbee      	blt.n	20003bda <cmd_free+0xe>
	}

    for (idx = 0; idx < cmd->swc; idx++) {
20003bfc:	2300      	movs	r3, #0
20003bfe:	60fb      	str	r3, [r7, #12]
20003c00:	e010      	b.n	20003c24 <cmd_free+0x58>
	KFREE(cmd->swv[idx].swname);
20003c02:	6879      	ldr	r1, [r7, #4]
20003c04:	68fa      	ldr	r2, [r7, #12]
20003c06:	4613      	mov	r3, r2
20003c08:	005b      	lsls	r3, r3, #1
20003c0a:	4413      	add	r3, r2
20003c0c:	009b      	lsls	r3, r3, #2
20003c0e:	440b      	add	r3, r1
20003c10:	f503 7386 	add.w	r3, r3, #268	@ 0x10c
20003c14:	681b      	ldr	r3, [r3, #0]
20003c16:	4619      	mov	r1, r3
20003c18:	480b      	ldr	r0, [pc, #44]	@ (20003c48 <cmd_free+0x7c>)
20003c1a:	f7fd f9a1 	bl	20000f60 <kfree>
    for (idx = 0; idx < cmd->swc; idx++) {
20003c1e:	68fb      	ldr	r3, [r7, #12]
20003c20:	3301      	adds	r3, #1
20003c22:	60fb      	str	r3, [r7, #12]
20003c24:	687b      	ldr	r3, [r7, #4]
20003c26:	f8d3 3104 	ldr.w	r3, [r3, #260]	@ 0x104
20003c2a:	68fa      	ldr	r2, [r7, #12]
20003c2c:	429a      	cmp	r2, r3
20003c2e:	dbe8      	blt.n	20003c02 <cmd_free+0x36>
	}

    cmd->argc = 0;
20003c30:	687b      	ldr	r3, [r7, #4]
20003c32:	2200      	movs	r2, #0
20003c34:	601a      	str	r2, [r3, #0]
    cmd->swc = 0;
20003c36:	687b      	ldr	r3, [r7, #4]
20003c38:	2200      	movs	r2, #0
20003c3a:	f8c3 2104 	str.w	r2, [r3, #260]	@ 0x104
}
20003c3e:	bf00      	nop
20003c40:	3710      	adds	r7, #16
20003c42:	46bd      	mov	sp, r7
20003c44:	bd80      	pop	{r7, pc}
20003c46:	bf00      	nop
20003c48:	20005e94 	.word	0x20005e94

20003c4c <cmd_sw_validate>:

int cmd_sw_validate(ui_cmdline_t *cmd,char *validstr)
{
20003c4c:	b580      	push	{r7, lr}
20003c4e:	b08a      	sub	sp, #40	@ 0x28
20003c50:	af00      	add	r7, sp, #0
20003c52:	6078      	str	r0, [r7, #4]
20003c54:	6039      	str	r1, [r7, #0]
    char atype;
    char *x;
    int idx;
    int valid;

    if (cmd->swc == 0) return -1;
20003c56:	687b      	ldr	r3, [r7, #4]
20003c58:	f8d3 3104 	ldr.w	r3, [r3, #260]	@ 0x104
20003c5c:	2b00      	cmp	r3, #0
20003c5e:	d102      	bne.n	20003c66 <cmd_sw_validate+0x1a>
20003c60:	f04f 33ff 	mov.w	r3, #4294967295	@ 0xffffffff
20003c64:	e094      	b.n	20003d90 <cmd_sw_validate+0x144>

    vdup = strdup(validstr);
20003c66:	6838      	ldr	r0, [r7, #0]
20003c68:	f7fd fc7a 	bl	20001560 <lib_strdup>
20003c6c:	6138      	str	r0, [r7, #16]

    for (idx = 0; idx < cmd->swc; idx++) {
20003c6e:	2300      	movs	r3, #0
20003c70:	61bb      	str	r3, [r7, #24]
20003c72:	e080      	b.n	20003d76 <cmd_sw_validate+0x12a>
	vptr = vdup;
20003c74:	693b      	ldr	r3, [r7, #16]
20003c76:	627b      	str	r3, [r7, #36]	@ 0x24

	vnext = vptr;
20003c78:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
20003c7a:	623b      	str	r3, [r7, #32]
	valid = 0;
20003c7c:	2300      	movs	r3, #0
20003c7e:	617b      	str	r3, [r7, #20]

	while (vnext) {
20003c80:	e06a      	b.n	20003d58 <cmd_sw_validate+0x10c>

	    /*
	     * Eat the next switch description from the valid string
	     */
	    x = strchr(vptr,'|');
20003c82:	217c      	movs	r1, #124	@ 0x7c
20003c84:	6a78      	ldr	r0, [r7, #36]	@ 0x24
20003c86:	f7fd fb67 	bl	20001358 <lib_strchr>
20003c8a:	60f8      	str	r0, [r7, #12]
	    if (x) {
20003c8c:	68fb      	ldr	r3, [r7, #12]
20003c8e:	2b00      	cmp	r3, #0
20003c90:	d006      	beq.n	20003ca0 <cmd_sw_validate+0x54>
		*x = '\0';
20003c92:	68fb      	ldr	r3, [r7, #12]
20003c94:	2200      	movs	r2, #0
20003c96:	701a      	strb	r2, [r3, #0]
		vnext = x+1;
20003c98:	68fb      	ldr	r3, [r7, #12]
20003c9a:	3301      	adds	r3, #1
20003c9c:	623b      	str	r3, [r7, #32]
20003c9e:	e001      	b.n	20003ca4 <cmd_sw_validate+0x58>
		}
	    else {
		vnext = NULL;
20003ca0:	2300      	movs	r3, #0
20003ca2:	623b      	str	r3, [r7, #32]
		}

	    /*
	     * Get the expected arg type, if any 
	     */
	    x = strchr(vptr,'=');
20003ca4:	213d      	movs	r1, #61	@ 0x3d
20003ca6:	6a78      	ldr	r0, [r7, #36]	@ 0x24
20003ca8:	f7fd fb56 	bl	20001358 <lib_strchr>
20003cac:	60f8      	str	r0, [r7, #12]
	    if (x) {
20003cae:	68fb      	ldr	r3, [r7, #12]
20003cb0:	2b00      	cmp	r3, #0
20003cb2:	d006      	beq.n	20003cc2 <cmd_sw_validate+0x76>
		atype = *(x+1);
20003cb4:	68fb      	ldr	r3, [r7, #12]
20003cb6:	785b      	ldrb	r3, [r3, #1]
20003cb8:	77fb      	strb	r3, [r7, #31]
		*x = 0;
20003cba:	68fb      	ldr	r3, [r7, #12]
20003cbc:	2200      	movs	r2, #0
20003cbe:	701a      	strb	r2, [r3, #0]
20003cc0:	e00c      	b.n	20003cdc <cmd_sw_validate+0x90>
		}
	    else {
		if ((x = strchr(vptr,';'))) *x = 0;
20003cc2:	213b      	movs	r1, #59	@ 0x3b
20003cc4:	6a78      	ldr	r0, [r7, #36]	@ 0x24
20003cc6:	f7fd fb47 	bl	20001358 <lib_strchr>
20003cca:	60f8      	str	r0, [r7, #12]
20003ccc:	68fb      	ldr	r3, [r7, #12]
20003cce:	2b00      	cmp	r3, #0
20003cd0:	d002      	beq.n	20003cd8 <cmd_sw_validate+0x8c>
20003cd2:	68fb      	ldr	r3, [r7, #12]
20003cd4:	2200      	movs	r2, #0
20003cd6:	701a      	strb	r2, [r3, #0]
		atype = 0;
20003cd8:	2300      	movs	r3, #0
20003cda:	77fb      	strb	r3, [r7, #31]
	     * See if this matches what the user typed
	     * XXX for now, ignore the arg type processing but
	     * complain if an arg is missing.
	     */

	    if (strcmp(vptr,cmd->swv[idx].swname) == 0) {
20003cdc:	6879      	ldr	r1, [r7, #4]
20003cde:	69ba      	ldr	r2, [r7, #24]
20003ce0:	4613      	mov	r3, r2
20003ce2:	005b      	lsls	r3, r3, #1
20003ce4:	4413      	add	r3, r2
20003ce6:	009b      	lsls	r3, r3, #2
20003ce8:	440b      	add	r3, r1
20003cea:	f503 7386 	add.w	r3, r3, #268	@ 0x10c
20003cee:	681b      	ldr	r3, [r3, #0]
20003cf0:	4619      	mov	r1, r3
20003cf2:	6a78      	ldr	r0, [r7, #36]	@ 0x24
20003cf4:	f7fd faef 	bl	200012d6 <lib_strcmp>
20003cf8:	4603      	mov	r3, r0
20003cfa:	2b00      	cmp	r3, #0
20003cfc:	d126      	bne.n	20003d4c <cmd_sw_validate+0x100>
		/* Value not needed and not supplied */
		if ((atype == 0) && (cmd->swv[idx].swvalue == NULL)) {
20003cfe:	7ffb      	ldrb	r3, [r7, #31]
20003d00:	2b00      	cmp	r3, #0
20003d02:	d10d      	bne.n	20003d20 <cmd_sw_validate+0xd4>
20003d04:	6879      	ldr	r1, [r7, #4]
20003d06:	69ba      	ldr	r2, [r7, #24]
20003d08:	4613      	mov	r3, r2
20003d0a:	005b      	lsls	r3, r3, #1
20003d0c:	4413      	add	r3, r2
20003d0e:	009b      	lsls	r3, r3, #2
20003d10:	440b      	add	r3, r1
20003d12:	f503 7388 	add.w	r3, r3, #272	@ 0x110
20003d16:	681b      	ldr	r3, [r3, #0]
20003d18:	2b00      	cmp	r3, #0
20003d1a:	d101      	bne.n	20003d20 <cmd_sw_validate+0xd4>
		    valid = 1;
20003d1c:	2301      	movs	r3, #1
20003d1e:	617b      	str	r3, [r7, #20]
		    }
		/* value needed and supplied */
		if ((atype != 0) && (cmd->swv[idx].swvalue != NULL)) {
20003d20:	7ffb      	ldrb	r3, [r7, #31]
20003d22:	2b00      	cmp	r3, #0
20003d24:	d00d      	beq.n	20003d42 <cmd_sw_validate+0xf6>
20003d26:	6879      	ldr	r1, [r7, #4]
20003d28:	69ba      	ldr	r2, [r7, #24]
20003d2a:	4613      	mov	r3, r2
20003d2c:	005b      	lsls	r3, r3, #1
20003d2e:	4413      	add	r3, r2
20003d30:	009b      	lsls	r3, r3, #2
20003d32:	440b      	add	r3, r1
20003d34:	f503 7388 	add.w	r3, r3, #272	@ 0x110
20003d38:	681b      	ldr	r3, [r3, #0]
20003d3a:	2b00      	cmp	r3, #0
20003d3c:	d001      	beq.n	20003d42 <cmd_sw_validate+0xf6>
		    valid = 1;
20003d3e:	2301      	movs	r3, #1
20003d40:	617b      	str	r3, [r7, #20]
		    }
		strcpy(vdup,validstr);
20003d42:	6839      	ldr	r1, [r7, #0]
20003d44:	6938      	ldr	r0, [r7, #16]
20003d46:	f7fd fa66 	bl	20001216 <lib_strcpy>
		break;
20003d4a:	e008      	b.n	20003d5e <cmd_sw_validate+0x112>

	    /*
	     * Otherwise, next!
	     */

	    strcpy(vdup,validstr);
20003d4c:	6839      	ldr	r1, [r7, #0]
20003d4e:	6938      	ldr	r0, [r7, #16]
20003d50:	f7fd fa61 	bl	20001216 <lib_strcpy>
	    vptr = vnext;
20003d54:	6a3b      	ldr	r3, [r7, #32]
20003d56:	627b      	str	r3, [r7, #36]	@ 0x24
	while (vnext) {
20003d58:	6a3b      	ldr	r3, [r7, #32]
20003d5a:	2b00      	cmp	r3, #0
20003d5c:	d191      	bne.n	20003c82 <cmd_sw_validate+0x36>

	/*
	 * If not valid, return index of bad switch
	 */

	if (valid == 0) {
20003d5e:	697b      	ldr	r3, [r7, #20]
20003d60:	2b00      	cmp	r3, #0
20003d62:	d105      	bne.n	20003d70 <cmd_sw_validate+0x124>
	    KFREE(vdup);
20003d64:	6939      	ldr	r1, [r7, #16]
20003d66:	480c      	ldr	r0, [pc, #48]	@ (20003d98 <cmd_sw_validate+0x14c>)
20003d68:	f7fd f8fa 	bl	20000f60 <kfree>
	    return idx;
20003d6c:	69bb      	ldr	r3, [r7, #24]
20003d6e:	e00f      	b.n	20003d90 <cmd_sw_validate+0x144>
    for (idx = 0; idx < cmd->swc; idx++) {
20003d70:	69bb      	ldr	r3, [r7, #24]
20003d72:	3301      	adds	r3, #1
20003d74:	61bb      	str	r3, [r7, #24]
20003d76:	687b      	ldr	r3, [r7, #4]
20003d78:	f8d3 3104 	ldr.w	r3, [r3, #260]	@ 0x104
20003d7c:	69ba      	ldr	r2, [r7, #24]
20003d7e:	429a      	cmp	r2, r3
20003d80:	f6ff af78 	blt.w	20003c74 <cmd_sw_validate+0x28>
    /*
     * Return -1 if everything went well.  A little strange,
     * but it's easier this way.
     */

    KFREE(vdup);
20003d84:	6939      	ldr	r1, [r7, #16]
20003d86:	4804      	ldr	r0, [pc, #16]	@ (20003d98 <cmd_sw_validate+0x14c>)
20003d88:	f7fd f8ea 	bl	20000f60 <kfree>
    return -1;
20003d8c:	f04f 33ff 	mov.w	r3, #4294967295	@ 0xffffffff
}
20003d90:	4618      	mov	r0, r3
20003d92:	3728      	adds	r7, #40	@ 0x28
20003d94:	46bd      	mov	sp, r7
20003d96:	bd80      	pop	{r7, pc}
20003d98:	20005e94 	.word	0x20005e94

20003d9c <cmd_findword>:

static cmdtab_t *cmd_findword(cmdtab_t *list,char *cmdword)
{
20003d9c:	b580      	push	{r7, lr}
20003d9e:	b082      	sub	sp, #8
20003da0:	af00      	add	r7, sp, #0
20003da2:	6078      	str	r0, [r7, #4]
20003da4:	6039      	str	r1, [r7, #0]
    while (list) {
20003da6:	e00d      	b.n	20003dc4 <cmd_findword+0x28>
	if (strcmp(cmdword,list->cmdword) == 0) return list;
20003da8:	687b      	ldr	r3, [r7, #4]
20003daa:	689b      	ldr	r3, [r3, #8]
20003dac:	4619      	mov	r1, r3
20003dae:	6838      	ldr	r0, [r7, #0]
20003db0:	f7fd fa91 	bl	200012d6 <lib_strcmp>
20003db4:	4603      	mov	r3, r0
20003db6:	2b00      	cmp	r3, #0
20003db8:	d101      	bne.n	20003dbe <cmd_findword+0x22>
20003dba:	687b      	ldr	r3, [r7, #4]
20003dbc:	e006      	b.n	20003dcc <cmd_findword+0x30>
	list = list->sibling;
20003dbe:	687b      	ldr	r3, [r7, #4]
20003dc0:	681b      	ldr	r3, [r3, #0]
20003dc2:	607b      	str	r3, [r7, #4]
    while (list) {
20003dc4:	687b      	ldr	r3, [r7, #4]
20003dc6:	2b00      	cmp	r3, #0
20003dc8:	d1ee      	bne.n	20003da8 <cmd_findword+0xc>
	}

    return NULL;
20003dca:	2300      	movs	r3, #0
}
20003dcc:	4618      	mov	r0, r3
20003dce:	3708      	adds	r7, #8
20003dd0:	46bd      	mov	sp, r7
20003dd2:	bd80      	pop	{r7, pc}

20003dd4 <cmd_build_cmdline>:


void cmd_build_cmdline(queue_t *head, ui_cmdline_t *cmd)
{
20003dd4:	b590      	push	{r4, r7, lr}
20003dd6:	b085      	sub	sp, #20
20003dd8:	af00      	add	r7, sp, #0
20003dda:	6078      	str	r0, [r7, #4]
20003ddc:	6039      	str	r1, [r7, #0]
    ui_token_t *t;
    ui_token_t *next;

    memset(cmd, 0, sizeof(ui_cmdline_t));
20003dde:	f44f 72ee 	mov.w	r2, #476	@ 0x1dc
20003de2:	2100      	movs	r1, #0
20003de4:	6838      	ldr	r0, [r7, #0]
20003de6:	f7fd faf3 	bl	200013d0 <lib_memset>

    t = (ui_token_t *) q_deqnext(head);
20003dea:	6878      	ldr	r0, [r7, #4]
20003dec:	f7fd f9d9 	bl	200011a2 <q_deqnext>
20003df0:	60f8      	str	r0, [r7, #12]

    while (t != NULL) {
20003df2:	e092      	b.n	20003f1a <cmd_build_cmdline+0x146>
	if (is_white_space(t)) {
20003df4:	68f8      	ldr	r0, [r7, #12]
20003df6:	f7ff fe31 	bl	20003a5c <is_white_space>
20003dfa:	4603      	mov	r3, r0
20003dfc:	2b00      	cmp	r3, #0
20003dfe:	f040 8084 	bne.w	20003f0a <cmd_build_cmdline+0x136>
	    /* do nothing */
	    } 
	else if (t->token != '-') {
20003e02:	68fb      	ldr	r3, [r7, #12]
20003e04:	7a1b      	ldrb	r3, [r3, #8]
20003e06:	2b2d      	cmp	r3, #45	@ 0x2d
20003e08:	d014      	beq.n	20003e34 <cmd_build_cmdline+0x60>
	    if(cmd->argc < MAX_TOKENS){
20003e0a:	683b      	ldr	r3, [r7, #0]
20003e0c:	681b      	ldr	r3, [r3, #0]
20003e0e:	2b3f      	cmp	r3, #63	@ 0x3f
20003e10:	dc7b      	bgt.n	20003f0a <cmd_build_cmdline+0x136>
		cmd->argv[cmd->argc] = cmd_eat_quoted_arg(head,t);
20003e12:	683b      	ldr	r3, [r7, #0]
20003e14:	681c      	ldr	r4, [r3, #0]
20003e16:	68f9      	ldr	r1, [r7, #12]
20003e18:	6878      	ldr	r0, [r7, #4]
20003e1a:	f000 fdbf 	bl	2000499c <cmd_eat_quoted_arg>
20003e1e:	4601      	mov	r1, r0
20003e20:	683a      	ldr	r2, [r7, #0]
20003e22:	00a3      	lsls	r3, r4, #2
20003e24:	4413      	add	r3, r2
20003e26:	6059      	str	r1, [r3, #4]
		cmd->argc++;
20003e28:	683b      	ldr	r3, [r7, #0]
20003e2a:	681b      	ldr	r3, [r3, #0]
20003e2c:	1c5a      	adds	r2, r3, #1
20003e2e:	683b      	ldr	r3, [r7, #0]
20003e30:	601a      	str	r2, [r3, #0]
20003e32:	e06a      	b.n	20003f0a <cmd_build_cmdline+0x136>
		}
	    /* Token is a switch */
	    }
	else {
	    if (cmd->swc < MAX_SWITCHES) {
20003e34:	683b      	ldr	r3, [r7, #0]
20003e36:	f8d3 3104 	ldr.w	r3, [r3, #260]	@ 0x104
20003e3a:	2b0f      	cmp	r3, #15
20003e3c:	dc65      	bgt.n	20003f0a <cmd_build_cmdline+0x136>
		cmd->swv[cmd->swc].swname = lib_strdup(&(t->token));
20003e3e:	68fb      	ldr	r3, [r7, #12]
20003e40:	f103 0208 	add.w	r2, r3, #8
20003e44:	683b      	ldr	r3, [r7, #0]
20003e46:	f8d3 4104 	ldr.w	r4, [r3, #260]	@ 0x104
20003e4a:	4610      	mov	r0, r2
20003e4c:	f7fd fb88 	bl	20001560 <lib_strdup>
20003e50:	4601      	mov	r1, r0
20003e52:	683a      	ldr	r2, [r7, #0]
20003e54:	4623      	mov	r3, r4
20003e56:	005b      	lsls	r3, r3, #1
20003e58:	4423      	add	r3, r4
20003e5a:	009b      	lsls	r3, r3, #2
20003e5c:	4413      	add	r3, r2
20003e5e:	f503 7386 	add.w	r3, r3, #268	@ 0x10c
20003e62:	6019      	str	r1, [r3, #0]

		if (t->qb.q_next != head) {			/* more tokens */
20003e64:	68fb      	ldr	r3, [r7, #12]
20003e66:	681b      	ldr	r3, [r3, #0]
20003e68:	687a      	ldr	r2, [r7, #4]
20003e6a:	429a      	cmp	r2, r3
20003e6c:	d038      	beq.n	20003ee0 <cmd_build_cmdline+0x10c>
		    next = (ui_token_t *) t->qb.q_next;
20003e6e:	68fb      	ldr	r3, [r7, #12]
20003e70:	681b      	ldr	r3, [r3, #0]
20003e72:	60bb      	str	r3, [r7, #8]
		    if (next->token == '=') {			/* switch has value */
20003e74:	68bb      	ldr	r3, [r7, #8]
20003e76:	7a1b      	ldrb	r3, [r3, #8]
20003e78:	2b3d      	cmp	r3, #61	@ 0x3d
20003e7a:	d124      	bne.n	20003ec6 <cmd_build_cmdline+0xf2>
			KFREE(t);				/* Free switch name */
20003e7c:	68f9      	ldr	r1, [r7, #12]
20003e7e:	482b      	ldr	r0, [pc, #172]	@ (20003f2c <cmd_build_cmdline+0x158>)
20003e80:	f7fd f86e 	bl	20000f60 <kfree>
			t = (ui_token_t *) q_deqnext(head);	/* eat equal sign */
20003e84:	6878      	ldr	r0, [r7, #4]
20003e86:	f7fd f98c 	bl	200011a2 <q_deqnext>
20003e8a:	60f8      	str	r0, [r7, #12]
			KFREE(t);				/* and free it */
20003e8c:	68f9      	ldr	r1, [r7, #12]
20003e8e:	4827      	ldr	r0, [pc, #156]	@ (20003f2c <cmd_build_cmdline+0x158>)
20003e90:	f7fd f866 	bl	20000f60 <kfree>
			t = (ui_token_t *) q_deqnext(head);	/* now have value */
20003e94:	6878      	ldr	r0, [r7, #4]
20003e96:	f7fd f984 	bl	200011a2 <q_deqnext>
20003e9a:	60f8      	str	r0, [r7, #12]
			if (t != NULL) {
20003e9c:	68fb      	ldr	r3, [r7, #12]
20003e9e:	2b00      	cmp	r3, #0
20003ea0:	d01e      	beq.n	20003ee0 <cmd_build_cmdline+0x10c>
			    cmd->swv[cmd->swc].swvalue = cmd_eat_quoted_arg(head,t);
20003ea2:	683b      	ldr	r3, [r7, #0]
20003ea4:	f8d3 4104 	ldr.w	r4, [r3, #260]	@ 0x104
20003ea8:	68f9      	ldr	r1, [r7, #12]
20003eaa:	6878      	ldr	r0, [r7, #4]
20003eac:	f000 fd76 	bl	2000499c <cmd_eat_quoted_arg>
20003eb0:	4601      	mov	r1, r0
20003eb2:	683a      	ldr	r2, [r7, #0]
20003eb4:	4623      	mov	r3, r4
20003eb6:	005b      	lsls	r3, r3, #1
20003eb8:	4423      	add	r3, r4
20003eba:	009b      	lsls	r3, r3, #2
20003ebc:	4413      	add	r3, r2
20003ebe:	f503 7388 	add.w	r3, r3, #272	@ 0x110
20003ec2:	6019      	str	r1, [r3, #0]
20003ec4:	e00c      	b.n	20003ee0 <cmd_build_cmdline+0x10c>
			    }
			}
		    else {					/* no value */
			cmd->swv[cmd->swc].swvalue = NULL;
20003ec6:	683b      	ldr	r3, [r7, #0]
20003ec8:	f8d3 2104 	ldr.w	r2, [r3, #260]	@ 0x104
20003ecc:	6839      	ldr	r1, [r7, #0]
20003ece:	4613      	mov	r3, r2
20003ed0:	005b      	lsls	r3, r3, #1
20003ed2:	4413      	add	r3, r2
20003ed4:	009b      	lsls	r3, r3, #2
20003ed6:	440b      	add	r3, r1
20003ed8:	f503 7388 	add.w	r3, r3, #272	@ 0x110
20003edc:	2200      	movs	r2, #0
20003ede:	601a      	str	r2, [r3, #0]
		/* 
		 * swidx is the index of the argument that this
		 * switch precedes.  So, if you have "foo -d bar",
		 * swidx for "-d" would be 1.
		 */
		cmd->swv[cmd->swc].swidx = cmd->argc;
20003ee0:	683b      	ldr	r3, [r7, #0]
20003ee2:	f8d3 2104 	ldr.w	r2, [r3, #260]	@ 0x104
20003ee6:	683b      	ldr	r3, [r7, #0]
20003ee8:	6819      	ldr	r1, [r3, #0]
20003eea:	6838      	ldr	r0, [r7, #0]
20003eec:	4613      	mov	r3, r2
20003eee:	005b      	lsls	r3, r3, #1
20003ef0:	4413      	add	r3, r2
20003ef2:	009b      	lsls	r3, r3, #2
20003ef4:	4403      	add	r3, r0
20003ef6:	f503 7384 	add.w	r3, r3, #264	@ 0x108
20003efa:	6019      	str	r1, [r3, #0]
		cmd->swc++;	
20003efc:	683b      	ldr	r3, [r7, #0]
20003efe:	f8d3 3104 	ldr.w	r3, [r3, #260]	@ 0x104
20003f02:	1c5a      	adds	r2, r3, #1
20003f04:	683b      	ldr	r3, [r7, #0]
20003f06:	f8c3 2104 	str.w	r2, [r3, #260]	@ 0x104
		}
	    }
	KFREE(t);
20003f0a:	68f9      	ldr	r1, [r7, #12]
20003f0c:	4807      	ldr	r0, [pc, #28]	@ (20003f2c <cmd_build_cmdline+0x158>)
20003f0e:	f7fd f827 	bl	20000f60 <kfree>
	t = (ui_token_t *) q_deqnext(head);
20003f12:	6878      	ldr	r0, [r7, #4]
20003f14:	f7fd f945 	bl	200011a2 <q_deqnext>
20003f18:	60f8      	str	r0, [r7, #12]
    while (t != NULL) {
20003f1a:	68fb      	ldr	r3, [r7, #12]
20003f1c:	2b00      	cmp	r3, #0
20003f1e:	f47f af69 	bne.w	20003df4 <cmd_build_cmdline+0x20>
	for (idx = 0; idx < cmd->swc; idx++) printf("switch[%s] = [%s]\n",cmd->swv[idx].swname,
						    cmd->swv[idx].swvalue);
	}
#endif

}
20003f22:	bf00      	nop
20003f24:	bf00      	nop
20003f26:	3714      	adds	r7, #20
20003f28:	46bd      	mov	sp, r7
20003f2a:	bd90      	pop	{r4, r7, pc}
20003f2c:	20005e94 	.word	0x20005e94

20003f30 <cmd_addcmd>:
	       int (*func)(ui_cmdline_t *,int argc,char *argv[]),
	       void *ref,
	       char *help,
	       char *usage,
	       char *switches)
{
20003f30:	b580      	push	{r7, lr}
20003f32:	b08a      	sub	sp, #40	@ 0x28
20003f34:	af00      	add	r7, sp, #0
20003f36:	60f8      	str	r0, [r7, #12]
20003f38:	60b9      	str	r1, [r7, #8]
20003f3a:	607a      	str	r2, [r7, #4]
20003f3c:	603b      	str	r3, [r7, #0]
    cmdtab_t **list = &cmd_root;
20003f3e:	4b38      	ldr	r3, [pc, #224]	@ (20004020 <cmd_addcmd+0xf0>)
20003f40:	627b      	str	r3, [r7, #36]	@ 0x24
    cmdtab_t *cmd = NULL;
20003f42:	2300      	movs	r3, #0
20003f44:	623b      	str	r3, [r7, #32]
    queue_t tokens;
    queue_t *cur;
    ui_token_t *t;

    cmd_build_list(&tokens,command);
20003f46:	f107 0310 	add.w	r3, r7, #16
20003f4a:	68f9      	ldr	r1, [r7, #12]
20003f4c:	4618      	mov	r0, r3
20003f4e:	f000 fc57 	bl	20004800 <cmd_build_list>
    cur = tokens.q_next;
20003f52:	693b      	ldr	r3, [r7, #16]
20003f54:	61fb      	str	r3, [r7, #28]

    while (cur != &tokens) {
20003f56:	e03f      	b.n	20003fd8 <cmd_addcmd+0xa8>
	t = (ui_token_t *) cur;
20003f58:	69fb      	ldr	r3, [r7, #28]
20003f5a:	61bb      	str	r3, [r7, #24]
	if (!is_white_space(t)) {
20003f5c:	69b8      	ldr	r0, [r7, #24]
20003f5e:	f7ff fd7d 	bl	20003a5c <is_white_space>
20003f62:	4603      	mov	r3, r0
20003f64:	2b00      	cmp	r3, #0
20003f66:	d134      	bne.n	20003fd2 <cmd_addcmd+0xa2>
	    cmd = cmd_findword(*list,&(t->token));
20003f68:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
20003f6a:	681a      	ldr	r2, [r3, #0]
20003f6c:	69bb      	ldr	r3, [r7, #24]
20003f6e:	3308      	adds	r3, #8
20003f70:	4619      	mov	r1, r3
20003f72:	4610      	mov	r0, r2
20003f74:	f7ff ff12 	bl	20003d9c <cmd_findword>
20003f78:	6238      	str	r0, [r7, #32]
	    if (!cmd) {
20003f7a:	6a3b      	ldr	r3, [r7, #32]
20003f7c:	2b00      	cmp	r3, #0
20003f7e:	d125      	bne.n	20003fcc <cmd_addcmd+0x9c>
		cmd = KMALLOC(sizeof(cmdtab_t)+strlen(&(t->token))+1,0);
20003f80:	69bb      	ldr	r3, [r7, #24]
20003f82:	3308      	adds	r3, #8
20003f84:	4618      	mov	r0, r3
20003f86:	f7fd f98e 	bl	200012a6 <lib_strlen>
20003f8a:	4603      	mov	r3, r0
20003f8c:	3321      	adds	r3, #33	@ 0x21
20003f8e:	2200      	movs	r2, #0
20003f90:	4619      	mov	r1, r3
20003f92:	4824      	ldr	r0, [pc, #144]	@ (20004024 <cmd_addcmd+0xf4>)
20003f94:	f7fd f818 	bl	20000fc8 <kmalloc>
20003f98:	6238      	str	r0, [r7, #32]
		memset(cmd,0,sizeof(cmdtab_t));
20003f9a:	2220      	movs	r2, #32
20003f9c:	2100      	movs	r1, #0
20003f9e:	6a38      	ldr	r0, [r7, #32]
20003fa0:	f7fd fa16 	bl	200013d0 <lib_memset>
		cmd->cmdword = (char *) (cmd+1);
20003fa4:	6a3b      	ldr	r3, [r7, #32]
20003fa6:	f103 0220 	add.w	r2, r3, #32
20003faa:	6a3b      	ldr	r3, [r7, #32]
20003fac:	609a      	str	r2, [r3, #8]
		strcpy(cmd->cmdword,&(t->token));
20003fae:	6a3b      	ldr	r3, [r7, #32]
20003fb0:	689a      	ldr	r2, [r3, #8]
20003fb2:	69bb      	ldr	r3, [r7, #24]
20003fb4:	3308      	adds	r3, #8
20003fb6:	4619      	mov	r1, r3
20003fb8:	4610      	mov	r0, r2
20003fba:	f7fd f92c 	bl	20001216 <lib_strcpy>
		cmd->sibling = *list;
20003fbe:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
20003fc0:	681a      	ldr	r2, [r3, #0]
20003fc2:	6a3b      	ldr	r3, [r7, #32]
20003fc4:	601a      	str	r2, [r3, #0]
		*list = cmd;
20003fc6:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
20003fc8:	6a3a      	ldr	r2, [r7, #32]
20003fca:	601a      	str	r2, [r3, #0]
		}
	    list = &(cmd->child);
20003fcc:	6a3b      	ldr	r3, [r7, #32]
20003fce:	3304      	adds	r3, #4
20003fd0:	627b      	str	r3, [r7, #36]	@ 0x24
	    }
	cur = cur->q_next;
20003fd2:	69fb      	ldr	r3, [r7, #28]
20003fd4:	681b      	ldr	r3, [r3, #0]
20003fd6:	61fb      	str	r3, [r7, #28]
    while (cur != &tokens) {
20003fd8:	f107 0310 	add.w	r3, r7, #16
20003fdc:	69fa      	ldr	r2, [r7, #28]
20003fde:	429a      	cmp	r2, r3
20003fe0:	d1ba      	bne.n	20003f58 <cmd_addcmd+0x28>
	}

    cmd_free_tokens(&tokens);
20003fe2:	f107 0310 	add.w	r3, r7, #16
20003fe6:	4618      	mov	r0, r3
20003fe8:	f000 fe16 	bl	20004c18 <cmd_free_tokens>

    if (!cmd) return -1;
20003fec:	6a3b      	ldr	r3, [r7, #32]
20003fee:	2b00      	cmp	r3, #0
20003ff0:	d102      	bne.n	20003ff8 <cmd_addcmd+0xc8>
20003ff2:	f04f 33ff 	mov.w	r3, #4294967295	@ 0xffffffff
20003ff6:	e00f      	b.n	20004018 <cmd_addcmd+0xe8>

    cmd->func = func;
20003ff8:	6a3b      	ldr	r3, [r7, #32]
20003ffa:	68ba      	ldr	r2, [r7, #8]
20003ffc:	60da      	str	r2, [r3, #12]
    cmd->usage = usage;
20003ffe:	6a3b      	ldr	r3, [r7, #32]
20004000:	6b3a      	ldr	r2, [r7, #48]	@ 0x30
20004002:	619a      	str	r2, [r3, #24]
    cmd->ref = ref;
20004004:	6a3b      	ldr	r3, [r7, #32]
20004006:	687a      	ldr	r2, [r7, #4]
20004008:	611a      	str	r2, [r3, #16]
    cmd->help = help;
2000400a:	6a3b      	ldr	r3, [r7, #32]
2000400c:	683a      	ldr	r2, [r7, #0]
2000400e:	615a      	str	r2, [r3, #20]
    cmd->switches = switches;
20004010:	6a3b      	ldr	r3, [r7, #32]
20004012:	6b7a      	ldr	r2, [r7, #52]	@ 0x34
20004014:	61da      	str	r2, [r3, #28]

    return 0;
20004016:	2300      	movs	r3, #0
}
20004018:	4618      	mov	r0, r3
2000401a:	3728      	adds	r7, #40	@ 0x28
2000401c:	46bd      	mov	sp, r7
2000401e:	bd80      	pop	{r7, pc}
20004020:	200060fc 	.word	0x200060fc
20004024:	20005e94 	.word	0x20005e94

20004028 <_dumpindented>:



static void _dumpindented(char *str,int amt)
{
20004028:	b580      	push	{r7, lr}
2000402a:	b086      	sub	sp, #24
2000402c:	af00      	add	r7, sp, #0
2000402e:	6078      	str	r0, [r7, #4]
20004030:	6039      	str	r1, [r7, #0]
    int idx;
    char *dupstr;
    char *end;
    char *ptr;

    dupstr = strdup(str);
20004032:	6878      	ldr	r0, [r7, #4]
20004034:	f7fd fa94 	bl	20001560 <lib_strdup>
20004038:	60b8      	str	r0, [r7, #8]

    ptr = dupstr;
2000403a:	68bb      	ldr	r3, [r7, #8]
2000403c:	60fb      	str	r3, [r7, #12]

    while (*ptr) {
2000403e:	e027      	b.n	20004090 <_dumpindented+0x68>
	for (idx = 0; idx < amt; idx++) printf(" ");
20004040:	2300      	movs	r3, #0
20004042:	617b      	str	r3, [r7, #20]
20004044:	e005      	b.n	20004052 <_dumpindented+0x2a>
20004046:	2020      	movs	r0, #32
20004048:	f7fc fe56 	bl	20000cf8 <putchar>
2000404c:	697b      	ldr	r3, [r7, #20]
2000404e:	3301      	adds	r3, #1
20004050:	617b      	str	r3, [r7, #20]
20004052:	697a      	ldr	r2, [r7, #20]
20004054:	683b      	ldr	r3, [r7, #0]
20004056:	429a      	cmp	r2, r3
20004058:	dbf5      	blt.n	20004046 <_dumpindented+0x1e>

	end = strchr(ptr,'\n');
2000405a:	210a      	movs	r1, #10
2000405c:	68f8      	ldr	r0, [r7, #12]
2000405e:	f7fd f97b 	bl	20001358 <lib_strchr>
20004062:	6138      	str	r0, [r7, #16]

	if (end) *end++ = '\0';
20004064:	693b      	ldr	r3, [r7, #16]
20004066:	2b00      	cmp	r3, #0
20004068:	d005      	beq.n	20004076 <_dumpindented+0x4e>
2000406a:	693b      	ldr	r3, [r7, #16]
2000406c:	1c5a      	adds	r2, r3, #1
2000406e:	613a      	str	r2, [r7, #16]
20004070:	2200      	movs	r2, #0
20004072:	701a      	strb	r2, [r3, #0]
20004074:	e007      	b.n	20004086 <_dumpindented+0x5e>
	else end = ptr + strlen(ptr);
20004076:	68f8      	ldr	r0, [r7, #12]
20004078:	f7fd f915 	bl	200012a6 <lib_strlen>
2000407c:	4603      	mov	r3, r0
2000407e:	461a      	mov	r2, r3
20004080:	68fb      	ldr	r3, [r7, #12]
20004082:	4413      	add	r3, r2
20004084:	613b      	str	r3, [r7, #16]

	printf("%s\n",ptr);
20004086:	68f8      	ldr	r0, [r7, #12]
20004088:	f7fc fe2a 	bl	20000ce0 <puts>
	ptr = end;
2000408c:	693b      	ldr	r3, [r7, #16]
2000408e:	60fb      	str	r3, [r7, #12]
    while (*ptr) {
20004090:	68fb      	ldr	r3, [r7, #12]
20004092:	781b      	ldrb	r3, [r3, #0]
20004094:	2b00      	cmp	r3, #0
20004096:	d1d3      	bne.n	20004040 <_dumpindented+0x18>
	}

    KFREE(dupstr);
20004098:	68b9      	ldr	r1, [r7, #8]
2000409a:	4803      	ldr	r0, [pc, #12]	@ (200040a8 <_dumpindented+0x80>)
2000409c:	f7fc ff60 	bl	20000f60 <kfree>
}
200040a0:	bf00      	nop
200040a2:	3718      	adds	r7, #24
200040a4:	46bd      	mov	sp, r7
200040a6:	bd80      	pop	{r7, pc}
200040a8:	20005e94 	.word	0x20005e94

200040ac <_dumpswitches>:

static void _dumpswitches(char *str)
{
200040ac:	b580      	push	{r7, lr}
200040ae:	b088      	sub	sp, #32
200040b0:	af00      	add	r7, sp, #0
200040b2:	6078      	str	r0, [r7, #4]
    char *end;
    char *ptr;
    char *semi;
    char *newline;

    switches = strdup(str);
200040b4:	6878      	ldr	r0, [r7, #4]
200040b6:	f7fd fa53 	bl	20001560 <lib_strdup>
200040ba:	6138      	str	r0, [r7, #16]

    ptr = switches;
200040bc:	693b      	ldr	r3, [r7, #16]
200040be:	61bb      	str	r3, [r7, #24]

    while (*ptr) {
200040c0:	e045      	b.n	2000414e <_dumpswitches+0xa2>
	end = strchr(ptr,'|');
200040c2:	217c      	movs	r1, #124	@ 0x7c
200040c4:	69b8      	ldr	r0, [r7, #24]
200040c6:	f7fd f947 	bl	20001358 <lib_strchr>
200040ca:	61f8      	str	r0, [r7, #28]
	if (end) *end++ = '\0';
200040cc:	69fb      	ldr	r3, [r7, #28]
200040ce:	2b00      	cmp	r3, #0
200040d0:	d005      	beq.n	200040de <_dumpswitches+0x32>
200040d2:	69fb      	ldr	r3, [r7, #28]
200040d4:	1c5a      	adds	r2, r3, #1
200040d6:	61fa      	str	r2, [r7, #28]
200040d8:	2200      	movs	r2, #0
200040da:	701a      	strb	r2, [r3, #0]
200040dc:	e007      	b.n	200040ee <_dumpswitches+0x42>
	else end = ptr + strlen(ptr);
200040de:	69b8      	ldr	r0, [r7, #24]
200040e0:	f7fd f8e1 	bl	200012a6 <lib_strlen>
200040e4:	4603      	mov	r3, r0
200040e6:	461a      	mov	r2, r3
200040e8:	69bb      	ldr	r3, [r7, #24]
200040ea:	4413      	add	r3, r2
200040ec:	61fb      	str	r3, [r7, #28]

	printf("     ");
200040ee:	481e      	ldr	r0, [pc, #120]	@ (20004168 <_dumpswitches+0xbc>)
200040f0:	f7fc fd9a 	bl	20000c28 <printf>
	if ((semi = strchr(ptr,';'))) {
200040f4:	213b      	movs	r1, #59	@ 0x3b
200040f6:	69b8      	ldr	r0, [r7, #24]
200040f8:	f7fd f92e 	bl	20001358 <lib_strchr>
200040fc:	60f8      	str	r0, [r7, #12]
200040fe:	68fb      	ldr	r3, [r7, #12]
20004100:	2b00      	cmp	r3, #0
20004102:	d01e      	beq.n	20004142 <_dumpswitches+0x96>
	    *semi++ = '\0';
20004104:	68fb      	ldr	r3, [r7, #12]
20004106:	1c5a      	adds	r2, r3, #1
20004108:	60fa      	str	r2, [r7, #12]
2000410a:	2200      	movs	r2, #0
2000410c:	701a      	strb	r2, [r3, #0]
	    newline = strchr(semi,'\n');
2000410e:	210a      	movs	r1, #10
20004110:	68f8      	ldr	r0, [r7, #12]
20004112:	f7fd f921 	bl	20001358 <lib_strchr>
20004116:	6178      	str	r0, [r7, #20]
	    if (newline) *newline++ = '\0';
20004118:	697b      	ldr	r3, [r7, #20]
2000411a:	2b00      	cmp	r3, #0
2000411c:	d004      	beq.n	20004128 <_dumpswitches+0x7c>
2000411e:	697b      	ldr	r3, [r7, #20]
20004120:	1c5a      	adds	r2, r3, #1
20004122:	617a      	str	r2, [r7, #20]
20004124:	2200      	movs	r2, #0
20004126:	701a      	strb	r2, [r3, #0]
	    printf("%-12s %s\n",ptr,semi);
20004128:	68fa      	ldr	r2, [r7, #12]
2000412a:	69b9      	ldr	r1, [r7, #24]
2000412c:	480f      	ldr	r0, [pc, #60]	@ (2000416c <_dumpswitches+0xc0>)
2000412e:	f7fc fd7b 	bl	20000c28 <printf>
	    if (newline) _dumpindented(newline,5+12+1);
20004132:	697b      	ldr	r3, [r7, #20]
20004134:	2b00      	cmp	r3, #0
20004136:	d008      	beq.n	2000414a <_dumpswitches+0x9e>
20004138:	2112      	movs	r1, #18
2000413a:	6978      	ldr	r0, [r7, #20]
2000413c:	f7ff ff74 	bl	20004028 <_dumpindented>
20004140:	e003      	b.n	2000414a <_dumpswitches+0x9e>
	    }
	else {
	    printf("%-12s (no information)\n",ptr);
20004142:	69b9      	ldr	r1, [r7, #24]
20004144:	480a      	ldr	r0, [pc, #40]	@ (20004170 <_dumpswitches+0xc4>)
20004146:	f7fc fd6f 	bl	20000c28 <printf>
	    }
	ptr = end;
2000414a:	69fb      	ldr	r3, [r7, #28]
2000414c:	61bb      	str	r3, [r7, #24]
    while (*ptr) {
2000414e:	69bb      	ldr	r3, [r7, #24]
20004150:	781b      	ldrb	r3, [r3, #0]
20004152:	2b00      	cmp	r3, #0
20004154:	d1b5      	bne.n	200040c2 <_dumpswitches+0x16>
	}

    KFREE(switches);
20004156:	6939      	ldr	r1, [r7, #16]
20004158:	4806      	ldr	r0, [pc, #24]	@ (20004174 <_dumpswitches+0xc8>)
2000415a:	f7fc ff01 	bl	20000f60 <kfree>
}
2000415e:	bf00      	nop
20004160:	3720      	adds	r7, #32
20004162:	46bd      	mov	sp, r7
20004164:	bd80      	pop	{r7, pc}
20004166:	bf00      	nop
20004168:	200055d4 	.word	0x200055d4
2000416c:	200055dc 	.word	0x200055dc
20004170:	200055e8 	.word	0x200055e8
20004174:	20005e94 	.word	0x20005e94

20004178 <_dumpcmds>:

static void _dumpcmds(cmdtab_t *cmd,int level,char **words,int verbose)
{
20004178:	b580      	push	{r7, lr}
2000417a:	b086      	sub	sp, #24
2000417c:	af00      	add	r7, sp, #0
2000417e:	60f8      	str	r0, [r7, #12]
20004180:	60b9      	str	r1, [r7, #8]
20004182:	607a      	str	r2, [r7, #4]
20004184:	603b      	str	r3, [r7, #0]
    int idx;
    int len;

    while (cmd) {
20004186:	e06e      	b.n	20004266 <_dumpcmds+0xee>
	len = 0;
20004188:	2300      	movs	r3, #0
2000418a:	613b      	str	r3, [r7, #16]
	words[level] = cmd->cmdword;
2000418c:	68bb      	ldr	r3, [r7, #8]
2000418e:	009b      	lsls	r3, r3, #2
20004190:	687a      	ldr	r2, [r7, #4]
20004192:	4413      	add	r3, r2
20004194:	68fa      	ldr	r2, [r7, #12]
20004196:	6892      	ldr	r2, [r2, #8]
20004198:	601a      	str	r2, [r3, #0]
	if (cmd->func) {
2000419a:	68fb      	ldr	r3, [r7, #12]
2000419c:	68db      	ldr	r3, [r3, #12]
2000419e:	2b00      	cmp	r3, #0
200041a0:	d056      	beq.n	20004250 <_dumpcmds+0xd8>
	    for (idx = 0; idx < level; idx++) {
200041a2:	2300      	movs	r3, #0
200041a4:	617b      	str	r3, [r7, #20]
200041a6:	e018      	b.n	200041da <_dumpcmds+0x62>
		printf("%s ",words[idx]);
200041a8:	697b      	ldr	r3, [r7, #20]
200041aa:	009b      	lsls	r3, r3, #2
200041ac:	687a      	ldr	r2, [r7, #4]
200041ae:	4413      	add	r3, r2
200041b0:	681b      	ldr	r3, [r3, #0]
200041b2:	4619      	mov	r1, r3
200041b4:	4830      	ldr	r0, [pc, #192]	@ (20004278 <_dumpcmds+0x100>)
200041b6:	f7fc fd37 	bl	20000c28 <printf>
		len += strlen(words[idx])+1;
200041ba:	697b      	ldr	r3, [r7, #20]
200041bc:	009b      	lsls	r3, r3, #2
200041be:	687a      	ldr	r2, [r7, #4]
200041c0:	4413      	add	r3, r2
200041c2:	681b      	ldr	r3, [r3, #0]
200041c4:	4618      	mov	r0, r3
200041c6:	f7fd f86e 	bl	200012a6 <lib_strlen>
200041ca:	4603      	mov	r3, r0
200041cc:	3301      	adds	r3, #1
200041ce:	693a      	ldr	r2, [r7, #16]
200041d0:	4413      	add	r3, r2
200041d2:	613b      	str	r3, [r7, #16]
	    for (idx = 0; idx < level; idx++) {
200041d4:	697b      	ldr	r3, [r7, #20]
200041d6:	3301      	adds	r3, #1
200041d8:	617b      	str	r3, [r7, #20]
200041da:	697a      	ldr	r2, [r7, #20]
200041dc:	68bb      	ldr	r3, [r7, #8]
200041de:	429a      	cmp	r2, r3
200041e0:	dbe2      	blt.n	200041a8 <_dumpcmds+0x30>
		}
	    printf("%s",cmd->cmdword);
200041e2:	68fb      	ldr	r3, [r7, #12]
200041e4:	689b      	ldr	r3, [r3, #8]
200041e6:	4619      	mov	r1, r3
200041e8:	4824      	ldr	r0, [pc, #144]	@ (2000427c <_dumpcmds+0x104>)
200041ea:	f7fc fd1d 	bl	20000c28 <printf>
	    len += strlen(cmd->cmdword);
200041ee:	68fb      	ldr	r3, [r7, #12]
200041f0:	689b      	ldr	r3, [r3, #8]
200041f2:	4618      	mov	r0, r3
200041f4:	f7fd f857 	bl	200012a6 <lib_strlen>
200041f8:	4602      	mov	r2, r0
200041fa:	693b      	ldr	r3, [r7, #16]
200041fc:	4413      	add	r3, r2
200041fe:	613b      	str	r3, [r7, #16]
	    for (idx = len; idx < 20; idx++) printf(" ");
20004200:	693b      	ldr	r3, [r7, #16]
20004202:	617b      	str	r3, [r7, #20]
20004204:	e005      	b.n	20004212 <_dumpcmds+0x9a>
20004206:	2020      	movs	r0, #32
20004208:	f7fc fd76 	bl	20000cf8 <putchar>
2000420c:	697b      	ldr	r3, [r7, #20]
2000420e:	3301      	adds	r3, #1
20004210:	617b      	str	r3, [r7, #20]
20004212:	697b      	ldr	r3, [r7, #20]
20004214:	2b13      	cmp	r3, #19
20004216:	ddf6      	ble.n	20004206 <_dumpcmds+0x8e>
	    printf("%s\n",cmd->help);
20004218:	68fb      	ldr	r3, [r7, #12]
2000421a:	695b      	ldr	r3, [r3, #20]
2000421c:	4618      	mov	r0, r3
2000421e:	f7fc fd5f 	bl	20000ce0 <puts>
	    if (verbose) {
20004222:	683b      	ldr	r3, [r7, #0]
20004224:	2b00      	cmp	r3, #0
20004226:	d013      	beq.n	20004250 <_dumpcmds+0xd8>
		printf("\n");
20004228:	200a      	movs	r0, #10
2000422a:	f7fc fd65 	bl	20000cf8 <putchar>
		_dumpindented(cmd->usage,5);
2000422e:	68fb      	ldr	r3, [r7, #12]
20004230:	699b      	ldr	r3, [r3, #24]
20004232:	2105      	movs	r1, #5
20004234:	4618      	mov	r0, r3
20004236:	f7ff fef7 	bl	20004028 <_dumpindented>
		printf("\n");
2000423a:	200a      	movs	r0, #10
2000423c:	f7fc fd5c 	bl	20000cf8 <putchar>
		_dumpswitches(cmd->switches);
20004240:	68fb      	ldr	r3, [r7, #12]
20004242:	69db      	ldr	r3, [r3, #28]
20004244:	4618      	mov	r0, r3
20004246:	f7ff ff31 	bl	200040ac <_dumpswitches>
		printf("\n");
2000424a:	200a      	movs	r0, #10
2000424c:	f7fc fd54 	bl	20000cf8 <putchar>
		}
	    }
	_dumpcmds(cmd->child,level+1,words,verbose);
20004250:	68fb      	ldr	r3, [r7, #12]
20004252:	6858      	ldr	r0, [r3, #4]
20004254:	68bb      	ldr	r3, [r7, #8]
20004256:	1c59      	adds	r1, r3, #1
20004258:	683b      	ldr	r3, [r7, #0]
2000425a:	687a      	ldr	r2, [r7, #4]
2000425c:	f7ff ff8c 	bl	20004178 <_dumpcmds>
	cmd = cmd->sibling;
20004260:	68fb      	ldr	r3, [r7, #12]
20004262:	681b      	ldr	r3, [r3, #0]
20004264:	60fb      	str	r3, [r7, #12]
    while (cmd) {
20004266:	68fb      	ldr	r3, [r7, #12]
20004268:	2b00      	cmp	r3, #0
2000426a:	d18d      	bne.n	20004188 <_dumpcmds+0x10>
	}
}
2000426c:	bf00      	nop
2000426e:	bf00      	nop
20004270:	3718      	adds	r7, #24
20004272:	46bd      	mov	sp, r7
20004274:	bd80      	pop	{r7, pc}
20004276:	bf00      	nop
20004278:	20005600 	.word	0x20005600
2000427c:	20005604 	.word	0x20005604

20004280 <dumpcmds>:

static void dumpcmds(int verbose)
{
20004280:	b580      	push	{r7, lr}
20004282:	b096      	sub	sp, #88	@ 0x58
20004284:	af00      	add	r7, sp, #0
20004286:	6078      	str	r0, [r7, #4]
    char *words[20];

    _dumpcmds(cmd_root,0,words,verbose);
20004288:	4b05      	ldr	r3, [pc, #20]	@ (200042a0 <dumpcmds+0x20>)
2000428a:	6818      	ldr	r0, [r3, #0]
2000428c:	f107 0208 	add.w	r2, r7, #8
20004290:	687b      	ldr	r3, [r7, #4]
20004292:	2100      	movs	r1, #0
20004294:	f7ff ff70 	bl	20004178 <_dumpcmds>
}
20004298:	bf00      	nop
2000429a:	3758      	adds	r7, #88	@ 0x58
2000429c:	46bd      	mov	sp, r7
2000429e:	bd80      	pop	{r7, pc}
200042a0:	200060fc 	.word	0x200060fc

200042a4 <_showpossible>:


static void _showpossible(ui_cmdline_t *cline,cmdtab_t *cmd)
{
200042a4:	b580      	push	{r7, lr}
200042a6:	b084      	sub	sp, #16
200042a8:	af00      	add	r7, sp, #0
200042aa:	6078      	str	r0, [r7, #4]
200042ac:	6039      	str	r1, [r7, #0]
    int i;

    if (cline->argidx == 0) {
200042ae:	687b      	ldr	r3, [r7, #4]
200042b0:	f8d3 31cc 	ldr.w	r3, [r3, #460]	@ 0x1cc
200042b4:	2b00      	cmp	r3, #0
200042b6:	d103      	bne.n	200042c0 <_showpossible+0x1c>
	printf("Available commands: ");
200042b8:	481f      	ldr	r0, [pc, #124]	@ (20004338 <_showpossible+0x94>)
200042ba:	f7fc fcb5 	bl	20000c28 <printf>
200042be:	e031      	b.n	20004324 <_showpossible+0x80>
	}
    else {
	printf("Available \"");
200042c0:	481e      	ldr	r0, [pc, #120]	@ (2000433c <_showpossible+0x98>)
200042c2:	f7fc fcb1 	bl	20000c28 <printf>
	for (i = 0; i < cline->argidx; i++) {
200042c6:	2300      	movs	r3, #0
200042c8:	60fb      	str	r3, [r7, #12]
200042ca:	e011      	b.n	200042f0 <_showpossible+0x4c>
	    printf("%s%s",(i == 0) ? "" : " ",cline->argv[i]);
200042cc:	68fb      	ldr	r3, [r7, #12]
200042ce:	2b00      	cmp	r3, #0
200042d0:	d101      	bne.n	200042d6 <_showpossible+0x32>
200042d2:	491b      	ldr	r1, [pc, #108]	@ (20004340 <_showpossible+0x9c>)
200042d4:	e000      	b.n	200042d8 <_showpossible+0x34>
200042d6:	491b      	ldr	r1, [pc, #108]	@ (20004344 <_showpossible+0xa0>)
200042d8:	687a      	ldr	r2, [r7, #4]
200042da:	68fb      	ldr	r3, [r7, #12]
200042dc:	009b      	lsls	r3, r3, #2
200042de:	4413      	add	r3, r2
200042e0:	685b      	ldr	r3, [r3, #4]
200042e2:	461a      	mov	r2, r3
200042e4:	4818      	ldr	r0, [pc, #96]	@ (20004348 <_showpossible+0xa4>)
200042e6:	f7fc fc9f 	bl	20000c28 <printf>
	for (i = 0; i < cline->argidx; i++) {
200042ea:	68fb      	ldr	r3, [r7, #12]
200042ec:	3301      	adds	r3, #1
200042ee:	60fb      	str	r3, [r7, #12]
200042f0:	687b      	ldr	r3, [r7, #4]
200042f2:	f8d3 31cc 	ldr.w	r3, [r3, #460]	@ 0x1cc
200042f6:	68fa      	ldr	r2, [r7, #12]
200042f8:	429a      	cmp	r2, r3
200042fa:	dbe7      	blt.n	200042cc <_showpossible+0x28>
	    }
	printf("\" commands: ");
200042fc:	4813      	ldr	r0, [pc, #76]	@ (2000434c <_showpossible+0xa8>)
200042fe:	f7fc fc93 	bl	20000c28 <printf>
	}

    while (cmd) {
20004302:	e00f      	b.n	20004324 <_showpossible+0x80>
	printf("%s",cmd->cmdword);
20004304:	683b      	ldr	r3, [r7, #0]
20004306:	689b      	ldr	r3, [r3, #8]
20004308:	4619      	mov	r1, r3
2000430a:	4811      	ldr	r0, [pc, #68]	@ (20004350 <_showpossible+0xac>)
2000430c:	f7fc fc8c 	bl	20000c28 <printf>
	if (cmd->sibling) printf(", ");
20004310:	683b      	ldr	r3, [r7, #0]
20004312:	681b      	ldr	r3, [r3, #0]
20004314:	2b00      	cmp	r3, #0
20004316:	d002      	beq.n	2000431e <_showpossible+0x7a>
20004318:	480e      	ldr	r0, [pc, #56]	@ (20004354 <_showpossible+0xb0>)
2000431a:	f7fc fc85 	bl	20000c28 <printf>
	cmd = cmd->sibling;
2000431e:	683b      	ldr	r3, [r7, #0]
20004320:	681b      	ldr	r3, [r3, #0]
20004322:	603b      	str	r3, [r7, #0]
    while (cmd) {
20004324:	683b      	ldr	r3, [r7, #0]
20004326:	2b00      	cmp	r3, #0
20004328:	d1ec      	bne.n	20004304 <_showpossible+0x60>
	}

    printf("\n");
2000432a:	200a      	movs	r0, #10
2000432c:	f7fc fce4 	bl	20000cf8 <putchar>
}
20004330:	bf00      	nop
20004332:	3710      	adds	r7, #16
20004334:	46bd      	mov	sp, r7
20004336:	bd80      	pop	{r7, pc}
20004338:	20005608 	.word	0x20005608
2000433c:	20005620 	.word	0x20005620
20004340:	2000562c 	.word	0x2000562c
20004344:	20005630 	.word	0x20005630
20004348:	20005634 	.word	0x20005634
2000434c:	2000563c 	.word	0x2000563c
20004350:	20005604 	.word	0x20005604
20004354:	2000564c 	.word	0x2000564c

20004358 <cmd_help>:

static int cmd_help(ui_cmdline_t *cmd,int argc,char *argv[])
{
20004358:	b580      	push	{r7, lr}
2000435a:	b088      	sub	sp, #32
2000435c:	af00      	add	r7, sp, #0
2000435e:	60f8      	str	r0, [r7, #12]
20004360:	60b9      	str	r1, [r7, #8]
20004362:	607a      	str	r2, [r7, #4]
    cmdtab_t **tab;
    cmdtab_t *cword;
    int idx;

    if (argc == 0) {
20004364:	68bb      	ldr	r3, [r7, #8]
20004366:	2b00      	cmp	r3, #0
20004368:	d10c      	bne.n	20004384 <cmd_help+0x2c>
	printf("Available commands:\n\n");
2000436a:	4843      	ldr	r0, [pc, #268]	@ (20004478 <cmd_help+0x120>)
2000436c:	f7fc fcb8 	bl	20000ce0 <puts>
	dumpcmds(0);
20004370:	2000      	movs	r0, #0
20004372:	f7ff ff85 	bl	20004280 <dumpcmds>
	printf("\n");
20004376:	200a      	movs	r0, #10
20004378:	f7fc fcbe 	bl	20000cf8 <putchar>
	printf("For more information about a command, enter 'help command-name'\n");
2000437c:	483f      	ldr	r0, [pc, #252]	@ (2000447c <cmd_help+0x124>)
2000437e:	f7fc fcaf 	bl	20000ce0 <puts>
20004382:	e073      	b.n	2000446c <cmd_help+0x114>
	}
    else {
	idx = 0;
20004384:	2300      	movs	r3, #0
20004386:	61bb      	str	r3, [r7, #24]
	tab = &cmd_root;
20004388:	4b3d      	ldr	r3, [pc, #244]	@ (20004480 <cmd_help+0x128>)
2000438a:	61fb      	str	r3, [r7, #28]
	cword = NULL;
2000438c:	2300      	movs	r3, #0
2000438e:	617b      	str	r3, [r7, #20]

	for (;;) {
	    cword = cmd_findword(*tab,argv[idx]);
20004390:	69fb      	ldr	r3, [r7, #28]
20004392:	6818      	ldr	r0, [r3, #0]
20004394:	69bb      	ldr	r3, [r7, #24]
20004396:	009b      	lsls	r3, r3, #2
20004398:	687a      	ldr	r2, [r7, #4]
2000439a:	4413      	add	r3, r2
2000439c:	681b      	ldr	r3, [r3, #0]
2000439e:	4619      	mov	r1, r3
200043a0:	f7ff fcfc 	bl	20003d9c <cmd_findword>
200043a4:	6178      	str	r0, [r7, #20]
	    if (!cword) break;
200043a6:	697b      	ldr	r3, [r7, #20]
200043a8:	2b00      	cmp	r3, #0
200043aa:	d00e      	beq.n	200043ca <cmd_help+0x72>
	    if (cword->func != NULL) break;
200043ac:	697b      	ldr	r3, [r7, #20]
200043ae:	68db      	ldr	r3, [r3, #12]
200043b0:	2b00      	cmp	r3, #0
200043b2:	d10c      	bne.n	200043ce <cmd_help+0x76>
	    idx++;
200043b4:	69bb      	ldr	r3, [r7, #24]
200043b6:	3301      	adds	r3, #1
200043b8:	61bb      	str	r3, [r7, #24]
	    tab = &(cword->child);
200043ba:	697b      	ldr	r3, [r7, #20]
200043bc:	3304      	adds	r3, #4
200043be:	61fb      	str	r3, [r7, #28]
	    if (idx >= argc) break;
200043c0:	69ba      	ldr	r2, [r7, #24]
200043c2:	68bb      	ldr	r3, [r7, #8]
200043c4:	429a      	cmp	r2, r3
200043c6:	da04      	bge.n	200043d2 <cmd_help+0x7a>
	    cword = cmd_findword(*tab,argv[idx]);
200043c8:	e7e2      	b.n	20004390 <cmd_help+0x38>
	    if (!cword) break;
200043ca:	bf00      	nop
200043cc:	e002      	b.n	200043d4 <cmd_help+0x7c>
	    if (cword->func != NULL) break;
200043ce:	bf00      	nop
200043d0:	e000      	b.n	200043d4 <cmd_help+0x7c>
	    if (idx >= argc) break;
200043d2:	bf00      	nop
	    }

	if (cword == NULL) {
200043d4:	697b      	ldr	r3, [r7, #20]
200043d6:	2b00      	cmp	r3, #0
200043d8:	d10e      	bne.n	200043f8 <cmd_help+0xa0>
	    printf("No help available for '%s'.\n\n",argv[idx]);
200043da:	69bb      	ldr	r3, [r7, #24]
200043dc:	009b      	lsls	r3, r3, #2
200043de:	687a      	ldr	r2, [r7, #4]
200043e0:	4413      	add	r3, r2
200043e2:	681b      	ldr	r3, [r3, #0]
200043e4:	4619      	mov	r1, r3
200043e6:	4827      	ldr	r0, [pc, #156]	@ (20004484 <cmd_help+0x12c>)
200043e8:	f7fc fc1e 	bl	20000c28 <printf>
	    printf("Type 'help' for a list of commands.\n");
200043ec:	4826      	ldr	r0, [pc, #152]	@ (20004488 <cmd_help+0x130>)
200043ee:	f7fc fc77 	bl	20000ce0 <puts>
	    return -1;
200043f2:	f04f 33ff 	mov.w	r3, #4294967295	@ 0xffffffff
200043f6:	e03a      	b.n	2000446e <cmd_help+0x116>
	    }

	if (!cword->func && (idx >= argc)) {
200043f8:	697b      	ldr	r3, [r7, #20]
200043fa:	68db      	ldr	r3, [r3, #12]
200043fc:	2b00      	cmp	r3, #0
200043fe:	d10f      	bne.n	20004420 <cmd_help+0xc8>
20004400:	69ba      	ldr	r2, [r7, #24]
20004402:	68bb      	ldr	r3, [r7, #8]
20004404:	429a      	cmp	r2, r3
20004406:	db0b      	blt.n	20004420 <cmd_help+0xc8>
	    printf("No help available for '%s'.\n\n",cword->cmdword);
20004408:	697b      	ldr	r3, [r7, #20]
2000440a:	689b      	ldr	r3, [r3, #8]
2000440c:	4619      	mov	r1, r3
2000440e:	481d      	ldr	r0, [pc, #116]	@ (20004484 <cmd_help+0x12c>)
20004410:	f7fc fc0a 	bl	20000c28 <printf>
	    printf("Type 'help' for a list of commands.\n");
20004414:	481c      	ldr	r0, [pc, #112]	@ (20004488 <cmd_help+0x130>)
20004416:	f7fc fc63 	bl	20000ce0 <puts>
	    return -1;
2000441a:	f04f 33ff 	mov.w	r3, #4294967295	@ 0xffffffff
2000441e:	e026      	b.n	2000446e <cmd_help+0x116>
	    }

	printf("\n  SUMMARY\n\n");
20004420:	481a      	ldr	r0, [pc, #104]	@ (2000448c <cmd_help+0x134>)
20004422:	f7fc fc5d 	bl	20000ce0 <puts>
	_dumpindented(cword->help,5);
20004426:	697b      	ldr	r3, [r7, #20]
20004428:	695b      	ldr	r3, [r3, #20]
2000442a:	2105      	movs	r1, #5
2000442c:	4618      	mov	r0, r3
2000442e:	f7ff fdfb 	bl	20004028 <_dumpindented>
	printf("\n  USAGE\n\n");
20004432:	4817      	ldr	r0, [pc, #92]	@ (20004490 <cmd_help+0x138>)
20004434:	f7fc fc54 	bl	20000ce0 <puts>
	_dumpindented(cword->usage,5);
20004438:	697b      	ldr	r3, [r7, #20]
2000443a:	699b      	ldr	r3, [r3, #24]
2000443c:	2105      	movs	r1, #5
2000443e:	4618      	mov	r0, r3
20004440:	f7ff fdf2 	bl	20004028 <_dumpindented>
	if (cword->switches && cword->switches[0]) {
20004444:	697b      	ldr	r3, [r7, #20]
20004446:	69db      	ldr	r3, [r3, #28]
20004448:	2b00      	cmp	r3, #0
2000444a:	d00c      	beq.n	20004466 <cmd_help+0x10e>
2000444c:	697b      	ldr	r3, [r7, #20]
2000444e:	69db      	ldr	r3, [r3, #28]
20004450:	781b      	ldrb	r3, [r3, #0]
20004452:	2b00      	cmp	r3, #0
20004454:	d007      	beq.n	20004466 <cmd_help+0x10e>
	    printf("\n  OPTIONS\n\n");
20004456:	480f      	ldr	r0, [pc, #60]	@ (20004494 <cmd_help+0x13c>)
20004458:	f7fc fc42 	bl	20000ce0 <puts>
	    _dumpswitches(cword->switches);
2000445c:	697b      	ldr	r3, [r7, #20]
2000445e:	69db      	ldr	r3, [r3, #28]
20004460:	4618      	mov	r0, r3
20004462:	f7ff fe23 	bl	200040ac <_dumpswitches>
	    }
	printf("\n");
20004466:	200a      	movs	r0, #10
20004468:	f7fc fc46 	bl	20000cf8 <putchar>
	}

    return 0;
2000446c:	2300      	movs	r3, #0
}
2000446e:	4618      	mov	r0, r3
20004470:	3720      	adds	r7, #32
20004472:	46bd      	mov	sp, r7
20004474:	bd80      	pop	{r7, pc}
20004476:	bf00      	nop
20004478:	20005650 	.word	0x20005650
2000447c:	20005668 	.word	0x20005668
20004480:	200060fc 	.word	0x200060fc
20004484:	200056a8 	.word	0x200056a8
20004488:	200056c8 	.word	0x200056c8
2000448c:	200056ec 	.word	0x200056ec
20004490:	200056f8 	.word	0x200056f8
20004494:	20005704 	.word	0x20005704

20004498 <cmd_init>:

void cmd_init(void)
{
20004498:	b580      	push	{r7, lr}
2000449a:	b082      	sub	sp, #8
2000449c:	af02      	add	r7, sp, #8
    cmd_root = NULL;
2000449e:	4b08      	ldr	r3, [pc, #32]	@ (200044c0 <cmd_init+0x28>)
200044a0:	2200      	movs	r2, #0
200044a2:	601a      	str	r2, [r3, #0]

    cmd_addcmd("help",
200044a4:	4b07      	ldr	r3, [pc, #28]	@ (200044c4 <cmd_init+0x2c>)
200044a6:	9301      	str	r3, [sp, #4]
200044a8:	4b07      	ldr	r3, [pc, #28]	@ (200044c8 <cmd_init+0x30>)
200044aa:	9300      	str	r3, [sp, #0]
200044ac:	4b07      	ldr	r3, [pc, #28]	@ (200044cc <cmd_init+0x34>)
200044ae:	2200      	movs	r2, #0
200044b0:	4907      	ldr	r1, [pc, #28]	@ (200044d0 <cmd_init+0x38>)
200044b2:	4808      	ldr	r0, [pc, #32]	@ (200044d4 <cmd_init+0x3c>)
200044b4:	f7ff fd3c 	bl	20003f30 <cmd_addcmd>
	       "help [command]\n\n"
	       "Without any parameters, the 'help' command will display a summary\n"
	       "of available commands.  For more details on a command, type 'help'\n"
	       "and the command name.",
	       "");
}
200044b8:	bf00      	nop
200044ba:	46bd      	mov	sp, r7
200044bc:	bd80      	pop	{r7, pc}
200044be:	bf00      	nop
200044c0:	200060fc 	.word	0x200060fc
200044c4:	2000562c 	.word	0x2000562c
200044c8:	20005738 	.word	0x20005738
200044cc:	20005710 	.word	0x20005710
200044d0:	20004359 	.word	0x20004359
200044d4:	20005730 	.word	0x20005730

200044d8 <cmd_lookup>:


int cmd_lookup(queue_t *head,ui_cmdline_t *cmd)
{
200044d8:	b580      	push	{r7, lr}
200044da:	b086      	sub	sp, #24
200044dc:	af00      	add	r7, sp, #0
200044de:	6078      	str	r0, [r7, #4]
200044e0:	6039      	str	r1, [r7, #0]

    /*
     * Reset the command line
     */

    memset(cmd,0,sizeof(ui_cmdline_t));
200044e2:	f44f 72ee 	mov.w	r2, #476	@ 0x1dc
200044e6:	2100      	movs	r1, #0
200044e8:	6838      	ldr	r0, [r7, #0]
200044ea:	f7fc ff71 	bl	200013d0 <lib_memset>

    /*
     * Break it up into tokens
     */
    
    cmd_build_cmdline(head, cmd);
200044ee:	6839      	ldr	r1, [r7, #0]
200044f0:	6878      	ldr	r0, [r7, #4]
200044f2:	f7ff fc6f 	bl	20003dd4 <cmd_build_cmdline>

    if (cmd->argc == 0) return CMD_ERR_BLANK;
200044f6:	683b      	ldr	r3, [r7, #0]
200044f8:	681b      	ldr	r3, [r3, #0]
200044fa:	2b00      	cmp	r3, #0
200044fc:	d102      	bne.n	20004504 <cmd_lookup+0x2c>
200044fe:	f06f 0302 	mvn.w	r3, #2
20004502:	e07f      	b.n	20004604 <cmd_lookup+0x12c>
    /*
     * Start walking the tree looking for a function	
     * to execute.
     */
  
    idx = 0;
20004504:	2300      	movs	r3, #0
20004506:	613b      	str	r3, [r7, #16]
    tab = &cmd_root;
20004508:	4b40      	ldr	r3, [pc, #256]	@ (2000460c <cmd_lookup+0x134>)
2000450a:	617b      	str	r3, [r7, #20]
    cword = NULL;
2000450c:	2300      	movs	r3, #0
2000450e:	60fb      	str	r3, [r7, #12]

    for (;;) {
	cword = cmd_findword(*tab,cmd->argv[idx]);
20004510:	697b      	ldr	r3, [r7, #20]
20004512:	6818      	ldr	r0, [r3, #0]
20004514:	683a      	ldr	r2, [r7, #0]
20004516:	693b      	ldr	r3, [r7, #16]
20004518:	009b      	lsls	r3, r3, #2
2000451a:	4413      	add	r3, r2
2000451c:	685b      	ldr	r3, [r3, #4]
2000451e:	4619      	mov	r1, r3
20004520:	f7ff fc3c 	bl	20003d9c <cmd_findword>
20004524:	60f8      	str	r0, [r7, #12]
	if (!cword) break;
20004526:	68fb      	ldr	r3, [r7, #12]
20004528:	2b00      	cmp	r3, #0
2000452a:	d00f      	beq.n	2000454c <cmd_lookup+0x74>
	if (cword->func != NULL) break;
2000452c:	68fb      	ldr	r3, [r7, #12]
2000452e:	68db      	ldr	r3, [r3, #12]
20004530:	2b00      	cmp	r3, #0
20004532:	d10d      	bne.n	20004550 <cmd_lookup+0x78>
	idx++;
20004534:	693b      	ldr	r3, [r7, #16]
20004536:	3301      	adds	r3, #1
20004538:	613b      	str	r3, [r7, #16]
	tab = &(cword->child);
2000453a:	68fb      	ldr	r3, [r7, #12]
2000453c:	3304      	adds	r3, #4
2000453e:	617b      	str	r3, [r7, #20]
	if (idx >= cmd->argc) break;
20004540:	683b      	ldr	r3, [r7, #0]
20004542:	681b      	ldr	r3, [r3, #0]
20004544:	693a      	ldr	r2, [r7, #16]
20004546:	429a      	cmp	r2, r3
20004548:	da04      	bge.n	20004554 <cmd_lookup+0x7c>
	cword = cmd_findword(*tab,cmd->argv[idx]);
2000454a:	e7e1      	b.n	20004510 <cmd_lookup+0x38>
	if (!cword) break;
2000454c:	bf00      	nop
2000454e:	e002      	b.n	20004556 <cmd_lookup+0x7e>
	if (cword->func != NULL) break;
20004550:	bf00      	nop
20004552:	e000      	b.n	20004556 <cmd_lookup+0x7e>
	if (idx >= cmd->argc) break;
20004554:	bf00      	nop
	}

    cmd->argidx = idx;
20004556:	683b      	ldr	r3, [r7, #0]
20004558:	693a      	ldr	r2, [r7, #16]
2000455a:	f8c3 21cc 	str.w	r2, [r3, #460]	@ 0x1cc

/* XXX - Must fix this... the error needs to walk the tree! */

    if (cword == NULL) {
2000455e:	68fb      	ldr	r3, [r7, #12]
20004560:	2b00      	cmp	r3, #0
20004562:	d114      	bne.n	2000458e <cmd_lookup+0xb6>
	printf("Invalid command: \"%s\"\n", cmd->argv[idx]);
20004564:	683a      	ldr	r2, [r7, #0]
20004566:	693b      	ldr	r3, [r7, #16]
20004568:	009b      	lsls	r3, r3, #2
2000456a:	4413      	add	r3, r2
2000456c:	685b      	ldr	r3, [r3, #4]
2000456e:	4619      	mov	r1, r3
20004570:	4827      	ldr	r0, [pc, #156]	@ (20004610 <cmd_lookup+0x138>)
20004572:	f7fc fb59 	bl	20000c28 <printf>
	_showpossible(cmd,*tab);
20004576:	697b      	ldr	r3, [r7, #20]
20004578:	681b      	ldr	r3, [r3, #0]
2000457a:	4619      	mov	r1, r3
2000457c:	6838      	ldr	r0, [r7, #0]
2000457e:	f7ff fe91 	bl	200042a4 <_showpossible>
	printf("\n");
20004582:	200a      	movs	r0, #10
20004584:	f7fc fbb8 	bl	20000cf8 <putchar>
	return CMD_ERR_INVALID;
20004588:	f04f 33ff 	mov.w	r3, #4294967295	@ 0xffffffff
2000458c:	e03a      	b.n	20004604 <cmd_lookup+0x12c>
	}

    if (!cword->func && (idx >= cmd->argc)) {
2000458e:	68fb      	ldr	r3, [r7, #12]
20004590:	68db      	ldr	r3, [r3, #12]
20004592:	2b00      	cmp	r3, #0
20004594:	d11a      	bne.n	200045cc <cmd_lookup+0xf4>
20004596:	683b      	ldr	r3, [r7, #0]
20004598:	681b      	ldr	r3, [r3, #0]
2000459a:	693a      	ldr	r2, [r7, #16]
2000459c:	429a      	cmp	r2, r3
2000459e:	db15      	blt.n	200045cc <cmd_lookup+0xf4>
	printf("Incomplete command: \"%s\"\n",cmd->argv[idx-1]);
200045a0:	693b      	ldr	r3, [r7, #16]
200045a2:	3b01      	subs	r3, #1
200045a4:	683a      	ldr	r2, [r7, #0]
200045a6:	009b      	lsls	r3, r3, #2
200045a8:	4413      	add	r3, r2
200045aa:	685b      	ldr	r3, [r3, #4]
200045ac:	4619      	mov	r1, r3
200045ae:	4819      	ldr	r0, [pc, #100]	@ (20004614 <cmd_lookup+0x13c>)
200045b0:	f7fc fb3a 	bl	20000c28 <printf>
	_showpossible(cmd,*tab);
200045b4:	697b      	ldr	r3, [r7, #20]
200045b6:	681b      	ldr	r3, [r3, #0]
200045b8:	4619      	mov	r1, r3
200045ba:	6838      	ldr	r0, [r7, #0]
200045bc:	f7ff fe72 	bl	200042a4 <_showpossible>
	printf("\n");
200045c0:	200a      	movs	r0, #10
200045c2:	f7fc fb99 	bl	20000cf8 <putchar>
	return CMD_ERR_AMBIGUOUS;
200045c6:	f06f 0301 	mvn.w	r3, #1
200045ca:	e01b      	b.n	20004604 <cmd_lookup+0x12c>
	}

    cmd->argidx++;
200045cc:	683b      	ldr	r3, [r7, #0]
200045ce:	f8d3 31cc 	ldr.w	r3, [r3, #460]	@ 0x1cc
200045d2:	1c5a      	adds	r2, r3, #1
200045d4:	683b      	ldr	r3, [r7, #0]
200045d6:	f8c3 21cc 	str.w	r2, [r3, #460]	@ 0x1cc
    cmd->ref = cword->ref;
200045da:	68fb      	ldr	r3, [r7, #12]
200045dc:	691a      	ldr	r2, [r3, #16]
200045de:	683b      	ldr	r3, [r7, #0]
200045e0:	f8c3 21d0 	str.w	r2, [r3, #464]	@ 0x1d0
    cmd->usage = cword->usage;
200045e4:	68fb      	ldr	r3, [r7, #12]
200045e6:	699a      	ldr	r2, [r3, #24]
200045e8:	683b      	ldr	r3, [r7, #0]
200045ea:	f8c3 21d4 	str.w	r2, [r3, #468]	@ 0x1d4
    cmd->switches = cword->switches;
200045ee:	68fb      	ldr	r3, [r7, #12]
200045f0:	69da      	ldr	r2, [r3, #28]
200045f2:	683b      	ldr	r3, [r7, #0]
200045f4:	f8c3 21d8 	str.w	r2, [r3, #472]	@ 0x1d8
    cmd->func = cword->func;
200045f8:	68fb      	ldr	r3, [r7, #12]
200045fa:	68da      	ldr	r2, [r3, #12]
200045fc:	683b      	ldr	r3, [r7, #0]
200045fe:	f8c3 21c8 	str.w	r2, [r3, #456]	@ 0x1c8

    return 0;
20004602:	2300      	movs	r3, #0
}
20004604:	4618      	mov	r0, r3
20004606:	3718      	adds	r7, #24
20004608:	46bd      	mov	sp, r7
2000460a:	bd80      	pop	{r7, pc}
2000460c:	200060fc 	.word	0x200060fc
20004610:	200057e4 	.word	0x200057e4
20004614:	200057fc 	.word	0x200057fc

20004618 <cmd_showusage>:


void cmd_showusage(ui_cmdline_t *cmd)
{
20004618:	b580      	push	{r7, lr}
2000461a:	b082      	sub	sp, #8
2000461c:	af00      	add	r7, sp, #0
2000461e:	6078      	str	r0, [r7, #4]
    printf("\n");
20004620:	200a      	movs	r0, #10
20004622:	f7fc fb69 	bl	20000cf8 <putchar>
    _dumpindented(cmd->usage,5);
20004626:	687b      	ldr	r3, [r7, #4]
20004628:	f8d3 31d4 	ldr.w	r3, [r3, #468]	@ 0x1d4
2000462c:	2105      	movs	r1, #5
2000462e:	4618      	mov	r0, r3
20004630:	f7ff fcfa 	bl	20004028 <_dumpindented>
    printf("\n");
20004634:	200a      	movs	r0, #10
20004636:	f7fc fb5f 	bl	20000cf8 <putchar>
    if (cmd->switches[0]) {
2000463a:	687b      	ldr	r3, [r7, #4]
2000463c:	f8d3 31d8 	ldr.w	r3, [r3, #472]	@ 0x1d8
20004640:	781b      	ldrb	r3, [r3, #0]
20004642:	2b00      	cmp	r3, #0
20004644:	d008      	beq.n	20004658 <cmd_showusage+0x40>
	_dumpswitches(cmd->switches);
20004646:	687b      	ldr	r3, [r7, #4]
20004648:	f8d3 31d8 	ldr.w	r3, [r3, #472]	@ 0x1d8
2000464c:	4618      	mov	r0, r3
2000464e:	f7ff fd2d 	bl	200040ac <_dumpswitches>
	printf("\n");
20004652:	200a      	movs	r0, #10
20004654:	f7fc fb50 	bl	20000cf8 <putchar>
	}
}
20004658:	bf00      	nop
2000465a:	3708      	adds	r7, #8
2000465c:	46bd      	mov	sp, r7
2000465e:	bd80      	pop	{r7, pc}

20004660 <cmd_eat_leading_white>:


static void cmd_eat_leading_white(queue_t *head)
{
20004660:	b580      	push	{r7, lr}
20004662:	b084      	sub	sp, #16
20004664:	af00      	add	r7, sp, #0
20004666:	6078      	str	r0, [r7, #4]
    ui_token_t *t;

    while (!q_isempty(head)) {
20004668:	e010      	b.n	2000468c <cmd_eat_leading_white+0x2c>
	t = (ui_token_t *) q_getfirst(head);
2000466a:	687b      	ldr	r3, [r7, #4]
2000466c:	681b      	ldr	r3, [r3, #0]
2000466e:	60fb      	str	r3, [r7, #12]
	if (is_white_space(t)) {
20004670:	68f8      	ldr	r0, [r7, #12]
20004672:	f7ff f9f3 	bl	20003a5c <is_white_space>
20004676:	4603      	mov	r3, r0
20004678:	2b00      	cmp	r3, #0
2000467a:	d00d      	beq.n	20004698 <cmd_eat_leading_white+0x38>
	    q_dequeue(&(t->qb));
2000467c:	68fb      	ldr	r3, [r7, #12]
2000467e:	4618      	mov	r0, r3
20004680:	f7fc fd7b 	bl	2000117a <q_dequeue>
	    KFREE(t);
20004684:	68f9      	ldr	r1, [r7, #12]
20004686:	4807      	ldr	r0, [pc, #28]	@ (200046a4 <cmd_eat_leading_white+0x44>)
20004688:	f7fc fc6a 	bl	20000f60 <kfree>
    while (!q_isempty(head)) {
2000468c:	687b      	ldr	r3, [r7, #4]
2000468e:	681b      	ldr	r3, [r3, #0]
20004690:	687a      	ldr	r2, [r7, #4]
20004692:	429a      	cmp	r2, r3
20004694:	d1e9      	bne.n	2000466a <cmd_eat_leading_white+0xa>
	    }
	else break;
	}
}
20004696:	e000      	b.n	2000469a <cmd_eat_leading_white+0x3a>
	else break;
20004698:	bf00      	nop
}
2000469a:	bf00      	nop
2000469c:	3710      	adds	r7, #16
2000469e:	46bd      	mov	sp, r7
200046a0:	bd80      	pop	{r7, pc}
200046a2:	bf00      	nop
200046a4:	20005e94 	.word	0x20005e94

200046a8 <cmd_readcommand>:

ui_command_t *cmd_readcommand(queue_t *head)
{
200046a8:	b580      	push	{r7, lr}
200046aa:	b088      	sub	sp, #32
200046ac:	af00      	add	r7, sp, #0
200046ae:	6078      	str	r0, [r7, #4]
    char *ptr;
    int insquote = FALSE;
200046b0:	2300      	movs	r3, #0
200046b2:	61fb      	str	r3, [r7, #28]
    int indquote = FALSE;
200046b4:	2300      	movs	r3, #0
200046b6:	61bb      	str	r3, [r7, #24]
    ui_command_t *cmd;
    int term = CMD_TERM_EOL;
200046b8:	2300      	movs	r3, #0
200046ba:	617b      	str	r3, [r7, #20]
    ui_token_t *t;

    cmd_eat_leading_white(head);
200046bc:	6878      	ldr	r0, [r7, #4]
200046be:	f7ff ffcf 	bl	20004660 <cmd_eat_leading_white>

    if (q_isempty(head)) return NULL;
200046c2:	687b      	ldr	r3, [r7, #4]
200046c4:	681b      	ldr	r3, [r3, #0]
200046c6:	687a      	ldr	r2, [r7, #4]
200046c8:	429a      	cmp	r2, r3
200046ca:	d101      	bne.n	200046d0 <cmd_readcommand+0x28>
200046cc:	2300      	movs	r3, #0
200046ce:	e06e      	b.n	200047ae <cmd_readcommand+0x106>

    cmd = (ui_command_t *) KMALLOC(sizeof(ui_command_t),0);
200046d0:	2200      	movs	r2, #0
200046d2:	2118      	movs	r1, #24
200046d4:	4838      	ldr	r0, [pc, #224]	@ (200047b8 <cmd_readcommand+0x110>)
200046d6:	f7fc fc77 	bl	20000fc8 <kmalloc>
200046da:	6138      	str	r0, [r7, #16]
    q_init(&(cmd->head));
200046dc:	693b      	ldr	r3, [r7, #16]
200046de:	f103 0210 	add.w	r2, r3, #16
200046e2:	693b      	ldr	r3, [r7, #16]
200046e4:	615a      	str	r2, [r3, #20]
200046e6:	693b      	ldr	r3, [r7, #16]
200046e8:	f103 0210 	add.w	r2, r3, #16
200046ec:	693b      	ldr	r3, [r7, #16]
200046ee:	611a      	str	r2, [r3, #16]

    while ((t = (ui_token_t *) q_deqnext(head))) {
200046f0:	e04b      	b.n	2000478a <cmd_readcommand+0xe2>

	ptr = &(t->token);
200046f2:	68fb      	ldr	r3, [r7, #12]
200046f4:	3308      	adds	r3, #8
200046f6:	60bb      	str	r3, [r7, #8]

	if (!insquote && !indquote) {
200046f8:	69fb      	ldr	r3, [r7, #28]
200046fa:	2b00      	cmp	r3, #0
200046fc:	d125      	bne.n	2000474a <cmd_readcommand+0xa2>
200046fe:	69bb      	ldr	r3, [r7, #24]
20004700:	2b00      	cmp	r3, #0
20004702:	d122      	bne.n	2000474a <cmd_readcommand+0xa2>
	    if ((*ptr == ';') || (*ptr == '\n')) {
20004704:	68bb      	ldr	r3, [r7, #8]
20004706:	781b      	ldrb	r3, [r3, #0]
20004708:	2b3b      	cmp	r3, #59	@ 0x3b
2000470a:	d003      	beq.n	20004714 <cmd_readcommand+0x6c>
2000470c:	68bb      	ldr	r3, [r7, #8]
2000470e:	781b      	ldrb	r3, [r3, #0]
20004710:	2b0a      	cmp	r3, #10
20004712:	d102      	bne.n	2000471a <cmd_readcommand+0x72>
		term = CMD_TERM_SEMI;
20004714:	2301      	movs	r3, #1
20004716:	617b      	str	r3, [r7, #20]
		break;
20004718:	e03e      	b.n	20004798 <cmd_readcommand+0xf0>
		}	
	    if ((*ptr == '&') && (*(ptr+1) == '&')) {
2000471a:	68bb      	ldr	r3, [r7, #8]
2000471c:	781b      	ldrb	r3, [r3, #0]
2000471e:	2b26      	cmp	r3, #38	@ 0x26
20004720:	d107      	bne.n	20004732 <cmd_readcommand+0x8a>
20004722:	68bb      	ldr	r3, [r7, #8]
20004724:	3301      	adds	r3, #1
20004726:	781b      	ldrb	r3, [r3, #0]
20004728:	2b26      	cmp	r3, #38	@ 0x26
2000472a:	d102      	bne.n	20004732 <cmd_readcommand+0x8a>
		term = CMD_TERM_AND;
2000472c:	2302      	movs	r3, #2
2000472e:	617b      	str	r3, [r7, #20]
		break;
20004730:	e032      	b.n	20004798 <cmd_readcommand+0xf0>
		}
	    if ((*ptr == '|') && (*(ptr+1) == '|')) {
20004732:	68bb      	ldr	r3, [r7, #8]
20004734:	781b      	ldrb	r3, [r3, #0]
20004736:	2b7c      	cmp	r3, #124	@ 0x7c
20004738:	d107      	bne.n	2000474a <cmd_readcommand+0xa2>
2000473a:	68bb      	ldr	r3, [r7, #8]
2000473c:	3301      	adds	r3, #1
2000473e:	781b      	ldrb	r3, [r3, #0]
20004740:	2b7c      	cmp	r3, #124	@ 0x7c
20004742:	d102      	bne.n	2000474a <cmd_readcommand+0xa2>
		term = CMD_TERM_OR;
20004744:	2303      	movs	r3, #3
20004746:	617b      	str	r3, [r7, #20]
		break;
20004748:	e026      	b.n	20004798 <cmd_readcommand+0xf0>
		}
	    }

	if (*ptr == '\'') {
2000474a:	68bb      	ldr	r3, [r7, #8]
2000474c:	781b      	ldrb	r3, [r3, #0]
2000474e:	2b27      	cmp	r3, #39	@ 0x27
20004750:	d106      	bne.n	20004760 <cmd_readcommand+0xb8>
	    insquote = !insquote;
20004752:	69fb      	ldr	r3, [r7, #28]
20004754:	2b00      	cmp	r3, #0
20004756:	bf0c      	ite	eq
20004758:	2301      	moveq	r3, #1
2000475a:	2300      	movne	r3, #0
2000475c:	b2db      	uxtb	r3, r3
2000475e:	61fb      	str	r3, [r7, #28]
	    }

	if (!insquote) {
20004760:	69fb      	ldr	r3, [r7, #28]
20004762:	2b00      	cmp	r3, #0
20004764:	d10a      	bne.n	2000477c <cmd_readcommand+0xd4>
	    if (*ptr == '"') {
20004766:	68bb      	ldr	r3, [r7, #8]
20004768:	781b      	ldrb	r3, [r3, #0]
2000476a:	2b22      	cmp	r3, #34	@ 0x22
2000476c:	d106      	bne.n	2000477c <cmd_readcommand+0xd4>
		indquote = !indquote;
2000476e:	69bb      	ldr	r3, [r7, #24]
20004770:	2b00      	cmp	r3, #0
20004772:	bf0c      	ite	eq
20004774:	2301      	moveq	r3, #1
20004776:	2300      	movne	r3, #0
20004778:	b2db      	uxtb	r3, r3
2000477a:	61bb      	str	r3, [r7, #24]
		}
	    }

	q_enqueue(&(cmd->head),&(t->qb));
2000477c:	693b      	ldr	r3, [r7, #16]
2000477e:	3310      	adds	r3, #16
20004780:	68fa      	ldr	r2, [r7, #12]
20004782:	4611      	mov	r1, r2
20004784:	4618      	mov	r0, r3
20004786:	f7fc fcdf 	bl	20001148 <q_enqueue>
    while ((t = (ui_token_t *) q_deqnext(head))) {
2000478a:	6878      	ldr	r0, [r7, #4]
2000478c:	f7fc fd09 	bl	200011a2 <q_deqnext>
20004790:	60f8      	str	r0, [r7, #12]
20004792:	68fb      	ldr	r3, [r7, #12]
20004794:	2b00      	cmp	r3, #0
20004796:	d1ac      	bne.n	200046f2 <cmd_readcommand+0x4a>
		
	}

    cmd->term = term;
20004798:	693b      	ldr	r3, [r7, #16]
2000479a:	697a      	ldr	r2, [r7, #20]
2000479c:	609a      	str	r2, [r3, #8]

    /* If we got out by finding a command separator, eat the separator */
    if (term != CMD_TERM_EOL) {
2000479e:	697b      	ldr	r3, [r7, #20]
200047a0:	2b00      	cmp	r3, #0
200047a2:	d003      	beq.n	200047ac <cmd_readcommand+0x104>
	KFREE(t);
200047a4:	68f9      	ldr	r1, [r7, #12]
200047a6:	4804      	ldr	r0, [pc, #16]	@ (200047b8 <cmd_readcommand+0x110>)
200047a8:	f7fc fbda 	bl	20000f60 <kfree>
	}

    return cmd;
200047ac:	693b      	ldr	r3, [r7, #16]
}
200047ae:	4618      	mov	r0, r3
200047b0:	3720      	adds	r7, #32
200047b2:	46bd      	mov	sp, r7
200047b4:	bd80      	pop	{r7, pc}
200047b6:	bf00      	nop
200047b8:	20005e94 	.word	0x20005e94

200047bc <make_token>:



static ui_token_t *make_token(char *str,int len)
{
200047bc:	b580      	push	{r7, lr}
200047be:	b084      	sub	sp, #16
200047c0:	af00      	add	r7, sp, #0
200047c2:	6078      	str	r0, [r7, #4]
200047c4:	6039      	str	r1, [r7, #0]
    ui_token_t *t = (ui_token_t *) KMALLOC(sizeof(ui_token_t) + len,0);
200047c6:	683b      	ldr	r3, [r7, #0]
200047c8:	330c      	adds	r3, #12
200047ca:	2200      	movs	r2, #0
200047cc:	4619      	mov	r1, r3
200047ce:	480b      	ldr	r0, [pc, #44]	@ (200047fc <make_token+0x40>)
200047d0:	f7fc fbfa 	bl	20000fc8 <kmalloc>
200047d4:	60f8      	str	r0, [r7, #12]

    memcpy(&(t->token),str,len);
200047d6:	68fb      	ldr	r3, [r7, #12]
200047d8:	3308      	adds	r3, #8
200047da:	683a      	ldr	r2, [r7, #0]
200047dc:	6879      	ldr	r1, [r7, #4]
200047de:	4618      	mov	r0, r3
200047e0:	f7fc fdd6 	bl	20001390 <lib_memcpy>
    (&(t->token))[len] = 0;
200047e4:	68fb      	ldr	r3, [r7, #12]
200047e6:	f103 0208 	add.w	r2, r3, #8
200047ea:	683b      	ldr	r3, [r7, #0]
200047ec:	4413      	add	r3, r2
200047ee:	2200      	movs	r2, #0
200047f0:	701a      	strb	r2, [r3, #0]

    return t;
200047f2:	68fb      	ldr	r3, [r7, #12]
}
200047f4:	4618      	mov	r0, r3
200047f6:	3710      	adds	r7, #16
200047f8:	46bd      	mov	sp, r7
200047fa:	bd80      	pop	{r7, pc}
200047fc:	20005e94 	.word	0x20005e94

20004800 <cmd_build_list>:

void cmd_build_list(queue_t *qb,char *buf)
{
20004800:	b580      	push	{r7, lr}
20004802:	b086      	sub	sp, #24
20004804:	af00      	add	r7, sp, #0
20004806:	6078      	str	r0, [r7, #4]
20004808:	6039      	str	r1, [r7, #0]
    char *cur = buf, *start = NULL, *fin = NULL;
2000480a:	683b      	ldr	r3, [r7, #0]
2000480c:	617b      	str	r3, [r7, #20]
2000480e:	2300      	movs	r3, #0
20004810:	613b      	str	r3, [r7, #16]
20004812:	2300      	movs	r3, #0
20004814:	60fb      	str	r3, [r7, #12]
    ui_token_t *t;

    q_init(qb);
20004816:	687b      	ldr	r3, [r7, #4]
20004818:	687a      	ldr	r2, [r7, #4]
2000481a:	605a      	str	r2, [r3, #4]
2000481c:	687b      	ldr	r3, [r7, #4]
2000481e:	687a      	ldr	r2, [r7, #4]
20004820:	601a      	str	r2, [r3, #0]

    start = cur;
20004822:	697b      	ldr	r3, [r7, #20]
20004824:	613b      	str	r3, [r7, #16]
    while(*cur != '\0'){
20004826:	e06a      	b.n	200048fe <cmd_build_list+0xfe>
	if (*cur == '&' && *(cur + 1) != '&') {
20004828:	697b      	ldr	r3, [r7, #20]
2000482a:	781b      	ldrb	r3, [r3, #0]
2000482c:	2b26      	cmp	r3, #38	@ 0x26
2000482e:	d104      	bne.n	2000483a <cmd_build_list+0x3a>
20004830:	697b      	ldr	r3, [r7, #20]
20004832:	3301      	adds	r3, #1
20004834:	781b      	ldrb	r3, [r3, #0]
20004836:	2b26      	cmp	r3, #38	@ 0x26
20004838:	d15e      	bne.n	200048f8 <cmd_build_list+0xf8>
	    /* Do nothing if we have only one & */
	    }
	else if (*cur == '|' && *(cur + 1) != '|') {
2000483a:	697b      	ldr	r3, [r7, #20]
2000483c:	781b      	ldrb	r3, [r3, #0]
2000483e:	2b7c      	cmp	r3, #124	@ 0x7c
20004840:	d104      	bne.n	2000484c <cmd_build_list+0x4c>
20004842:	697b      	ldr	r3, [r7, #20]
20004844:	3301      	adds	r3, #1
20004846:	781b      	ldrb	r3, [r3, #0]
20004848:	2b7c      	cmp	r3, #124	@ 0x7c
2000484a:	d155      	bne.n	200048f8 <cmd_build_list+0xf8>
	    /* Do nothing if we have only one | */
	    }
	else if (((*cur == ' ')||(*cur == '\t')) &&
2000484c:	697b      	ldr	r3, [r7, #20]
2000484e:	781b      	ldrb	r3, [r3, #0]
20004850:	2b20      	cmp	r3, #32
20004852:	d003      	beq.n	2000485c <cmd_build_list+0x5c>
20004854:	697b      	ldr	r3, [r7, #20]
20004856:	781b      	ldrb	r3, [r3, #0]
20004858:	2b09      	cmp	r3, #9
2000485a:	d109      	bne.n	20004870 <cmd_build_list+0x70>
		 ((*(cur - 1) == ' ')||(*(cur - 1) == '\t'))) {
2000485c:	697b      	ldr	r3, [r7, #20]
2000485e:	3b01      	subs	r3, #1
20004860:	781b      	ldrb	r3, [r3, #0]
	else if (((*cur == ' ')||(*cur == '\t')) &&
20004862:	2b20      	cmp	r3, #32
20004864:	d047      	beq.n	200048f6 <cmd_build_list+0xf6>
		 ((*(cur - 1) == ' ')||(*(cur - 1) == '\t'))) {
20004866:	697b      	ldr	r3, [r7, #20]
20004868:	3b01      	subs	r3, #1
2000486a:	781b      	ldrb	r3, [r3, #0]
2000486c:	2b09      	cmp	r3, #9
2000486e:	d042      	beq.n	200048f6 <cmd_build_list+0xf6>
	    /* Make one big token for white space */
	    }
	else {

	    if (strchr(tokenbreaks,*cur)) {
20004870:	4b31      	ldr	r3, [pc, #196]	@ (20004938 <cmd_build_list+0x138>)
20004872:	681a      	ldr	r2, [r3, #0]
20004874:	697b      	ldr	r3, [r7, #20]
20004876:	781b      	ldrb	r3, [r3, #0]
20004878:	4619      	mov	r1, r3
2000487a:	4610      	mov	r0, r2
2000487c:	f7fc fd6c 	bl	20001358 <lib_strchr>
20004880:	4603      	mov	r3, r0
20004882:	2b00      	cmp	r3, #0
20004884:	d015      	beq.n	200048b2 <cmd_build_list+0xb2>
		if (cur != buf) {
20004886:	697a      	ldr	r2, [r7, #20]
20004888:	683b      	ldr	r3, [r7, #0]
2000488a:	429a      	cmp	r2, r3
2000488c:	d034      	beq.n	200048f8 <cmd_build_list+0xf8>
		    fin = cur;
2000488e:	697b      	ldr	r3, [r7, #20]
20004890:	60fb      	str	r3, [r7, #12]
		    t = make_token(start,fin-start);
20004892:	68fa      	ldr	r2, [r7, #12]
20004894:	693b      	ldr	r3, [r7, #16]
20004896:	1ad3      	subs	r3, r2, r3
20004898:	4619      	mov	r1, r3
2000489a:	6938      	ldr	r0, [r7, #16]
2000489c:	f7ff ff8e 	bl	200047bc <make_token>
200048a0:	60b8      	str	r0, [r7, #8]
		    q_enqueue(qb,&(t->qb));
200048a2:	68bb      	ldr	r3, [r7, #8]
200048a4:	4619      	mov	r1, r3
200048a6:	6878      	ldr	r0, [r7, #4]
200048a8:	f7fc fc4e 	bl	20001148 <q_enqueue>
		    start = cur; /* Start new token */
200048ac:	697b      	ldr	r3, [r7, #20]
200048ae:	613b      	str	r3, [r7, #16]
200048b0:	e022      	b.n	200048f8 <cmd_build_list+0xf8>
		}
	    else {
		/* If we are on a normal character but the last character was */
		/* a special char we need to start a new token */

		if ((cur > buf) && strchr(tokenbreaks,*(cur-1))) {
200048b2:	697a      	ldr	r2, [r7, #20]
200048b4:	683b      	ldr	r3, [r7, #0]
200048b6:	429a      	cmp	r2, r3
200048b8:	d91e      	bls.n	200048f8 <cmd_build_list+0xf8>
200048ba:	4b1f      	ldr	r3, [pc, #124]	@ (20004938 <cmd_build_list+0x138>)
200048bc:	681a      	ldr	r2, [r3, #0]
200048be:	697b      	ldr	r3, [r7, #20]
200048c0:	3b01      	subs	r3, #1
200048c2:	781b      	ldrb	r3, [r3, #0]
200048c4:	4619      	mov	r1, r3
200048c6:	4610      	mov	r0, r2
200048c8:	f7fc fd46 	bl	20001358 <lib_strchr>
200048cc:	4603      	mov	r3, r0
200048ce:	2b00      	cmp	r3, #0
200048d0:	d012      	beq.n	200048f8 <cmd_build_list+0xf8>
		    fin = cur;
200048d2:	697b      	ldr	r3, [r7, #20]
200048d4:	60fb      	str	r3, [r7, #12]
		    t = make_token(start,fin-start);
200048d6:	68fa      	ldr	r2, [r7, #12]
200048d8:	693b      	ldr	r3, [r7, #16]
200048da:	1ad3      	subs	r3, r2, r3
200048dc:	4619      	mov	r1, r3
200048de:	6938      	ldr	r0, [r7, #16]
200048e0:	f7ff ff6c 	bl	200047bc <make_token>
200048e4:	60b8      	str	r0, [r7, #8]
		    q_enqueue(qb,&(t->qb));
200048e6:	68bb      	ldr	r3, [r7, #8]
200048e8:	4619      	mov	r1, r3
200048ea:	6878      	ldr	r0, [r7, #4]
200048ec:	f7fc fc2c 	bl	20001148 <q_enqueue>
		    start = cur; /* Start new token */
200048f0:	697b      	ldr	r3, [r7, #20]
200048f2:	613b      	str	r3, [r7, #16]
200048f4:	e000      	b.n	200048f8 <cmd_build_list+0xf8>
	else if (((*cur == ' ')||(*cur == '\t')) &&
200048f6:	bf00      	nop


		}

	    }
	cur++;
200048f8:	697b      	ldr	r3, [r7, #20]
200048fa:	3301      	adds	r3, #1
200048fc:	617b      	str	r3, [r7, #20]
    while(*cur != '\0'){
200048fe:	697b      	ldr	r3, [r7, #20]
20004900:	781b      	ldrb	r3, [r3, #0]
20004902:	2b00      	cmp	r3, #0
20004904:	d190      	bne.n	20004828 <cmd_build_list+0x28>
	}

    fin = cur;
20004906:	697b      	ldr	r3, [r7, #20]
20004908:	60fb      	str	r3, [r7, #12]

    if (fin-start > 0) {
2000490a:	68fa      	ldr	r2, [r7, #12]
2000490c:	693b      	ldr	r3, [r7, #16]
2000490e:	1ad3      	subs	r3, r2, r3
20004910:	2b00      	cmp	r3, #0
20004912:	dd0d      	ble.n	20004930 <cmd_build_list+0x130>
	t = make_token(start,fin-start);
20004914:	68fa      	ldr	r2, [r7, #12]
20004916:	693b      	ldr	r3, [r7, #16]
20004918:	1ad3      	subs	r3, r2, r3
2000491a:	4619      	mov	r1, r3
2000491c:	6938      	ldr	r0, [r7, #16]
2000491e:	f7ff ff4d 	bl	200047bc <make_token>
20004922:	60b8      	str	r0, [r7, #8]
	q_enqueue(qb,&(t->qb));
20004924:	68bb      	ldr	r3, [r7, #8]
20004926:	4619      	mov	r1, r3
20004928:	6878      	ldr	r0, [r7, #4]
2000492a:	f7fc fc0d 	bl	20001148 <q_enqueue>
	}

    return;
2000492e:	bf00      	nop
20004930:	bf00      	nop
}
20004932:	3718      	adds	r7, #24
20004934:	46bd      	mov	sp, r7
20004936:	bd80      	pop	{r7, pc}
20004938:	20005e84 	.word	0x20005e84

2000493c <is_command_separator>:

static int is_command_separator(ui_token_t *t)
{
2000493c:	b480      	push	{r7}
2000493e:	b085      	sub	sp, #20
20004940:	af00      	add	r7, sp, #0
20004942:	6078      	str	r0, [r7, #4]
    char *string = &(t->token);
20004944:	687b      	ldr	r3, [r7, #4]
20004946:	3308      	adds	r3, #8
20004948:	60bb      	str	r3, [r7, #8]
    int sep = 0;
2000494a:	2300      	movs	r3, #0
2000494c:	60fb      	str	r3, [r7, #12]

    switch(*string){
2000494e:	68bb      	ldr	r3, [r7, #8]
20004950:	781b      	ldrb	r3, [r3, #0]
20004952:	2b7c      	cmp	r3, #124	@ 0x7c
20004954:	d010      	beq.n	20004978 <is_command_separator+0x3c>
20004956:	2b7c      	cmp	r3, #124	@ 0x7c
20004958:	dc15      	bgt.n	20004986 <is_command_separator+0x4a>
2000495a:	2b26      	cmp	r3, #38	@ 0x26
2000495c:	d004      	beq.n	20004968 <is_command_separator+0x2c>
2000495e:	2b3b      	cmp	r3, #59	@ 0x3b
20004960:	d111      	bne.n	20004986 <is_command_separator+0x4a>
	case ';':
	    sep = 1;
20004962:	2301      	movs	r3, #1
20004964:	60fb      	str	r3, [r7, #12]
	    break;
20004966:	e011      	b.n	2000498c <is_command_separator+0x50>
	case '&':
	    if(*(string + 1) == '&')
20004968:	68bb      	ldr	r3, [r7, #8]
2000496a:	3301      	adds	r3, #1
2000496c:	781b      	ldrb	r3, [r3, #0]
2000496e:	2b26      	cmp	r3, #38	@ 0x26
20004970:	d10b      	bne.n	2000498a <is_command_separator+0x4e>
		sep = 1;
20004972:	2301      	movs	r3, #1
20004974:	60fb      	str	r3, [r7, #12]
	    break;
20004976:	e008      	b.n	2000498a <is_command_separator+0x4e>
	case '|':
	    if(*(string + 1) == '|')
20004978:	68bb      	ldr	r3, [r7, #8]
2000497a:	3301      	adds	r3, #1
2000497c:	781b      	ldrb	r3, [r3, #0]
2000497e:	2b7c      	cmp	r3, #124	@ 0x7c
20004980:	d101      	bne.n	20004986 <is_command_separator+0x4a>
		sep = 1;
20004982:	2301      	movs	r3, #1
20004984:	60fb      	str	r3, [r7, #12]
	default:
	    break;
20004986:	bf00      	nop
20004988:	e000      	b.n	2000498c <is_command_separator+0x50>
	    break;
2000498a:	bf00      	nop
	}

    return(sep);
2000498c:	68fb      	ldr	r3, [r7, #12]
}
2000498e:	4618      	mov	r0, r3
20004990:	3714      	adds	r7, #20
20004992:	46bd      	mov	sp, r7
20004994:	f85d 7b04 	ldr.w	r7, [sp], #4
20004998:	4770      	bx	lr
	...

2000499c <cmd_eat_quoted_arg>:

static char *cmd_eat_quoted_arg(queue_t *head,ui_token_t *t)
{
2000499c:	b580      	push	{r7, lr}
2000499e:	b08a      	sub	sp, #40	@ 0x28
200049a0:	af00      	add	r7, sp, #0
200049a2:	6078      	str	r0, [r7, #4]
200049a4:	6039      	str	r1, [r7, #0]
    int dquote = 0;
200049a6:	2300      	movs	r3, #0
200049a8:	627b      	str	r3, [r7, #36]	@ 0x24
    int squote = 0;
200049aa:	2300      	movs	r3, #0
200049ac:	623b      	str	r3, [r7, #32]
    queue_t qlist;
    queue_t *q;
    char *dest;
    int maxlen = 0;
200049ae:	2300      	movs	r3, #0
200049b0:	61bb      	str	r3, [r7, #24]

    /*
     * If it's not a quoted string, just return this token.
     */

    if (!myisquote(t->token)) {
200049b2:	683b      	ldr	r3, [r7, #0]
200049b4:	7a1b      	ldrb	r3, [r3, #8]
200049b6:	2b27      	cmp	r3, #39	@ 0x27
200049b8:	d00b      	beq.n	200049d2 <cmd_eat_quoted_arg+0x36>
200049ba:	683b      	ldr	r3, [r7, #0]
200049bc:	7a1b      	ldrb	r3, [r3, #8]
200049be:	2b22      	cmp	r3, #34	@ 0x22
200049c0:	d007      	beq.n	200049d2 <cmd_eat_quoted_arg+0x36>
	dest = lib_strdup(&(t->token));
200049c2:	683b      	ldr	r3, [r7, #0]
200049c4:	3308      	adds	r3, #8
200049c6:	4618      	mov	r0, r3
200049c8:	f7fc fdca 	bl	20001560 <lib_strdup>
200049cc:	6178      	str	r0, [r7, #20]
	/* Note: caller deletes original token */
	return dest;
200049ce:	697b      	ldr	r3, [r7, #20]
200049d0:	e074      	b.n	20004abc <cmd_eat_quoted_arg+0x120>

    /*
     * Otherwise, eat tokens in the quotes.
     */

    q_init(&qlist);
200049d2:	f107 030c 	add.w	r3, r7, #12
200049d6:	613b      	str	r3, [r7, #16]
200049d8:	f107 030c 	add.w	r3, r7, #12
200049dc:	60fb      	str	r3, [r7, #12]

    if (t->token == '"') dquote = 1;
200049de:	683b      	ldr	r3, [r7, #0]
200049e0:	7a1b      	ldrb	r3, [r3, #8]
200049e2:	2b22      	cmp	r3, #34	@ 0x22
200049e4:	d102      	bne.n	200049ec <cmd_eat_quoted_arg+0x50>
200049e6:	2301      	movs	r3, #1
200049e8:	627b      	str	r3, [r7, #36]	@ 0x24
200049ea:	e001      	b.n	200049f0 <cmd_eat_quoted_arg+0x54>
    else squote = 1;			/* must be one or the other */
200049ec:	2301      	movs	r3, #1
200049ee:	623b      	str	r3, [r7, #32]

    t = (ui_token_t *) q_deqnext(head);
200049f0:	6878      	ldr	r0, [r7, #4]
200049f2:	f7fc fbd6 	bl	200011a2 <q_deqnext>
200049f6:	6038      	str	r0, [r7, #0]
    while (t != NULL) {
200049f8:	e024      	b.n	20004a44 <cmd_eat_quoted_arg+0xa8>
	/* A single quote can only be terminated by another single quote */
	if (squote && (t->token == '\'')) {
200049fa:	6a3b      	ldr	r3, [r7, #32]
200049fc:	2b00      	cmp	r3, #0
200049fe:	d008      	beq.n	20004a12 <cmd_eat_quoted_arg+0x76>
20004a00:	683b      	ldr	r3, [r7, #0]
20004a02:	7a1b      	ldrb	r3, [r3, #8]
20004a04:	2b27      	cmp	r3, #39	@ 0x27
20004a06:	d104      	bne.n	20004a12 <cmd_eat_quoted_arg+0x76>
	    KFREE(t);
20004a08:	6839      	ldr	r1, [r7, #0]
20004a0a:	482e      	ldr	r0, [pc, #184]	@ (20004ac4 <cmd_eat_quoted_arg+0x128>)
20004a0c:	f7fc faa8 	bl	20000f60 <kfree>
	    break;
20004a10:	e01b      	b.n	20004a4a <cmd_eat_quoted_arg+0xae>
	    }
	/* A double quote is only honored if not in a single quote */
	if (dquote && !squote && (t->token == '\"')) {
20004a12:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
20004a14:	2b00      	cmp	r3, #0
20004a16:	d00b      	beq.n	20004a30 <cmd_eat_quoted_arg+0x94>
20004a18:	6a3b      	ldr	r3, [r7, #32]
20004a1a:	2b00      	cmp	r3, #0
20004a1c:	d108      	bne.n	20004a30 <cmd_eat_quoted_arg+0x94>
20004a1e:	683b      	ldr	r3, [r7, #0]
20004a20:	7a1b      	ldrb	r3, [r3, #8]
20004a22:	2b22      	cmp	r3, #34	@ 0x22
20004a24:	d104      	bne.n	20004a30 <cmd_eat_quoted_arg+0x94>
	    KFREE(t);
20004a26:	6839      	ldr	r1, [r7, #0]
20004a28:	4826      	ldr	r0, [pc, #152]	@ (20004ac4 <cmd_eat_quoted_arg+0x128>)
20004a2a:	f7fc fa99 	bl	20000f60 <kfree>
	    break;
20004a2e:	e00c      	b.n	20004a4a <cmd_eat_quoted_arg+0xae>
	    }
	/* Otherwise, keep this token. */
	q_enqueue(&qlist,(queue_t *) t);
20004a30:	f107 030c 	add.w	r3, r7, #12
20004a34:	6839      	ldr	r1, [r7, #0]
20004a36:	4618      	mov	r0, r3
20004a38:	f7fc fb86 	bl	20001148 <q_enqueue>
	t = (ui_token_t *) q_deqnext(head);
20004a3c:	6878      	ldr	r0, [r7, #4]
20004a3e:	f7fc fbb0 	bl	200011a2 <q_deqnext>
20004a42:	6038      	str	r0, [r7, #0]
    while (t != NULL) {
20004a44:	683b      	ldr	r3, [r7, #0]
20004a46:	2b00      	cmp	r3, #0
20004a48:	d1d7      	bne.n	200049fa <cmd_eat_quoted_arg+0x5e>

    /*
     * Go back through what we collected and figure out the string length.
     */

    for (q = qlist.q_next; q != &qlist; q = q->q_next) {
20004a4a:	68fb      	ldr	r3, [r7, #12]
20004a4c:	61fb      	str	r3, [r7, #28]
20004a4e:	e00b      	b.n	20004a68 <cmd_eat_quoted_arg+0xcc>
	maxlen += strlen(&(((ui_token_t *) q)->token));
20004a50:	69fb      	ldr	r3, [r7, #28]
20004a52:	3308      	adds	r3, #8
20004a54:	4618      	mov	r0, r3
20004a56:	f7fc fc26 	bl	200012a6 <lib_strlen>
20004a5a:	4602      	mov	r2, r0
20004a5c:	69bb      	ldr	r3, [r7, #24]
20004a5e:	4413      	add	r3, r2
20004a60:	61bb      	str	r3, [r7, #24]
    for (q = qlist.q_next; q != &qlist; q = q->q_next) {
20004a62:	69fb      	ldr	r3, [r7, #28]
20004a64:	681b      	ldr	r3, [r3, #0]
20004a66:	61fb      	str	r3, [r7, #28]
20004a68:	f107 030c 	add.w	r3, r7, #12
20004a6c:	69fa      	ldr	r2, [r7, #28]
20004a6e:	429a      	cmp	r2, r3
20004a70:	d1ee      	bne.n	20004a50 <cmd_eat_quoted_arg+0xb4>
	}

    dest = KMALLOC(maxlen+1,0);
20004a72:	69bb      	ldr	r3, [r7, #24]
20004a74:	3301      	adds	r3, #1
20004a76:	2200      	movs	r2, #0
20004a78:	4619      	mov	r1, r3
20004a7a:	4812      	ldr	r0, [pc, #72]	@ (20004ac4 <cmd_eat_quoted_arg+0x128>)
20004a7c:	f7fc faa4 	bl	20000fc8 <kmalloc>
20004a80:	6178      	str	r0, [r7, #20]
    if (!dest) return NULL;
20004a82:	697b      	ldr	r3, [r7, #20]
20004a84:	2b00      	cmp	r3, #0
20004a86:	d101      	bne.n	20004a8c <cmd_eat_quoted_arg+0xf0>
20004a88:	2300      	movs	r3, #0
20004a8a:	e017      	b.n	20004abc <cmd_eat_quoted_arg+0x120>

    *dest = '\0';
20004a8c:	697b      	ldr	r3, [r7, #20]
20004a8e:	2200      	movs	r2, #0
20004a90:	701a      	strb	r2, [r3, #0]

    while ((t = (ui_token_t *) q_deqnext(&qlist))) {
20004a92:	e009      	b.n	20004aa8 <cmd_eat_quoted_arg+0x10c>
	strcat(dest,&(t->token));
20004a94:	683b      	ldr	r3, [r7, #0]
20004a96:	3308      	adds	r3, #8
20004a98:	4619      	mov	r1, r3
20004a9a:	6978      	ldr	r0, [r7, #20]
20004a9c:	f7fc fcb4 	bl	20001408 <lib_strcat>
	KFREE(t);
20004aa0:	6839      	ldr	r1, [r7, #0]
20004aa2:	4808      	ldr	r0, [pc, #32]	@ (20004ac4 <cmd_eat_quoted_arg+0x128>)
20004aa4:	f7fc fa5c 	bl	20000f60 <kfree>
    while ((t = (ui_token_t *) q_deqnext(&qlist))) {
20004aa8:	f107 030c 	add.w	r3, r7, #12
20004aac:	4618      	mov	r0, r3
20004aae:	f7fc fb78 	bl	200011a2 <q_deqnext>
20004ab2:	6038      	str	r0, [r7, #0]
20004ab4:	683b      	ldr	r3, [r7, #0]
20004ab6:	2b00      	cmp	r3, #0
20004ab8:	d1ec      	bne.n	20004a94 <cmd_eat_quoted_arg+0xf8>
	}

    return dest;
20004aba:	697b      	ldr	r3, [r7, #20]
}
20004abc:	4618      	mov	r0, r3
20004abe:	3728      	adds	r7, #40	@ 0x28
20004ac0:	46bd      	mov	sp, r7
20004ac2:	bd80      	pop	{r7, pc}
20004ac4:	20005e94 	.word	0x20005e94

20004ac8 <cmd_append_tokens>:

static void cmd_append_tokens(queue_t *qb,char *str)
{
20004ac8:	b580      	push	{r7, lr}
20004aca:	b086      	sub	sp, #24
20004acc:	af00      	add	r7, sp, #0
20004ace:	6078      	str	r0, [r7, #4]
20004ad0:	6039      	str	r1, [r7, #0]
    queue_t *qq;
    queue_t explist;

    cmd_build_list(&explist,str);
20004ad2:	f107 030c 	add.w	r3, r7, #12
20004ad6:	6839      	ldr	r1, [r7, #0]
20004ad8:	4618      	mov	r0, r3
20004ada:	f7ff fe91 	bl	20004800 <cmd_build_list>

    while ((qq = q_deqnext(&explist))) {
20004ade:	e003      	b.n	20004ae8 <cmd_append_tokens+0x20>
	q_enqueue(qb,qq);
20004ae0:	6979      	ldr	r1, [r7, #20]
20004ae2:	6878      	ldr	r0, [r7, #4]
20004ae4:	f7fc fb30 	bl	20001148 <q_enqueue>
    while ((qq = q_deqnext(&explist))) {
20004ae8:	f107 030c 	add.w	r3, r7, #12
20004aec:	4618      	mov	r0, r3
20004aee:	f7fc fb58 	bl	200011a2 <q_deqnext>
20004af2:	6178      	str	r0, [r7, #20]
20004af4:	697b      	ldr	r3, [r7, #20]
20004af6:	2b00      	cmp	r3, #0
20004af8:	d1f2      	bne.n	20004ae0 <cmd_append_tokens+0x18>
	}
}
20004afa:	bf00      	nop
20004afc:	bf00      	nop
20004afe:	3718      	adds	r7, #24
20004b00:	46bd      	mov	sp, r7
20004b02:	bd80      	pop	{r7, pc}

20004b04 <cmd_walk_and_expand>:
    printf("\n");
}
#endif

void cmd_walk_and_expand (queue_t *qb)
{
20004b04:	b580      	push	{r7, lr}
20004b06:	b08a      	sub	sp, #40	@ 0x28
20004b08:	af00      	add	r7, sp, #0
20004b0a:	6078      	str	r0, [r7, #4]
    queue_t *q;
    queue_t newq;
    ui_token_t *t;
    int alias_check = TRUE;
20004b0c:	2301      	movs	r3, #1
20004b0e:	623b      	str	r3, [r7, #32]
    int insquote = FALSE;
20004b10:	2300      	movs	r3, #0
20004b12:	61fb      	str	r3, [r7, #28]
    char *envstr;

    q_init(&newq);
20004b14:	f107 030c 	add.w	r3, r7, #12
20004b18:	613b      	str	r3, [r7, #16]
20004b1a:	f107 030c 	add.w	r3, r7, #12
20004b1e:	60fb      	str	r3, [r7, #12]

    while ((t = (ui_token_t *) q_deqnext(qb))) {
20004b20:	e05c      	b.n	20004bdc <cmd_walk_and_expand+0xd8>
	if (t->token == '\'') {
20004b22:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
20004b24:	7a1b      	ldrb	r3, [r3, #8]
20004b26:	2b27      	cmp	r3, #39	@ 0x27
20004b28:	d109      	bne.n	20004b3e <cmd_walk_and_expand+0x3a>
	    alias_check = FALSE;
20004b2a:	2300      	movs	r3, #0
20004b2c:	623b      	str	r3, [r7, #32]
	    insquote = !insquote;
20004b2e:	69fb      	ldr	r3, [r7, #28]
20004b30:	2b00      	cmp	r3, #0
20004b32:	bf0c      	ite	eq
20004b34:	2301      	moveq	r3, #1
20004b36:	2300      	movne	r3, #0
20004b38:	b2db      	uxtb	r3, r3
20004b3a:	61fb      	str	r3, [r7, #28]
20004b3c:	e040      	b.n	20004bc0 <cmd_walk_and_expand+0xbc>
	    /* Check to see if we should try to expand this token */
	    }
	else if (!insquote) {
20004b3e:	69fb      	ldr	r3, [r7, #28]
20004b40:	2b00      	cmp	r3, #0
20004b42:	d13d      	bne.n	20004bc0 <cmd_walk_and_expand+0xbc>
	    if (alias_check && !strchr(tokenbreaks,t->token) && 
20004b44:	6a3b      	ldr	r3, [r7, #32]
20004b46:	2b00      	cmp	r3, #0
20004b48:	d020      	beq.n	20004b8c <cmd_walk_and_expand+0x88>
20004b4a:	4b31      	ldr	r3, [pc, #196]	@ (20004c10 <cmd_walk_and_expand+0x10c>)
20004b4c:	681a      	ldr	r2, [r3, #0]
20004b4e:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
20004b50:	7a1b      	ldrb	r3, [r3, #8]
20004b52:	4619      	mov	r1, r3
20004b54:	4610      	mov	r0, r2
20004b56:	f7fc fbff 	bl	20001358 <lib_strchr>
20004b5a:	4603      	mov	r3, r0
20004b5c:	2b00      	cmp	r3, #0
20004b5e:	d115      	bne.n	20004b8c <cmd_walk_and_expand+0x88>
		(envstr = env_getenv(&(t->token)))) {
20004b60:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
20004b62:	3308      	adds	r3, #8
20004b64:	4618      	mov	r0, r3
20004b66:	f7fe fdf1 	bl	2000374c <env_getenv>
20004b6a:	6178      	str	r0, [r7, #20]
	    if (alias_check && !strchr(tokenbreaks,t->token) && 
20004b6c:	697b      	ldr	r3, [r7, #20]
20004b6e:	2b00      	cmp	r3, #0
20004b70:	d00c      	beq.n	20004b8c <cmd_walk_and_expand+0x88>
		/* Aliases: stick into token stream if no environment found */
		cmd_append_tokens(&newq,envstr);
20004b72:	f107 030c 	add.w	r3, r7, #12
20004b76:	6979      	ldr	r1, [r7, #20]
20004b78:	4618      	mov	r0, r3
20004b7a:	f7ff ffa5 	bl	20004ac8 <cmd_append_tokens>
		KFREE(t);
20004b7e:	6a79      	ldr	r1, [r7, #36]	@ 0x24
20004b80:	4824      	ldr	r0, [pc, #144]	@ (20004c14 <cmd_walk_and_expand+0x110>)
20004b82:	f7fc f9ed 	bl	20000f60 <kfree>
		t = NULL;
20004b86:	2300      	movs	r3, #0
20004b88:	627b      	str	r3, [r7, #36]	@ 0x24
20004b8a:	e019      	b.n	20004bc0 <cmd_walk_and_expand+0xbc>
		}
	    else if (t->token == '$') {
20004b8c:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
20004b8e:	7a1b      	ldrb	r3, [r3, #8]
20004b90:	2b24      	cmp	r3, #36	@ 0x24
20004b92:	d115      	bne.n	20004bc0 <cmd_walk_and_expand+0xbc>
		/* non-aliases: remove from token stream if no env found */
		envstr = env_getenv(&(t->token)+1);
20004b94:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
20004b96:	3308      	adds	r3, #8
20004b98:	3301      	adds	r3, #1
20004b9a:	4618      	mov	r0, r3
20004b9c:	f7fe fdd6 	bl	2000374c <env_getenv>
20004ba0:	6178      	str	r0, [r7, #20]
		if (envstr) cmd_append_tokens(&newq,envstr);
20004ba2:	697b      	ldr	r3, [r7, #20]
20004ba4:	2b00      	cmp	r3, #0
20004ba6:	d005      	beq.n	20004bb4 <cmd_walk_and_expand+0xb0>
20004ba8:	f107 030c 	add.w	r3, r7, #12
20004bac:	6979      	ldr	r1, [r7, #20]
20004bae:	4618      	mov	r0, r3
20004bb0:	f7ff ff8a 	bl	20004ac8 <cmd_append_tokens>
		KFREE(t);
20004bb4:	6a79      	ldr	r1, [r7, #36]	@ 0x24
20004bb6:	4817      	ldr	r0, [pc, #92]	@ (20004c14 <cmd_walk_and_expand+0x110>)
20004bb8:	f7fc f9d2 	bl	20000f60 <kfree>
		t = NULL;
20004bbc:	2300      	movs	r3, #0
20004bbe:	627b      	str	r3, [r7, #36]	@ 0x24

	/*
	 * If token was not removed, add it to the new queue
	 */

	if (t) {
20004bc0:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
20004bc2:	2b00      	cmp	r3, #0
20004bc4:	d00a      	beq.n	20004bdc <cmd_walk_and_expand+0xd8>
	    q_enqueue(&newq,&(t->qb));
20004bc6:	6a7a      	ldr	r2, [r7, #36]	@ 0x24
20004bc8:	f107 030c 	add.w	r3, r7, #12
20004bcc:	4611      	mov	r1, r2
20004bce:	4618      	mov	r0, r3
20004bd0:	f7fc faba 	bl	20001148 <q_enqueue>
	    alias_check = is_command_separator(t);
20004bd4:	6a78      	ldr	r0, [r7, #36]	@ 0x24
20004bd6:	f7ff feb1 	bl	2000493c <is_command_separator>
20004bda:	6238      	str	r0, [r7, #32]
    while ((t = (ui_token_t *) q_deqnext(qb))) {
20004bdc:	6878      	ldr	r0, [r7, #4]
20004bde:	f7fc fae0 	bl	200011a2 <q_deqnext>
20004be2:	6278      	str	r0, [r7, #36]	@ 0x24
20004be4:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
20004be6:	2b00      	cmp	r3, #0
20004be8:	d19b      	bne.n	20004b22 <cmd_walk_and_expand+0x1e>

    /*
     * Put everything back on the original list. 
     */

    while ((q = q_deqnext(&newq))) {
20004bea:	e003      	b.n	20004bf4 <cmd_walk_and_expand+0xf0>
	q_enqueue(qb,q);
20004bec:	69b9      	ldr	r1, [r7, #24]
20004bee:	6878      	ldr	r0, [r7, #4]
20004bf0:	f7fc faaa 	bl	20001148 <q_enqueue>
    while ((q = q_deqnext(&newq))) {
20004bf4:	f107 030c 	add.w	r3, r7, #12
20004bf8:	4618      	mov	r0, r3
20004bfa:	f7fc fad2 	bl	200011a2 <q_deqnext>
20004bfe:	61b8      	str	r0, [r7, #24]
20004c00:	69bb      	ldr	r3, [r7, #24]
20004c02:	2b00      	cmp	r3, #0
20004c04:	d1f2      	bne.n	20004bec <cmd_walk_and_expand+0xe8>
	}

}
20004c06:	bf00      	nop
20004c08:	bf00      	nop
20004c0a:	3728      	adds	r7, #40	@ 0x28
20004c0c:	46bd      	mov	sp, r7
20004c0e:	bd80      	pop	{r7, pc}
20004c10:	20005e84 	.word	0x20005e84
20004c14:	20005e94 	.word	0x20005e94

20004c18 <cmd_free_tokens>:

void cmd_free_tokens(queue_t *list)
{
20004c18:	b580      	push	{r7, lr}
20004c1a:	b084      	sub	sp, #16
20004c1c:	af00      	add	r7, sp, #0
20004c1e:	6078      	str	r0, [r7, #4]
    queue_t *q;

    while ((q = q_deqnext(list))) {
20004c20:	e003      	b.n	20004c2a <cmd_free_tokens+0x12>
	KFREE(q);
20004c22:	68f9      	ldr	r1, [r7, #12]
20004c24:	4807      	ldr	r0, [pc, #28]	@ (20004c44 <cmd_free_tokens+0x2c>)
20004c26:	f7fc f99b 	bl	20000f60 <kfree>
    while ((q = q_deqnext(list))) {
20004c2a:	6878      	ldr	r0, [r7, #4]
20004c2c:	f7fc fab9 	bl	200011a2 <q_deqnext>
20004c30:	60f8      	str	r0, [r7, #12]
20004c32:	68fb      	ldr	r3, [r7, #12]
20004c34:	2b00      	cmp	r3, #0
20004c36:	d1f4      	bne.n	20004c22 <cmd_free_tokens+0xa>
	}
}
20004c38:	bf00      	nop
20004c3a:	bf00      	nop
20004c3c:	3710      	adds	r7, #16
20004c3e:	46bd      	mov	sp, r7
20004c40:	bd80      	pop	{r7, pc}
20004c42:	bf00      	nop
20004c44:	20005e94 	.word	0x20005e94

20004c48 <ui_init_misccmds>:


int ui_init_misccmds(void);

int ui_init_misccmds(void)
{
20004c48:	b580      	push	{r7, lr}
20004c4a:	b082      	sub	sp, #8
20004c4c:	af02      	add	r7, sp, #8

    cmd_addcmd("loop",
20004c4e:	4b34      	ldr	r3, [pc, #208]	@ (20004d20 <ui_init_misccmds+0xd8>)
20004c50:	9301      	str	r3, [sp, #4]
20004c52:	4b34      	ldr	r3, [pc, #208]	@ (20004d24 <ui_init_misccmds+0xdc>)
20004c54:	9300      	str	r3, [sp, #0]
20004c56:	4b34      	ldr	r3, [pc, #208]	@ (20004d28 <ui_init_misccmds+0xe0>)
20004c58:	2200      	movs	r2, #0
20004c5a:	4934      	ldr	r1, [pc, #208]	@ (20004d2c <ui_init_misccmds+0xe4>)
20004c5c:	4834      	ldr	r0, [pc, #208]	@ (20004d30 <ui_init_misccmds+0xe8>)
20004c5e:	f7ff f967 	bl	20003f30 <cmd_addcmd>
	       "The 'loop' command causes the specified command or list of commands\n"
	       "to be repeated 'count' times or forever, or until a character is typed",
	       "-count=*;Specifies number of iterations|"
	       "-forever;Loops forever");

    cmd_addcmd("sleep",
20004c62:	4b34      	ldr	r3, [pc, #208]	@ (20004d34 <ui_init_misccmds+0xec>)
20004c64:	9301      	str	r3, [sp, #4]
20004c66:	4b34      	ldr	r3, [pc, #208]	@ (20004d38 <ui_init_misccmds+0xf0>)
20004c68:	9300      	str	r3, [sp, #0]
20004c6a:	4b34      	ldr	r3, [pc, #208]	@ (20004d3c <ui_init_misccmds+0xf4>)
20004c6c:	2200      	movs	r2, #0
20004c6e:	4934      	ldr	r1, [pc, #208]	@ (20004d40 <ui_init_misccmds+0xf8>)
20004c70:	4834      	ldr	r0, [pc, #208]	@ (20004d44 <ui_init_misccmds+0xfc>)
20004c72:	f7ff f95d 	bl	20003f30 <cmd_addcmd>
	       "operating system.  If specified, 'n' will be placed in $4 as a\n"
	       "return code.",
	       "");
#endif

    cmd_addcmd("set console",
20004c76:	4b2f      	ldr	r3, [pc, #188]	@ (20004d34 <ui_init_misccmds+0xec>)
20004c78:	9301      	str	r3, [sp, #4]
20004c7a:	4b33      	ldr	r3, [pc, #204]	@ (20004d48 <ui_init_misccmds+0x100>)
20004c7c:	9300      	str	r3, [sp, #0]
20004c7e:	4b33      	ldr	r3, [pc, #204]	@ (20004d4c <ui_init_misccmds+0x104>)
20004c80:	2200      	movs	r2, #0
20004c82:	4933      	ldr	r1, [pc, #204]	@ (20004d50 <ui_init_misccmds+0x108>)
20004c84:	4833      	ldr	r0, [pc, #204]	@ (20004d54 <ui_init_misccmds+0x10c>)
20004c86:	f7ff f953 	bl	20003f30 <cmd_addcmd>
	       "must be a serial-style device.  Be careful not to change the console\n"
	       "to a device that is not connected!",
	       "");


    cmd_addcmd("display",
20004c8a:	4b2a      	ldr	r3, [pc, #168]	@ (20004d34 <ui_init_misccmds+0xec>)
20004c8c:	9301      	str	r3, [sp, #4]
20004c8e:	4b29      	ldr	r3, [pc, #164]	@ (20004d34 <ui_init_misccmds+0xec>)
20004c90:	9300      	str	r3, [sp, #0]
20004c92:	4b31      	ldr	r3, [pc, #196]	@ (20004d58 <ui_init_misccmds+0x110>)
20004c94:	2200      	movs	r2, #0
20004c96:	4931      	ldr	r1, [pc, #196]	@ (20004d5c <ui_init_misccmds+0x114>)
20004c98:	4831      	ldr	r0, [pc, #196]	@ (20004d60 <ui_init_misccmds+0x118>)
20004c9a:	f7ff f949 	bl	20003f30 <cmd_addcmd>
	       NULL,
	       "enter a address display <addr>",
	       "",
	       "");

    cmd_addcmd("edit",
20004c9e:	4b25      	ldr	r3, [pc, #148]	@ (20004d34 <ui_init_misccmds+0xec>)
20004ca0:	9301      	str	r3, [sp, #4]
20004ca2:	4b24      	ldr	r3, [pc, #144]	@ (20004d34 <ui_init_misccmds+0xec>)
20004ca4:	9300      	str	r3, [sp, #0]
20004ca6:	4b2f      	ldr	r3, [pc, #188]	@ (20004d64 <ui_init_misccmds+0x11c>)
20004ca8:	2200      	movs	r2, #0
20004caa:	492f      	ldr	r1, [pc, #188]	@ (20004d68 <ui_init_misccmds+0x120>)
20004cac:	482f      	ldr	r0, [pc, #188]	@ (20004d6c <ui_init_misccmds+0x124>)
20004cae:	f7ff f93f 	bl	20003f30 <cmd_addcmd>
	       ui_cmd_edit,
	       NULL,
	       "edit a specific addr edit <addr> <newvalue> ",
	       "",
	       "");
    cmd_addcmd("printten",
20004cb2:	4b20      	ldr	r3, [pc, #128]	@ (20004d34 <ui_init_misccmds+0xec>)
20004cb4:	9301      	str	r3, [sp, #4]
20004cb6:	4b1f      	ldr	r3, [pc, #124]	@ (20004d34 <ui_init_misccmds+0xec>)
20004cb8:	9300      	str	r3, [sp, #0]
20004cba:	4b2d      	ldr	r3, [pc, #180]	@ (20004d70 <ui_init_misccmds+0x128>)
20004cbc:	2200      	movs	r2, #0
20004cbe:	492d      	ldr	r1, [pc, #180]	@ (20004d74 <ui_init_misccmds+0x12c>)
20004cc0:	482b      	ldr	r0, [pc, #172]	@ (20004d70 <ui_init_misccmds+0x128>)
20004cc2:	f7ff f935 	bl	20003f30 <cmd_addcmd>
	       NULL,
	       "printten",
	       "",
	       "");

    cmd_addcmd("led",
20004cc6:	4b1b      	ldr	r3, [pc, #108]	@ (20004d34 <ui_init_misccmds+0xec>)
20004cc8:	9301      	str	r3, [sp, #4]
20004cca:	4b2b      	ldr	r3, [pc, #172]	@ (20004d78 <ui_init_misccmds+0x130>)
20004ccc:	9300      	str	r3, [sp, #0]
20004cce:	4b2b      	ldr	r3, [pc, #172]	@ (20004d7c <ui_init_misccmds+0x134>)
20004cd0:	2200      	movs	r2, #0
20004cd2:	492b      	ldr	r1, [pc, #172]	@ (20004d80 <ui_init_misccmds+0x138>)
20004cd4:	482b      	ldr	r0, [pc, #172]	@ (20004d84 <ui_init_misccmds+0x13c>)
20004cd6:	f7ff f92b 	bl	20003f30 <cmd_addcmd>
	       NULL,
	       "1 to turn on light",
	       "0 to turn off light",
	       "");

    cmd_addcmd("ledb",
20004cda:	4b16      	ldr	r3, [pc, #88]	@ (20004d34 <ui_init_misccmds+0xec>)
20004cdc:	9301      	str	r3, [sp, #4]
20004cde:	4b26      	ldr	r3, [pc, #152]	@ (20004d78 <ui_init_misccmds+0x130>)
20004ce0:	9300      	str	r3, [sp, #0]
20004ce2:	4b26      	ldr	r3, [pc, #152]	@ (20004d7c <ui_init_misccmds+0x134>)
20004ce4:	2200      	movs	r2, #0
20004ce6:	4928      	ldr	r1, [pc, #160]	@ (20004d88 <ui_init_misccmds+0x140>)
20004ce8:	4828      	ldr	r0, [pc, #160]	@ (20004d8c <ui_init_misccmds+0x144>)
20004cea:	f7ff f921 	bl	20003f30 <cmd_addcmd>
	       NULL,
	       "1 to turn on light",
	       "0 to turn off light",
	       "");
     */
cmd_addcmd("ledo",
20004cee:	4b11      	ldr	r3, [pc, #68]	@ (20004d34 <ui_init_misccmds+0xec>)
20004cf0:	9301      	str	r3, [sp, #4]
20004cf2:	4b21      	ldr	r3, [pc, #132]	@ (20004d78 <ui_init_misccmds+0x130>)
20004cf4:	9300      	str	r3, [sp, #0]
20004cf6:	4b21      	ldr	r3, [pc, #132]	@ (20004d7c <ui_init_misccmds+0x134>)
20004cf8:	2200      	movs	r2, #0
20004cfa:	4925      	ldr	r1, [pc, #148]	@ (20004d90 <ui_init_misccmds+0x148>)
20004cfc:	4825      	ldr	r0, [pc, #148]	@ (20004d94 <ui_init_misccmds+0x14c>)
20004cfe:	f7ff f917 	bl	20003f30 <cmd_addcmd>
	       "1 to turn on light",
	       "0 to turn off light",
	       "");


cmd_addcmd("i2c",
20004d02:	4b0c      	ldr	r3, [pc, #48]	@ (20004d34 <ui_init_misccmds+0xec>)
20004d04:	9301      	str	r3, [sp, #4]
20004d06:	4b0b      	ldr	r3, [pc, #44]	@ (20004d34 <ui_init_misccmds+0xec>)
20004d08:	9300      	str	r3, [sp, #0]
20004d0a:	4b0a      	ldr	r3, [pc, #40]	@ (20004d34 <ui_init_misccmds+0xec>)
20004d0c:	2200      	movs	r2, #0
20004d0e:	4922      	ldr	r1, [pc, #136]	@ (20004d98 <ui_init_misccmds+0x150>)
20004d10:	4822      	ldr	r0, [pc, #136]	@ (20004d9c <ui_init_misccmds+0x154>)
20004d12:	f7ff f90d 	bl	20003f30 <cmd_addcmd>
	       ui_cmd_I2C,
	       NULL,
	       "",
	       "",
	       "");
    return 0;
20004d16:	2300      	movs	r3, #0

}
20004d18:	4618      	mov	r0, r3
20004d1a:	46bd      	mov	sp, r7
20004d1c:	bd80      	pop	{r7, pc}
20004d1e:	bf00      	nop
20004d20:	20005830 	.word	0x20005830
20004d24:	20005870 	.word	0x20005870
20004d28:	20005818 	.word	0x20005818
20004d2c:	20004e1d 	.word	0x20004e1d
20004d30:	20005828 	.word	0x20005828
20004d34:	20005940 	.word	0x20005940
20004d38:	20005944 	.word	0x20005944
20004d3c:	20005918 	.word	0x20005918
20004d40:	20004da1 	.word	0x20004da1
20004d44:	20005938 	.word	0x20005938
20004d48:	20005a04 	.word	0x20005a04
20004d4c:	200059d4 	.word	0x200059d4
20004d50:	20004ebd 	.word	0x20004ebd
20004d54:	200059f8 	.word	0x200059f8
20004d58:	20005acc 	.word	0x20005acc
20004d5c:	20004f2d 	.word	0x20004f2d
20004d60:	20005aec 	.word	0x20005aec
20004d64:	20005af4 	.word	0x20005af4
20004d68:	20004f99 	.word	0x20004f99
20004d6c:	20005b24 	.word	0x20005b24
20004d70:	20005b2c 	.word	0x20005b2c
20004d74:	20005005 	.word	0x20005005
20004d78:	20005b50 	.word	0x20005b50
20004d7c:	20005b38 	.word	0x20005b38
20004d80:	2000508d 	.word	0x2000508d
20004d84:	20005b4c 	.word	0x20005b4c
20004d88:	20005155 	.word	0x20005155
20004d8c:	20005b64 	.word	0x20005b64
20004d90:	200053bd 	.word	0x200053bd
20004d94:	20005b6c 	.word	0x20005b6c
20004d98:	200051c1 	.word	0x200051c1
20004d9c:	20005b74 	.word	0x20005b74

20004da0 <ui_cmd_sleep>:

static int ui_cmd_sleep(ui_cmdline_t *cmd,int argc,char *argv[])
{
20004da0:	e92d 43b0 	stmdb	sp!, {r4, r5, r7, r8, r9, lr}
20004da4:	b088      	sub	sp, #32
20004da6:	af00      	add	r7, sp, #0
20004da8:	60f8      	str	r0, [r7, #12]
20004daa:	60b9      	str	r1, [r7, #8]
20004dac:	607a      	str	r2, [r7, #4]
    int seconds = 1;
20004dae:	2301      	movs	r3, #1
20004db0:	61fb      	str	r3, [r7, #28]
    char *x;
    cfe_timer_t timer;

    if ((x = cmd_getarg(cmd,0))) seconds = atoi(x);
20004db2:	2100      	movs	r1, #0
20004db4:	68f8      	ldr	r0, [r7, #12]
20004db6:	f7fe fee8 	bl	20003b8a <cmd_getarg>
20004dba:	61b8      	str	r0, [r7, #24]
20004dbc:	69bb      	ldr	r3, [r7, #24]
20004dbe:	2b00      	cmp	r3, #0
20004dc0:	d003      	beq.n	20004dca <ui_cmd_sleep+0x2a>
20004dc2:	69b8      	ldr	r0, [r7, #24]
20004dc4:	f7fc fb46 	bl	20001454 <lib_atoi>
20004dc8:	61f8      	str	r0, [r7, #28]

    TIMER_SET(timer,seconds*CFE_HZ);
20004dca:	69fa      	ldr	r2, [r7, #28]
20004dcc:	4613      	mov	r3, r2
20004dce:	009b      	lsls	r3, r3, #2
20004dd0:	4413      	add	r3, r2
20004dd2:	005b      	lsls	r3, r3, #1
20004dd4:	17da      	asrs	r2, r3, #31
20004dd6:	461c      	mov	r4, r3
20004dd8:	4615      	mov	r5, r2
20004dda:	4b0f      	ldr	r3, [pc, #60]	@ (20004e18 <ui_cmd_sleep+0x78>)
20004ddc:	e9d3 2300 	ldrd	r2, r3, [r3]
20004de0:	eb14 0802 	adds.w	r8, r4, r2
20004de4:	eb45 0903 	adc.w	r9, r5, r3
20004de8:	e9c7 8904 	strd	r8, r9, [r7, #16]
    while (!TIMER_EXPIRED(timer)) {
20004dec:	e001      	b.n	20004df2 <ui_cmd_sleep+0x52>
	POLL();
20004dee:	f7fc fcff 	bl	200017f0 <background>
    while (!TIMER_EXPIRED(timer)) {
20004df2:	e9d7 2304 	ldrd	r2, r3, [r7, #16]
20004df6:	4313      	orrs	r3, r2
20004df8:	d0f9      	beq.n	20004dee <ui_cmd_sleep+0x4e>
20004dfa:	4b07      	ldr	r3, [pc, #28]	@ (20004e18 <ui_cmd_sleep+0x78>)
20004dfc:	e9d3 2300 	ldrd	r2, r3, [r3]
20004e00:	e9d7 0104 	ldrd	r0, r1, [r7, #16]
20004e04:	4290      	cmp	r0, r2
20004e06:	eb71 0303 	sbcs.w	r3, r1, r3
20004e0a:	daf0      	bge.n	20004dee <ui_cmd_sleep+0x4e>
	}

    return 0;
20004e0c:	2300      	movs	r3, #0
}
20004e0e:	4618      	mov	r0, r3
20004e10:	3720      	adds	r7, #32
20004e12:	46bd      	mov	sp, r7
20004e14:	e8bd 83b0 	ldmia.w	sp!, {r4, r5, r7, r8, r9, pc}
20004e18:	200060d8 	.word	0x200060d8

20004e1c <ui_cmd_loop>:

static int ui_cmd_loop(ui_cmdline_t *cmd,int argc,char *argv[])
{
20004e1c:	b580      	push	{r7, lr}
20004e1e:	b088      	sub	sp, #32
20004e20:	af00      	add	r7, sp, #0
20004e22:	60f8      	str	r0, [r7, #12]
20004e24:	60b9      	str	r1, [r7, #8]
20004e26:	607a      	str	r2, [r7, #4]
    int count = 10;
20004e28:	230a      	movs	r3, #10
20004e2a:	61fb      	str	r3, [r7, #28]
    char *x;
    int res;
    int forever;

    if (cmd_sw_value(cmd,"-count",&x)) count = atoi(x);
20004e2c:	f107 0310 	add.w	r3, r7, #16
20004e30:	461a      	mov	r2, r3
20004e32:	4920      	ldr	r1, [pc, #128]	@ (20004eb4 <ui_cmd_loop+0x98>)
20004e34:	68f8      	ldr	r0, [r7, #12]
20004e36:	f7fe fe29 	bl	20003a8c <cmd_sw_value>
20004e3a:	4603      	mov	r3, r0
20004e3c:	2b00      	cmp	r3, #0
20004e3e:	d004      	beq.n	20004e4a <ui_cmd_loop+0x2e>
20004e40:	693b      	ldr	r3, [r7, #16]
20004e42:	4618      	mov	r0, r3
20004e44:	f7fc fb06 	bl	20001454 <lib_atoi>
20004e48:	61f8      	str	r0, [r7, #28]
    
    forever = cmd_sw_isset(cmd,"-forever");
20004e4a:	491b      	ldr	r1, [pc, #108]	@ (20004eb8 <ui_cmd_loop+0x9c>)
20004e4c:	68f8      	ldr	r0, [r7, #12]
20004e4e:	f7fe fe73 	bl	20003b38 <cmd_sw_isset>
20004e52:	6178      	str	r0, [r7, #20]

    x = cmd_getarg(cmd,0);
20004e54:	2100      	movs	r1, #0
20004e56:	68f8      	ldr	r0, [r7, #12]
20004e58:	f7fe fe97 	bl	20003b8a <cmd_getarg>
20004e5c:	4603      	mov	r3, r0
20004e5e:	613b      	str	r3, [r7, #16]
    if (!x) return ui_showusage(cmd);
20004e60:	693b      	ldr	r3, [r7, #16]
20004e62:	2b00      	cmp	r3, #0
20004e64:	d104      	bne.n	20004e70 <ui_cmd_loop+0x54>
20004e66:	68f8      	ldr	r0, [r7, #12]
20004e68:	f7fe fd63 	bl	20003932 <ui_showusage>
20004e6c:	4603      	mov	r3, r0
20004e6e:	e01d      	b.n	20004eac <ui_cmd_loop+0x90>

    res = 0;
20004e70:	2300      	movs	r3, #0
20004e72:	61bb      	str	r3, [r7, #24]
    while (count || forever) {
20004e74:	e00f      	b.n	20004e96 <ui_cmd_loop+0x7a>
	if (console_status()) break;
20004e76:	f7fc fd87 	bl	20001988 <console_status>
20004e7a:	4603      	mov	r3, r0
20004e7c:	2b00      	cmp	r3, #0
20004e7e:	d111      	bne.n	20004ea4 <ui_cmd_loop+0x88>
	res = ui_docommands(x);
20004e80:	693b      	ldr	r3, [r7, #16]
20004e82:	4618      	mov	r0, r3
20004e84:	f7fe fdca 	bl	20003a1c <ui_docommands>
20004e88:	61b8      	str	r0, [r7, #24]
	if (res != 0) break;
20004e8a:	69bb      	ldr	r3, [r7, #24]
20004e8c:	2b00      	cmp	r3, #0
20004e8e:	d10b      	bne.n	20004ea8 <ui_cmd_loop+0x8c>
	count--;
20004e90:	69fb      	ldr	r3, [r7, #28]
20004e92:	3b01      	subs	r3, #1
20004e94:	61fb      	str	r3, [r7, #28]
    while (count || forever) {
20004e96:	69fb      	ldr	r3, [r7, #28]
20004e98:	2b00      	cmp	r3, #0
20004e9a:	d1ec      	bne.n	20004e76 <ui_cmd_loop+0x5a>
20004e9c:	697b      	ldr	r3, [r7, #20]
20004e9e:	2b00      	cmp	r3, #0
20004ea0:	d1e9      	bne.n	20004e76 <ui_cmd_loop+0x5a>
20004ea2:	e002      	b.n	20004eaa <ui_cmd_loop+0x8e>
	if (console_status()) break;
20004ea4:	bf00      	nop
20004ea6:	e000      	b.n	20004eaa <ui_cmd_loop+0x8e>
	if (res != 0) break;
20004ea8:	bf00      	nop
	}

    return res;
20004eaa:	69bb      	ldr	r3, [r7, #24]
}
20004eac:	4618      	mov	r0, r3
20004eae:	3720      	adds	r7, #32
20004eb0:	46bd      	mov	sp, r7
20004eb2:	bd80      	pop	{r7, pc}
20004eb4:	20005b78 	.word	0x20005b78
20004eb8:	20005b80 	.word	0x20005b80

20004ebc <ui_cmd_console>:
}
#endif


static int ui_cmd_console(ui_cmdline_t *cmd,int argc,char *argv[])
{
20004ebc:	b580      	push	{r7, lr}
20004ebe:	b086      	sub	sp, #24
20004ec0:	af00      	add	r7, sp, #0
20004ec2:	60f8      	str	r0, [r7, #12]
20004ec4:	60b9      	str	r1, [r7, #8]
20004ec6:	607a      	str	r2, [r7, #4]
    int res;
    char *dev;

    dev = cmd_getarg(cmd,0);
20004ec8:	2100      	movs	r1, #0
20004eca:	68f8      	ldr	r0, [r7, #12]
20004ecc:	f7fe fe5d 	bl	20003b8a <cmd_getarg>
20004ed0:	6178      	str	r0, [r7, #20]
    if (!dev) return -1; 	/* XXX usage */
20004ed2:	697b      	ldr	r3, [r7, #20]
20004ed4:	2b00      	cmp	r3, #0
20004ed6:	d102      	bne.n	20004ede <ui_cmd_console+0x22>
20004ed8:	f04f 33ff 	mov.w	r3, #4294967295	@ 0xffffffff
20004edc:	e01d      	b.n	20004f1a <ui_cmd_console+0x5e>

    res = cfe_getdevinfo(dev);
20004ede:	6978      	ldr	r0, [r7, #20]
20004ee0:	f7fd fde4 	bl	20002aac <cfe_getdevinfo>
20004ee4:	6138      	str	r0, [r7, #16]
    if (res < 0) {
20004ee6:	693b      	ldr	r3, [r7, #16]
20004ee8:	2b00      	cmp	r3, #0
20004eea:	da06      	bge.n	20004efa <ui_cmd_console+0x3e>
	printf("Device '%s' is not valid\n",dev);
20004eec:	6979      	ldr	r1, [r7, #20]
20004eee:	480d      	ldr	r0, [pc, #52]	@ (20004f24 <ui_cmd_console+0x68>)
20004ef0:	f7fb fe9a 	bl	20000c28 <printf>
	return CFE_ERR_DEVNOTFOUND;
20004ef4:	f06f 0305 	mvn.w	r3, #5
20004ef8:	e00f      	b.n	20004f1a <ui_cmd_console+0x5e>
	}

    if ((res & CFE_DEV_MASK) != CFE_DEV_SERIAL) {
20004efa:	693b      	ldr	r3, [r7, #16]
20004efc:	f003 030f 	and.w	r3, r3, #15
20004f00:	2b04      	cmp	r3, #4
20004f02:	d006      	beq.n	20004f12 <ui_cmd_console+0x56>
	printf("Device '%s' is not the appropriate type to be a console\n",
20004f04:	6979      	ldr	r1, [r7, #20]
20004f06:	4808      	ldr	r0, [pc, #32]	@ (20004f28 <ui_cmd_console+0x6c>)
20004f08:	f7fb fe8e 	bl	20000c28 <printf>
		dev);
	return CFE_ERR_WRONGDEVTYPE;
20004f0c:	f06f 031f 	mvn.w	r3, #31
20004f10:	e003      	b.n	20004f1a <ui_cmd_console+0x5e>
	}

    cfe_set_console(dev);
20004f12:	6978      	ldr	r0, [r7, #20]
20004f14:	f7fc fd82 	bl	20001a1c <cfe_set_console>

    return 0;
20004f18:	2300      	movs	r3, #0
}
20004f1a:	4618      	mov	r0, r3
20004f1c:	3718      	adds	r7, #24
20004f1e:	46bd      	mov	sp, r7
20004f20:	bd80      	pop	{r7, pc}
20004f22:	bf00      	nop
20004f24:	20005b8c 	.word	0x20005b8c
20004f28:	20005ba8 	.word	0x20005ba8

20004f2c <ui_cmd_display>:

static int ui_cmd_display(ui_cmdline_t *cmd,int argc,char *argv[])
{
20004f2c:	b580      	push	{r7, lr}
20004f2e:	b08a      	sub	sp, #40	@ 0x28
20004f30:	af00      	add	r7, sp, #0
20004f32:	60f8      	str	r0, [r7, #12]
20004f34:	60b9      	str	r1, [r7, #8]
20004f36:	607a      	str	r2, [r7, #4]

    printf("Printing out Memory Contents:\n");
20004f38:	4814      	ldr	r0, [pc, #80]	@ (20004f8c <ui_cmd_display+0x60>)
20004f3a:	f7fb fed1 	bl	20000ce0 <puts>
    uint32_t address;
    volatile uint32_t *ptr;
    uint32_t value;


    addr_str = cmd_getarg(cmd, 0);
20004f3e:	2100      	movs	r1, #0
20004f40:	68f8      	ldr	r0, [r7, #12]
20004f42:	f7fe fe22 	bl	20003b8a <cmd_getarg>
20004f46:	6238      	str	r0, [r7, #32]


    address = atoi(addr_str);
20004f48:	6a38      	ldr	r0, [r7, #32]
20004f4a:	f7fc fa83 	bl	20001454 <lib_atoi>
20004f4e:	4603      	mov	r3, r0
20004f50:	627b      	str	r3, [r7, #36]	@ 0x24

    volatile uint32_t *ADDRESS_END = (uint32_t *)(address + 0x32);
20004f52:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
20004f54:	3332      	adds	r3, #50	@ 0x32
20004f56:	61fb      	str	r3, [r7, #28]

	for (address; address <= ADDRESS_END; address= address + 0x4) {
20004f58:	e00f      	b.n	20004f7a <ui_cmd_display+0x4e>
	    ptr = (volatile uint32_t *)address;
20004f5a:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
20004f5c:	61bb      	str	r3, [r7, #24]
	    value = *ptr;
20004f5e:	69bb      	ldr	r3, [r7, #24]
20004f60:	681b      	ldr	r3, [r3, #0]
20004f62:	617b      	str	r3, [r7, #20]

		printf("0x%08X", address);
20004f64:	6a79      	ldr	r1, [r7, #36]	@ 0x24
20004f66:	480a      	ldr	r0, [pc, #40]	@ (20004f90 <ui_cmd_display+0x64>)
20004f68:	f7fb fe5e 	bl	20000c28 <printf>
		printf("0x%08X\n", value);
20004f6c:	6979      	ldr	r1, [r7, #20]
20004f6e:	4809      	ldr	r0, [pc, #36]	@ (20004f94 <ui_cmd_display+0x68>)
20004f70:	f7fb fe5a 	bl	20000c28 <printf>
	for (address; address <= ADDRESS_END; address= address + 0x4) {
20004f74:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
20004f76:	3304      	adds	r3, #4
20004f78:	627b      	str	r3, [r7, #36]	@ 0x24
20004f7a:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
20004f7c:	69fa      	ldr	r2, [r7, #28]
20004f7e:	429a      	cmp	r2, r3
20004f80:	d2eb      	bcs.n	20004f5a <ui_cmd_display+0x2e>
	        printf("0x%08X", address);
	        printf("0x%08X\n", value);
	    }

*/
    return 0;
20004f82:	2300      	movs	r3, #0
}
20004f84:	4618      	mov	r0, r3
20004f86:	3728      	adds	r7, #40	@ 0x28
20004f88:	46bd      	mov	sp, r7
20004f8a:	bd80      	pop	{r7, pc}
20004f8c:	20005be4 	.word	0x20005be4
20004f90:	20005c04 	.word	0x20005c04
20004f94:	20005c0c 	.word	0x20005c0c

20004f98 <ui_cmd_edit>:


static int ui_cmd_edit(ui_cmdline_t *cmd,int argc,char *argv[])
{
20004f98:	b580      	push	{r7, lr}
20004f9a:	b08a      	sub	sp, #40	@ 0x28
20004f9c:	af00      	add	r7, sp, #0
20004f9e:	60f8      	str	r0, [r7, #12]
20004fa0:	60b9      	str	r1, [r7, #8]
20004fa2:	607a      	str	r2, [r7, #4]
	uint32_t address;
	volatile uint32_t *ptr;
	uint32_t value;


	addr_str = cmd_getarg(cmd, 0);
20004fa4:	2100      	movs	r1, #0
20004fa6:	68f8      	ldr	r0, [r7, #12]
20004fa8:	f7fe fdef 	bl	20003b8a <cmd_getarg>
20004fac:	6278      	str	r0, [r7, #36]	@ 0x24
	address = atoi(addr_str);
20004fae:	6a78      	ldr	r0, [r7, #36]	@ 0x24
20004fb0:	f7fc fa50 	bl	20001454 <lib_atoi>
20004fb4:	4603      	mov	r3, r0
20004fb6:	623b      	str	r3, [r7, #32]

	value_str = cmd_getarg(cmd, 1);
20004fb8:	2101      	movs	r1, #1
20004fba:	68f8      	ldr	r0, [r7, #12]
20004fbc:	f7fe fde5 	bl	20003b8a <cmd_getarg>
20004fc0:	61f8      	str	r0, [r7, #28]
	value = atoi(value_str);
20004fc2:	69f8      	ldr	r0, [r7, #28]
20004fc4:	f7fc fa46 	bl	20001454 <lib_atoi>
20004fc8:	4603      	mov	r3, r0
20004fca:	61bb      	str	r3, [r7, #24]

    ptr = (volatile uint32_t *)address;
20004fcc:	6a3b      	ldr	r3, [r7, #32]
20004fce:	617b      	str	r3, [r7, #20]
    *ptr = value;
20004fd0:	697b      	ldr	r3, [r7, #20]
20004fd2:	69ba      	ldr	r2, [r7, #24]
20004fd4:	601a      	str	r2, [r3, #0]

    printf("new value:");
20004fd6:	4808      	ldr	r0, [pc, #32]	@ (20004ff8 <ui_cmd_edit+0x60>)
20004fd8:	f7fb fe26 	bl	20000c28 <printf>

    printf("0x%08X", address);
20004fdc:	6a39      	ldr	r1, [r7, #32]
20004fde:	4807      	ldr	r0, [pc, #28]	@ (20004ffc <ui_cmd_edit+0x64>)
20004fe0:	f7fb fe22 	bl	20000c28 <printf>

    printf("0x%08X\n", value);
20004fe4:	69b9      	ldr	r1, [r7, #24]
20004fe6:	4806      	ldr	r0, [pc, #24]	@ (20005000 <ui_cmd_edit+0x68>)
20004fe8:	f7fb fe1e 	bl	20000c28 <printf>


	return 0;
20004fec:	2300      	movs	r3, #0
}
20004fee:	4618      	mov	r0, r3
20004ff0:	3728      	adds	r7, #40	@ 0x28
20004ff2:	46bd      	mov	sp, r7
20004ff4:	bd80      	pop	{r7, pc}
20004ff6:	bf00      	nop
20004ff8:	20005c14 	.word	0x20005c14
20004ffc:	20005c04 	.word	0x20005c04
20005000:	20005c0c 	.word	0x20005c0c

20005004 <ui_cmd_printten>:

static int ui_cmd_printten(ui_cmdline_t *cmd,int argc,char *argv[])
{
20005004:	b580      	push	{r7, lr}
20005006:	b086      	sub	sp, #24
20005008:	af00      	add	r7, sp, #0
2000500a:	60f8      	str	r0, [r7, #12]
2000500c:	60b9      	str	r1, [r7, #8]
2000500e:	607a      	str	r2, [r7, #4]
	for(int i = 1; i< 10; i++){
20005010:	2301      	movs	r3, #1
20005012:	617b      	str	r3, [r7, #20]
20005014:	e005      	b.n	20005022 <ui_cmd_printten+0x1e>
		printf("hello world");
20005016:	4807      	ldr	r0, [pc, #28]	@ (20005034 <ui_cmd_printten+0x30>)
20005018:	f7fb fe06 	bl	20000c28 <printf>
	for(int i = 1; i< 10; i++){
2000501c:	697b      	ldr	r3, [r7, #20]
2000501e:	3301      	adds	r3, #1
20005020:	617b      	str	r3, [r7, #20]
20005022:	697b      	ldr	r3, [r7, #20]
20005024:	2b09      	cmp	r3, #9
20005026:	ddf6      	ble.n	20005016 <ui_cmd_printten+0x12>
	}
	return 0;
20005028:	2300      	movs	r3, #0
}
2000502a:	4618      	mov	r0, r3
2000502c:	3718      	adds	r7, #24
2000502e:	46bd      	mov	sp, r7
20005030:	bd80      	pop	{r7, pc}
20005032:	bf00      	nop
20005034:	20005c20 	.word	0x20005c20

20005038 <LED_Init>:

#define PWR_BASE 0x40007000



void LED_Init(void) {
20005038:	b480      	push	{r7}
2000503a:	b083      	sub	sp, #12
2000503c:	af00      	add	r7, sp, #0

    *(volatile uint32_t *)(0x40007004) = 0x200;
2000503e:	4b0e      	ldr	r3, [pc, #56]	@ (20005078 <LED_Init+0x40>)
20005040:	f44f 7200 	mov.w	r2, #512	@ 0x200
20005044:	601a      	str	r2, [r3, #0]

    volatile uint32_t *RCC_AHB2ENR = (uint32_t *)(0x40021000 + 0x4C);
20005046:	4b0d      	ldr	r3, [pc, #52]	@ (2000507c <LED_Init+0x44>)
20005048:	607b      	str	r3, [r7, #4]
    *RCC_AHB2ENR = 0xf;
2000504a:	687b      	ldr	r3, [r7, #4]
2000504c:	220f      	movs	r2, #15
2000504e:	601a      	str	r2, [r3, #0]


    volatile uint32_t *RCC_APB1ENR1 = (uint32_t *)(0x40021000 + 0x58);
20005050:	4b0b      	ldr	r3, [pc, #44]	@ (20005080 <LED_Init+0x48>)
20005052:	603b      	str	r3, [r7, #0]
    *RCC_APB1ENR1 |= (1 << 28);
20005054:	683b      	ldr	r3, [r7, #0]
20005056:	681b      	ldr	r3, [r3, #0]
20005058:	f043 5280 	orr.w	r2, r3, #268435456	@ 0x10000000
2000505c:	683b      	ldr	r3, [r7, #0]
2000505e:	601a      	str	r2, [r3, #0]


    *(volatile uint32_t *)(GPIOC_BASE) = 0x4; // turn on
20005060:	4b08      	ldr	r3, [pc, #32]	@ (20005084 <LED_Init+0x4c>)
20005062:	2204      	movs	r2, #4
20005064:	601a      	str	r2, [r3, #0]


    *(volatile uint32_t *)(GPIOC_BASE + 0x14) = 0x0; // turn off
20005066:	4b08      	ldr	r3, [pc, #32]	@ (20005088 <LED_Init+0x50>)
20005068:	2200      	movs	r2, #0
2000506a:	601a      	str	r2, [r3, #0]
}
2000506c:	bf00      	nop
2000506e:	370c      	adds	r7, #12
20005070:	46bd      	mov	sp, r7
20005072:	f85d 7b04 	ldr.w	r7, [sp], #4
20005076:	4770      	bx	lr
20005078:	40007004 	.word	0x40007004
2000507c:	4002104c 	.word	0x4002104c
20005080:	40021058 	.word	0x40021058
20005084:	48000800 	.word	0x48000800
20005088:	48000814 	.word	0x48000814

2000508c <ui_cmd_LED>:

static int ui_cmd_LED(ui_cmdline_t *cmd, int argc, char *argv[])
{
2000508c:	b580      	push	{r7, lr}
2000508e:	b088      	sub	sp, #32
20005090:	af00      	add	r7, sp, #0
20005092:	60f8      	str	r0, [r7, #12]
20005094:	60b9      	str	r1, [r7, #8]
20005096:	607a      	str	r2, [r7, #4]
    char *state_str;
    int state;

    state_str = cmd_getarg(cmd, 0);
20005098:	2100      	movs	r1, #0
2000509a:	68f8      	ldr	r0, [r7, #12]
2000509c:	f7fe fd75 	bl	20003b8a <cmd_getarg>
200050a0:	61f8      	str	r0, [r7, #28]
    state = atoi(state_str);
200050a2:	69f8      	ldr	r0, [r7, #28]
200050a4:	f7fc f9d6 	bl	20001454 <lib_atoi>
200050a8:	61b8      	str	r0, [r7, #24]

    LED_Init();
200050aa:	f7ff ffc5 	bl	20005038 <LED_Init>
    volatile uint32_t *GPIOC_ODR = (uint32_t *)(GPIOC_BASE + 0x14);
200050ae:	4b0f      	ldr	r3, [pc, #60]	@ (200050ec <ui_cmd_LED+0x60>)
200050b0:	617b      	str	r3, [r7, #20]

    if (state == 0) {
200050b2:	69bb      	ldr	r3, [r7, #24]
200050b4:	2b00      	cmp	r3, #0
200050b6:	d108      	bne.n	200050ca <ui_cmd_LED+0x3e>

        *GPIOC_ODR |= (1 << 1);
200050b8:	697b      	ldr	r3, [r7, #20]
200050ba:	681b      	ldr	r3, [r3, #0]
200050bc:	f043 0202 	orr.w	r2, r3, #2
200050c0:	697b      	ldr	r3, [r7, #20]
200050c2:	601a      	str	r2, [r3, #0]
        printf("LED is OFF\n");
200050c4:	480a      	ldr	r0, [pc, #40]	@ (200050f0 <ui_cmd_LED+0x64>)
200050c6:	f7fb fe0b 	bl	20000ce0 <puts>
    }
    if (state == 1) {
200050ca:	69bb      	ldr	r3, [r7, #24]
200050cc:	2b01      	cmp	r3, #1
200050ce:	d108      	bne.n	200050e2 <ui_cmd_LED+0x56>

        *GPIOC_ODR &= ~(1 << 1);
200050d0:	697b      	ldr	r3, [r7, #20]
200050d2:	681b      	ldr	r3, [r3, #0]
200050d4:	f023 0202 	bic.w	r2, r3, #2
200050d8:	697b      	ldr	r3, [r7, #20]
200050da:	601a      	str	r2, [r3, #0]
        printf("LED is ON\n");
200050dc:	4805      	ldr	r0, [pc, #20]	@ (200050f4 <ui_cmd_LED+0x68>)
200050de:	f7fb fdff 	bl	20000ce0 <puts>
    }

    return 0;
200050e2:	2300      	movs	r3, #0
}
200050e4:	4618      	mov	r0, r3
200050e6:	3720      	adds	r7, #32
200050e8:	46bd      	mov	sp, r7
200050ea:	bd80      	pop	{r7, pc}
200050ec:	48000814 	.word	0x48000814
200050f0:	20005c2c 	.word	0x20005c2c
200050f4:	20005c38 	.word	0x20005c38

200050f8 <LEDB_Init>:

void LEDB_Init(void) {
200050f8:	b480      	push	{r7}
200050fa:	b083      	sub	sp, #12
200050fc:	af00      	add	r7, sp, #0

    *(volatile uint32_t *)(0x40007004) = 0x200;
200050fe:	4b10      	ldr	r3, [pc, #64]	@ (20005140 <LEDB_Init+0x48>)
20005100:	f44f 7200 	mov.w	r2, #512	@ 0x200
20005104:	601a      	str	r2, [r3, #0]

    volatile uint32_t *RCC_AHB2ENR = (uint32_t *)(0x40021000 + 0x4C);
20005106:	4b0f      	ldr	r3, [pc, #60]	@ (20005144 <LEDB_Init+0x4c>)
20005108:	607b      	str	r3, [r7, #4]
    *RCC_AHB2ENR = 0xf;
2000510a:	687b      	ldr	r3, [r7, #4]
2000510c:	220f      	movs	r2, #15
2000510e:	601a      	str	r2, [r3, #0]

    volatile uint32_t *RCC_APB1ENR1 = (uint32_t *)(0x40021000 + 0x58);
20005110:	4b0d      	ldr	r3, [pc, #52]	@ (20005148 <LEDB_Init+0x50>)
20005112:	603b      	str	r3, [r7, #0]
    *RCC_APB1ENR1 |= (1 << 28);
20005114:	683b      	ldr	r3, [r7, #0]
20005116:	681b      	ldr	r3, [r3, #0]
20005118:	f043 5280 	orr.w	r2, r3, #268435456	@ 0x10000000
2000511c:	683b      	ldr	r3, [r7, #0]
2000511e:	601a      	str	r2, [r3, #0]


    *(volatile uint32_t *)(GPIOB_BASE + 0)  |= 0x10; //
20005120:	4b0a      	ldr	r3, [pc, #40]	@ (2000514c <LEDB_Init+0x54>)
20005122:	681b      	ldr	r3, [r3, #0]
20005124:	4a09      	ldr	r2, [pc, #36]	@ (2000514c <LEDB_Init+0x54>)
20005126:	f043 0310 	orr.w	r3, r3, #16
2000512a:	6013      	str	r3, [r2, #0]

    *(volatile uint32_t *)(GPIOB_BASE + 0x14) = 0x0;
2000512c:	4b08      	ldr	r3, [pc, #32]	@ (20005150 <LEDB_Init+0x58>)
2000512e:	2200      	movs	r2, #0
20005130:	601a      	str	r2, [r3, #0]
}
20005132:	bf00      	nop
20005134:	370c      	adds	r7, #12
20005136:	46bd      	mov	sp, r7
20005138:	f85d 7b04 	ldr.w	r7, [sp], #4
2000513c:	4770      	bx	lr
2000513e:	bf00      	nop
20005140:	40007004 	.word	0x40007004
20005144:	4002104c 	.word	0x4002104c
20005148:	40021058 	.word	0x40021058
2000514c:	48000400 	.word	0x48000400
20005150:	48000414 	.word	0x48000414

20005154 <ui_cmd_LEDB>:


static int ui_cmd_LEDB(ui_cmdline_t *cmd, int argc, char *argv[]) {
20005154:	b580      	push	{r7, lr}
20005156:	b088      	sub	sp, #32
20005158:	af00      	add	r7, sp, #0
2000515a:	60f8      	str	r0, [r7, #12]
2000515c:	60b9      	str	r1, [r7, #8]
2000515e:	607a      	str	r2, [r7, #4]
    char *state_str;
    int state;

    state_str = cmd_getarg(cmd, 0);
20005160:	2100      	movs	r1, #0
20005162:	68f8      	ldr	r0, [r7, #12]
20005164:	f7fe fd11 	bl	20003b8a <cmd_getarg>
20005168:	61f8      	str	r0, [r7, #28]
    state = atoi(state_str);
2000516a:	69f8      	ldr	r0, [r7, #28]
2000516c:	f7fc f972 	bl	20001454 <lib_atoi>
20005170:	61b8      	str	r0, [r7, #24]

    LEDB_Init();
20005172:	f7ff ffc1 	bl	200050f8 <LEDB_Init>
    volatile uint32_t *GPIOB_ODR = (uint32_t *)(GPIOB_BASE + 0x14);
20005176:	4b0f      	ldr	r3, [pc, #60]	@ (200051b4 <ui_cmd_LEDB+0x60>)
20005178:	617b      	str	r3, [r7, #20]

    if (state == 0) {
2000517a:	69bb      	ldr	r3, [r7, #24]
2000517c:	2b00      	cmp	r3, #0
2000517e:	d108      	bne.n	20005192 <ui_cmd_LEDB+0x3e>
        *GPIOB_ODR |= (1 << 2);
20005180:	697b      	ldr	r3, [r7, #20]
20005182:	681b      	ldr	r3, [r3, #0]
20005184:	f043 0204 	orr.w	r2, r3, #4
20005188:	697b      	ldr	r3, [r7, #20]
2000518a:	601a      	str	r2, [r3, #0]
        printf("LED1 is OFF\n");
2000518c:	480a      	ldr	r0, [pc, #40]	@ (200051b8 <ui_cmd_LEDB+0x64>)
2000518e:	f7fb fda7 	bl	20000ce0 <puts>
    }
    if (state == 1) {
20005192:	69bb      	ldr	r3, [r7, #24]
20005194:	2b01      	cmp	r3, #1
20005196:	d108      	bne.n	200051aa <ui_cmd_LEDB+0x56>
        *GPIOB_ODR &= ~(1 << 2);
20005198:	697b      	ldr	r3, [r7, #20]
2000519a:	681b      	ldr	r3, [r3, #0]
2000519c:	f023 0204 	bic.w	r2, r3, #4
200051a0:	697b      	ldr	r3, [r7, #20]
200051a2:	601a      	str	r2, [r3, #0]
        printf("LED1 is ON\n");
200051a4:	4805      	ldr	r0, [pc, #20]	@ (200051bc <ui_cmd_LEDB+0x68>)
200051a6:	f7fb fd9b 	bl	20000ce0 <puts>
    }

    return 0;
200051aa:	2300      	movs	r3, #0
}
200051ac:	4618      	mov	r0, r3
200051ae:	3720      	adds	r7, #32
200051b0:	46bd      	mov	sp, r7
200051b2:	bd80      	pop	{r7, pc}
200051b4:	48000414 	.word	0x48000414
200051b8:	20005c44 	.word	0x20005c44
200051bc:	20005c50 	.word	0x20005c50

200051c0 <ui_cmd_I2C>:




static int ui_cmd_I2C(ui_cmdline_t *cmd, int argc, char *argv[])
{
200051c0:	b580      	push	{r7, lr}
200051c2:	b088      	sub	sp, #32
200051c4:	af00      	add	r7, sp, #0
200051c6:	60f8      	str	r0, [r7, #12]
200051c8:	60b9      	str	r1, [r7, #8]
200051ca:	607a      	str	r2, [r7, #4]

    *(volatile uint32_t *)(0x40021060) = 0x4001; // __HAL_RCC_SYSCFG_CLK_ENABLE();
200051cc:	4b59      	ldr	r3, [pc, #356]	@ (20005334 <ui_cmd_I2C+0x174>)
200051ce:	f244 0201 	movw	r2, #16385	@ 0x4001
200051d2:	601a      	str	r2, [r3, #0]

    *(volatile uint32_t *)(0x40021058) = 0x10000000;//__HAL_RCC_PWR_CLK_ENABLE();
200051d4:	4b58      	ldr	r3, [pc, #352]	@ (20005338 <ui_cmd_I2C+0x178>)
200051d6:	f04f 5280 	mov.w	r2, #268435456	@ 0x10000000
200051da:	601a      	str	r2, [r3, #0]


	*(volatile uint32_t *)(0x40021088) = 0; //RCC i2c clock selection
200051dc:	4b57      	ldr	r3, [pc, #348]	@ (2000533c <ui_cmd_I2C+0x17c>)
200051de:	2200      	movs	r2, #0
200051e0:	601a      	str	r2, [r3, #0]

    *(volatile uint32_t *)(0x40007004) = 0x200;   // PWR_CR2 enable
200051e2:	4b57      	ldr	r3, [pc, #348]	@ (20005340 <ui_cmd_I2C+0x180>)
200051e4:	f44f 7200 	mov.w	r2, #512	@ 0x200
200051e8:	601a      	str	r2, [r3, #0]

    *(volatile uint32_t *)(0x4002104C) = 0x20ff;    // GPIOG_CLK_ENABLE
200051ea:	4b56      	ldr	r3, [pc, #344]	@ (20005344 <ui_cmd_I2C+0x184>)
200051ec:	f242 02ff 	movw	r2, #8447	@ 0x20ff
200051f0:	601a      	str	r2, [r3, #0]

    *(volatile uint32_t *)(0x40021058) = 0x32200000;
200051f2:	4b51      	ldr	r3, [pc, #324]	@ (20005338 <ui_cmd_I2C+0x178>)
200051f4:	4a54      	ldr	r2, [pc, #336]	@ (20005348 <ui_cmd_I2C+0x188>)
200051f6:	601a      	str	r2, [r3, #0]


    *(volatile uint32_t *)(0x48001808) = 0xc3c0fff; //GPIOx_OSPEEDR
200051f8:	4b54      	ldr	r3, [pc, #336]	@ (2000534c <ui_cmd_I2C+0x18c>)
200051fa:	4a55      	ldr	r2, [pc, #340]	@ (20005350 <ui_cmd_I2C+0x190>)
200051fc:	601a      	str	r2, [r3, #0]
    *(volatile uint32_t *)(0x48001804) = 0x2000; //GPIO port output type register (GPIOx_OTYPER)
200051fe:	4b55      	ldr	r3, [pc, #340]	@ (20005354 <ui_cmd_I2C+0x194>)
20005200:	f44f 5200 	mov.w	r2, #8192	@ 0x2000
20005204:	601a      	str	r2, [r3, #0]
    *(volatile uint32_t *)(0x4800180C) = 0x4000000; //GPIOG_PUPDR
20005206:	4b54      	ldr	r3, [pc, #336]	@ (20005358 <ui_cmd_I2C+0x198>)
20005208:	f04f 6280 	mov.w	r2, #67108864	@ 0x4000000
2000520c:	601a      	str	r2, [r3, #0]

    *(volatile uint32_t *)(0x48001824) = 0x400cc0;// Configure Alternate function mapped with the current IO
2000520e:	4b53      	ldr	r3, [pc, #332]	@ (2000535c <ui_cmd_I2C+0x19c>)
20005210:	4a53      	ldr	r2, [pc, #332]	@ (20005360 <ui_cmd_I2C+0x1a0>)
20005212:	601a      	str	r2, [r3, #0]
    *(volatile uint32_t *)(0x48001800) = 0x3bebcaaa; // Configure IO Direction mode (Input, Output, Alternate or Analog)
20005214:	4b53      	ldr	r3, [pc, #332]	@ (20005364 <ui_cmd_I2C+0x1a4>)
20005216:	4a54      	ldr	r2, [pc, #336]	@ (20005368 <ui_cmd_I2C+0x1a8>)
20005218:	601a      	str	r2, [r3, #0]
    *(volatile uint32_t *)(0x48001808) = 0x3c3c0fff;  // Configure the IO Speed */
2000521a:	4b4c      	ldr	r3, [pc, #304]	@ (2000534c <ui_cmd_I2C+0x18c>)
2000521c:	4a53      	ldr	r2, [pc, #332]	@ (2000536c <ui_cmd_I2C+0x1ac>)
2000521e:	601a      	str	r2, [r3, #0]
    *(volatile uint32_t *)(0x48001804) = 0x6000; // GPIO_OTYPER
20005220:	4b4c      	ldr	r3, [pc, #304]	@ (20005354 <ui_cmd_I2C+0x194>)
20005222:	f44f 42c0 	mov.w	r2, #24576	@ 0x6000
20005226:	601a      	str	r2, [r3, #0]
    *(volatile uint32_t *)(0x4800082C) = 0x4000000; // activate pull up or pull down GPIO_PUPDR
20005228:	4b51      	ldr	r3, [pc, #324]	@ (20005370 <ui_cmd_I2C+0x1b0>)
2000522a:	f04f 6280 	mov.w	r2, #67108864	@ 0x4000000
2000522e:	601a      	str	r2, [r3, #0]

    *(volatile uint32_t *)(0x48001824) = 0x4400cc0;// Configure Alternate function mapped with the current IO
20005230:	4b4a      	ldr	r3, [pc, #296]	@ (2000535c <ui_cmd_I2C+0x19c>)
20005232:	4a50      	ldr	r2, [pc, #320]	@ (20005374 <ui_cmd_I2C+0x1b4>)
20005234:	601a      	str	r2, [r3, #0]
    *(volatile uint32_t *)(0x48001800) = 0x2bebcaaa; // Configure IO Direction mode (Input, Output, Alternate or Analog)
20005236:	4b4b      	ldr	r3, [pc, #300]	@ (20005364 <ui_cmd_I2C+0x1a4>)
20005238:	4a4f      	ldr	r2, [pc, #316]	@ (20005378 <ui_cmd_I2C+0x1b8>)
2000523a:	601a      	str	r2, [r3, #0]


    *(volatile uint32_t *)(0x48001808) = 0x3c3c0fff;  /* Configure the IO Speed */
2000523c:	4b43      	ldr	r3, [pc, #268]	@ (2000534c <ui_cmd_I2C+0x18c>)
2000523e:	4a4b      	ldr	r2, [pc, #300]	@ (2000536c <ui_cmd_I2C+0x1ac>)
20005240:	601a      	str	r2, [r3, #0]
    *(volatile uint32_t *)(0x48001804) = 0x6000; // GPIO_OTYPER
20005242:	4b44      	ldr	r3, [pc, #272]	@ (20005354 <ui_cmd_I2C+0x194>)
20005244:	f44f 42c0 	mov.w	r2, #24576	@ 0x6000
20005248:	601a      	str	r2, [r3, #0]
    *(volatile uint32_t *)(0x4800082C) = 0x0; /* activate pull up or pull down GPIO_PUPDR */
2000524a:	4b49      	ldr	r3, [pc, #292]	@ (20005370 <ui_cmd_I2C+0x1b0>)
2000524c:	2200      	movs	r2, #0
2000524e:	601a      	str	r2, [r3, #0]

    //*(volatile uint32_t *)(0x4800002C) = 32;
    //*(volatile uint32_t *)(0x48000000) = 0xACFF00FF;


    *(volatile uint8_t *)(0x48001841) = 0x24; //hi2c->State = HAL_I2C_STATE_BUSY;
20005250:	4b4a      	ldr	r3, [pc, #296]	@ (2000537c <ui_cmd_I2C+0x1bc>)
20005252:	2224      	movs	r2, #36	@ 0x24
20005254:	701a      	strb	r2, [r3, #0]



	*(volatile uint32_t *)(0x40005400) = 0; //Disable the selected I2C peripheral
20005256:	4b4a      	ldr	r3, [pc, #296]	@ (20005380 <ui_cmd_I2C+0x1c0>)
20005258:	2200      	movs	r2, #0
2000525a:	601a      	str	r2, [r3, #0]
	*(volatile uint32_t *)(0x40005410) = 0x20303E5D; //Configure I2Cx: Frequency range
2000525c:	4b49      	ldr	r3, [pc, #292]	@ (20005384 <ui_cmd_I2C+0x1c4>)
2000525e:	4a4a      	ldr	r2, [pc, #296]	@ (20005388 <ui_cmd_I2C+0x1c8>)
20005260:	601a      	str	r2, [r3, #0]
	*(volatile uint32_t *)(0x40005408) = 0; //I2Cx OAR1 Configuration
20005262:	4b4a      	ldr	r3, [pc, #296]	@ (2000538c <ui_cmd_I2C+0x1cc>)
20005264:	2200      	movs	r2, #0
20005266:	601a      	str	r2, [r3, #0]
	*(volatile uint32_t *)(0x40005408) = 0x8000; //ack own address1 mode
20005268:	4b48      	ldr	r3, [pc, #288]	@ (2000538c <ui_cmd_I2C+0x1cc>)
2000526a:	f44f 4200 	mov.w	r2, #32768	@ 0x8000
2000526e:	601a      	str	r2, [r3, #0]

	*(volatile uint32_t *)(0x40005404) = 0; //Clear the I2C ADD10 bit
20005270:	4b47      	ldr	r3, [pc, #284]	@ (20005390 <ui_cmd_I2C+0x1d0>)
20005272:	2200      	movs	r2, #0
20005274:	601a      	str	r2, [r3, #0]
	*(volatile uint32_t *)(0x4000540C) = 0; //I2Cx OAR2 Configuration
20005276:	4b47      	ldr	r3, [pc, #284]	@ (20005394 <ui_cmd_I2C+0x1d4>)
20005278:	2200      	movs	r2, #0
2000527a:	601a      	str	r2, [r3, #0]
	*(volatile uint32_t *)(0x40005400) = 0; //Configure I2Cx: Generalcall and NoStretch mode
2000527c:	4b40      	ldr	r3, [pc, #256]	@ (20005380 <ui_cmd_I2C+0x1c0>)
2000527e:	2200      	movs	r2, #0
20005280:	601a      	str	r2, [r3, #0]
	*(volatile uint32_t *)(0x40005400) = 1; //Enable the selected I2C peripheral
20005282:	4b3f      	ldr	r3, [pc, #252]	@ (20005380 <ui_cmd_I2C+0x1c0>)
20005284:	2201      	movs	r2, #1
20005286:	601a      	str	r2, [r3, #0]




// transmit
	*(volatile uint32_t *)(0x40005400) = 0; //I2C_CR1, clear
20005288:	4b3d      	ldr	r3, [pc, #244]	@ (20005380 <ui_cmd_I2C+0x1c0>)
2000528a:	2200      	movs	r2, #0
2000528c:	601a      	str	r2, [r3, #0]
	*(volatile uint32_t *)(0x40005410) = 0x20303e5d; //595, timing
2000528e:	4b3d      	ldr	r3, [pc, #244]	@ (20005384 <ui_cmd_I2C+0x1c4>)
20005290:	4a3d      	ldr	r2, [pc, #244]	@ (20005388 <ui_cmd_I2C+0x1c8>)
20005292:	601a      	str	r2, [r3, #0]
	*(volatile uint32_t *)(0x40005408) = 0; //595, OAR1
20005294:	4b3d      	ldr	r3, [pc, #244]	@ (2000538c <ui_cmd_I2C+0x1cc>)
20005296:	2200      	movs	r2, #0
20005298:	601a      	str	r2, [r3, #0]
	*(volatile uint32_t *)(0x40005408) = 0x8000;
2000529a:	4b3c      	ldr	r3, [pc, #240]	@ (2000538c <ui_cmd_I2C+0x1cc>)
2000529c:	f44f 4200 	mov.w	r2, #32768	@ 0x8000
200052a0:	601a      	str	r2, [r3, #0]
	*(volatile uint32_t *)(0x40005404) = 0; //616, CR2
200052a2:	4b3b      	ldr	r3, [pc, #236]	@ (20005390 <ui_cmd_I2C+0x1d0>)
200052a4:	2200      	movs	r2, #0
200052a6:	601a      	str	r2, [r3, #0]
	*(volatile uint32_t *)(0x40004404) = 0x2008000; //618, auto end, bit 15, NACK
200052a8:	4b3b      	ldr	r3, [pc, #236]	@ (20005398 <ui_cmd_I2C+0x1d8>)
200052aa:	4a3c      	ldr	r2, [pc, #240]	@ (2000539c <ui_cmd_I2C+0x1dc>)
200052ac:	601a      	str	r2, [r3, #0]
	*(volatile uint32_t *)(0x4000540C) = 0;//623,  OAR2
200052ae:	4b39      	ldr	r3, [pc, #228]	@ (20005394 <ui_cmd_I2C+0x1d4>)
200052b0:	2200      	movs	r2, #0
200052b2:	601a      	str	r2, [r3, #0]

	*(volatile uint32_t *)(0x40005400) = 1;//634, peripheral enable bit 0
200052b4:	4b32      	ldr	r3, [pc, #200]	@ (20005380 <ui_cmd_I2C+0x1c0>)
200052b6:	2201      	movs	r2, #1
200052b8:	601a      	str	r2, [r3, #0]
	*(volatile uint32_t *)(0x40005428) = 2;//1162, TX reg,
200052ba:	4b39      	ldr	r3, [pc, #228]	@ (200053a0 <ui_cmd_I2C+0x1e0>)
200052bc:	2202      	movs	r2, #2
200052be:	601a      	str	r2, [r3, #0]
	*(volatile uint32_t *)(0x40005404) = 0x2012082; //7217,      82 device address
200052c0:	4b33      	ldr	r3, [pc, #204]	@ (20005390 <ui_cmd_I2C+0x1d0>)
200052c2:	4a38      	ldr	r2, [pc, #224]	@ (200053a4 <ui_cmd_I2C+0x1e4>)
200052c4:	601a      	str	r2, [r3, #0]

	//receive

	uint32_t temp = 0; //I2C_ISR STOPF: STOP detection flag
200052c6:	2300      	movs	r3, #0
200052c8:	61fb      	str	r3, [r7, #28]
	while(((temp = *(volatile uint32_t *)(0x40005418)) & 0x20) == 0){
200052ca:	bf00      	nop
200052cc:	4b36      	ldr	r3, [pc, #216]	@ (200053a8 <ui_cmd_I2C+0x1e8>)
200052ce:	681b      	ldr	r3, [r3, #0]
200052d0:	61fb      	str	r3, [r7, #28]
200052d2:	69fb      	ldr	r3, [r7, #28]
200052d4:	f003 0320 	and.w	r3, r3, #32
200052d8:	2b00      	cmp	r3, #0
200052da:	d0f7      	beq.n	200052cc <ui_cmd_I2C+0x10c>
	}

	*(volatile uint32_t *)(0x40005404) = 0x2012482; //7217 update CR2 register */
200052dc:	4b2c      	ldr	r3, [pc, #176]	@ (20005390 <ui_cmd_I2C+0x1d0>)
200052de:	4a33      	ldr	r2, [pc, #204]	@ (200053ac <ui_cmd_I2C+0x1ec>)
200052e0:	601a      	str	r2, [r3, #0]

	uint32_t busy = 0; //I2C_ISR BUSY: BUSY detection flag
200052e2:	2300      	movs	r3, #0
200052e4:	61bb      	str	r3, [r7, #24]
	while(((busy = *(volatile uint32_t *)(0x40005400)) & 0x8000) == 1){
200052e6:	bf00      	nop
200052e8:	4b25      	ldr	r3, [pc, #148]	@ (20005380 <ui_cmd_I2C+0x1c0>)
200052ea:	681b      	ldr	r3, [r3, #0]
200052ec:	61bb      	str	r3, [r7, #24]
200052ee:	69bb      	ldr	r3, [r7, #24]
200052f0:	f403 4300 	and.w	r3, r3, #32768	@ 0x8000
200052f4:	2b01      	cmp	r3, #1
200052f6:	d0f7      	beq.n	200052e8 <ui_cmd_I2C+0x128>
	}

	uint32_t RXNE_BUSY = 0; //RXNE: Receive data register
200052f8:	2300      	movs	r3, #0
200052fa:	617b      	str	r3, [r7, #20]
	while(((RXNE_BUSY = *(volatile uint32_t *)(0x40005418)) & 0x4) == 0){
200052fc:	bf00      	nop
200052fe:	4b2a      	ldr	r3, [pc, #168]	@ (200053a8 <ui_cmd_I2C+0x1e8>)
20005300:	681b      	ldr	r3, [r3, #0]
20005302:	617b      	str	r3, [r7, #20]
20005304:	697b      	ldr	r3, [r7, #20]
20005306:	f003 0304 	and.w	r3, r3, #4
2000530a:	2b00      	cmp	r3, #0
2000530c:	d0f7      	beq.n	200052fe <ui_cmd_I2C+0x13e>


	/*
	 * corrections for printing function
	 */
	*(volatile uint32_t *)(0x40021088) = 0x2;
2000530e:	4b0b      	ldr	r3, [pc, #44]	@ (2000533c <ui_cmd_I2C+0x17c>)
20005310:	2202      	movs	r2, #2
20005312:	601a      	str	r2, [r3, #0]


    uint32_t received_data = *(volatile uint32_t *)(0x40005424);
20005314:	4b26      	ldr	r3, [pc, #152]	@ (200053b0 <ui_cmd_I2C+0x1f0>)
20005316:	681b      	ldr	r3, [r3, #0]
20005318:	613b      	str	r3, [r7, #16]
    printf("data");
2000531a:	4826      	ldr	r0, [pc, #152]	@ (200053b4 <ui_cmd_I2C+0x1f4>)
2000531c:	f7fb fc84 	bl	20000c28 <printf>
    printf("Received data: 0x%08X\n", received_data);
20005320:	6939      	ldr	r1, [r7, #16]
20005322:	4825      	ldr	r0, [pc, #148]	@ (200053b8 <ui_cmd_I2C+0x1f8>)
20005324:	f7fb fc80 	bl	20000c28 <printf>


    return 0;
20005328:	2300      	movs	r3, #0
}
2000532a:	4618      	mov	r0, r3
2000532c:	3720      	adds	r7, #32
2000532e:	46bd      	mov	sp, r7
20005330:	bd80      	pop	{r7, pc}
20005332:	bf00      	nop
20005334:	40021060 	.word	0x40021060
20005338:	40021058 	.word	0x40021058
2000533c:	40021088 	.word	0x40021088
20005340:	40007004 	.word	0x40007004
20005344:	4002104c 	.word	0x4002104c
20005348:	32200000 	.word	0x32200000
2000534c:	48001808 	.word	0x48001808
20005350:	0c3c0fff 	.word	0x0c3c0fff
20005354:	48001804 	.word	0x48001804
20005358:	4800180c 	.word	0x4800180c
2000535c:	48001824 	.word	0x48001824
20005360:	00400cc0 	.word	0x00400cc0
20005364:	48001800 	.word	0x48001800
20005368:	3bebcaaa 	.word	0x3bebcaaa
2000536c:	3c3c0fff 	.word	0x3c3c0fff
20005370:	4800082c 	.word	0x4800082c
20005374:	04400cc0 	.word	0x04400cc0
20005378:	2bebcaaa 	.word	0x2bebcaaa
2000537c:	48001841 	.word	0x48001841
20005380:	40005400 	.word	0x40005400
20005384:	40005410 	.word	0x40005410
20005388:	20303e5d 	.word	0x20303e5d
2000538c:	40005408 	.word	0x40005408
20005390:	40005404 	.word	0x40005404
20005394:	4000540c 	.word	0x4000540c
20005398:	40004404 	.word	0x40004404
2000539c:	02008000 	.word	0x02008000
200053a0:	40005428 	.word	0x40005428
200053a4:	02012082 	.word	0x02012082
200053a8:	40005418 	.word	0x40005418
200053ac:	02012482 	.word	0x02012482
200053b0:	40005424 	.word	0x40005424
200053b4:	20005c5c 	.word	0x20005c5c
200053b8:	20005c64 	.word	0x20005c64

200053bc <ui_cmd_LEDO>:


}


static int ui_cmd_LEDO(ui_cmdline_t *cmd, int argc, char *argv[]) {
200053bc:	b480      	push	{r7}
200053be:	b085      	sub	sp, #20
200053c0:	af00      	add	r7, sp, #0
200053c2:	60f8      	str	r0, [r7, #12]
200053c4:	60b9      	str	r1, [r7, #8]
200053c6:	607a      	str	r2, [r7, #4]

}
200053c8:	bf00      	nop
200053ca:	4618      	mov	r0, r3
200053cc:	3714      	adds	r7, #20
200053ce:	46bd      	mov	sp, r7
200053d0:	f85d 7b04 	ldr.w	r7, [sp], #4
200053d4:	4770      	bx	lr
	...

Disassembly of section .init:

200053d8 <_init>:
200053d8:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
200053da:	bf00      	nop

Disassembly of section .fini:

200053dc <_fini>:
200053dc:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
200053de:	bf00      	nop

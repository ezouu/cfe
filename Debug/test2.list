
test2.elf:     file format elf32-littlearm

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .isr_vector   000000d8  20000000  20000000  00001000  2**0
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  1 .text         00007568  200000d8  200000d8  000010d8  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  2 .init         00000004  20007640  20007640  00008640  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  3 .fini         00000004  20007644  20007644  00008644  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  4 .rodata       00001a08  20007648  20007648  00008648  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  5 .ARM.exidx    00000008  20009050  20009050  0000a050  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  6 .data         0000019c  20009058  20009058  0000a058  2**2
                  CONTENTS, ALLOC, LOAD, DATA
  7 .bss          00000284  200091f8  200091f8  0000a1f4  2**3
                  ALLOC
  8 ._user_heap_stack 00000604  2000947c  2000947c  0000a1f4  2**0
                  ALLOC
  9 .ARM.attributes 00000030  00000000  00000000  0000a1f4  2**0
                  CONTENTS, READONLY
 10 .comment      00000043  00000000  00000000  0000a224  2**0
                  CONTENTS, READONLY
 11 .debug_line   00007cb6  00000000  00000000  0000a267  2**0
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 12 .debug_line_str 00000055  00000000  00000000  00011f1d  2**0
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 13 .debug_info   0000882c  00000000  00000000  00011f72  2**0
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 14 .debug_abbrev 000027b1  00000000  00000000  0001a79e  2**0
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 15 .debug_aranges 00000990  00000000  00000000  0001cf50  2**3
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 16 .debug_str    00008e0d  00000000  00000000  0001d8e0  2**0
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 17 .debug_rnglists 00000716  00000000  00000000  000266ed  2**0
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 18 .debug_macro  00001dc5  00000000  00000000  00026e03  2**0
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 19 .debug_frame  00002434  00000000  00000000  00028bc8  2**2
                  CONTENTS, READONLY, DEBUGGING, OCTETS

Disassembly of section .text:

200000d8 <SysTick_Handler>:
.section .text
.global SysTick_Handler
.type SysTick_Handler, %function
SysTick_Handler:

    push {r0}
200000d8:	b401      	push	{r0}
    push {r1}
200000da:	b402      	push	{r1}
    push {r2}
200000dc:	b404      	push	{r2}
    push {r3}
200000de:	b408      	push	{r3}
    push {r4}
200000e0:	b410      	push	{r4}
    push {r5}
200000e2:	b420      	push	{r5}
    push {r6}
200000e4:	b440      	push	{r6}
    push {r7}
200000e6:	b480      	push	{r7}
    push {r8}
200000e8:	f84d 8d04 	str.w	r8, [sp, #-4]!
    push {r9}
200000ec:	f84d 9d04 	str.w	r9, [sp, #-4]!
    push {r10}
200000f0:	f84d ad04 	str.w	sl, [sp, #-4]!
    push {r11}
200000f4:	f84d bd04 	str.w	fp, [sp, #-4]!
    push {r12}
200000f8:	f84d cd04 	str.w	ip, [sp, #-4]!
    push {lr}
200000fc:	b500      	push	{lr}


	bl mytest_1
200000fe:	f007 f973 	bl	200073e8 <mytest_1>
//
    pop {lr}
20000102:	f85d eb04 	ldr.w	lr, [sp], #4
    pop {r12}
20000106:	f85d cb04 	ldr.w	ip, [sp], #4
    pop {r11}
2000010a:	f85d bb04 	ldr.w	fp, [sp], #4
    pop {r10}
2000010e:	f85d ab04 	ldr.w	sl, [sp], #4
    pop {r9}
20000112:	f85d 9b04 	ldr.w	r9, [sp], #4
    pop {r8}
20000116:	f85d 8b04 	ldr.w	r8, [sp], #4
    pop {r7}
2000011a:	bc80      	pop	{r7}
    pop {r6}
2000011c:	bc40      	pop	{r6}
    pop {r5}
2000011e:	bc20      	pop	{r5}
    pop {r4}
20000120:	bc10      	pop	{r4}
    pop {r3}
20000122:	bc08      	pop	{r3}
    pop {r2}
20000124:	bc04      	pop	{r2}
    pop {r1}
20000126:	bc02      	pop	{r1}
    pop {r0}
20000128:	bc01      	pop	{r0}

    bx lr
2000012a:	4770      	bx	lr

2000012c <add_function>:
.global add_function

.type add_function, %function
add_function:

    add r0, r0, r1
2000012c:	4408      	add	r0, r1
    add r0, r0, r2
2000012e:	4410      	add	r0, r2
    add r0, r0, r3
20000130:	4418      	add	r0, r3
    add r0, r0, r4
20000132:	4420      	add	r0, r4

	//push r1
    ldr r1, [sp, #0]
20000134:	9900      	ldr	r1, [sp, #0]
    add r0, r0, r1
20000136:	4408      	add	r0, r1


    ldr r1, [sp, #4]
20000138:	9901      	ldr	r1, [sp, #4]
    add r0, r0, r1
2000013a:	4408      	add	r0, r1
    bx lr
2000013c:	4770      	bx	lr

2000013e <USART1_IRQHandler>:
.section .text
.global USART1_IRQHandler
.type USART1_IRQHandler, %function
USART1_IRQHandler:

 	push {r0-r12, lr}
2000013e:	e92d 5fff 	stmdb	sp!, {r0, r1, r2, r3, r4, r5, r6, r7, r8, r9, sl, fp, ip, lr}


	bl mytest_1
20000142:	f007 f951 	bl	200073e8 <mytest_1>
    //ldr r0, =0x40013800      // USART1 base address
    //ldr r1, [r0, #0x1C]      // Read USART1 status register (SR)
    //ldr r2, [r0, #0x24]      // Read USART1 data register (DR)


	pop {r0-r12, lr}
20000146:	e8bd 5fff 	ldmia.w	sp!, {r0, r1, r2, r3, r4, r5, r6, r7, r8, r9, sl, fp, ip, lr}

    bx lr
2000014a:	4770      	bx	lr

2000014c <__aeabi_uldivmod>:
2000014c:	b953      	cbnz	r3, 20000164 <__aeabi_uldivmod+0x18>
2000014e:	b94a      	cbnz	r2, 20000164 <__aeabi_uldivmod+0x18>
20000150:	2900      	cmp	r1, #0
20000152:	bf08      	it	eq
20000154:	2800      	cmpeq	r0, #0
20000156:	bf1c      	itt	ne
20000158:	f04f 31ff 	movne.w	r1, #4294967295	@ 0xffffffff
2000015c:	f04f 30ff 	movne.w	r0, #4294967295	@ 0xffffffff
20000160:	f000 b96a 	b.w	20000438 <__aeabi_idiv0>
20000164:	f1ad 0c08 	sub.w	ip, sp, #8
20000168:	e96d ce04 	strd	ip, lr, [sp, #-16]!
2000016c:	f000 f806 	bl	2000017c <__udivmoddi4>
20000170:	f8dd e004 	ldr.w	lr, [sp, #4]
20000174:	e9dd 2302 	ldrd	r2, r3, [sp, #8]
20000178:	b004      	add	sp, #16
2000017a:	4770      	bx	lr

2000017c <__udivmoddi4>:
2000017c:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
20000180:	9d08      	ldr	r5, [sp, #32]
20000182:	460c      	mov	r4, r1
20000184:	2b00      	cmp	r3, #0
20000186:	d14e      	bne.n	20000226 <__udivmoddi4+0xaa>
20000188:	4694      	mov	ip, r2
2000018a:	458c      	cmp	ip, r1
2000018c:	4686      	mov	lr, r0
2000018e:	fab2 f282 	clz	r2, r2
20000192:	d962      	bls.n	2000025a <__udivmoddi4+0xde>
20000194:	b14a      	cbz	r2, 200001aa <__udivmoddi4+0x2e>
20000196:	f1c2 0320 	rsb	r3, r2, #32
2000019a:	4091      	lsls	r1, r2
2000019c:	fa20 f303 	lsr.w	r3, r0, r3
200001a0:	fa0c fc02 	lsl.w	ip, ip, r2
200001a4:	4319      	orrs	r1, r3
200001a6:	fa00 fe02 	lsl.w	lr, r0, r2
200001aa:	ea4f 471c 	mov.w	r7, ip, lsr #16
200001ae:	fa1f f68c 	uxth.w	r6, ip
200001b2:	fbb1 f4f7 	udiv	r4, r1, r7
200001b6:	ea4f 431e 	mov.w	r3, lr, lsr #16
200001ba:	fb07 1114 	mls	r1, r7, r4, r1
200001be:	ea43 4301 	orr.w	r3, r3, r1, lsl #16
200001c2:	fb04 f106 	mul.w	r1, r4, r6
200001c6:	4299      	cmp	r1, r3
200001c8:	d90a      	bls.n	200001e0 <__udivmoddi4+0x64>
200001ca:	eb1c 0303 	adds.w	r3, ip, r3
200001ce:	f104 30ff 	add.w	r0, r4, #4294967295	@ 0xffffffff
200001d2:	f080 8112 	bcs.w	200003fa <__udivmoddi4+0x27e>
200001d6:	4299      	cmp	r1, r3
200001d8:	f240 810f 	bls.w	200003fa <__udivmoddi4+0x27e>
200001dc:	3c02      	subs	r4, #2
200001de:	4463      	add	r3, ip
200001e0:	1a59      	subs	r1, r3, r1
200001e2:	fa1f f38e 	uxth.w	r3, lr
200001e6:	fbb1 f0f7 	udiv	r0, r1, r7
200001ea:	fb07 1110 	mls	r1, r7, r0, r1
200001ee:	ea43 4301 	orr.w	r3, r3, r1, lsl #16
200001f2:	fb00 f606 	mul.w	r6, r0, r6
200001f6:	429e      	cmp	r6, r3
200001f8:	d90a      	bls.n	20000210 <__udivmoddi4+0x94>
200001fa:	eb1c 0303 	adds.w	r3, ip, r3
200001fe:	f100 31ff 	add.w	r1, r0, #4294967295	@ 0xffffffff
20000202:	f080 80fc 	bcs.w	200003fe <__udivmoddi4+0x282>
20000206:	429e      	cmp	r6, r3
20000208:	f240 80f9 	bls.w	200003fe <__udivmoddi4+0x282>
2000020c:	4463      	add	r3, ip
2000020e:	3802      	subs	r0, #2
20000210:	1b9b      	subs	r3, r3, r6
20000212:	ea40 4004 	orr.w	r0, r0, r4, lsl #16
20000216:	2100      	movs	r1, #0
20000218:	b11d      	cbz	r5, 20000222 <__udivmoddi4+0xa6>
2000021a:	40d3      	lsrs	r3, r2
2000021c:	2200      	movs	r2, #0
2000021e:	e9c5 3200 	strd	r3, r2, [r5]
20000222:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
20000226:	428b      	cmp	r3, r1
20000228:	d905      	bls.n	20000236 <__udivmoddi4+0xba>
2000022a:	b10d      	cbz	r5, 20000230 <__udivmoddi4+0xb4>
2000022c:	e9c5 0100 	strd	r0, r1, [r5]
20000230:	2100      	movs	r1, #0
20000232:	4608      	mov	r0, r1
20000234:	e7f5      	b.n	20000222 <__udivmoddi4+0xa6>
20000236:	fab3 f183 	clz	r1, r3
2000023a:	2900      	cmp	r1, #0
2000023c:	d146      	bne.n	200002cc <__udivmoddi4+0x150>
2000023e:	42a3      	cmp	r3, r4
20000240:	d302      	bcc.n	20000248 <__udivmoddi4+0xcc>
20000242:	4290      	cmp	r0, r2
20000244:	f0c0 80f0 	bcc.w	20000428 <__udivmoddi4+0x2ac>
20000248:	1a86      	subs	r6, r0, r2
2000024a:	eb64 0303 	sbc.w	r3, r4, r3
2000024e:	2001      	movs	r0, #1
20000250:	2d00      	cmp	r5, #0
20000252:	d0e6      	beq.n	20000222 <__udivmoddi4+0xa6>
20000254:	e9c5 6300 	strd	r6, r3, [r5]
20000258:	e7e3      	b.n	20000222 <__udivmoddi4+0xa6>
2000025a:	2a00      	cmp	r2, #0
2000025c:	f040 8090 	bne.w	20000380 <__udivmoddi4+0x204>
20000260:	eba1 040c 	sub.w	r4, r1, ip
20000264:	ea4f 481c 	mov.w	r8, ip, lsr #16
20000268:	fa1f f78c 	uxth.w	r7, ip
2000026c:	2101      	movs	r1, #1
2000026e:	fbb4 f6f8 	udiv	r6, r4, r8
20000272:	ea4f 431e 	mov.w	r3, lr, lsr #16
20000276:	fb08 4416 	mls	r4, r8, r6, r4
2000027a:	ea43 4304 	orr.w	r3, r3, r4, lsl #16
2000027e:	fb07 f006 	mul.w	r0, r7, r6
20000282:	4298      	cmp	r0, r3
20000284:	d908      	bls.n	20000298 <__udivmoddi4+0x11c>
20000286:	eb1c 0303 	adds.w	r3, ip, r3
2000028a:	f106 34ff 	add.w	r4, r6, #4294967295	@ 0xffffffff
2000028e:	d202      	bcs.n	20000296 <__udivmoddi4+0x11a>
20000290:	4298      	cmp	r0, r3
20000292:	f200 80cd 	bhi.w	20000430 <__udivmoddi4+0x2b4>
20000296:	4626      	mov	r6, r4
20000298:	1a1c      	subs	r4, r3, r0
2000029a:	fa1f f38e 	uxth.w	r3, lr
2000029e:	fbb4 f0f8 	udiv	r0, r4, r8
200002a2:	fb08 4410 	mls	r4, r8, r0, r4
200002a6:	ea43 4304 	orr.w	r3, r3, r4, lsl #16
200002aa:	fb00 f707 	mul.w	r7, r0, r7
200002ae:	429f      	cmp	r7, r3
200002b0:	d908      	bls.n	200002c4 <__udivmoddi4+0x148>
200002b2:	eb1c 0303 	adds.w	r3, ip, r3
200002b6:	f100 34ff 	add.w	r4, r0, #4294967295	@ 0xffffffff
200002ba:	d202      	bcs.n	200002c2 <__udivmoddi4+0x146>
200002bc:	429f      	cmp	r7, r3
200002be:	f200 80b0 	bhi.w	20000422 <__udivmoddi4+0x2a6>
200002c2:	4620      	mov	r0, r4
200002c4:	1bdb      	subs	r3, r3, r7
200002c6:	ea40 4006 	orr.w	r0, r0, r6, lsl #16
200002ca:	e7a5      	b.n	20000218 <__udivmoddi4+0x9c>
200002cc:	f1c1 0620 	rsb	r6, r1, #32
200002d0:	408b      	lsls	r3, r1
200002d2:	fa22 f706 	lsr.w	r7, r2, r6
200002d6:	431f      	orrs	r7, r3
200002d8:	fa20 fc06 	lsr.w	ip, r0, r6
200002dc:	fa04 f301 	lsl.w	r3, r4, r1
200002e0:	ea43 030c 	orr.w	r3, r3, ip
200002e4:	40f4      	lsrs	r4, r6
200002e6:	fa00 f801 	lsl.w	r8, r0, r1
200002ea:	0c38      	lsrs	r0, r7, #16
200002ec:	ea4f 4913 	mov.w	r9, r3, lsr #16
200002f0:	fbb4 fef0 	udiv	lr, r4, r0
200002f4:	fa1f fc87 	uxth.w	ip, r7
200002f8:	fb00 441e 	mls	r4, r0, lr, r4
200002fc:	ea49 4404 	orr.w	r4, r9, r4, lsl #16
20000300:	fb0e f90c 	mul.w	r9, lr, ip
20000304:	45a1      	cmp	r9, r4
20000306:	fa02 f201 	lsl.w	r2, r2, r1
2000030a:	d90a      	bls.n	20000322 <__udivmoddi4+0x1a6>
2000030c:	193c      	adds	r4, r7, r4
2000030e:	f10e 3aff 	add.w	sl, lr, #4294967295	@ 0xffffffff
20000312:	f080 8084 	bcs.w	2000041e <__udivmoddi4+0x2a2>
20000316:	45a1      	cmp	r9, r4
20000318:	f240 8081 	bls.w	2000041e <__udivmoddi4+0x2a2>
2000031c:	f1ae 0e02 	sub.w	lr, lr, #2
20000320:	443c      	add	r4, r7
20000322:	eba4 0409 	sub.w	r4, r4, r9
20000326:	fa1f f983 	uxth.w	r9, r3
2000032a:	fbb4 f3f0 	udiv	r3, r4, r0
2000032e:	fb00 4413 	mls	r4, r0, r3, r4
20000332:	ea49 4404 	orr.w	r4, r9, r4, lsl #16
20000336:	fb03 fc0c 	mul.w	ip, r3, ip
2000033a:	45a4      	cmp	ip, r4
2000033c:	d907      	bls.n	2000034e <__udivmoddi4+0x1d2>
2000033e:	193c      	adds	r4, r7, r4
20000340:	f103 30ff 	add.w	r0, r3, #4294967295	@ 0xffffffff
20000344:	d267      	bcs.n	20000416 <__udivmoddi4+0x29a>
20000346:	45a4      	cmp	ip, r4
20000348:	d965      	bls.n	20000416 <__udivmoddi4+0x29a>
2000034a:	3b02      	subs	r3, #2
2000034c:	443c      	add	r4, r7
2000034e:	ea43 400e 	orr.w	r0, r3, lr, lsl #16
20000352:	fba0 9302 	umull	r9, r3, r0, r2
20000356:	eba4 040c 	sub.w	r4, r4, ip
2000035a:	429c      	cmp	r4, r3
2000035c:	46ce      	mov	lr, r9
2000035e:	469c      	mov	ip, r3
20000360:	d351      	bcc.n	20000406 <__udivmoddi4+0x28a>
20000362:	d04e      	beq.n	20000402 <__udivmoddi4+0x286>
20000364:	b155      	cbz	r5, 2000037c <__udivmoddi4+0x200>
20000366:	ebb8 030e 	subs.w	r3, r8, lr
2000036a:	eb64 040c 	sbc.w	r4, r4, ip
2000036e:	fa04 f606 	lsl.w	r6, r4, r6
20000372:	40cb      	lsrs	r3, r1
20000374:	431e      	orrs	r6, r3
20000376:	40cc      	lsrs	r4, r1
20000378:	e9c5 6400 	strd	r6, r4, [r5]
2000037c:	2100      	movs	r1, #0
2000037e:	e750      	b.n	20000222 <__udivmoddi4+0xa6>
20000380:	f1c2 0320 	rsb	r3, r2, #32
20000384:	fa20 f103 	lsr.w	r1, r0, r3
20000388:	fa0c fc02 	lsl.w	ip, ip, r2
2000038c:	fa24 f303 	lsr.w	r3, r4, r3
20000390:	4094      	lsls	r4, r2
20000392:	430c      	orrs	r4, r1
20000394:	ea4f 481c 	mov.w	r8, ip, lsr #16
20000398:	fa00 fe02 	lsl.w	lr, r0, r2
2000039c:	fa1f f78c 	uxth.w	r7, ip
200003a0:	fbb3 f0f8 	udiv	r0, r3, r8
200003a4:	fb08 3110 	mls	r1, r8, r0, r3
200003a8:	0c23      	lsrs	r3, r4, #16
200003aa:	ea43 4301 	orr.w	r3, r3, r1, lsl #16
200003ae:	fb00 f107 	mul.w	r1, r0, r7
200003b2:	4299      	cmp	r1, r3
200003b4:	d908      	bls.n	200003c8 <__udivmoddi4+0x24c>
200003b6:	eb1c 0303 	adds.w	r3, ip, r3
200003ba:	f100 36ff 	add.w	r6, r0, #4294967295	@ 0xffffffff
200003be:	d22c      	bcs.n	2000041a <__udivmoddi4+0x29e>
200003c0:	4299      	cmp	r1, r3
200003c2:	d92a      	bls.n	2000041a <__udivmoddi4+0x29e>
200003c4:	3802      	subs	r0, #2
200003c6:	4463      	add	r3, ip
200003c8:	1a5b      	subs	r3, r3, r1
200003ca:	b2a4      	uxth	r4, r4
200003cc:	fbb3 f1f8 	udiv	r1, r3, r8
200003d0:	fb08 3311 	mls	r3, r8, r1, r3
200003d4:	ea44 4403 	orr.w	r4, r4, r3, lsl #16
200003d8:	fb01 f307 	mul.w	r3, r1, r7
200003dc:	42a3      	cmp	r3, r4
200003de:	d908      	bls.n	200003f2 <__udivmoddi4+0x276>
200003e0:	eb1c 0404 	adds.w	r4, ip, r4
200003e4:	f101 36ff 	add.w	r6, r1, #4294967295	@ 0xffffffff
200003e8:	d213      	bcs.n	20000412 <__udivmoddi4+0x296>
200003ea:	42a3      	cmp	r3, r4
200003ec:	d911      	bls.n	20000412 <__udivmoddi4+0x296>
200003ee:	3902      	subs	r1, #2
200003f0:	4464      	add	r4, ip
200003f2:	1ae4      	subs	r4, r4, r3
200003f4:	ea41 4100 	orr.w	r1, r1, r0, lsl #16
200003f8:	e739      	b.n	2000026e <__udivmoddi4+0xf2>
200003fa:	4604      	mov	r4, r0
200003fc:	e6f0      	b.n	200001e0 <__udivmoddi4+0x64>
200003fe:	4608      	mov	r0, r1
20000400:	e706      	b.n	20000210 <__udivmoddi4+0x94>
20000402:	45c8      	cmp	r8, r9
20000404:	d2ae      	bcs.n	20000364 <__udivmoddi4+0x1e8>
20000406:	ebb9 0e02 	subs.w	lr, r9, r2
2000040a:	eb63 0c07 	sbc.w	ip, r3, r7
2000040e:	3801      	subs	r0, #1
20000410:	e7a8      	b.n	20000364 <__udivmoddi4+0x1e8>
20000412:	4631      	mov	r1, r6
20000414:	e7ed      	b.n	200003f2 <__udivmoddi4+0x276>
20000416:	4603      	mov	r3, r0
20000418:	e799      	b.n	2000034e <__udivmoddi4+0x1d2>
2000041a:	4630      	mov	r0, r6
2000041c:	e7d4      	b.n	200003c8 <__udivmoddi4+0x24c>
2000041e:	46d6      	mov	lr, sl
20000420:	e77f      	b.n	20000322 <__udivmoddi4+0x1a6>
20000422:	4463      	add	r3, ip
20000424:	3802      	subs	r0, #2
20000426:	e74d      	b.n	200002c4 <__udivmoddi4+0x148>
20000428:	4606      	mov	r6, r0
2000042a:	4623      	mov	r3, r4
2000042c:	4608      	mov	r0, r1
2000042e:	e70f      	b.n	20000250 <__udivmoddi4+0xd4>
20000430:	3e02      	subs	r6, #2
20000432:	4463      	add	r3, ip
20000434:	e730      	b.n	20000298 <__udivmoddi4+0x11c>
20000436:	bf00      	nop

20000438 <__aeabi_idiv0>:
20000438:	4770      	bx	lr
2000043a:	bf00      	nop

2000043c <Reset_Handler>:
 ldr   sp, =_estack    /* Set stack pointer */
2000043c:	f8df d0e8 	ldr.w	sp, [pc, #232]	@ 20000528 <L__usart_tdr+0x4>
  ldr r2, =_sbss
20000440:	4a3a      	ldr	r2, [pc, #232]	@ (2000052c <L__usart_tdr+0x8>)
  ldr r4, =_ebss
20000442:	4c3b      	ldr	r4, [pc, #236]	@ (20000530 <L__usart_tdr+0xc>)
  movs r3, #0
20000444:	2300      	movs	r3, #0
  cmp r2, r4
20000446:	42a2      	cmp	r2, r4
  beq 2f
20000448:	d002      	beq.n	20000450 <Reset_Handler+0x14>
  str  r3, [r2]
2000044a:	6013      	str	r3, [r2, #0]
  adds r2, r2, #4
2000044c:	3204      	adds	r2, #4
  b  1b
2000044e:	e7fa      	b.n	20000446 <Reset_Handler+0xa>
  ldr   r0, L__rcc_ahb2enr
20000450:	f8df 00a4 	ldr.w	r0, [pc, #164]	@ 200004f8 <L__rcc_ahb2enr>
  mov   r1, 0x2
20000454:	f04f 0102 	mov.w	r1, #2
  str   r1, [r0]
20000458:	6001      	str	r1, [r0, #0]
  ldr   r0, L__rcc_cr
2000045a:	4826      	ldr	r0, [pc, #152]	@ (200004f4 <L__rcc_cr>)
  mov   r1, 0xf00
2000045c:	f44f 6170 	mov.w	r1, #3840	@ 0xf00
  str   r1, [r0]
20000460:	6001      	str	r1, [r0, #0]
  ldr   r0, L__rcc_ccipr
20000462:	4826      	ldr	r0, [pc, #152]	@ (200004fc <L__rcc_ccipr>)
  mov   r1, 0x2
20000464:	f04f 0102 	mov.w	r1, #2
  str   r1, [r0]
20000468:	6001      	str	r1, [r0, #0]
  ldr   r0, L__rcc_apb2enr
2000046a:	4825      	ldr	r0, [pc, #148]	@ (20000500 <L__rcc_apb2enr>)
  mov   r1, 0x4000
2000046c:	f44f 4180 	mov.w	r1, #16384	@ 0x4000
  str   r1, [r0]
20000470:	6001      	str	r1, [r0, #0]
  ldr   r0, L__gpio_moder
20000472:	4824      	ldr	r0, [pc, #144]	@ (20000504 <L__gpio_moder>)
  mov   r1, 0xa000
20000474:	f44f 4120 	mov.w	r1, #40960	@ 0xa000
  str   r1, [r0]
20000478:	6001      	str	r1, [r0, #0]
  ldr   r0, L__gpio_afrl
2000047a:	4823      	ldr	r0, [pc, #140]	@ (20000508 <L__gpio_afrl>)
  mov   r1, 0x77000000
2000047c:	f04f 41ee 	mov.w	r1, #1996488704	@ 0x77000000
  str   r1, [r0]
20000480:	6001      	str	r1, [r0, #0]
  ldr   r0, L__usart_cr1
20000482:	4824      	ldr	r0, [pc, #144]	@ (20000514 <L__usart_cr1>)
  mov   r1, 0xd
20000484:	f04f 010d 	mov.w	r1, #13
  str   r1, [r0]
20000488:	6001      	str	r1, [r0, #0]
  ldr   r0, L__usart_brr
2000048a:	4824      	ldr	r0, [pc, #144]	@ (2000051c <L__usart_brr>)
  mov   r1, 0x8b
2000048c:	f04f 018b 	mov.w	r1, #139	@ 0x8b
  str   r1, [r0]
20000490:	6001      	str	r1, [r0, #0]
  ldr   r0, L__usart_isr
20000492:	4823      	ldr	r0, [pc, #140]	@ (20000520 <L__usart_isr>)
  ldr   r1, [r0]
20000494:	6801      	ldr	r1, [r0, #0]
  and   r1,  1<<7
20000496:	f001 0180 	and.w	r1, r1, #128	@ 0x80
  cmp   r1,  1<<7
2000049a:	2980      	cmp	r1, #128	@ 0x80
  bne   1b
2000049c:	d1fa      	bne.n	20000494 <Reset_Handler+0x58>
  ldr   r0, L__usart_tdr
2000049e:	4821      	ldr	r0, [pc, #132]	@ (20000524 <L__usart_tdr>)
  mov   r1, 0x0A  // Changed from 0x59 (Y) to 0x0A (newline)
200004a0:	f04f 010a 	mov.w	r1, #10
  str   r1, [r0]
200004a4:	6001      	str	r1, [r0, #0]
  ldr   r0, L__usart_isr
200004a6:	481e      	ldr	r0, [pc, #120]	@ (20000520 <L__usart_isr>)
  ldr   r1, [r0]
200004a8:	6801      	ldr	r1, [r0, #0]
  and   r1, 1<<7
200004aa:	f001 0180 	and.w	r1, r1, #128	@ 0x80
  cmp   r1, 1<<7
200004ae:	2980      	cmp	r1, #128	@ 0x80
  bne   1b
200004b0:	d1fa      	bne.n	200004a8 <Reset_Handler+0x6c>
  ldr   r0, L__usart_tdr
200004b2:	481c      	ldr	r0, [pc, #112]	@ (20000524 <L__usart_tdr>)
  mov   r1, 0x58  // This line can be kept as it is or changed based on what character you want to print next
200004b4:	f04f 0158 	mov.w	r1, #88	@ 0x58
  str   r1, [r0]
200004b8:	6001      	str	r1, [r0, #0]
  mov r0, #1
200004ba:	f04f 0001 	mov.w	r0, #1
  mov r1, #2
200004be:	f04f 0102 	mov.w	r1, #2

200004c2 <compute>:
  add r2, r1, r0
200004c2:	eb01 0200 	add.w	r2, r1, r0
  mov r0, r2
200004c6:	4610      	mov	r0, r2
  add r1, r1, #1
200004c8:	f101 0101 	add.w	r1, r1, #1
  cmp r1, #101
200004cc:	2965      	cmp	r1, #101	@ 0x65
  bne compute
200004ce:	d1f8      	bne.n	200004c2 <compute>
bl cfe_main
200004d0:	f003 f93c 	bl	2000374c <cfe_main>

200004d4 <start>:
    ldr   r1, [r0]
200004d4:	6801      	ldr	r1, [r0, #0]
    ands  r1, r1, 1<<7
200004d6:	f011 0180 	ands.w	r1, r1, #128	@ 0x80
    beq   start
200004da:	d0fb      	beq.n	200004d4 <start>
    ldr   r0, L__usart_tdr
200004dc:	4811      	ldr	r0, [pc, #68]	@ (20000524 <L__usart_tdr>)
    mov   r1, #48
200004de:	f04f 0130 	mov.w	r1, #48	@ 0x30
    str   r1, [r0]
200004e2:	6001      	str	r1, [r0, #0]

200004e4 <stop>:
    ldr   r1, [r0]
200004e4:	6801      	ldr	r1, [r0, #0]
    ands  r1, r1, 1<<7
200004e6:	f011 0180 	ands.w	r1, r1, #128	@ 0x80
    beq   stop
200004ea:	d0fb      	beq.n	200004e4 <stop>
    ldr   r0, L__usart_tdr
200004ec:	480d      	ldr	r0, [pc, #52]	@ (20000524 <L__usart_tdr>)
    mov   r1, #49
200004ee:	f04f 0131 	mov.w	r1, #49	@ 0x31
    str   r1, [r0]
200004f2:	6001      	str	r1, [r0, #0]

200004f4 <L__rcc_cr>:
200004f4:	40021000 	.word	0x40021000

200004f8 <L__rcc_ahb2enr>:
200004f8:	4002104c 	.word	0x4002104c

200004fc <L__rcc_ccipr>:
200004fc:	40021088 	.word	0x40021088

20000500 <L__rcc_apb2enr>:
20000500:	40021060 	.word	0x40021060

20000504 <L__gpio_moder>:
20000504:	48000400 	.word	0x48000400

20000508 <L__gpio_afrl>:
20000508:	48000420 	.word	0x48000420

2000050c <L__gpio_ospeedr>:
2000050c:	48000408 	.word	0x48000408

20000510 <L__gpio_pupdr>:
20000510:	4800040c 	.word	0x4800040c

20000514 <L__usart_cr1>:
20000514:	40013800 	.word	0x40013800

20000518 <L__usart_otyper>:
20000518:	40013804 	.word	0x40013804

2000051c <L__usart_brr>:
2000051c:	4001380c 	.word	0x4001380c

20000520 <L__usart_isr>:
20000520:	4001381c 	.word	0x4001381c

20000524 <L__usart_tdr>:
20000524:	40013828 	.word	0x40013828
 ldr   sp, =_estack    /* Set stack pointer */
20000528:	20018000 	.word	0x20018000
  ldr r2, =_sbss
2000052c:	200091f8 	.word	0x200091f8
  ldr r4, =_ebss
20000530:	2000947c 	.word	0x2000947c

20000534 <__atox>:
    *  Return Value:
    *      number of digits placed in output buffer
    ********************************************************************* */
static int __atox(char *buf,unsigned int num,unsigned int radix,int width,
		     const char *digits)
{
20000534:	b480      	push	{r7}
20000536:	b08b      	sub	sp, #44	@ 0x2c
20000538:	af00      	add	r7, sp, #0
2000053a:	60f8      	str	r0, [r7, #12]
2000053c:	60b9      	str	r1, [r7, #8]
2000053e:	607a      	str	r2, [r7, #4]
20000540:	603b      	str	r3, [r7, #0]
    char buffer[16];
    char *op;
    int retval;

    op = &buffer[0];
20000542:	f107 0310 	add.w	r3, r7, #16
20000546:	627b      	str	r3, [r7, #36]	@ 0x24
    retval = 0;
20000548:	2300      	movs	r3, #0
2000054a:	623b      	str	r3, [r7, #32]

    do {
	*op++ = digits[num % radix];
2000054c:	68bb      	ldr	r3, [r7, #8]
2000054e:	687a      	ldr	r2, [r7, #4]
20000550:	fbb3 f2f2 	udiv	r2, r3, r2
20000554:	6879      	ldr	r1, [r7, #4]
20000556:	fb01 f202 	mul.w	r2, r1, r2
2000055a:	1a9b      	subs	r3, r3, r2
2000055c:	6b3a      	ldr	r2, [r7, #48]	@ 0x30
2000055e:	441a      	add	r2, r3
20000560:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
20000562:	1c59      	adds	r1, r3, #1
20000564:	6279      	str	r1, [r7, #36]	@ 0x24
20000566:	7812      	ldrb	r2, [r2, #0]
20000568:	701a      	strb	r2, [r3, #0]
	retval++;
2000056a:	6a3b      	ldr	r3, [r7, #32]
2000056c:	3301      	adds	r3, #1
2000056e:	623b      	str	r3, [r7, #32]
	num /= radix;
20000570:	68ba      	ldr	r2, [r7, #8]
20000572:	687b      	ldr	r3, [r7, #4]
20000574:	fbb2 f3f3 	udiv	r3, r2, r3
20000578:	60bb      	str	r3, [r7, #8]
	} while (num != 0);
2000057a:	68bb      	ldr	r3, [r7, #8]
2000057c:	2b00      	cmp	r3, #0
2000057e:	d1e5      	bne.n	2000054c <__atox+0x18>

    if (width && (width > retval)) {
20000580:	683b      	ldr	r3, [r7, #0]
20000582:	2b00      	cmp	r3, #0
20000584:	d020      	beq.n	200005c8 <__atox+0x94>
20000586:	683a      	ldr	r2, [r7, #0]
20000588:	6a3b      	ldr	r3, [r7, #32]
2000058a:	429a      	cmp	r2, r3
2000058c:	dd1c      	ble.n	200005c8 <__atox+0x94>
	width = width - retval;
2000058e:	683a      	ldr	r2, [r7, #0]
20000590:	6a3b      	ldr	r3, [r7, #32]
20000592:	1ad3      	subs	r3, r2, r3
20000594:	603b      	str	r3, [r7, #0]
	while (width) {
20000596:	e00a      	b.n	200005ae <__atox+0x7a>
	    *op++ = '0';
20000598:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
2000059a:	1c5a      	adds	r2, r3, #1
2000059c:	627a      	str	r2, [r7, #36]	@ 0x24
2000059e:	2230      	movs	r2, #48	@ 0x30
200005a0:	701a      	strb	r2, [r3, #0]
	    retval++;
200005a2:	6a3b      	ldr	r3, [r7, #32]
200005a4:	3301      	adds	r3, #1
200005a6:	623b      	str	r3, [r7, #32]
	    width--;
200005a8:	683b      	ldr	r3, [r7, #0]
200005aa:	3b01      	subs	r3, #1
200005ac:	603b      	str	r3, [r7, #0]
	while (width) {
200005ae:	683b      	ldr	r3, [r7, #0]
200005b0:	2b00      	cmp	r3, #0
200005b2:	d1f1      	bne.n	20000598 <__atox+0x64>
	    }
	}

    while (op != buffer) {
200005b4:	e008      	b.n	200005c8 <__atox+0x94>
	op--;
200005b6:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
200005b8:	3b01      	subs	r3, #1
200005ba:	627b      	str	r3, [r7, #36]	@ 0x24
	*buf++ = *op;
200005bc:	68fb      	ldr	r3, [r7, #12]
200005be:	1c5a      	adds	r2, r3, #1
200005c0:	60fa      	str	r2, [r7, #12]
200005c2:	6a7a      	ldr	r2, [r7, #36]	@ 0x24
200005c4:	7812      	ldrb	r2, [r2, #0]
200005c6:	701a      	strb	r2, [r3, #0]
    while (op != buffer) {
200005c8:	f107 0310 	add.w	r3, r7, #16
200005cc:	6a7a      	ldr	r2, [r7, #36]	@ 0x24
200005ce:	429a      	cmp	r2, r3
200005d0:	d1f1      	bne.n	200005b6 <__atox+0x82>
	}

    return retval;
200005d2:	6a3b      	ldr	r3, [r7, #32]
}
200005d4:	4618      	mov	r0, r3
200005d6:	372c      	adds	r7, #44	@ 0x2c
200005d8:	46bd      	mov	sp, r7
200005da:	f85d 7b04 	ldr.w	r7, [sp], #4
200005de:	4770      	bx	lr

200005e0 <__llatox>:
    *  Return Value:
    *      number of digits placed in output buffer
    ********************************************************************* */
static int __llatox(char *buf,unsigned long long num,unsigned int radix,
		    int width,const char *digits)
{
200005e0:	e92d 43b0 	stmdb	sp!, {r4, r5, r7, r8, r9, lr}
200005e4:	b08a      	sub	sp, #40	@ 0x28
200005e6:	af00      	add	r7, sp, #0
200005e8:	60f8      	str	r0, [r7, #12]
200005ea:	e9c7 2300 	strd	r2, r3, [r7]
    char buffer[16];
    char *op;
    int retval;

    op = &buffer[0];
200005ee:	f107 0310 	add.w	r3, r7, #16
200005f2:	627b      	str	r3, [r7, #36]	@ 0x24
    retval = 0;
200005f4:	2300      	movs	r3, #0
200005f6:	623b      	str	r3, [r7, #32]
	retval++;
	num >>= 4;
	} while (num != 0);
#else
    do {
	*op++ = digits[num % radix];
200005f8:	6c3b      	ldr	r3, [r7, #64]	@ 0x40
200005fa:	2200      	movs	r2, #0
200005fc:	4698      	mov	r8, r3
200005fe:	4691      	mov	r9, r2
20000600:	e9d7 0100 	ldrd	r0, r1, [r7]
20000604:	4642      	mov	r2, r8
20000606:	464b      	mov	r3, r9
20000608:	f7ff fda0 	bl	2000014c <__aeabi_uldivmod>
2000060c:	6cbb      	ldr	r3, [r7, #72]	@ 0x48
2000060e:	441a      	add	r2, r3
20000610:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
20000612:	1c59      	adds	r1, r3, #1
20000614:	6279      	str	r1, [r7, #36]	@ 0x24
20000616:	7812      	ldrb	r2, [r2, #0]
20000618:	701a      	strb	r2, [r3, #0]
	retval++;
2000061a:	6a3b      	ldr	r3, [r7, #32]
2000061c:	3301      	adds	r3, #1
2000061e:	623b      	str	r3, [r7, #32]
	num /= radix;
20000620:	6c3b      	ldr	r3, [r7, #64]	@ 0x40
20000622:	2200      	movs	r2, #0
20000624:	461c      	mov	r4, r3
20000626:	4615      	mov	r5, r2
20000628:	4622      	mov	r2, r4
2000062a:	462b      	mov	r3, r5
2000062c:	e9d7 0100 	ldrd	r0, r1, [r7]
20000630:	f7ff fd8c 	bl	2000014c <__aeabi_uldivmod>
20000634:	4602      	mov	r2, r0
20000636:	460b      	mov	r3, r1
20000638:	e9c7 2300 	strd	r2, r3, [r7]
	} while (num != 0);
2000063c:	e9d7 2300 	ldrd	r2, r3, [r7]
20000640:	4313      	orrs	r3, r2
20000642:	d1d9      	bne.n	200005f8 <__llatox+0x18>
#endif

    if (width && (width > retval)) {
20000644:	6c7b      	ldr	r3, [r7, #68]	@ 0x44
20000646:	2b00      	cmp	r3, #0
20000648:	d020      	beq.n	2000068c <__llatox+0xac>
2000064a:	6c7a      	ldr	r2, [r7, #68]	@ 0x44
2000064c:	6a3b      	ldr	r3, [r7, #32]
2000064e:	429a      	cmp	r2, r3
20000650:	dd1c      	ble.n	2000068c <__llatox+0xac>
	width = width - retval;
20000652:	6c7a      	ldr	r2, [r7, #68]	@ 0x44
20000654:	6a3b      	ldr	r3, [r7, #32]
20000656:	1ad3      	subs	r3, r2, r3
20000658:	647b      	str	r3, [r7, #68]	@ 0x44
	while (width) {
2000065a:	e00a      	b.n	20000672 <__llatox+0x92>
	    *op++ = '0';
2000065c:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
2000065e:	1c5a      	adds	r2, r3, #1
20000660:	627a      	str	r2, [r7, #36]	@ 0x24
20000662:	2230      	movs	r2, #48	@ 0x30
20000664:	701a      	strb	r2, [r3, #0]
	    retval++;
20000666:	6a3b      	ldr	r3, [r7, #32]
20000668:	3301      	adds	r3, #1
2000066a:	623b      	str	r3, [r7, #32]
	    width--;
2000066c:	6c7b      	ldr	r3, [r7, #68]	@ 0x44
2000066e:	3b01      	subs	r3, #1
20000670:	647b      	str	r3, [r7, #68]	@ 0x44
	while (width) {
20000672:	6c7b      	ldr	r3, [r7, #68]	@ 0x44
20000674:	2b00      	cmp	r3, #0
20000676:	d1f1      	bne.n	2000065c <__llatox+0x7c>
	    }
	}

    while (op != buffer) {
20000678:	e008      	b.n	2000068c <__llatox+0xac>
	op--;
2000067a:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
2000067c:	3b01      	subs	r3, #1
2000067e:	627b      	str	r3, [r7, #36]	@ 0x24
	*buf++ = *op;
20000680:	68fb      	ldr	r3, [r7, #12]
20000682:	1c5a      	adds	r2, r3, #1
20000684:	60fa      	str	r2, [r7, #12]
20000686:	6a7a      	ldr	r2, [r7, #36]	@ 0x24
20000688:	7812      	ldrb	r2, [r2, #0]
2000068a:	701a      	strb	r2, [r3, #0]
    while (op != buffer) {
2000068c:	f107 0310 	add.w	r3, r7, #16
20000690:	6a7a      	ldr	r2, [r7, #36]	@ 0x24
20000692:	429a      	cmp	r2, r3
20000694:	d1f1      	bne.n	2000067a <__llatox+0x9a>
	}

    return retval;
20000696:	6a3b      	ldr	r3, [r7, #32]
}
20000698:	4618      	mov	r0, r3
2000069a:	3728      	adds	r7, #40	@ 0x28
2000069c:	46bd      	mov	sp, r7
2000069e:	e8bd 83b0 	ldmia.w	sp!, {r4, r5, r7, r8, r9, pc}
	...

200006a4 <xvsprintf>:
    *  Return Value:
    *      number of characters copied
    ********************************************************************* */
#define isdigit(x) (((x) >= '0') && ((x) <= '9'))
int xvsprintf(char *outbuf,const char *templat,va_list marker)
{
200006a4:	b5b0      	push	{r4, r5, r7, lr}
200006a6:	b09a      	sub	sp, #104	@ 0x68
200006a8:	af04      	add	r7, sp, #16
200006aa:	60f8      	str	r0, [r7, #12]
200006ac:	60b9      	str	r1, [r7, #8]
200006ae:	607a      	str	r2, [r7, #4]
    long long ll;
    int leadingzero;
    int leadingnegsign;
    int islong;
    int width;
    int width2 = 0;
200006b0:	2300      	movs	r3, #0
200006b2:	62fb      	str	r3, [r7, #44]	@ 0x2c
    int hashash = 0;
200006b4:	2300      	movs	r3, #0
200006b6:	62bb      	str	r3, [r7, #40]	@ 0x28

    optr = outbuf;
200006b8:	68fb      	ldr	r3, [r7, #12]
200006ba:	657b      	str	r3, [r7, #84]	@ 0x54
    iptr = templat;
200006bc:	68bb      	ldr	r3, [r7, #8]
200006be:	653b      	str	r3, [r7, #80]	@ 0x50

    while (*iptr) {
200006c0:	e326      	b.n	20000d10 <xvsprintf+0x66c>
	if (*iptr != '%') {*optr++ = *iptr++; continue;}
200006c2:	6d3b      	ldr	r3, [r7, #80]	@ 0x50
200006c4:	781b      	ldrb	r3, [r3, #0]
200006c6:	2b25      	cmp	r3, #37	@ 0x25
200006c8:	d008      	beq.n	200006dc <xvsprintf+0x38>
200006ca:	6d3a      	ldr	r2, [r7, #80]	@ 0x50
200006cc:	1c53      	adds	r3, r2, #1
200006ce:	653b      	str	r3, [r7, #80]	@ 0x50
200006d0:	6d7b      	ldr	r3, [r7, #84]	@ 0x54
200006d2:	1c59      	adds	r1, r3, #1
200006d4:	6579      	str	r1, [r7, #84]	@ 0x54
200006d6:	7812      	ldrb	r2, [r2, #0]
200006d8:	701a      	strb	r2, [r3, #0]
200006da:	e319      	b.n	20000d10 <xvsprintf+0x66c>

	iptr++;
200006dc:	6d3b      	ldr	r3, [r7, #80]	@ 0x50
200006de:	3301      	adds	r3, #1
200006e0:	653b      	str	r3, [r7, #80]	@ 0x50

	if (*iptr == '#') { hashash = 1; iptr++; }
200006e2:	6d3b      	ldr	r3, [r7, #80]	@ 0x50
200006e4:	781b      	ldrb	r3, [r3, #0]
200006e6:	2b23      	cmp	r3, #35	@ 0x23
200006e8:	d104      	bne.n	200006f4 <xvsprintf+0x50>
200006ea:	2301      	movs	r3, #1
200006ec:	62bb      	str	r3, [r7, #40]	@ 0x28
200006ee:	6d3b      	ldr	r3, [r7, #80]	@ 0x50
200006f0:	3301      	adds	r3, #1
200006f2:	653b      	str	r3, [r7, #80]	@ 0x50
	if (*iptr == '-') {
200006f4:	6d3b      	ldr	r3, [r7, #80]	@ 0x50
200006f6:	781b      	ldrb	r3, [r3, #0]
200006f8:	2b2d      	cmp	r3, #45	@ 0x2d
200006fa:	d105      	bne.n	20000708 <xvsprintf+0x64>
	    leadingnegsign = 1;
200006fc:	2301      	movs	r3, #1
200006fe:	627b      	str	r3, [r7, #36]	@ 0x24
	    iptr++;
20000700:	6d3b      	ldr	r3, [r7, #80]	@ 0x50
20000702:	3301      	adds	r3, #1
20000704:	653b      	str	r3, [r7, #80]	@ 0x50
20000706:	e001      	b.n	2000070c <xvsprintf+0x68>
	    }
	else leadingnegsign = 0;
20000708:	2300      	movs	r3, #0
2000070a:	627b      	str	r3, [r7, #36]	@ 0x24

	if (*iptr == '0') leadingzero = 1;
2000070c:	6d3b      	ldr	r3, [r7, #80]	@ 0x50
2000070e:	781b      	ldrb	r3, [r3, #0]
20000710:	2b30      	cmp	r3, #48	@ 0x30
20000712:	d102      	bne.n	2000071a <xvsprintf+0x76>
20000714:	2301      	movs	r3, #1
20000716:	623b      	str	r3, [r7, #32]
20000718:	e001      	b.n	2000071e <xvsprintf+0x7a>
	else leadingzero = 0;
2000071a:	2300      	movs	r3, #0
2000071c:	623b      	str	r3, [r7, #32]

	width = 0;
2000071e:	2300      	movs	r3, #0
20000720:	633b      	str	r3, [r7, #48]	@ 0x30
	while (*iptr && isdigit(*iptr)) {
20000722:	e016      	b.n	20000752 <xvsprintf+0xae>
	    width += (*iptr - '0');
20000724:	6d3b      	ldr	r3, [r7, #80]	@ 0x50
20000726:	781b      	ldrb	r3, [r3, #0]
20000728:	3b30      	subs	r3, #48	@ 0x30
2000072a:	6b3a      	ldr	r2, [r7, #48]	@ 0x30
2000072c:	4413      	add	r3, r2
2000072e:	633b      	str	r3, [r7, #48]	@ 0x30
	    iptr++;
20000730:	6d3b      	ldr	r3, [r7, #80]	@ 0x50
20000732:	3301      	adds	r3, #1
20000734:	653b      	str	r3, [r7, #80]	@ 0x50
	    if (isdigit(*iptr)) width *= 10;
20000736:	6d3b      	ldr	r3, [r7, #80]	@ 0x50
20000738:	781b      	ldrb	r3, [r3, #0]
2000073a:	2b2f      	cmp	r3, #47	@ 0x2f
2000073c:	d909      	bls.n	20000752 <xvsprintf+0xae>
2000073e:	6d3b      	ldr	r3, [r7, #80]	@ 0x50
20000740:	781b      	ldrb	r3, [r3, #0]
20000742:	2b39      	cmp	r3, #57	@ 0x39
20000744:	d805      	bhi.n	20000752 <xvsprintf+0xae>
20000746:	6b3a      	ldr	r2, [r7, #48]	@ 0x30
20000748:	4613      	mov	r3, r2
2000074a:	009b      	lsls	r3, r3, #2
2000074c:	4413      	add	r3, r2
2000074e:	005b      	lsls	r3, r3, #1
20000750:	633b      	str	r3, [r7, #48]	@ 0x30
	while (*iptr && isdigit(*iptr)) {
20000752:	6d3b      	ldr	r3, [r7, #80]	@ 0x50
20000754:	781b      	ldrb	r3, [r3, #0]
20000756:	2b00      	cmp	r3, #0
20000758:	d007      	beq.n	2000076a <xvsprintf+0xc6>
2000075a:	6d3b      	ldr	r3, [r7, #80]	@ 0x50
2000075c:	781b      	ldrb	r3, [r3, #0]
2000075e:	2b2f      	cmp	r3, #47	@ 0x2f
20000760:	d903      	bls.n	2000076a <xvsprintf+0xc6>
20000762:	6d3b      	ldr	r3, [r7, #80]	@ 0x50
20000764:	781b      	ldrb	r3, [r3, #0]
20000766:	2b39      	cmp	r3, #57	@ 0x39
20000768:	d9dc      	bls.n	20000724 <xvsprintf+0x80>
	    }
	if (*iptr == '.') {
2000076a:	6d3b      	ldr	r3, [r7, #80]	@ 0x50
2000076c:	781b      	ldrb	r3, [r3, #0]
2000076e:	2b2e      	cmp	r3, #46	@ 0x2e
20000770:	d128      	bne.n	200007c4 <xvsprintf+0x120>
	    iptr++;
20000772:	6d3b      	ldr	r3, [r7, #80]	@ 0x50
20000774:	3301      	adds	r3, #1
20000776:	653b      	str	r3, [r7, #80]	@ 0x50
	    width2 = 0;
20000778:	2300      	movs	r3, #0
2000077a:	62fb      	str	r3, [r7, #44]	@ 0x2c
	    while (*iptr && isdigit(*iptr)) {
2000077c:	e016      	b.n	200007ac <xvsprintf+0x108>
		width2 += (*iptr - '0');
2000077e:	6d3b      	ldr	r3, [r7, #80]	@ 0x50
20000780:	781b      	ldrb	r3, [r3, #0]
20000782:	3b30      	subs	r3, #48	@ 0x30
20000784:	6afa      	ldr	r2, [r7, #44]	@ 0x2c
20000786:	4413      	add	r3, r2
20000788:	62fb      	str	r3, [r7, #44]	@ 0x2c
		iptr++;
2000078a:	6d3b      	ldr	r3, [r7, #80]	@ 0x50
2000078c:	3301      	adds	r3, #1
2000078e:	653b      	str	r3, [r7, #80]	@ 0x50
		if (isdigit(*iptr)) width2 *= 10;
20000790:	6d3b      	ldr	r3, [r7, #80]	@ 0x50
20000792:	781b      	ldrb	r3, [r3, #0]
20000794:	2b2f      	cmp	r3, #47	@ 0x2f
20000796:	d909      	bls.n	200007ac <xvsprintf+0x108>
20000798:	6d3b      	ldr	r3, [r7, #80]	@ 0x50
2000079a:	781b      	ldrb	r3, [r3, #0]
2000079c:	2b39      	cmp	r3, #57	@ 0x39
2000079e:	d805      	bhi.n	200007ac <xvsprintf+0x108>
200007a0:	6afa      	ldr	r2, [r7, #44]	@ 0x2c
200007a2:	4613      	mov	r3, r2
200007a4:	009b      	lsls	r3, r3, #2
200007a6:	4413      	add	r3, r2
200007a8:	005b      	lsls	r3, r3, #1
200007aa:	62fb      	str	r3, [r7, #44]	@ 0x2c
	    while (*iptr && isdigit(*iptr)) {
200007ac:	6d3b      	ldr	r3, [r7, #80]	@ 0x50
200007ae:	781b      	ldrb	r3, [r3, #0]
200007b0:	2b00      	cmp	r3, #0
200007b2:	d007      	beq.n	200007c4 <xvsprintf+0x120>
200007b4:	6d3b      	ldr	r3, [r7, #80]	@ 0x50
200007b6:	781b      	ldrb	r3, [r3, #0]
200007b8:	2b2f      	cmp	r3, #47	@ 0x2f
200007ba:	d903      	bls.n	200007c4 <xvsprintf+0x120>
200007bc:	6d3b      	ldr	r3, [r7, #80]	@ 0x50
200007be:	781b      	ldrb	r3, [r3, #0]
200007c0:	2b39      	cmp	r3, #57	@ 0x39
200007c2:	d9dc      	bls.n	2000077e <xvsprintf+0xda>
		}
	    }

	islong = 0;
200007c4:	2300      	movs	r3, #0
200007c6:	637b      	str	r3, [r7, #52]	@ 0x34
	if (*iptr == 'l') { islong++; iptr++; }
200007c8:	6d3b      	ldr	r3, [r7, #80]	@ 0x50
200007ca:	781b      	ldrb	r3, [r3, #0]
200007cc:	2b6c      	cmp	r3, #108	@ 0x6c
200007ce:	d105      	bne.n	200007dc <xvsprintf+0x138>
200007d0:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
200007d2:	3301      	adds	r3, #1
200007d4:	637b      	str	r3, [r7, #52]	@ 0x34
200007d6:	6d3b      	ldr	r3, [r7, #80]	@ 0x50
200007d8:	3301      	adds	r3, #1
200007da:	653b      	str	r3, [r7, #80]	@ 0x50
	if (*iptr == 'l') { islong++; iptr++; }
200007dc:	6d3b      	ldr	r3, [r7, #80]	@ 0x50
200007de:	781b      	ldrb	r3, [r3, #0]
200007e0:	2b6c      	cmp	r3, #108	@ 0x6c
200007e2:	d105      	bne.n	200007f0 <xvsprintf+0x14c>
200007e4:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
200007e6:	3301      	adds	r3, #1
200007e8:	637b      	str	r3, [r7, #52]	@ 0x34
200007ea:	6d3b      	ldr	r3, [r7, #80]	@ 0x50
200007ec:	3301      	adds	r3, #1
200007ee:	653b      	str	r3, [r7, #80]	@ 0x50

	switch (*iptr) {
200007f0:	6d3b      	ldr	r3, [r7, #80]	@ 0x50
200007f2:	781b      	ldrb	r3, [r3, #0]
200007f4:	3b49      	subs	r3, #73	@ 0x49
200007f6:	2b2f      	cmp	r3, #47	@ 0x2f
200007f8:	f200 8280 	bhi.w	20000cfc <xvsprintf+0x658>
200007fc:	a201      	add	r2, pc, #4	@ (adr r2, 20000804 <xvsprintf+0x160>)
200007fe:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
20000802:	bf00      	nop
20000804:	200008c5 	.word	0x200008c5
20000808:	20000cfd 	.word	0x20000cfd
2000080c:	20000cfd 	.word	0x20000cfd
20000810:	20000cfd 	.word	0x20000cfd
20000814:	20000cfd 	.word	0x20000cfd
20000818:	20000cfd 	.word	0x20000cfd
2000081c:	20000cfd 	.word	0x20000cfd
20000820:	20000c15 	.word	0x20000c15
20000824:	20000cfd 	.word	0x20000cfd
20000828:	20000cfd 	.word	0x20000cfd
2000082c:	20000cfd 	.word	0x20000cfd
20000830:	20000cfd 	.word	0x20000cfd
20000834:	20000cfd 	.word	0x20000cfd
20000838:	20000cfd 	.word	0x20000cfd
2000083c:	20000cfd 	.word	0x20000cfd
20000840:	20000b87 	.word	0x20000b87
20000844:	20000cfd 	.word	0x20000cfd
20000848:	20000c9f 	.word	0x20000c9f
2000084c:	20000cfd 	.word	0x20000cfd
20000850:	20000cfd 	.word	0x20000cfd
20000854:	20000cfd 	.word	0x20000cfd
20000858:	20000cfd 	.word	0x20000cfd
2000085c:	20000cfd 	.word	0x20000cfd
20000860:	20000cfd 	.word	0x20000cfd
20000864:	200009ef 	.word	0x200009ef
20000868:	20000c73 	.word	0x20000c73
2000086c:	20000ce5 	.word	0x20000ce5
20000870:	20000a5b 	.word	0x20000a5b
20000874:	20000cfd 	.word	0x20000cfd
20000878:	20000cfd 	.word	0x20000cfd
2000087c:	20000cfd 	.word	0x20000cfd
20000880:	20000cfd 	.word	0x20000cfd
20000884:	20000cfd 	.word	0x20000cfd
20000888:	20000cfd 	.word	0x20000cfd
2000088c:	20000cfd 	.word	0x20000cfd
20000890:	20000cfd 	.word	0x20000cfd
20000894:	20000cfd 	.word	0x20000cfd
20000898:	20000cfd 	.word	0x20000cfd
2000089c:	20000cfd 	.word	0x20000cfd
200008a0:	20000c15 	.word	0x20000c15
200008a4:	20000cfd 	.word	0x20000cfd
200008a8:	20000cfd 	.word	0x20000cfd
200008ac:	20000977 	.word	0x20000977
200008b0:	20000cfd 	.word	0x20000cfd
200008b4:	20000b09 	.word	0x20000b09
200008b8:	20000cfd 	.word	0x20000cfd
200008bc:	20000c47 	.word	0x20000c47
200008c0:	20000b87 	.word	0x20000b87
	    case 'I':
		tmpptr = (unsigned char *) va_arg(marker,unsigned char *);
200008c4:	687b      	ldr	r3, [r7, #4]
200008c6:	1d1a      	adds	r2, r3, #4
200008c8:	607a      	str	r2, [r7, #4]
200008ca:	681b      	ldr	r3, [r3, #0]
200008cc:	64fb      	str	r3, [r7, #76]	@ 0x4c
		optr += __atox(optr,*tmpptr++,10,0,digits);
200008ce:	6cfb      	ldr	r3, [r7, #76]	@ 0x4c
200008d0:	1c5a      	adds	r2, r3, #1
200008d2:	64fa      	str	r2, [r7, #76]	@ 0x4c
200008d4:	781b      	ldrb	r3, [r3, #0]
200008d6:	4619      	mov	r1, r3
200008d8:	4b9a      	ldr	r3, [pc, #616]	@ (20000b44 <xvsprintf+0x4a0>)
200008da:	9300      	str	r3, [sp, #0]
200008dc:	2300      	movs	r3, #0
200008de:	220a      	movs	r2, #10
200008e0:	6d78      	ldr	r0, [r7, #84]	@ 0x54
200008e2:	f7ff fe27 	bl	20000534 <__atox>
200008e6:	4603      	mov	r3, r0
200008e8:	461a      	mov	r2, r3
200008ea:	6d7b      	ldr	r3, [r7, #84]	@ 0x54
200008ec:	4413      	add	r3, r2
200008ee:	657b      	str	r3, [r7, #84]	@ 0x54
		*optr++ = '.';
200008f0:	6d7b      	ldr	r3, [r7, #84]	@ 0x54
200008f2:	1c5a      	adds	r2, r3, #1
200008f4:	657a      	str	r2, [r7, #84]	@ 0x54
200008f6:	222e      	movs	r2, #46	@ 0x2e
200008f8:	701a      	strb	r2, [r3, #0]
		optr += __atox(optr,*tmpptr++,10,0,digits);
200008fa:	6cfb      	ldr	r3, [r7, #76]	@ 0x4c
200008fc:	1c5a      	adds	r2, r3, #1
200008fe:	64fa      	str	r2, [r7, #76]	@ 0x4c
20000900:	781b      	ldrb	r3, [r3, #0]
20000902:	4619      	mov	r1, r3
20000904:	4b8f      	ldr	r3, [pc, #572]	@ (20000b44 <xvsprintf+0x4a0>)
20000906:	9300      	str	r3, [sp, #0]
20000908:	2300      	movs	r3, #0
2000090a:	220a      	movs	r2, #10
2000090c:	6d78      	ldr	r0, [r7, #84]	@ 0x54
2000090e:	f7ff fe11 	bl	20000534 <__atox>
20000912:	4603      	mov	r3, r0
20000914:	461a      	mov	r2, r3
20000916:	6d7b      	ldr	r3, [r7, #84]	@ 0x54
20000918:	4413      	add	r3, r2
2000091a:	657b      	str	r3, [r7, #84]	@ 0x54
		*optr++ = '.';
2000091c:	6d7b      	ldr	r3, [r7, #84]	@ 0x54
2000091e:	1c5a      	adds	r2, r3, #1
20000920:	657a      	str	r2, [r7, #84]	@ 0x54
20000922:	222e      	movs	r2, #46	@ 0x2e
20000924:	701a      	strb	r2, [r3, #0]
		optr += __atox(optr,*tmpptr++,10,0,digits);
20000926:	6cfb      	ldr	r3, [r7, #76]	@ 0x4c
20000928:	1c5a      	adds	r2, r3, #1
2000092a:	64fa      	str	r2, [r7, #76]	@ 0x4c
2000092c:	781b      	ldrb	r3, [r3, #0]
2000092e:	4619      	mov	r1, r3
20000930:	4b84      	ldr	r3, [pc, #528]	@ (20000b44 <xvsprintf+0x4a0>)
20000932:	9300      	str	r3, [sp, #0]
20000934:	2300      	movs	r3, #0
20000936:	220a      	movs	r2, #10
20000938:	6d78      	ldr	r0, [r7, #84]	@ 0x54
2000093a:	f7ff fdfb 	bl	20000534 <__atox>
2000093e:	4603      	mov	r3, r0
20000940:	461a      	mov	r2, r3
20000942:	6d7b      	ldr	r3, [r7, #84]	@ 0x54
20000944:	4413      	add	r3, r2
20000946:	657b      	str	r3, [r7, #84]	@ 0x54
		*optr++ = '.';
20000948:	6d7b      	ldr	r3, [r7, #84]	@ 0x54
2000094a:	1c5a      	adds	r2, r3, #1
2000094c:	657a      	str	r2, [r7, #84]	@ 0x54
2000094e:	222e      	movs	r2, #46	@ 0x2e
20000950:	701a      	strb	r2, [r3, #0]
		optr += __atox(optr,*tmpptr++,10,0,digits);
20000952:	6cfb      	ldr	r3, [r7, #76]	@ 0x4c
20000954:	1c5a      	adds	r2, r3, #1
20000956:	64fa      	str	r2, [r7, #76]	@ 0x4c
20000958:	781b      	ldrb	r3, [r3, #0]
2000095a:	4619      	mov	r1, r3
2000095c:	4b79      	ldr	r3, [pc, #484]	@ (20000b44 <xvsprintf+0x4a0>)
2000095e:	9300      	str	r3, [sp, #0]
20000960:	2300      	movs	r3, #0
20000962:	220a      	movs	r2, #10
20000964:	6d78      	ldr	r0, [r7, #84]	@ 0x54
20000966:	f7ff fde5 	bl	20000534 <__atox>
2000096a:	4603      	mov	r3, r0
2000096c:	461a      	mov	r2, r3
2000096e:	6d7b      	ldr	r3, [r7, #84]	@ 0x54
20000970:	4413      	add	r3, r2
20000972:	657b      	str	r3, [r7, #84]	@ 0x54
		break;
20000974:	e1c9      	b.n	20000d0a <xvsprintf+0x666>
	    case 's':
		tmpptr = (unsigned char *) va_arg(marker,unsigned char *);
20000976:	687b      	ldr	r3, [r7, #4]
20000978:	1d1a      	adds	r2, r3, #4
2000097a:	607a      	str	r2, [r7, #4]
2000097c:	681b      	ldr	r3, [r3, #0]
2000097e:	64fb      	str	r3, [r7, #76]	@ 0x4c
		if (!tmpptr) tmpptr = (unsigned char *) "(null)";
20000980:	6cfb      	ldr	r3, [r7, #76]	@ 0x4c
20000982:	2b00      	cmp	r3, #0
20000984:	d101      	bne.n	2000098a <xvsprintf+0x2e6>
20000986:	4b70      	ldr	r3, [pc, #448]	@ (20000b48 <xvsprintf+0x4a4>)
20000988:	64fb      	str	r3, [r7, #76]	@ 0x4c
		if ((width == 0) & (width2 == 0)) {
2000098a:	6b3a      	ldr	r2, [r7, #48]	@ 0x30
2000098c:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
2000098e:	4313      	orrs	r3, r2
20000990:	2b00      	cmp	r3, #0
20000992:	d118      	bne.n	200009c6 <xvsprintf+0x322>
		    while (*tmpptr) *optr++ = *tmpptr++;
20000994:	e007      	b.n	200009a6 <xvsprintf+0x302>
20000996:	6cfa      	ldr	r2, [r7, #76]	@ 0x4c
20000998:	1c53      	adds	r3, r2, #1
2000099a:	64fb      	str	r3, [r7, #76]	@ 0x4c
2000099c:	6d7b      	ldr	r3, [r7, #84]	@ 0x54
2000099e:	1c59      	adds	r1, r3, #1
200009a0:	6579      	str	r1, [r7, #84]	@ 0x54
200009a2:	7812      	ldrb	r2, [r2, #0]
200009a4:	701a      	strb	r2, [r3, #0]
200009a6:	6cfb      	ldr	r3, [r7, #76]	@ 0x4c
200009a8:	781b      	ldrb	r3, [r3, #0]
200009aa:	2b00      	cmp	r3, #0
200009ac:	d1f3      	bne.n	20000996 <xvsprintf+0x2f2>
		    break;
200009ae:	e1ac      	b.n	20000d0a <xvsprintf+0x666>
		    }
		while (width && *tmpptr) {
		    *optr++ = *tmpptr++;
200009b0:	6cfa      	ldr	r2, [r7, #76]	@ 0x4c
200009b2:	1c53      	adds	r3, r2, #1
200009b4:	64fb      	str	r3, [r7, #76]	@ 0x4c
200009b6:	6d7b      	ldr	r3, [r7, #84]	@ 0x54
200009b8:	1c59      	adds	r1, r3, #1
200009ba:	6579      	str	r1, [r7, #84]	@ 0x54
200009bc:	7812      	ldrb	r2, [r2, #0]
200009be:	701a      	strb	r2, [r3, #0]
		    width--;
200009c0:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
200009c2:	3b01      	subs	r3, #1
200009c4:	633b      	str	r3, [r7, #48]	@ 0x30
		while (width && *tmpptr) {
200009c6:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
200009c8:	2b00      	cmp	r3, #0
200009ca:	d00c      	beq.n	200009e6 <xvsprintf+0x342>
200009cc:	6cfb      	ldr	r3, [r7, #76]	@ 0x4c
200009ce:	781b      	ldrb	r3, [r3, #0]
200009d0:	2b00      	cmp	r3, #0
200009d2:	d1ed      	bne.n	200009b0 <xvsprintf+0x30c>
		    }
		while (width) {
200009d4:	e007      	b.n	200009e6 <xvsprintf+0x342>
		    *optr++ = ' ';
200009d6:	6d7b      	ldr	r3, [r7, #84]	@ 0x54
200009d8:	1c5a      	adds	r2, r3, #1
200009da:	657a      	str	r2, [r7, #84]	@ 0x54
200009dc:	2220      	movs	r2, #32
200009de:	701a      	strb	r2, [r3, #0]
		    width--;
200009e0:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
200009e2:	3b01      	subs	r3, #1
200009e4:	633b      	str	r3, [r7, #48]	@ 0x30
		while (width) {
200009e6:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
200009e8:	2b00      	cmp	r3, #0
200009ea:	d1f4      	bne.n	200009d6 <xvsprintf+0x332>
		    }
		break;
200009ec:	e18d      	b.n	20000d0a <xvsprintf+0x666>
	    case 'a':
		tmpptr = (unsigned char *) va_arg(marker,unsigned char *);
200009ee:	687b      	ldr	r3, [r7, #4]
200009f0:	1d1a      	adds	r2, r3, #4
200009f2:	607a      	str	r2, [r7, #4]
200009f4:	681b      	ldr	r3, [r3, #0]
200009f6:	64fb      	str	r3, [r7, #76]	@ 0x4c
		for (x = 0; x < 5; x++) {
200009f8:	2300      	movs	r3, #0
200009fa:	64bb      	str	r3, [r7, #72]	@ 0x48
200009fc:	e018      	b.n	20000a30 <xvsprintf+0x38c>
		    optr += __atox(optr,*tmpptr++,16,2,digits);
200009fe:	6cfb      	ldr	r3, [r7, #76]	@ 0x4c
20000a00:	1c5a      	adds	r2, r3, #1
20000a02:	64fa      	str	r2, [r7, #76]	@ 0x4c
20000a04:	781b      	ldrb	r3, [r3, #0]
20000a06:	4619      	mov	r1, r3
20000a08:	4b4e      	ldr	r3, [pc, #312]	@ (20000b44 <xvsprintf+0x4a0>)
20000a0a:	9300      	str	r3, [sp, #0]
20000a0c:	2302      	movs	r3, #2
20000a0e:	2210      	movs	r2, #16
20000a10:	6d78      	ldr	r0, [r7, #84]	@ 0x54
20000a12:	f7ff fd8f 	bl	20000534 <__atox>
20000a16:	4603      	mov	r3, r0
20000a18:	461a      	mov	r2, r3
20000a1a:	6d7b      	ldr	r3, [r7, #84]	@ 0x54
20000a1c:	4413      	add	r3, r2
20000a1e:	657b      	str	r3, [r7, #84]	@ 0x54
		    *optr++ = '-';
20000a20:	6d7b      	ldr	r3, [r7, #84]	@ 0x54
20000a22:	1c5a      	adds	r2, r3, #1
20000a24:	657a      	str	r2, [r7, #84]	@ 0x54
20000a26:	222d      	movs	r2, #45	@ 0x2d
20000a28:	701a      	strb	r2, [r3, #0]
		for (x = 0; x < 5; x++) {
20000a2a:	6cbb      	ldr	r3, [r7, #72]	@ 0x48
20000a2c:	3301      	adds	r3, #1
20000a2e:	64bb      	str	r3, [r7, #72]	@ 0x48
20000a30:	6cbb      	ldr	r3, [r7, #72]	@ 0x48
20000a32:	2b04      	cmp	r3, #4
20000a34:	dde3      	ble.n	200009fe <xvsprintf+0x35a>
		    }
		optr += __atox(optr,*tmpptr++,16,2,digits);
20000a36:	6cfb      	ldr	r3, [r7, #76]	@ 0x4c
20000a38:	1c5a      	adds	r2, r3, #1
20000a3a:	64fa      	str	r2, [r7, #76]	@ 0x4c
20000a3c:	781b      	ldrb	r3, [r3, #0]
20000a3e:	4619      	mov	r1, r3
20000a40:	4b40      	ldr	r3, [pc, #256]	@ (20000b44 <xvsprintf+0x4a0>)
20000a42:	9300      	str	r3, [sp, #0]
20000a44:	2302      	movs	r3, #2
20000a46:	2210      	movs	r2, #16
20000a48:	6d78      	ldr	r0, [r7, #84]	@ 0x54
20000a4a:	f7ff fd73 	bl	20000534 <__atox>
20000a4e:	4603      	mov	r3, r0
20000a50:	461a      	mov	r2, r3
20000a52:	6d7b      	ldr	r3, [r7, #84]	@ 0x54
20000a54:	4413      	add	r3, r2
20000a56:	657b      	str	r3, [r7, #84]	@ 0x54
		break;
20000a58:	e157      	b.n	20000d0a <xvsprintf+0x666>
20000a5a:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
20000a5c:	2b01      	cmp	r3, #1
20000a5e:	dc03      	bgt.n	20000a68 <xvsprintf+0x3c4>
20000a60:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
20000a62:	2b00      	cmp	r3, #0
20000a64:	da04      	bge.n	20000a70 <xvsprintf+0x3cc>
			ll = va_arg(marker,long long int);
			if (ll < 0) { *optr++='-'; ll = -ll;}
			optr += __llatox(optr,ll,10,width,digits);
			break;
		    }
		break;
20000a66:	e150      	b.n	20000d0a <xvsprintf+0x666>
20000a68:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
20000a6a:	2b02      	cmp	r3, #2
20000a6c:	d01e      	beq.n	20000aac <xvsprintf+0x408>
20000a6e:	e14c      	b.n	20000d0a <xvsprintf+0x666>
			i = va_arg(marker,int);
20000a70:	687b      	ldr	r3, [r7, #4]
20000a72:	1d1a      	adds	r2, r3, #4
20000a74:	607a      	str	r2, [r7, #4]
20000a76:	681b      	ldr	r3, [r3, #0]
20000a78:	647b      	str	r3, [r7, #68]	@ 0x44
			if (i < 0) { *optr++='-'; i = -i;}
20000a7a:	6c7b      	ldr	r3, [r7, #68]	@ 0x44
20000a7c:	2b00      	cmp	r3, #0
20000a7e:	da07      	bge.n	20000a90 <xvsprintf+0x3ec>
20000a80:	6d7b      	ldr	r3, [r7, #84]	@ 0x54
20000a82:	1c5a      	adds	r2, r3, #1
20000a84:	657a      	str	r2, [r7, #84]	@ 0x54
20000a86:	222d      	movs	r2, #45	@ 0x2d
20000a88:	701a      	strb	r2, [r3, #0]
20000a8a:	6c7b      	ldr	r3, [r7, #68]	@ 0x44
20000a8c:	425b      	negs	r3, r3
20000a8e:	647b      	str	r3, [r7, #68]	@ 0x44
			optr += __atox(optr,i,10,width,digits);
20000a90:	6c79      	ldr	r1, [r7, #68]	@ 0x44
20000a92:	4b2c      	ldr	r3, [pc, #176]	@ (20000b44 <xvsprintf+0x4a0>)
20000a94:	9300      	str	r3, [sp, #0]
20000a96:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
20000a98:	220a      	movs	r2, #10
20000a9a:	6d78      	ldr	r0, [r7, #84]	@ 0x54
20000a9c:	f7ff fd4a 	bl	20000534 <__atox>
20000aa0:	4603      	mov	r3, r0
20000aa2:	461a      	mov	r2, r3
20000aa4:	6d7b      	ldr	r3, [r7, #84]	@ 0x54
20000aa6:	4413      	add	r3, r2
20000aa8:	657b      	str	r3, [r7, #84]	@ 0x54
			break;
20000aaa:	e02c      	b.n	20000b06 <xvsprintf+0x462>
			ll = va_arg(marker,long long int);
20000aac:	687b      	ldr	r3, [r7, #4]
20000aae:	3307      	adds	r3, #7
20000ab0:	f023 0307 	bic.w	r3, r3, #7
20000ab4:	f103 0208 	add.w	r2, r3, #8
20000ab8:	607a      	str	r2, [r7, #4]
20000aba:	e9d3 2300 	ldrd	r2, r3, [r3]
20000abe:	e9c7 230e 	strd	r2, r3, [r7, #56]	@ 0x38
			if (ll < 0) { *optr++='-'; ll = -ll;}
20000ac2:	e9d7 230e 	ldrd	r2, r3, [r7, #56]	@ 0x38
20000ac6:	2b00      	cmp	r3, #0
20000ac8:	da0c      	bge.n	20000ae4 <xvsprintf+0x440>
20000aca:	6d7b      	ldr	r3, [r7, #84]	@ 0x54
20000acc:	1c5a      	adds	r2, r3, #1
20000ace:	657a      	str	r2, [r7, #84]	@ 0x54
20000ad0:	222d      	movs	r2, #45	@ 0x2d
20000ad2:	701a      	strb	r2, [r3, #0]
20000ad4:	e9d7 230e 	ldrd	r2, r3, [r7, #56]	@ 0x38
20000ad8:	2100      	movs	r1, #0
20000ada:	4254      	negs	r4, r2
20000adc:	eb61 0503 	sbc.w	r5, r1, r3
20000ae0:	e9c7 450e 	strd	r4, r5, [r7, #56]	@ 0x38
			optr += __llatox(optr,ll,10,width,digits);
20000ae4:	e9d7 230e 	ldrd	r2, r3, [r7, #56]	@ 0x38
20000ae8:	4916      	ldr	r1, [pc, #88]	@ (20000b44 <xvsprintf+0x4a0>)
20000aea:	9102      	str	r1, [sp, #8]
20000aec:	6b39      	ldr	r1, [r7, #48]	@ 0x30
20000aee:	9101      	str	r1, [sp, #4]
20000af0:	210a      	movs	r1, #10
20000af2:	9100      	str	r1, [sp, #0]
20000af4:	6d78      	ldr	r0, [r7, #84]	@ 0x54
20000af6:	f7ff fd73 	bl	200005e0 <__llatox>
20000afa:	4603      	mov	r3, r0
20000afc:	461a      	mov	r2, r3
20000afe:	6d7b      	ldr	r3, [r7, #84]	@ 0x54
20000b00:	4413      	add	r3, r2
20000b02:	657b      	str	r3, [r7, #84]	@ 0x54
			break;
20000b04:	bf00      	nop
		break;
20000b06:	e100      	b.n	20000d0a <xvsprintf+0x666>
20000b08:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
20000b0a:	2b01      	cmp	r3, #1
20000b0c:	dc03      	bgt.n	20000b16 <xvsprintf+0x472>
20000b0e:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
20000b10:	2b00      	cmp	r3, #0
20000b12:	da04      	bge.n	20000b1e <xvsprintf+0x47a>
		    case 2:
			ulx = va_arg(marker,unsigned long long);
			optr += __llatox(optr,ulx,10,width,digits);
			break;
		    }
		break;
20000b14:	e0f9      	b.n	20000d0a <xvsprintf+0x666>
20000b16:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
20000b18:	2b02      	cmp	r3, #2
20000b1a:	d017      	beq.n	20000b4c <xvsprintf+0x4a8>
20000b1c:	e0f5      	b.n	20000d0a <xvsprintf+0x666>
			ux = va_arg(marker,unsigned int);
20000b1e:	687b      	ldr	r3, [r7, #4]
20000b20:	1d1a      	adds	r2, r3, #4
20000b22:	607a      	str	r2, [r7, #4]
20000b24:	681b      	ldr	r3, [r3, #0]
20000b26:	617b      	str	r3, [r7, #20]
			optr += __atox(optr,ux,10,width,digits);
20000b28:	4b06      	ldr	r3, [pc, #24]	@ (20000b44 <xvsprintf+0x4a0>)
20000b2a:	9300      	str	r3, [sp, #0]
20000b2c:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
20000b2e:	220a      	movs	r2, #10
20000b30:	6979      	ldr	r1, [r7, #20]
20000b32:	6d78      	ldr	r0, [r7, #84]	@ 0x54
20000b34:	f7ff fcfe 	bl	20000534 <__atox>
20000b38:	4603      	mov	r3, r0
20000b3a:	461a      	mov	r2, r3
20000b3c:	6d7b      	ldr	r3, [r7, #84]	@ 0x54
20000b3e:	4413      	add	r3, r2
20000b40:	657b      	str	r3, [r7, #84]	@ 0x54
			break;
20000b42:	e01f      	b.n	20000b84 <xvsprintf+0x4e0>
20000b44:	20008e88 	.word	0x20008e88
20000b48:	20007648 	.word	0x20007648
			ulx = va_arg(marker,unsigned long long);
20000b4c:	687b      	ldr	r3, [r7, #4]
20000b4e:	3307      	adds	r3, #7
20000b50:	f023 0307 	bic.w	r3, r3, #7
20000b54:	f103 0208 	add.w	r2, r3, #8
20000b58:	607a      	str	r2, [r7, #4]
20000b5a:	e9d3 2300 	ldrd	r2, r3, [r3]
20000b5e:	e9c7 2306 	strd	r2, r3, [r7, #24]
			optr += __llatox(optr,ulx,10,width,digits);
20000b62:	4b73      	ldr	r3, [pc, #460]	@ (20000d30 <xvsprintf+0x68c>)
20000b64:	9302      	str	r3, [sp, #8]
20000b66:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
20000b68:	9301      	str	r3, [sp, #4]
20000b6a:	230a      	movs	r3, #10
20000b6c:	9300      	str	r3, [sp, #0]
20000b6e:	e9d7 2306 	ldrd	r2, r3, [r7, #24]
20000b72:	6d78      	ldr	r0, [r7, #84]	@ 0x54
20000b74:	f7ff fd34 	bl	200005e0 <__llatox>
20000b78:	4603      	mov	r3, r0
20000b7a:	461a      	mov	r2, r3
20000b7c:	6d7b      	ldr	r3, [r7, #84]	@ 0x54
20000b7e:	4413      	add	r3, r2
20000b80:	657b      	str	r3, [r7, #84]	@ 0x54
			break;
20000b82:	bf00      	nop
		break;
20000b84:	e0c1      	b.n	20000d0a <xvsprintf+0x666>
20000b86:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
20000b88:	2b01      	cmp	r3, #1
20000b8a:	dc03      	bgt.n	20000b94 <xvsprintf+0x4f0>
20000b8c:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
20000b8e:	2b00      	cmp	r3, #0
20000b90:	da04      	bge.n	20000b9c <xvsprintf+0x4f8>
			ulx = va_arg(marker,unsigned long long);
			optr += __llatox(optr,ulx,16,width,
				       (*iptr == 'X') ? digits : ldigits);
			break;
		    }
		break;
20000b92:	e0ba      	b.n	20000d0a <xvsprintf+0x666>
20000b94:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
20000b96:	2b02      	cmp	r3, #2
20000b98:	d019      	beq.n	20000bce <xvsprintf+0x52a>
20000b9a:	e0b6      	b.n	20000d0a <xvsprintf+0x666>
			ux = va_arg(marker,unsigned int);
20000b9c:	687b      	ldr	r3, [r7, #4]
20000b9e:	1d1a      	adds	r2, r3, #4
20000ba0:	607a      	str	r2, [r7, #4]
20000ba2:	681b      	ldr	r3, [r3, #0]
20000ba4:	617b      	str	r3, [r7, #20]
				       (*iptr == 'X') ? digits : ldigits);
20000ba6:	6d3b      	ldr	r3, [r7, #80]	@ 0x50
20000ba8:	781b      	ldrb	r3, [r3, #0]
			optr += __atox(optr,ux,16,width,
20000baa:	2b58      	cmp	r3, #88	@ 0x58
20000bac:	d101      	bne.n	20000bb2 <xvsprintf+0x50e>
20000bae:	4b60      	ldr	r3, [pc, #384]	@ (20000d30 <xvsprintf+0x68c>)
20000bb0:	e000      	b.n	20000bb4 <xvsprintf+0x510>
20000bb2:	4b60      	ldr	r3, [pc, #384]	@ (20000d34 <xvsprintf+0x690>)
20000bb4:	9300      	str	r3, [sp, #0]
20000bb6:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
20000bb8:	2210      	movs	r2, #16
20000bba:	6979      	ldr	r1, [r7, #20]
20000bbc:	6d78      	ldr	r0, [r7, #84]	@ 0x54
20000bbe:	f7ff fcb9 	bl	20000534 <__atox>
20000bc2:	4603      	mov	r3, r0
20000bc4:	461a      	mov	r2, r3
20000bc6:	6d7b      	ldr	r3, [r7, #84]	@ 0x54
20000bc8:	4413      	add	r3, r2
20000bca:	657b      	str	r3, [r7, #84]	@ 0x54
			break;
20000bcc:	e021      	b.n	20000c12 <xvsprintf+0x56e>
			ulx = va_arg(marker,unsigned long long);
20000bce:	687b      	ldr	r3, [r7, #4]
20000bd0:	3307      	adds	r3, #7
20000bd2:	f023 0307 	bic.w	r3, r3, #7
20000bd6:	f103 0208 	add.w	r2, r3, #8
20000bda:	607a      	str	r2, [r7, #4]
20000bdc:	e9d3 2300 	ldrd	r2, r3, [r3]
20000be0:	e9c7 2306 	strd	r2, r3, [r7, #24]
				       (*iptr == 'X') ? digits : ldigits);
20000be4:	6d3b      	ldr	r3, [r7, #80]	@ 0x50
20000be6:	781b      	ldrb	r3, [r3, #0]
			optr += __llatox(optr,ulx,16,width,
20000be8:	2b58      	cmp	r3, #88	@ 0x58
20000bea:	d101      	bne.n	20000bf0 <xvsprintf+0x54c>
20000bec:	4b50      	ldr	r3, [pc, #320]	@ (20000d30 <xvsprintf+0x68c>)
20000bee:	e000      	b.n	20000bf2 <xvsprintf+0x54e>
20000bf0:	4b50      	ldr	r3, [pc, #320]	@ (20000d34 <xvsprintf+0x690>)
20000bf2:	9302      	str	r3, [sp, #8]
20000bf4:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
20000bf6:	9301      	str	r3, [sp, #4]
20000bf8:	2310      	movs	r3, #16
20000bfa:	9300      	str	r3, [sp, #0]
20000bfc:	e9d7 2306 	ldrd	r2, r3, [r7, #24]
20000c00:	6d78      	ldr	r0, [r7, #84]	@ 0x54
20000c02:	f7ff fced 	bl	200005e0 <__llatox>
20000c06:	4603      	mov	r3, r0
20000c08:	461a      	mov	r2, r3
20000c0a:	6d7b      	ldr	r3, [r7, #84]	@ 0x54
20000c0c:	4413      	add	r3, r2
20000c0e:	657b      	str	r3, [r7, #84]	@ 0x54
			break;
20000c10:	bf00      	nop
		break;
20000c12:	e07a      	b.n	20000d0a <xvsprintf+0x666>
#ifdef __long64
		lx = va_arg(marker,long long);
		optr += __llatox(optr,lx,16,16,
				 (*iptr == 'P') ? digits : ldigits);
#else
		x = va_arg(marker,long);
20000c14:	687b      	ldr	r3, [r7, #4]
20000c16:	1d1a      	adds	r2, r3, #4
20000c18:	607a      	str	r2, [r7, #4]
20000c1a:	681b      	ldr	r3, [r3, #0]
20000c1c:	64bb      	str	r3, [r7, #72]	@ 0x48
		optr += __atox(optr,x,16,8,
20000c1e:	6cb9      	ldr	r1, [r7, #72]	@ 0x48
			       (*iptr == 'P') ? digits : ldigits);
20000c20:	6d3b      	ldr	r3, [r7, #80]	@ 0x50
20000c22:	781b      	ldrb	r3, [r3, #0]
		optr += __atox(optr,x,16,8,
20000c24:	2b50      	cmp	r3, #80	@ 0x50
20000c26:	d101      	bne.n	20000c2c <xvsprintf+0x588>
20000c28:	4b41      	ldr	r3, [pc, #260]	@ (20000d30 <xvsprintf+0x68c>)
20000c2a:	e000      	b.n	20000c2e <xvsprintf+0x58a>
20000c2c:	4b41      	ldr	r3, [pc, #260]	@ (20000d34 <xvsprintf+0x690>)
20000c2e:	9300      	str	r3, [sp, #0]
20000c30:	2308      	movs	r3, #8
20000c32:	2210      	movs	r2, #16
20000c34:	6d78      	ldr	r0, [r7, #84]	@ 0x54
20000c36:	f7ff fc7d 	bl	20000534 <__atox>
20000c3a:	4603      	mov	r3, r0
20000c3c:	461a      	mov	r2, r3
20000c3e:	6d7b      	ldr	r3, [r7, #84]	@ 0x54
20000c40:	4413      	add	r3, r2
20000c42:	657b      	str	r3, [r7, #84]	@ 0x54
#endif
		break;
20000c44:	e061      	b.n	20000d0a <xvsprintf+0x666>
	    case 'w':
		x = va_arg(marker,unsigned int);
20000c46:	687b      	ldr	r3, [r7, #4]
20000c48:	1d1a      	adds	r2, r3, #4
20000c4a:	607a      	str	r2, [r7, #4]
20000c4c:	681b      	ldr	r3, [r3, #0]
20000c4e:	64bb      	str	r3, [r7, #72]	@ 0x48
	        x &= 0x0000FFFF;
20000c50:	6cbb      	ldr	r3, [r7, #72]	@ 0x48
20000c52:	b29b      	uxth	r3, r3
20000c54:	64bb      	str	r3, [r7, #72]	@ 0x48
		optr += __atox(optr,x,16,4,digits);
20000c56:	6cb9      	ldr	r1, [r7, #72]	@ 0x48
20000c58:	4b35      	ldr	r3, [pc, #212]	@ (20000d30 <xvsprintf+0x68c>)
20000c5a:	9300      	str	r3, [sp, #0]
20000c5c:	2304      	movs	r3, #4
20000c5e:	2210      	movs	r2, #16
20000c60:	6d78      	ldr	r0, [r7, #84]	@ 0x54
20000c62:	f7ff fc67 	bl	20000534 <__atox>
20000c66:	4603      	mov	r3, r0
20000c68:	461a      	mov	r2, r3
20000c6a:	6d7b      	ldr	r3, [r7, #84]	@ 0x54
20000c6c:	4413      	add	r3, r2
20000c6e:	657b      	str	r3, [r7, #84]	@ 0x54
		break;
20000c70:	e04b      	b.n	20000d0a <xvsprintf+0x666>
	    case 'b':
		x = va_arg(marker,unsigned int);
20000c72:	687b      	ldr	r3, [r7, #4]
20000c74:	1d1a      	adds	r2, r3, #4
20000c76:	607a      	str	r2, [r7, #4]
20000c78:	681b      	ldr	r3, [r3, #0]
20000c7a:	64bb      	str	r3, [r7, #72]	@ 0x48
	        x &= 0x0000FF;
20000c7c:	6cbb      	ldr	r3, [r7, #72]	@ 0x48
20000c7e:	b2db      	uxtb	r3, r3
20000c80:	64bb      	str	r3, [r7, #72]	@ 0x48
		optr += __atox(optr,x,16,2,digits);
20000c82:	6cb9      	ldr	r1, [r7, #72]	@ 0x48
20000c84:	4b2a      	ldr	r3, [pc, #168]	@ (20000d30 <xvsprintf+0x68c>)
20000c86:	9300      	str	r3, [sp, #0]
20000c88:	2302      	movs	r3, #2
20000c8a:	2210      	movs	r2, #16
20000c8c:	6d78      	ldr	r0, [r7, #84]	@ 0x54
20000c8e:	f7ff fc51 	bl	20000534 <__atox>
20000c92:	4603      	mov	r3, r0
20000c94:	461a      	mov	r2, r3
20000c96:	6d7b      	ldr	r3, [r7, #84]	@ 0x54
20000c98:	4413      	add	r3, r2
20000c9a:	657b      	str	r3, [r7, #84]	@ 0x54
		break;
20000c9c:	e035      	b.n	20000d0a <xvsprintf+0x666>
	    case 'Z':
		x = va_arg(marker,unsigned int);
20000c9e:	687b      	ldr	r3, [r7, #4]
20000ca0:	1d1a      	adds	r2, r3, #4
20000ca2:	607a      	str	r2, [r7, #4]
20000ca4:	681b      	ldr	r3, [r3, #0]
20000ca6:	64bb      	str	r3, [r7, #72]	@ 0x48
		tmpptr = va_arg(marker,unsigned char *);
20000ca8:	687b      	ldr	r3, [r7, #4]
20000caa:	1d1a      	adds	r2, r3, #4
20000cac:	607a      	str	r2, [r7, #4]
20000cae:	681b      	ldr	r3, [r3, #0]
20000cb0:	64fb      	str	r3, [r7, #76]	@ 0x4c
		while (x) {
20000cb2:	e013      	b.n	20000cdc <xvsprintf+0x638>
		    optr += __atox(optr,*tmpptr++,16,2,digits);
20000cb4:	6cfb      	ldr	r3, [r7, #76]	@ 0x4c
20000cb6:	1c5a      	adds	r2, r3, #1
20000cb8:	64fa      	str	r2, [r7, #76]	@ 0x4c
20000cba:	781b      	ldrb	r3, [r3, #0]
20000cbc:	4619      	mov	r1, r3
20000cbe:	4b1c      	ldr	r3, [pc, #112]	@ (20000d30 <xvsprintf+0x68c>)
20000cc0:	9300      	str	r3, [sp, #0]
20000cc2:	2302      	movs	r3, #2
20000cc4:	2210      	movs	r2, #16
20000cc6:	6d78      	ldr	r0, [r7, #84]	@ 0x54
20000cc8:	f7ff fc34 	bl	20000534 <__atox>
20000ccc:	4603      	mov	r3, r0
20000cce:	461a      	mov	r2, r3
20000cd0:	6d7b      	ldr	r3, [r7, #84]	@ 0x54
20000cd2:	4413      	add	r3, r2
20000cd4:	657b      	str	r3, [r7, #84]	@ 0x54
		    x--;
20000cd6:	6cbb      	ldr	r3, [r7, #72]	@ 0x48
20000cd8:	3b01      	subs	r3, #1
20000cda:	64bb      	str	r3, [r7, #72]	@ 0x48
		while (x) {
20000cdc:	6cbb      	ldr	r3, [r7, #72]	@ 0x48
20000cde:	2b00      	cmp	r3, #0
20000ce0:	d1e8      	bne.n	20000cb4 <xvsprintf+0x610>
		    }
		break;
20000ce2:	e012      	b.n	20000d0a <xvsprintf+0x666>
	    case 'c':
		x = va_arg(marker, int);
20000ce4:	687b      	ldr	r3, [r7, #4]
20000ce6:	1d1a      	adds	r2, r3, #4
20000ce8:	607a      	str	r2, [r7, #4]
20000cea:	681b      	ldr	r3, [r3, #0]
20000cec:	64bb      	str	r3, [r7, #72]	@ 0x48
		*optr++ = x & 0xff;
20000cee:	6d7b      	ldr	r3, [r7, #84]	@ 0x54
20000cf0:	1c5a      	adds	r2, r3, #1
20000cf2:	657a      	str	r2, [r7, #84]	@ 0x54
20000cf4:	6cba      	ldr	r2, [r7, #72]	@ 0x48
20000cf6:	b2d2      	uxtb	r2, r2
20000cf8:	701a      	strb	r2, [r3, #0]
		break;
20000cfa:	e006      	b.n	20000d0a <xvsprintf+0x666>

	    default:
		*optr++ = *iptr;
20000cfc:	6d7b      	ldr	r3, [r7, #84]	@ 0x54
20000cfe:	1c5a      	adds	r2, r3, #1
20000d00:	657a      	str	r2, [r7, #84]	@ 0x54
20000d02:	6d3a      	ldr	r2, [r7, #80]	@ 0x50
20000d04:	7812      	ldrb	r2, [r2, #0]
20000d06:	701a      	strb	r2, [r3, #0]
		break;
20000d08:	bf00      	nop
	    }
	iptr++;
20000d0a:	6d3b      	ldr	r3, [r7, #80]	@ 0x50
20000d0c:	3301      	adds	r3, #1
20000d0e:	653b      	str	r3, [r7, #80]	@ 0x50
    while (*iptr) {
20000d10:	6d3b      	ldr	r3, [r7, #80]	@ 0x50
20000d12:	781b      	ldrb	r3, [r3, #0]
20000d14:	2b00      	cmp	r3, #0
20000d16:	f47f acd4 	bne.w	200006c2 <xvsprintf+0x1e>
	}

 //   *optr++ = '\r';
 //   *optr++ = '\n';
    *optr = '\0';
20000d1a:	6d7b      	ldr	r3, [r7, #84]	@ 0x54
20000d1c:	2200      	movs	r2, #0
20000d1e:	701a      	strb	r2, [r3, #0]

    return (optr - outbuf);
20000d20:	6d7a      	ldr	r2, [r7, #84]	@ 0x54
20000d22:	68fb      	ldr	r3, [r7, #12]
20000d24:	1ad3      	subs	r3, r2, r3
}
20000d26:	4618      	mov	r0, r3
20000d28:	3758      	adds	r7, #88	@ 0x58
20000d2a:	46bd      	mov	sp, r7
20000d2c:	bdb0      	pop	{r4, r5, r7, pc}
20000d2e:	bf00      	nop
20000d30:	20008e88 	.word	0x20008e88
20000d34:	20008e9c 	.word	0x20008e9c

20000d38 <xsprintf>:
    *
    *  Return Value:
    *      number of bytes copied to buffer
    ********************************************************************* */
int xsprintf(char *buf,const char *templat,...)
{
20000d38:	b40e      	push	{r1, r2, r3}
20000d3a:	b580      	push	{r7, lr}
20000d3c:	b085      	sub	sp, #20
20000d3e:	af00      	add	r7, sp, #0
20000d40:	6078      	str	r0, [r7, #4]
    va_list marker;
    int count;

    va_start(marker,templat);
20000d42:	f107 0320 	add.w	r3, r7, #32
20000d46:	60bb      	str	r3, [r7, #8]
    count = xvsprintf(buf,templat,marker);
20000d48:	68ba      	ldr	r2, [r7, #8]
20000d4a:	69f9      	ldr	r1, [r7, #28]
20000d4c:	6878      	ldr	r0, [r7, #4]
20000d4e:	f7ff fca9 	bl	200006a4 <xvsprintf>
20000d52:	60f8      	str	r0, [r7, #12]
    va_end(marker);

    return count;
20000d54:	68fb      	ldr	r3, [r7, #12]
}
20000d56:	4618      	mov	r0, r3
20000d58:	3714      	adds	r7, #20
20000d5a:	46bd      	mov	sp, r7
20000d5c:	e8bd 4080 	ldmia.w	sp!, {r7, lr}
20000d60:	b003      	add	sp, #12
20000d62:	4770      	bx	lr

20000d64 <printf>:
    *  Return value:
    *  	   number of bytes written
    ********************************************************************* */

int printf(const char *templat,...)
{
20000d64:	b40f      	push	{r0, r1, r2, r3}
20000d66:	b580      	push	{r7, lr}
20000d68:	f5ad 7d04 	sub.w	sp, sp, #528	@ 0x210
20000d6c:	af00      	add	r7, sp, #0
    va_list marker;
    int count;
    char buffer[512];

    va_start(marker,templat);
20000d6e:	f507 7307 	add.w	r3, r7, #540	@ 0x21c
20000d72:	f8c7 3204 	str.w	r3, [r7, #516]	@ 0x204
    count = xvsprintf(buffer,templat,marker);
20000d76:	1d3b      	adds	r3, r7, #4
20000d78:	f8d7 2204 	ldr.w	r2, [r7, #516]	@ 0x204
20000d7c:	f8d7 1218 	ldr.w	r1, [r7, #536]	@ 0x218
20000d80:	4618      	mov	r0, r3
20000d82:	f7ff fc8f 	bl	200006a4 <xvsprintf>
20000d86:	f8c7 0208 	str.w	r0, [r7, #520]	@ 0x208
    va_end(marker);


    for(int i = 0; i< count; i++){
20000d8a:	2300      	movs	r3, #0
20000d8c:	f8c7 320c 	str.w	r3, [r7, #524]	@ 0x20c
20000d90:	e00f      	b.n	20000db2 <printf+0x4e>
    	putc(buffer[i]);
20000d92:	f507 7304 	add.w	r3, r7, #528	@ 0x210
20000d96:	f5a3 7203 	sub.w	r2, r3, #524	@ 0x20c
20000d9a:	f8d7 320c 	ldr.w	r3, [r7, #524]	@ 0x20c
20000d9e:	4413      	add	r3, r2
20000da0:	781b      	ldrb	r3, [r3, #0]
20000da2:	4618      	mov	r0, r3
20000da4:	f000 f816 	bl	20000dd4 <putc>
    for(int i = 0; i< count; i++){
20000da8:	f8d7 320c 	ldr.w	r3, [r7, #524]	@ 0x20c
20000dac:	3301      	adds	r3, #1
20000dae:	f8c7 320c 	str.w	r3, [r7, #524]	@ 0x20c
20000db2:	f8d7 220c 	ldr.w	r2, [r7, #524]	@ 0x20c
20000db6:	f8d7 3208 	ldr.w	r3, [r7, #520]	@ 0x208
20000dba:	429a      	cmp	r2, r3
20000dbc:	dbe9      	blt.n	20000d92 <printf+0x2e>
    }

    //putc('\r');
    //putc('\n');

    return count;
20000dbe:	f8d7 3208 	ldr.w	r3, [r7, #520]	@ 0x208
}
20000dc2:	4618      	mov	r0, r3
20000dc4:	f507 7704 	add.w	r7, r7, #528	@ 0x210
20000dc8:	46bd      	mov	sp, r7
20000dca:	e8bd 4080 	ldmia.w	sp!, {r7, lr}
20000dce:	b004      	add	sp, #16
20000dd0:	4770      	bx	lr
	...

20000dd4 <putc>:
	for(int i = 0; i< strlen(str); i++)
		putc(*str++);
}


void putc(char c) {
20000dd4:	b480      	push	{r7}
20000dd6:	b085      	sub	sp, #20
20000dd8:	af00      	add	r7, sp, #0
20000dda:	4603      	mov	r3, r0
20000ddc:	71fb      	strb	r3, [r7, #7]
    volatile uint32_t *usart_isr = (volatile uint32_t *)(0x40013800 + 0x1C);
20000dde:	4b10      	ldr	r3, [pc, #64]	@ (20000e20 <putc+0x4c>)
20000de0:	60fb      	str	r3, [r7, #12]
    volatile uint32_t *usart_tdr = (volatile uint32_t *)(0x40013800 + 0x28);
20000de2:	4b10      	ldr	r3, [pc, #64]	@ (20000e24 <putc+0x50>)
20000de4:	60bb      	str	r3, [r7, #8]

    if (c == '\n'){
20000de6:	79fb      	ldrb	r3, [r7, #7]
20000de8:	2b0a      	cmp	r3, #10
20000dea:	d109      	bne.n	20000e00 <putc+0x2c>

		 while((*usart_isr & (1 << 7)) == 0);
20000dec:	bf00      	nop
20000dee:	68fb      	ldr	r3, [r7, #12]
20000df0:	681b      	ldr	r3, [r3, #0]
20000df2:	f003 0380 	and.w	r3, r3, #128	@ 0x80
20000df6:	2b00      	cmp	r3, #0
20000df8:	d0f9      	beq.n	20000dee <putc+0x1a>
		 *usart_tdr = '\r';
20000dfa:	68bb      	ldr	r3, [r7, #8]
20000dfc:	220d      	movs	r2, #13
20000dfe:	601a      	str	r2, [r3, #0]
    }

    while((*usart_isr & (1 << 7)) == 0);
20000e00:	bf00      	nop
20000e02:	68fb      	ldr	r3, [r7, #12]
20000e04:	681b      	ldr	r3, [r3, #0]
20000e06:	f003 0380 	and.w	r3, r3, #128	@ 0x80
20000e0a:	2b00      	cmp	r3, #0
20000e0c:	d0f9      	beq.n	20000e02 <putc+0x2e>



    *usart_tdr = c;
20000e0e:	79fa      	ldrb	r2, [r7, #7]
20000e10:	68bb      	ldr	r3, [r7, #8]
20000e12:	601a      	str	r2, [r3, #0]
}
20000e14:	bf00      	nop
20000e16:	3714      	adds	r7, #20
20000e18:	46bd      	mov	sp, r7
20000e1a:	f85d 7b04 	ldr.w	r7, [sp], #4
20000e1e:	4770      	bx	lr
20000e20:	4001381c 	.word	0x4001381c
20000e24:	40013828 	.word	0x40013828

20000e28 <putchar>:

void puts(const char *templat,...) {
    printf(templat);
}

void putchar(char c) {
20000e28:	b580      	push	{r7, lr}
20000e2a:	b082      	sub	sp, #8
20000e2c:	af00      	add	r7, sp, #0
20000e2e:	4603      	mov	r3, r0
20000e30:	71fb      	strb	r3, [r7, #7]
	putc(c);
20000e32:	79fb      	ldrb	r3, [r7, #7]
20000e34:	4618      	mov	r0, r3
20000e36:	f7ff ffcd 	bl	20000dd4 <putc>
}
20000e3a:	bf00      	nop
20000e3c:	3708      	adds	r7, #8
20000e3e:	46bd      	mov	sp, r7
20000e40:	bd80      	pop	{r7, pc}

20000e42 <stm32_uart_probe>:

static void
stm32_uart_probe(cfe_driver_t *drv,
		    unsigned long probe_a, unsigned long probe_b,
		    void *probe_ptr)
{
20000e42:	b580      	push	{r7, lr}
20000e44:	b084      	sub	sp, #16
20000e46:	af00      	add	r7, sp, #0
20000e48:	60f8      	str	r0, [r7, #12]
20000e4a:	60b9      	str	r1, [r7, #8]
20000e4c:	607a      	str	r2, [r7, #4]
20000e4e:	603b      	str	r3, [r7, #0]
    cfe_attach(drv, NULL, NULL, NULL);
20000e50:	2300      	movs	r3, #0
20000e52:	2200      	movs	r2, #0
20000e54:	2100      	movs	r1, #0
20000e56:	68f8      	ldr	r0, [r7, #12]
20000e58:	f000 fe76 	bl	20001b48 <cfe_attach>
}
20000e5c:	bf00      	nop
20000e5e:	3710      	adds	r7, #16
20000e60:	46bd      	mov	sp, r7
20000e62:	bd80      	pop	{r7, pc}

20000e64 <stm32_uart_open>:

static int
stm32_uart_open(cfe_devctx_t *ctx) {
20000e64:	b480      	push	{r7}
20000e66:	b083      	sub	sp, #12
20000e68:	af00      	add	r7, sp, #0
20000e6a:	6078      	str	r0, [r7, #4]

   return 0;
20000e6c:	2300      	movs	r3, #0
}
20000e6e:	4618      	mov	r0, r3
20000e70:	370c      	adds	r7, #12
20000e72:	46bd      	mov	sp, r7
20000e74:	f85d 7b04 	ldr.w	r7, [sp], #4
20000e78:	4770      	bx	lr
	...

20000e7c <stm32_uart_read>:


static int
stm32_uart_read(cfe_devctx_t *ctx, iocb_buffer_t *buffer)
{
20000e7c:	b480      	push	{r7}
20000e7e:	b089      	sub	sp, #36	@ 0x24
20000e80:	af00      	add	r7, sp, #0
20000e82:	6078      	str	r0, [r7, #4]
20000e84:	6039      	str	r1, [r7, #0]
    volatile uint32_t *LPUART_ISR = (uint32_t *)(0x40013800 + 0x1C);
20000e86:	4b15      	ldr	r3, [pc, #84]	@ (20000edc <stm32_uart_read+0x60>)
20000e88:	61bb      	str	r3, [r7, #24]
    volatile uint32_t *LPUART_RDR = (uint32_t *)(0x40013800 + 0x24);
20000e8a:	4b15      	ldr	r3, [pc, #84]	@ (20000ee0 <stm32_uart_read+0x64>)
20000e8c:	617b      	str	r3, [r7, #20]
    char *ptr = buffer->buf_ptr;
20000e8e:	683b      	ldr	r3, [r7, #0]
20000e90:	689b      	ldr	r3, [r3, #8]
20000e92:	613b      	str	r3, [r7, #16]
    uint32_t len = buffer->buf_length;
20000e94:	683b      	ldr	r3, [r7, #0]
20000e96:	68db      	ldr	r3, [r3, #12]
20000e98:	61fb      	str	r3, [r7, #28]
    uint32_t read_len = 0;
20000e9a:	2300      	movs	r3, #0
20000e9c:	60fb      	str	r3, [r7, #12]

    while (len > 0)
20000e9e:	e00d      	b.n	20000ebc <stm32_uart_read+0x40>
    {
        if (*LPUART_ISR & (1 << 5) )
20000ea0:	69bb      	ldr	r3, [r7, #24]
20000ea2:	681b      	ldr	r3, [r3, #0]
20000ea4:	f003 0320 	and.w	r3, r3, #32
20000ea8:	2b00      	cmp	r3, #0
20000eaa:	d00b      	beq.n	20000ec4 <stm32_uart_read+0x48>
        {
        	*ptr = (*LPUART_RDR);
20000eac:	697b      	ldr	r3, [r7, #20]
20000eae:	681b      	ldr	r3, [r3, #0]
20000eb0:	b2da      	uxtb	r2, r3
20000eb2:	693b      	ldr	r3, [r7, #16]
20000eb4:	701a      	strb	r2, [r3, #0]
        	len--;
20000eb6:	69fb      	ldr	r3, [r7, #28]
20000eb8:	3b01      	subs	r3, #1
20000eba:	61fb      	str	r3, [r7, #28]
    while (len > 0)
20000ebc:	69fb      	ldr	r3, [r7, #28]
20000ebe:	2b00      	cmp	r3, #0
20000ec0:	d1ee      	bne.n	20000ea0 <stm32_uart_read+0x24>
20000ec2:	e000      	b.n	20000ec6 <stm32_uart_read+0x4a>

        }
        else
        {
            break;
20000ec4:	bf00      	nop
        }
    }
    buffer-> buf_retlen =  buffer->buf_length;
20000ec6:	683b      	ldr	r3, [r7, #0]
20000ec8:	68da      	ldr	r2, [r3, #12]
20000eca:	683b      	ldr	r3, [r7, #0]
20000ecc:	611a      	str	r2, [r3, #16]


    return 0;
20000ece:	2300      	movs	r3, #0
}
20000ed0:	4618      	mov	r0, r3
20000ed2:	3724      	adds	r7, #36	@ 0x24
20000ed4:	46bd      	mov	sp, r7
20000ed6:	f85d 7b04 	ldr.w	r7, [sp], #4
20000eda:	4770      	bx	lr
20000edc:	4001381c 	.word	0x4001381c
20000ee0:	40013824 	.word	0x40013824

20000ee4 <stm32_uart_inpstat>:
static int
stm32_uart_inpstat(cfe_devctx_t *ctx, iocb_inpstat_t *inpstat)
{
20000ee4:	b480      	push	{r7}
20000ee6:	b085      	sub	sp, #20
20000ee8:	af00      	add	r7, sp, #0
20000eea:	6078      	str	r0, [r7, #4]
20000eec:	6039      	str	r1, [r7, #0]

	volatile uint32_t *LPUART_ISR  = (volatile uint32_t *)(0x40013800 + 0x1C);
20000eee:	4b0b      	ldr	r3, [pc, #44]	@ (20000f1c <stm32_uart_inpstat+0x38>)
20000ef0:	60fb      	str	r3, [r7, #12]


	if (*LPUART_ISR & (1 << 5))
20000ef2:	68fb      	ldr	r3, [r7, #12]
20000ef4:	681b      	ldr	r3, [r3, #0]
20000ef6:	f003 0320 	and.w	r3, r3, #32
20000efa:	2b00      	cmp	r3, #0
20000efc:	d003      	beq.n	20000f06 <stm32_uart_inpstat+0x22>
	{
		inpstat->inp_status = 1;
20000efe:	683b      	ldr	r3, [r7, #0]
20000f00:	2201      	movs	r2, #1
20000f02:	601a      	str	r2, [r3, #0]
20000f04:	e002      	b.n	20000f0c <stm32_uart_inpstat+0x28>
	}
	else
	{
		inpstat->inp_status = 0;
20000f06:	683b      	ldr	r3, [r7, #0]
20000f08:	2200      	movs	r2, #0
20000f0a:	601a      	str	r2, [r3, #0]
	}

	return 0;
20000f0c:	2300      	movs	r3, #0
}
20000f0e:	4618      	mov	r0, r3
20000f10:	3714      	adds	r7, #20
20000f12:	46bd      	mov	sp, r7
20000f14:	f85d 7b04 	ldr.w	r7, [sp], #4
20000f18:	4770      	bx	lr
20000f1a:	bf00      	nop
20000f1c:	4001381c 	.word	0x4001381c

20000f20 <stm32_uart_write>:

static int
stm32_uart_write(cfe_devctx_t *ctx, iocb_buffer_t *buffer)
{
20000f20:	b580      	push	{r7, lr}
20000f22:	b086      	sub	sp, #24
20000f24:	af00      	add	r7, sp, #0
20000f26:	6078      	str	r0, [r7, #4]
20000f28:	6039      	str	r1, [r7, #0]
    char* ptr = buffer->buf_ptr;
20000f2a:	683b      	ldr	r3, [r7, #0]
20000f2c:	689b      	ldr	r3, [r3, #8]
20000f2e:	617b      	str	r3, [r7, #20]
    uint32_t len = buffer->buf_length;
20000f30:	683b      	ldr	r3, [r7, #0]
20000f32:	68db      	ldr	r3, [r3, #12]
20000f34:	60fb      	str	r3, [r7, #12]
    for(int i =0; i< len; i++)
20000f36:	2300      	movs	r3, #0
20000f38:	613b      	str	r3, [r7, #16]
20000f3a:	e009      	b.n	20000f50 <stm32_uart_write+0x30>
    	putchar(*ptr++);
20000f3c:	697b      	ldr	r3, [r7, #20]
20000f3e:	1c5a      	adds	r2, r3, #1
20000f40:	617a      	str	r2, [r7, #20]
20000f42:	781b      	ldrb	r3, [r3, #0]
20000f44:	4618      	mov	r0, r3
20000f46:	f7ff ff6f 	bl	20000e28 <putchar>
    for(int i =0; i< len; i++)
20000f4a:	693b      	ldr	r3, [r7, #16]
20000f4c:	3301      	adds	r3, #1
20000f4e:	613b      	str	r3, [r7, #16]
20000f50:	693b      	ldr	r3, [r7, #16]
20000f52:	68fa      	ldr	r2, [r7, #12]
20000f54:	429a      	cmp	r2, r3
20000f56:	d8f1      	bhi.n	20000f3c <stm32_uart_write+0x1c>

    buffer->buf_retlen = len;
20000f58:	683b      	ldr	r3, [r7, #0]
20000f5a:	68fa      	ldr	r2, [r7, #12]
20000f5c:	611a      	str	r2, [r3, #16]
    return 0;
20000f5e:	2300      	movs	r3, #0
}
20000f60:	4618      	mov	r0, r3
20000f62:	3718      	adds	r7, #24
20000f64:	46bd      	mov	sp, r7
20000f66:	bd80      	pop	{r7, pc}

20000f68 <board_init>:

void board_init() {
20000f68:	b598      	push	{r3, r4, r7, lr}
20000f6a:	af00      	add	r7, sp, #0
	cfe_add_device(&stm32_uart, 0, 0, 0);
20000f6c:	4b05      	ldr	r3, [pc, #20]	@ (20000f84 <board_init+0x1c>)
20000f6e:	691c      	ldr	r4, [r3, #16]
20000f70:	2300      	movs	r3, #0
20000f72:	2200      	movs	r2, #0
20000f74:	2100      	movs	r1, #0
20000f76:	4803      	ldr	r0, [pc, #12]	@ (20000f84 <board_init+0x1c>)
20000f78:	47a0      	blx	r4
	cfe_set_console("uart0");
20000f7a:	4803      	ldr	r0, [pc, #12]	@ (20000f88 <board_init+0x20>)
20000f7c:	f000 ff66 	bl	20001e4c <cfe_set_console>
}
20000f80:	bf00      	nop
20000f82:	bd98      	pop	{r3, r4, r7, pc}
20000f84:	20009058 	.word	0x20009058
20000f88:	20007664 	.word	0x20007664

20000f8c <kmeminit>:
    *  	   nothing
    ********************************************************************* */


void kmeminit(mempool_t *pool,unsigned char *buffer,int length)
{
20000f8c:	b480      	push	{r7}
20000f8e:	b085      	sub	sp, #20
20000f90:	af00      	add	r7, sp, #0
20000f92:	60f8      	str	r0, [r7, #12]
20000f94:	60b9      	str	r1, [r7, #8]
20000f96:	607a      	str	r2, [r7, #4]
    pool->root = (memnode_t *) buffer;
20000f98:	68fb      	ldr	r3, [r7, #12]
20000f9a:	68ba      	ldr	r2, [r7, #8]
20000f9c:	601a      	str	r2, [r3, #0]
    pool->root->seal = MEMNODE_SEAL;
20000f9e:	68fb      	ldr	r3, [r7, #12]
20000fa0:	681b      	ldr	r3, [r3, #0]
20000fa2:	4a10      	ldr	r2, [pc, #64]	@ (20000fe4 <kmeminit+0x58>)
20000fa4:	601a      	str	r2, [r3, #0]
    pool->root->length = length - sizeof(memnode_t);
20000fa6:	687a      	ldr	r2, [r7, #4]
20000fa8:	68fb      	ldr	r3, [r7, #12]
20000faa:	681b      	ldr	r3, [r3, #0]
20000fac:	3a18      	subs	r2, #24
20000fae:	609a      	str	r2, [r3, #8]
    pool->root->data = memnode_data(unsigned char *,pool->root);
20000fb0:	68fb      	ldr	r3, [r7, #12]
20000fb2:	681a      	ldr	r2, [r3, #0]
20000fb4:	68fb      	ldr	r3, [r7, #12]
20000fb6:	681b      	ldr	r3, [r3, #0]
20000fb8:	3218      	adds	r2, #24
20000fba:	611a      	str	r2, [r3, #16]
    pool->root->status = memnode_free;
20000fbc:	68fb      	ldr	r3, [r7, #12]
20000fbe:	681b      	ldr	r3, [r3, #0]
20000fc0:	2200      	movs	r2, #0
20000fc2:	731a      	strb	r2, [r3, #12]
    pool->root->next = NULL;
20000fc4:	68fb      	ldr	r3, [r7, #12]
20000fc6:	681b      	ldr	r3, [r3, #0]
20000fc8:	2200      	movs	r2, #0
20000fca:	605a      	str	r2, [r3, #4]

    pool->base = buffer;
20000fcc:	68fb      	ldr	r3, [r7, #12]
20000fce:	68ba      	ldr	r2, [r7, #8]
20000fd0:	605a      	str	r2, [r3, #4]
    pool->length = length;
20000fd2:	687a      	ldr	r2, [r7, #4]
20000fd4:	68fb      	ldr	r3, [r7, #12]
20000fd6:	609a      	str	r2, [r3, #8]
}
20000fd8:	bf00      	nop
20000fda:	3714      	adds	r7, #20
20000fdc:	46bd      	mov	sp, r7
20000fde:	f85d 7b04 	ldr.w	r7, [sp], #4
20000fe2:	4770      	bx	lr
20000fe4:	faafa123 	.word	0xfaafa123

20000fe8 <kmemcompact>:
    *  Return value:
    *  	   nothing
    ********************************************************************* */

static void kmemcompact(mempool_t *pool)
{
20000fe8:	b480      	push	{r7}
20000fea:	b085      	sub	sp, #20
20000fec:	af00      	add	r7, sp, #0
20000fee:	6078      	str	r0, [r7, #4]
    memnode_t *m;
    int compacted;

    do {
	compacted = 0;
20000ff0:	2300      	movs	r3, #0
20000ff2:	60bb      	str	r3, [r7, #8]

	for (m = pool->root; m; m = m->next) {
20000ff4:	687b      	ldr	r3, [r7, #4]
20000ff6:	681b      	ldr	r3, [r3, #0]
20000ff8:	60fb      	str	r3, [r7, #12]
20000ffa:	e02a      	b.n	20001052 <kmemcompact+0x6a>

	    /* Check seal to be sure that we're doing ok */

	    if (m->seal != MEMNODE_SEAL) {
20000ffc:	68fb      	ldr	r3, [r7, #12]
20000ffe:	681b      	ldr	r3, [r3, #0]
20001000:	4a1a      	ldr	r2, [pc, #104]	@ (2000106c <kmemcompact+0x84>)
20001002:	4293      	cmp	r3, r2
20001004:	d12c      	bne.n	20001060 <kmemcompact+0x78>
	    /* 
	     * If we're not on the last block and both this
	     * block and the next one are free, combine them
	     */

	    if (m->next && 
20001006:	68fb      	ldr	r3, [r7, #12]
20001008:	685b      	ldr	r3, [r3, #4]
2000100a:	2b00      	cmp	r3, #0
2000100c:	d01e      	beq.n	2000104c <kmemcompact+0x64>
		(m->status == memnode_free) &&
2000100e:	68fb      	ldr	r3, [r7, #12]
20001010:	7b1b      	ldrb	r3, [r3, #12]
	    if (m->next && 
20001012:	2b00      	cmp	r3, #0
20001014:	d11a      	bne.n	2000104c <kmemcompact+0x64>
		(m->next->status == memnode_free)) {
20001016:	68fb      	ldr	r3, [r7, #12]
20001018:	685b      	ldr	r3, [r3, #4]
2000101a:	7b1b      	ldrb	r3, [r3, #12]
		(m->status == memnode_free) &&
2000101c:	2b00      	cmp	r3, #0
2000101e:	d115      	bne.n	2000104c <kmemcompact+0x64>
		m->length += sizeof(memnode_t) + m->next->length;
20001020:	68fb      	ldr	r3, [r7, #12]
20001022:	689a      	ldr	r2, [r3, #8]
20001024:	68fb      	ldr	r3, [r7, #12]
20001026:	685b      	ldr	r3, [r3, #4]
20001028:	689b      	ldr	r3, [r3, #8]
2000102a:	4413      	add	r3, r2
2000102c:	f103 0218 	add.w	r2, r3, #24
20001030:	68fb      	ldr	r3, [r7, #12]
20001032:	609a      	str	r2, [r3, #8]
		m->next->seal = 0;
20001034:	68fb      	ldr	r3, [r7, #12]
20001036:	685b      	ldr	r3, [r3, #4]
20001038:	2200      	movs	r2, #0
2000103a:	601a      	str	r2, [r3, #0]
		m->next = m->next->next;
2000103c:	68fb      	ldr	r3, [r7, #12]
2000103e:	685b      	ldr	r3, [r3, #4]
20001040:	685a      	ldr	r2, [r3, #4]
20001042:	68fb      	ldr	r3, [r7, #12]
20001044:	605a      	str	r2, [r3, #4]
		compacted++;
20001046:	68bb      	ldr	r3, [r7, #8]
20001048:	3301      	adds	r3, #1
2000104a:	60bb      	str	r3, [r7, #8]
	for (m = pool->root; m; m = m->next) {
2000104c:	68fb      	ldr	r3, [r7, #12]
2000104e:	685b      	ldr	r3, [r3, #4]
20001050:	60fb      	str	r3, [r7, #12]
20001052:	68fb      	ldr	r3, [r7, #12]
20001054:	2b00      	cmp	r3, #0
20001056:	d1d1      	bne.n	20000ffc <kmemcompact+0x14>
		}

	    /* Keep going till we make a pass without doing anything. */
	    }
	} while (compacted > 0);
20001058:	68bb      	ldr	r3, [r7, #8]
2000105a:	2b00      	cmp	r3, #0
2000105c:	dcc8      	bgt.n	20000ff0 <kmemcompact+0x8>
2000105e:	e000      	b.n	20001062 <kmemcompact+0x7a>
		return;
20001060:	bf00      	nop
}
20001062:	3714      	adds	r7, #20
20001064:	46bd      	mov	sp, r7
20001066:	f85d 7b04 	ldr.w	r7, [sp], #4
2000106a:	4770      	bx	lr
2000106c:	faafa123 	.word	0xfaafa123

20001070 <kfree>:
    *  Return value:
    *  	   nothing
    ********************************************************************* */

void kfree(mempool_t *pool,void *ptr)
{
20001070:	b580      	push	{r7, lr}
20001072:	b084      	sub	sp, #16
20001074:	af00      	add	r7, sp, #0
20001076:	6078      	str	r0, [r7, #4]
20001078:	6039      	str	r1, [r7, #0]
    memnode_t **backptr;
    memnode_t *m;

    if (((unsigned char *) ptr < pool->base) ||
2000107a:	687b      	ldr	r3, [r7, #4]
2000107c:	685b      	ldr	r3, [r3, #4]
2000107e:	683a      	ldr	r2, [r7, #0]
20001080:	429a      	cmp	r2, r3
20001082:	d319      	bcc.n	200010b8 <kfree+0x48>
	((unsigned char *) ptr >= (pool->base+pool->length))) {
20001084:	687b      	ldr	r3, [r7, #4]
20001086:	685a      	ldr	r2, [r3, #4]
20001088:	687b      	ldr	r3, [r7, #4]
2000108a:	689b      	ldr	r3, [r3, #8]
2000108c:	4413      	add	r3, r2
    if (((unsigned char *) ptr < pool->base) ||
2000108e:	683a      	ldr	r2, [r7, #0]
20001090:	429a      	cmp	r2, r3
20001092:	d211      	bcs.n	200010b8 <kfree+0x48>
	printf("Pointer %08X does not belong to pool %08X\n",ptr,pool);
#endif
	return;
	}

    backptr = (memnode_t **) (((unsigned char *) ptr) - sizeof(memnode_t *));
20001094:	683b      	ldr	r3, [r7, #0]
20001096:	3b04      	subs	r3, #4
20001098:	60fb      	str	r3, [r7, #12]
    m = *backptr;
2000109a:	68fb      	ldr	r3, [r7, #12]
2000109c:	681b      	ldr	r3, [r3, #0]
2000109e:	60bb      	str	r3, [r7, #8]

    if (m->seal != MEMNODE_SEAL) {
200010a0:	68bb      	ldr	r3, [r7, #8]
200010a2:	681b      	ldr	r3, [r3, #0]
200010a4:	4a07      	ldr	r2, [pc, #28]	@ (200010c4 <kfree+0x54>)
200010a6:	4293      	cmp	r3, r2
200010a8:	d108      	bne.n	200010bc <kfree+0x4c>
	printf("Invalid node freed: %08X\n",m);
#endif
	return;
	}

    m->status = memnode_free;
200010aa:	68bb      	ldr	r3, [r7, #8]
200010ac:	2200      	movs	r2, #0
200010ae:	731a      	strb	r2, [r3, #12]

    kmemcompact(pool);
200010b0:	6878      	ldr	r0, [r7, #4]
200010b2:	f7ff ff99 	bl	20000fe8 <kmemcompact>
200010b6:	e002      	b.n	200010be <kfree+0x4e>
	return;
200010b8:	bf00      	nop
200010ba:	e000      	b.n	200010be <kfree+0x4e>
	return;
200010bc:	bf00      	nop
}
200010be:	3710      	adds	r7, #16
200010c0:	46bd      	mov	sp, r7
200010c2:	bd80      	pop	{r7, pc}
200010c4:	faafa123 	.word	0xfaafa123

200010c8 <lib_outofmemory>:
    *  	   nothing
    ********************************************************************* */

void lib_outofmemory(void);
void lib_outofmemory(void)
{
200010c8:	b480      	push	{r7}
200010ca:	af00      	add	r7, sp, #0
    //xprintf("PANIC: out of memory!\n");
}
200010cc:	bf00      	nop
200010ce:	46bd      	mov	sp, r7
200010d0:	f85d 7b04 	ldr.w	r7, [sp], #4
200010d4:	4770      	bx	lr
	...

200010d8 <kmalloc>:
    *  Return value:
    *  	   pointer to data, or NULL if no memory left
    ********************************************************************* */

void *kmalloc(mempool_t *pool,unsigned int size,unsigned int align)
{
200010d8:	b580      	push	{r7, lr}
200010da:	b08c      	sub	sp, #48	@ 0x30
200010dc:	af00      	add	r7, sp, #0
200010de:	60f8      	str	r0, [r7, #12]
200010e0:	60b9      	str	r1, [r7, #8]
200010e2:	607a      	str	r2, [r7, #4]
    memnode_t *m;
    memnode_t *newm;
    memnode_t **backptr;
    uintptr_t daddr = 0;
200010e4:	2300      	movs	r3, #0
200010e6:	62bb      	str	r3, [r7, #40]	@ 0x28
    uintptr_t realsize = 0;
200010e8:	2300      	movs	r3, #0
200010ea:	627b      	str	r3, [r7, #36]	@ 0x24
    /*
     * Everything should be aligned by at least the
     * size of an int64
     */

    ptralign = (uintptr_t) align;
200010ec:	687b      	ldr	r3, [r7, #4]
200010ee:	61fb      	str	r3, [r7, #28]
    if (ptralign < sizeof(void *)) ptralign = sizeof(uint64_t);
200010f0:	69fb      	ldr	r3, [r7, #28]
200010f2:	2b03      	cmp	r3, #3
200010f4:	d801      	bhi.n	200010fa <kmalloc+0x22>
200010f6:	2308      	movs	r3, #8
200010f8:	61fb      	str	r3, [r7, #28]
    /*	
     * Everything should be at least a multiple of the 
     * size of a pointer.
     */

    if (size == 0) size = sizeof(void *);
200010fa:	68bb      	ldr	r3, [r7, #8]
200010fc:	2b00      	cmp	r3, #0
200010fe:	d101      	bne.n	20001104 <kmalloc+0x2c>
20001100:	2304      	movs	r3, #4
20001102:	60bb      	str	r3, [r7, #8]
    if (size & (sizeof(void *)-1)) {
20001104:	68bb      	ldr	r3, [r7, #8]
20001106:	f003 0303 	and.w	r3, r3, #3
2000110a:	2b00      	cmp	r3, #0
2000110c:	d006      	beq.n	2000111c <kmalloc+0x44>
	size += sizeof(void *);
2000110e:	68bb      	ldr	r3, [r7, #8]
20001110:	3304      	adds	r3, #4
20001112:	60bb      	str	r3, [r7, #8]
	size &= ~(sizeof(void *)-1);
20001114:	68bb      	ldr	r3, [r7, #8]
20001116:	f023 0303 	bic.w	r3, r3, #3
2000111a:	60bb      	str	r3, [r7, #8]
    /*
     * Find a memnode at least big enough to hold the storage we
     * want.
     */

    for (m = pool->root; m; m = m->next) {
2000111c:	68fb      	ldr	r3, [r7, #12]
2000111e:	681b      	ldr	r3, [r3, #0]
20001120:	62fb      	str	r3, [r7, #44]	@ 0x2c
20001122:	e025      	b.n	20001170 <kmalloc+0x98>

	if (m->status == memnode_alloc) continue;
20001124:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
20001126:	7b1b      	ldrb	r3, [r3, #12]
20001128:	2b01      	cmp	r3, #1
2000112a:	d01d      	beq.n	20001168 <kmalloc+0x90>
	/*
	 * If we wanted a particular alignment, we will
	 * need to adjust the size.
	 */

	daddr = memnode_data(uintptr_t,m);
2000112c:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
2000112e:	3318      	adds	r3, #24
20001130:	62bb      	str	r3, [r7, #40]	@ 0x28
	extra = 0;
20001132:	2300      	movs	r3, #0
20001134:	623b      	str	r3, [r7, #32]
	if (daddr & (ptralign-1)) {
20001136:	69fb      	ldr	r3, [r7, #28]
20001138:	1e5a      	subs	r2, r3, #1
2000113a:	6abb      	ldr	r3, [r7, #40]	@ 0x28
2000113c:	4013      	ands	r3, r2
2000113e:	2b00      	cmp	r3, #0
20001140:	d008      	beq.n	20001154 <kmalloc+0x7c>
	    extra = size + (ptralign - (daddr & (ptralign-1)));
20001142:	69fb      	ldr	r3, [r7, #28]
20001144:	1e5a      	subs	r2, r3, #1
20001146:	6abb      	ldr	r3, [r7, #40]	@ 0x28
20001148:	4013      	ands	r3, r2
2000114a:	69fa      	ldr	r2, [r7, #28]
2000114c:	1ad3      	subs	r3, r2, r3
2000114e:	68ba      	ldr	r2, [r7, #8]
20001150:	4413      	add	r3, r2
20001152:	623b      	str	r3, [r7, #32]
	    }
	realsize = size + extra;
20001154:	68ba      	ldr	r2, [r7, #8]
20001156:	6a3b      	ldr	r3, [r7, #32]
20001158:	4413      	add	r3, r2
2000115a:	627b      	str	r3, [r7, #36]	@ 0x24

	if (m->length < realsize) continue;
2000115c:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
2000115e:	689b      	ldr	r3, [r3, #8]
20001160:	6a7a      	ldr	r2, [r7, #36]	@ 0x24
20001162:	429a      	cmp	r2, r3
20001164:	d908      	bls.n	20001178 <kmalloc+0xa0>
20001166:	e000      	b.n	2000116a <kmalloc+0x92>
	if (m->status == memnode_alloc) continue;
20001168:	bf00      	nop
    for (m = pool->root; m; m = m->next) {
2000116a:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
2000116c:	685b      	ldr	r3, [r3, #4]
2000116e:	62fb      	str	r3, [r7, #44]	@ 0x2c
20001170:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
20001172:	2b00      	cmp	r3, #0
20001174:	d1d6      	bne.n	20001124 <kmalloc+0x4c>
20001176:	e000      	b.n	2000117a <kmalloc+0xa2>
	break;
20001178:	bf00      	nop

    /*
     * If m is null, there's no memory left.
     */

    if (m == NULL) {
2000117a:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
2000117c:	2b00      	cmp	r3, #0
2000117e:	d103      	bne.n	20001188 <kmalloc+0xb0>
	lib_outofmemory();
20001180:	f7ff ffa2 	bl	200010c8 <lib_outofmemory>
	return NULL;
20001184:	2300      	movs	r3, #0
20001186:	e061      	b.n	2000124c <kmalloc+0x174>
    /*
     * Otherwise, use this block.  Calculate the address of the data
     * to preserve the alignment.
     */

    if (daddr & (ptralign-1)) {
20001188:	69fb      	ldr	r3, [r7, #28]
2000118a:	1e5a      	subs	r2, r3, #1
2000118c:	6abb      	ldr	r3, [r7, #40]	@ 0x28
2000118e:	4013      	ands	r3, r2
20001190:	2b00      	cmp	r3, #0
20001192:	d008      	beq.n	200011a6 <kmalloc+0xce>
	daddr += ptralign;
20001194:	6aba      	ldr	r2, [r7, #40]	@ 0x28
20001196:	69fb      	ldr	r3, [r7, #28]
20001198:	4413      	add	r3, r2
2000119a:	62bb      	str	r3, [r7, #40]	@ 0x28
	daddr &= ~(ptralign-1);
2000119c:	69fb      	ldr	r3, [r7, #28]
2000119e:	425b      	negs	r3, r3
200011a0:	6aba      	ldr	r2, [r7, #40]	@ 0x28
200011a2:	4013      	ands	r3, r2
200011a4:	62bb      	str	r3, [r7, #40]	@ 0x28
	}

    /* Mark this node as allocated. */

    m->data   = (unsigned char *) daddr;
200011a6:	6aba      	ldr	r2, [r7, #40]	@ 0x28
200011a8:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
200011aa:	611a      	str	r2, [r3, #16]
    m->status = memnode_alloc;
200011ac:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
200011ae:	2201      	movs	r2, #1
200011b0:	731a      	strb	r2, [r3, #12]
     * aligned, backing up will put us inside the memnode
     * structure itself... that's why the memnodeptr field
     * is there, as a placeholder for this eventuality.
     */

    backptr   = (memnode_t **) (m->data - sizeof(memnode_t *));
200011b2:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
200011b4:	691b      	ldr	r3, [r3, #16]
200011b6:	3b04      	subs	r3, #4
200011b8:	61bb      	str	r3, [r7, #24]
    *backptr  = m;
200011ba:	69bb      	ldr	r3, [r7, #24]
200011bc:	6afa      	ldr	r2, [r7, #44]	@ 0x2c
200011be:	601a      	str	r2, [r3, #0]
     * See if we need to split it.
     * Don't bother to split if the resulting size will be 
     * less than MINBLKSIZE bytes
     */

    if (m->length - realsize < MINBLKSIZE) {
200011c0:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
200011c2:	689a      	ldr	r2, [r3, #8]
200011c4:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
200011c6:	1ad3      	subs	r3, r2, r3
200011c8:	2b3f      	cmp	r3, #63	@ 0x3f
200011ca:	d802      	bhi.n	200011d2 <kmalloc+0xfa>
	return m->data;
200011cc:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
200011ce:	691b      	ldr	r3, [r3, #16]
200011d0:	e03c      	b.n	2000124c <kmalloc+0x174>
    /*
     * Split this block.  Align the address on a pointer-size
     * boundary.
     */

    daddr += size;
200011d2:	6aba      	ldr	r2, [r7, #40]	@ 0x28
200011d4:	68bb      	ldr	r3, [r7, #8]
200011d6:	4413      	add	r3, r2
200011d8:	62bb      	str	r3, [r7, #40]	@ 0x28
    if (daddr & (uintptr_t)(sizeof(void *)-1)) {
200011da:	6abb      	ldr	r3, [r7, #40]	@ 0x28
200011dc:	f003 0303 	and.w	r3, r3, #3
200011e0:	2b00      	cmp	r3, #0
200011e2:	d006      	beq.n	200011f2 <kmalloc+0x11a>
	daddr += (uintptr_t)sizeof(void *);
200011e4:	6abb      	ldr	r3, [r7, #40]	@ 0x28
200011e6:	3304      	adds	r3, #4
200011e8:	62bb      	str	r3, [r7, #40]	@ 0x28
	daddr &= ~(uintptr_t)(sizeof(void *)-1);
200011ea:	6abb      	ldr	r3, [r7, #40]	@ 0x28
200011ec:	f023 0303 	bic.w	r3, r3, #3
200011f0:	62bb      	str	r3, [r7, #40]	@ 0x28
	}

    blkend = memnode_data(uintptr_t,m) + (uintptr_t)(m->length);
200011f2:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
200011f4:	689a      	ldr	r2, [r3, #8]
200011f6:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
200011f8:	4413      	add	r3, r2
200011fa:	3318      	adds	r3, #24
200011fc:	617b      	str	r3, [r7, #20]

    newm = (memnode_t *) daddr;
200011fe:	6abb      	ldr	r3, [r7, #40]	@ 0x28
20001200:	613b      	str	r3, [r7, #16]

    newm->next   = m->next;
20001202:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
20001204:	685a      	ldr	r2, [r3, #4]
20001206:	693b      	ldr	r3, [r7, #16]
20001208:	605a      	str	r2, [r3, #4]
    m->length    = (unsigned int) (daddr - memnode_data(uintptr_t,m));
2000120a:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
2000120c:	6aba      	ldr	r2, [r7, #40]	@ 0x28
2000120e:	1ad3      	subs	r3, r2, r3
20001210:	f1a3 0218 	sub.w	r2, r3, #24
20001214:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
20001216:	609a      	str	r2, [r3, #8]
    m->next      = newm;
20001218:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
2000121a:	693a      	ldr	r2, [r7, #16]
2000121c:	605a      	str	r2, [r3, #4]
    m->status    = memnode_alloc;
2000121e:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
20001220:	2201      	movs	r2, #1
20001222:	731a      	strb	r2, [r3, #12]
    newm->seal   = MEMNODE_SEAL;
20001224:	693b      	ldr	r3, [r7, #16]
20001226:	4a0b      	ldr	r2, [pc, #44]	@ (20001254 <kmalloc+0x17c>)
20001228:	601a      	str	r2, [r3, #0]
    newm->data    = memnode_data(unsigned char *,newm);
2000122a:	693b      	ldr	r3, [r7, #16]
2000122c:	f103 0218 	add.w	r2, r3, #24
20001230:	693b      	ldr	r3, [r7, #16]
20001232:	611a      	str	r2, [r3, #16]
    newm->length = (unsigned int) (blkend - memnode_data(uintptr_t,newm));
20001234:	693b      	ldr	r3, [r7, #16]
20001236:	697a      	ldr	r2, [r7, #20]
20001238:	1ad3      	subs	r3, r2, r3
2000123a:	f1a3 0218 	sub.w	r2, r3, #24
2000123e:	693b      	ldr	r3, [r7, #16]
20001240:	609a      	str	r2, [r3, #8]
    newm->status = memnode_free;
20001242:	693b      	ldr	r3, [r7, #16]
20001244:	2200      	movs	r2, #0
20001246:	731a      	strb	r2, [r3, #12]

    return m->data;    
20001248:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
2000124a:	691b      	ldr	r3, [r3, #16]
}
2000124c:	4618      	mov	r0, r3
2000124e:	3730      	adds	r7, #48	@ 0x30
20001250:	46bd      	mov	sp, r7
20001252:	bd80      	pop	{r7, pc}
20001254:	faafa123 	.word	0xfaafa123

20001258 <mem_peek>:
    *  	   0 if ok
    *  	   else error code
    ********************************************************************* */

int mem_peek(void *d, hsaddr_t addr, int type)
{
20001258:	b580      	push	{r7, lr}
2000125a:	b086      	sub	sp, #24
2000125c:	af00      	add	r7, sp, #0
2000125e:	60f8      	str	r0, [r7, #12]
20001260:	60b9      	str	r1, [r7, #8]
20001262:	607a      	str	r2, [r7, #4]

    jmpbuf_t *jb;

    jb = exc_initialize_block();
20001264:	f000 fb90 	bl	20001988 <exc_initialize_block>
20001268:	6178      	str	r0, [r7, #20]
    if( jb == NULL ) {
2000126a:	697b      	ldr	r3, [r7, #20]
2000126c:	2b00      	cmp	r3, #0
2000126e:	d102      	bne.n	20001276 <mem_peek+0x1e>
	return CFE_ERR_NOMEM;
20001270:	f06f 0304 	mvn.w	r3, #4
20001274:	e02a      	b.n	200012cc <mem_peek+0x74>
	}

    if (1) {
  
	switch (type) {
20001276:	687b      	ldr	r3, [r7, #4]
20001278:	3b01      	subs	r3, #1
2000127a:	2b03      	cmp	r3, #3
2000127c:	d822      	bhi.n	200012c4 <mem_peek+0x6c>
2000127e:	a201      	add	r2, pc, #4	@ (adr r2, 20001284 <mem_peek+0x2c>)
20001280:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
20001284:	20001295 	.word	0x20001295
20001288:	200012a1 	.word	0x200012a1
2000128c:	200012ad 	.word	0x200012ad
20001290:	200012b7 	.word	0x200012b7
	    case MEM_BYTE:
		*(uint8_t *)d = hs_read8(addr);
20001294:	68bb      	ldr	r3, [r7, #8]
20001296:	781b      	ldrb	r3, [r3, #0]
20001298:	b2da      	uxtb	r2, r3
2000129a:	68fb      	ldr	r3, [r7, #12]
2000129c:	701a      	strb	r2, [r3, #0]
		break;
2000129e:	e014      	b.n	200012ca <mem_peek+0x72>
	    case MEM_HALFWORD:
		*(uint16_t *)d = hs_read16(addr);
200012a0:	68bb      	ldr	r3, [r7, #8]
200012a2:	881b      	ldrh	r3, [r3, #0]
200012a4:	b29a      	uxth	r2, r3
200012a6:	68fb      	ldr	r3, [r7, #12]
200012a8:	801a      	strh	r2, [r3, #0]
		break;
200012aa:	e00e      	b.n	200012ca <mem_peek+0x72>
	    case MEM_WORD:
		*(uint32_t *)d = hs_read32(addr);
200012ac:	68bb      	ldr	r3, [r7, #8]
200012ae:	681a      	ldr	r2, [r3, #0]
200012b0:	68fb      	ldr	r3, [r7, #12]
200012b2:	601a      	str	r2, [r3, #0]
		break;
200012b4:	e009      	b.n	200012ca <mem_peek+0x72>
	    case MEM_QUADWORD:
		*(uint64_t *)d = hs_read64(addr);
200012b6:	68bb      	ldr	r3, [r7, #8]
200012b8:	e9d3 2300 	ldrd	r2, r3, [r3]
200012bc:	68f9      	ldr	r1, [r7, #12]
200012be:	e9c1 2300 	strd	r2, r3, [r1]
		break;
200012c2:	e002      	b.n	200012ca <mem_peek+0x72>
	    default:
		return CFE_ERR_INV_PARAM;
200012c4:	f06f 0307 	mvn.w	r3, #7
200012c8:	e000      	b.n	200012cc <mem_peek+0x74>

	//exc_cleanup_handler(jb, EXC_NORMAL_RETURN);
	return CFE_ERR_GETMEM;
	}

    return 0;
200012ca:	2300      	movs	r3, #0
}
200012cc:	4618      	mov	r0, r3
200012ce:	3718      	adds	r7, #24
200012d0:	46bd      	mov	sp, r7
200012d2:	bd80      	pop	{r7, pc}

200012d4 <mem_poke>:
   *  1 success
   *  0 failure
   ********************************************************************* */

int mem_poke(hsaddr_t addr, uint64_t val, int type)
{
200012d4:	b480      	push	{r7}
200012d6:	b087      	sub	sp, #28
200012d8:	af00      	add	r7, sp, #0
200012da:	60f8      	str	r0, [r7, #12]
200012dc:	e9c7 2300 	strd	r2, r3, [r7]

    jmpbuf_t *jb;

    jb = 1;
200012e0:	2301      	movs	r3, #1
200012e2:	617b      	str	r3, [r7, #20]
    if( jb == NULL ) {
200012e4:	697b      	ldr	r3, [r7, #20]
200012e6:	2b00      	cmp	r3, #0
200012e8:	d102      	bne.n	200012f0 <mem_poke+0x1c>
	return CFE_ERR_NOMEM;
200012ea:	f06f 0304 	mvn.w	r3, #4
200012ee:	e025      	b.n	2000133c <mem_poke+0x68>
	}

    if (1) {
  
	switch (type) {
200012f0:	6a3b      	ldr	r3, [r7, #32]
200012f2:	3b01      	subs	r3, #1
200012f4:	2b03      	cmp	r3, #3
200012f6:	d81d      	bhi.n	20001334 <mem_poke+0x60>
200012f8:	a201      	add	r2, pc, #4	@ (adr r2, 20001300 <mem_poke+0x2c>)
200012fa:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
200012fe:	bf00      	nop
20001300:	20001311 	.word	0x20001311
20001304:	20001319 	.word	0x20001319
20001308:	20001321 	.word	0x20001321
2000130c:	20001329 	.word	0x20001329
	    case MEM_BYTE:
		hs_write8(addr,(uint8_t)val);
20001310:	68fb      	ldr	r3, [r7, #12]
20001312:	783a      	ldrb	r2, [r7, #0]
20001314:	701a      	strb	r2, [r3, #0]
		break;
20001316:	e010      	b.n	2000133a <mem_poke+0x66>
	    case MEM_HALFWORD:
		hs_write16(addr,(uint16_t)val);
20001318:	68fb      	ldr	r3, [r7, #12]
2000131a:	883a      	ldrh	r2, [r7, #0]
2000131c:	801a      	strh	r2, [r3, #0]
		break;
2000131e:	e00c      	b.n	2000133a <mem_poke+0x66>
	    case MEM_WORD:
		hs_write32(addr,(uint32_t)val);
20001320:	68fb      	ldr	r3, [r7, #12]
20001322:	683a      	ldr	r2, [r7, #0]
20001324:	601a      	str	r2, [r3, #0]
		break;
20001326:	e008      	b.n	2000133a <mem_poke+0x66>
	    case MEM_QUADWORD:
		hs_write64(addr,(uint64_t)val);
20001328:	68f9      	ldr	r1, [r7, #12]
2000132a:	e9d7 2300 	ldrd	r2, r3, [r7]
2000132e:	e9c1 2300 	strd	r2, r3, [r1]
		break;
20001332:	e002      	b.n	2000133a <mem_poke+0x66>
	    default:
		return CFE_ERR_INV_PARAM;
20001334:	f06f 0307 	mvn.w	r3, #7
20001338:	e000      	b.n	2000133c <mem_poke+0x68>

	//exc_cleanup_handler(jb, EXC_NORMAL_RETURN);
	return CFE_ERR_SETMEM;
	}

    return 0;
2000133a:	2300      	movs	r3, #0
}
2000133c:	4618      	mov	r0, r3
2000133e:	371c      	adds	r7, #28
20001340:	46bd      	mov	sp, r7
20001342:	f85d 7b04 	ldr.w	r7, [sp], #4
20001346:	4770      	bx	lr

20001348 <q_enqueue>:
    *  Return Value:		
    *      Nothing.		
    ********************************************************************* */

void q_enqueue(queue_t *qb,queue_t *item)
{
20001348:	b480      	push	{r7}
2000134a:	b083      	sub	sp, #12
2000134c:	af00      	add	r7, sp, #0
2000134e:	6078      	str	r0, [r7, #4]
20001350:	6039      	str	r1, [r7, #0]
    qb->q_prev->q_next = item;
20001352:	687b      	ldr	r3, [r7, #4]
20001354:	685b      	ldr	r3, [r3, #4]
20001356:	683a      	ldr	r2, [r7, #0]
20001358:	601a      	str	r2, [r3, #0]
    item->q_next = qb;
2000135a:	683b      	ldr	r3, [r7, #0]
2000135c:	687a      	ldr	r2, [r7, #4]
2000135e:	601a      	str	r2, [r3, #0]
    item->q_prev = qb->q_prev;
20001360:	687b      	ldr	r3, [r7, #4]
20001362:	685a      	ldr	r2, [r3, #4]
20001364:	683b      	ldr	r3, [r7, #0]
20001366:	605a      	str	r2, [r3, #4]
    qb->q_prev = item;
20001368:	687b      	ldr	r3, [r7, #4]
2000136a:	683a      	ldr	r2, [r7, #0]
2000136c:	605a      	str	r2, [r3, #4]
}
2000136e:	bf00      	nop
20001370:	370c      	adds	r7, #12
20001372:	46bd      	mov	sp, r7
20001374:	f85d 7b04 	ldr.w	r7, [sp], #4
20001378:	4770      	bx	lr

2000137a <q_dequeue>:
    *  Return Value:			
    *      Nothing.			
    ********************************************************************* */

void q_dequeue(queue_t *item)
{
2000137a:	b480      	push	{r7}
2000137c:	b083      	sub	sp, #12
2000137e:	af00      	add	r7, sp, #0
20001380:	6078      	str	r0, [r7, #4]
    item->q_prev->q_next = item->q_next;
20001382:	687b      	ldr	r3, [r7, #4]
20001384:	685b      	ldr	r3, [r3, #4]
20001386:	687a      	ldr	r2, [r7, #4]
20001388:	6812      	ldr	r2, [r2, #0]
2000138a:	601a      	str	r2, [r3, #0]
    item->q_next->q_prev = item->q_prev;
2000138c:	687b      	ldr	r3, [r7, #4]
2000138e:	681b      	ldr	r3, [r3, #0]
20001390:	687a      	ldr	r2, [r7, #4]
20001392:	6852      	ldr	r2, [r2, #4]
20001394:	605a      	str	r2, [r3, #4]
}
20001396:	bf00      	nop
20001398:	370c      	adds	r7, #12
2000139a:	46bd      	mov	sp, r7
2000139c:	f85d 7b04 	ldr.w	r7, [sp], #4
200013a0:	4770      	bx	lr

200013a2 <q_deqnext>:
    *  Return Value:		
    *      next element, or NULL
    ********************************************************************* */

queue_t *q_deqnext(queue_t *qb)
{
200013a2:	b480      	push	{r7}
200013a4:	b083      	sub	sp, #12
200013a6:	af00      	add	r7, sp, #0
200013a8:	6078      	str	r0, [r7, #4]
    if (qb->q_next == qb) {
200013aa:	687b      	ldr	r3, [r7, #4]
200013ac:	681b      	ldr	r3, [r3, #0]
200013ae:	687a      	ldr	r2, [r7, #4]
200013b0:	429a      	cmp	r2, r3
200013b2:	d101      	bne.n	200013b8 <q_deqnext+0x16>
	return NULL;
200013b4:	2300      	movs	r3, #0
200013b6:	e00d      	b.n	200013d4 <q_deqnext+0x32>
	}

    qb = qb->q_next;
200013b8:	687b      	ldr	r3, [r7, #4]
200013ba:	681b      	ldr	r3, [r3, #0]
200013bc:	607b      	str	r3, [r7, #4]

    qb->q_prev->q_next = qb->q_next;
200013be:	687b      	ldr	r3, [r7, #4]
200013c0:	685b      	ldr	r3, [r3, #4]
200013c2:	687a      	ldr	r2, [r7, #4]
200013c4:	6812      	ldr	r2, [r2, #0]
200013c6:	601a      	str	r2, [r3, #0]
    qb->q_next->q_prev = qb->q_prev;
200013c8:	687b      	ldr	r3, [r7, #4]
200013ca:	681b      	ldr	r3, [r3, #0]
200013cc:	687a      	ldr	r2, [r7, #4]
200013ce:	6852      	ldr	r2, [r2, #4]
200013d0:	605a      	str	r2, [r3, #4]

    return qb;
200013d2:	687b      	ldr	r3, [r7, #4]
}
200013d4:	4618      	mov	r0, r3
200013d6:	370c      	adds	r7, #12
200013d8:	46bd      	mov	sp, r7
200013da:	f85d 7b04 	ldr.w	r7, [sp], #4
200013de:	4770      	bx	lr

200013e0 <q_count>:
    *      								*
    *  Return Value:							*
    *      number of elements						*
    ********************************************************************* */
int q_count(queue_t *qb)
{
200013e0:	b480      	push	{r7}
200013e2:	b085      	sub	sp, #20
200013e4:	af00      	add	r7, sp, #0
200013e6:	6078      	str	r0, [r7, #4]
    queue_t *qe;
    int res = 0;
200013e8:	2300      	movs	r3, #0
200013ea:	60bb      	str	r3, [r7, #8]

    qe = qb;
200013ec:	687b      	ldr	r3, [r7, #4]
200013ee:	60fb      	str	r3, [r7, #12]

    while (qe->q_next != qb) {
200013f0:	e005      	b.n	200013fe <q_count+0x1e>
	qe = qe->q_next;
200013f2:	68fb      	ldr	r3, [r7, #12]
200013f4:	681b      	ldr	r3, [r3, #0]
200013f6:	60fb      	str	r3, [r7, #12]
	res++;
200013f8:	68bb      	ldr	r3, [r7, #8]
200013fa:	3301      	adds	r3, #1
200013fc:	60bb      	str	r3, [r7, #8]
    while (qe->q_next != qb) {
200013fe:	68fb      	ldr	r3, [r7, #12]
20001400:	681b      	ldr	r3, [r3, #0]
20001402:	687a      	ldr	r2, [r7, #4]
20001404:	429a      	cmp	r2, r3
20001406:	d1f4      	bne.n	200013f2 <q_count+0x12>
	}

    return res;
20001408:	68bb      	ldr	r3, [r7, #8]
}
2000140a:	4618      	mov	r0, r3
2000140c:	3714      	adds	r7, #20
2000140e:	46bd      	mov	sp, r7
20001410:	f85d 7b04 	ldr.w	r7, [sp], #4
20001414:	4770      	bx	lr

20001416 <lib_strcpy>:
#include "lib_types.h"
#define _LIB_NO_MACROS_
#include "lib_string.h"

char *lib_strcpy(char *dest,const char *src)
{
20001416:	b480      	push	{r7}
20001418:	b085      	sub	sp, #20
2000141a:	af00      	add	r7, sp, #0
2000141c:	6078      	str	r0, [r7, #4]
2000141e:	6039      	str	r1, [r7, #0]
    char *ptr = dest;
20001420:	687b      	ldr	r3, [r7, #4]
20001422:	60fb      	str	r3, [r7, #12]

    while (*src) *ptr++ = *src++;
20001424:	e007      	b.n	20001436 <lib_strcpy+0x20>
20001426:	683a      	ldr	r2, [r7, #0]
20001428:	1c53      	adds	r3, r2, #1
2000142a:	603b      	str	r3, [r7, #0]
2000142c:	68fb      	ldr	r3, [r7, #12]
2000142e:	1c59      	adds	r1, r3, #1
20001430:	60f9      	str	r1, [r7, #12]
20001432:	7812      	ldrb	r2, [r2, #0]
20001434:	701a      	strb	r2, [r3, #0]
20001436:	683b      	ldr	r3, [r7, #0]
20001438:	781b      	ldrb	r3, [r3, #0]
2000143a:	2b00      	cmp	r3, #0
2000143c:	d1f3      	bne.n	20001426 <lib_strcpy+0x10>
    *ptr = '\0';
2000143e:	68fb      	ldr	r3, [r7, #12]
20001440:	2200      	movs	r2, #0
20001442:	701a      	strb	r2, [r3, #0]

    return dest;
20001444:	687b      	ldr	r3, [r7, #4]
}
20001446:	4618      	mov	r0, r3
20001448:	3714      	adds	r7, #20
2000144a:	46bd      	mov	sp, r7
2000144c:	f85d 7b04 	ldr.w	r7, [sp], #4
20001450:	4770      	bx	lr

20001452 <lib_xstrncpy>:
    return dest;
}


size_t lib_xstrncpy(char *dest,const char *src,size_t cnt)
{
20001452:	b480      	push	{r7}
20001454:	b087      	sub	sp, #28
20001456:	af00      	add	r7, sp, #0
20001458:	60f8      	str	r0, [r7, #12]
2000145a:	60b9      	str	r1, [r7, #8]
2000145c:	607a      	str	r2, [r7, #4]
    char *ptr = dest;
2000145e:	68fb      	ldr	r3, [r7, #12]
20001460:	617b      	str	r3, [r7, #20]
    size_t copied = 0;
20001462:	2300      	movs	r3, #0
20001464:	613b      	str	r3, [r7, #16]

    while (*src && (cnt > 1)) {
20001466:	e00d      	b.n	20001484 <lib_xstrncpy+0x32>
	*ptr++ = *src++;
20001468:	68ba      	ldr	r2, [r7, #8]
2000146a:	1c53      	adds	r3, r2, #1
2000146c:	60bb      	str	r3, [r7, #8]
2000146e:	697b      	ldr	r3, [r7, #20]
20001470:	1c59      	adds	r1, r3, #1
20001472:	6179      	str	r1, [r7, #20]
20001474:	7812      	ldrb	r2, [r2, #0]
20001476:	701a      	strb	r2, [r3, #0]
	cnt--;
20001478:	687b      	ldr	r3, [r7, #4]
2000147a:	3b01      	subs	r3, #1
2000147c:	607b      	str	r3, [r7, #4]
	copied++;
2000147e:	693b      	ldr	r3, [r7, #16]
20001480:	3301      	adds	r3, #1
20001482:	613b      	str	r3, [r7, #16]
    while (*src && (cnt > 1)) {
20001484:	68bb      	ldr	r3, [r7, #8]
20001486:	781b      	ldrb	r3, [r3, #0]
20001488:	2b00      	cmp	r3, #0
2000148a:	d002      	beq.n	20001492 <lib_xstrncpy+0x40>
2000148c:	687b      	ldr	r3, [r7, #4]
2000148e:	2b01      	cmp	r3, #1
20001490:	dcea      	bgt.n	20001468 <lib_xstrncpy+0x16>
	}
    *ptr = '\0';
20001492:	697b      	ldr	r3, [r7, #20]
20001494:	2200      	movs	r2, #0
20001496:	701a      	strb	r2, [r3, #0]

    return copied;
20001498:	693b      	ldr	r3, [r7, #16]
}
2000149a:	4618      	mov	r0, r3
2000149c:	371c      	adds	r7, #28
2000149e:	46bd      	mov	sp, r7
200014a0:	f85d 7b04 	ldr.w	r7, [sp], #4
200014a4:	4770      	bx	lr

200014a6 <lib_strlen>:

size_t lib_strlen(const char *str)
{
200014a6:	b480      	push	{r7}
200014a8:	b085      	sub	sp, #20
200014aa:	af00      	add	r7, sp, #0
200014ac:	6078      	str	r0, [r7, #4]
    size_t cnt = 0;
200014ae:	2300      	movs	r3, #0
200014b0:	60fb      	str	r3, [r7, #12]

    while (*str) {
200014b2:	e005      	b.n	200014c0 <lib_strlen+0x1a>
	str++;
200014b4:	687b      	ldr	r3, [r7, #4]
200014b6:	3301      	adds	r3, #1
200014b8:	607b      	str	r3, [r7, #4]
	cnt++;
200014ba:	68fb      	ldr	r3, [r7, #12]
200014bc:	3301      	adds	r3, #1
200014be:	60fb      	str	r3, [r7, #12]
    while (*str) {
200014c0:	687b      	ldr	r3, [r7, #4]
200014c2:	781b      	ldrb	r3, [r3, #0]
200014c4:	2b00      	cmp	r3, #0
200014c6:	d1f5      	bne.n	200014b4 <lib_strlen+0xe>
	}

    return cnt;
200014c8:	68fb      	ldr	r3, [r7, #12]
}
200014ca:	4618      	mov	r0, r3
200014cc:	3714      	adds	r7, #20
200014ce:	46bd      	mov	sp, r7
200014d0:	f85d 7b04 	ldr.w	r7, [sp], #4
200014d4:	4770      	bx	lr

200014d6 <lib_strcmp>:


int lib_strcmp(const char *dest,const char *src)
{
200014d6:	b480      	push	{r7}
200014d8:	b083      	sub	sp, #12
200014da:	af00      	add	r7, sp, #0
200014dc:	6078      	str	r0, [r7, #4]
200014de:	6039      	str	r1, [r7, #0]
    while (*src && *dest) {
200014e0:	e016      	b.n	20001510 <lib_strcmp+0x3a>
	if (*dest < *src) return -1;
200014e2:	687b      	ldr	r3, [r7, #4]
200014e4:	781a      	ldrb	r2, [r3, #0]
200014e6:	683b      	ldr	r3, [r7, #0]
200014e8:	781b      	ldrb	r3, [r3, #0]
200014ea:	429a      	cmp	r2, r3
200014ec:	d202      	bcs.n	200014f4 <lib_strcmp+0x1e>
200014ee:	f04f 33ff 	mov.w	r3, #4294967295	@ 0xffffffff
200014f2:	e02b      	b.n	2000154c <lib_strcmp+0x76>
	if (*dest > *src) return 1;
200014f4:	687b      	ldr	r3, [r7, #4]
200014f6:	781a      	ldrb	r2, [r3, #0]
200014f8:	683b      	ldr	r3, [r7, #0]
200014fa:	781b      	ldrb	r3, [r3, #0]
200014fc:	429a      	cmp	r2, r3
200014fe:	d901      	bls.n	20001504 <lib_strcmp+0x2e>
20001500:	2301      	movs	r3, #1
20001502:	e023      	b.n	2000154c <lib_strcmp+0x76>
	dest++;	
20001504:	687b      	ldr	r3, [r7, #4]
20001506:	3301      	adds	r3, #1
20001508:	607b      	str	r3, [r7, #4]
	src++;
2000150a:	683b      	ldr	r3, [r7, #0]
2000150c:	3301      	adds	r3, #1
2000150e:	603b      	str	r3, [r7, #0]
    while (*src && *dest) {
20001510:	683b      	ldr	r3, [r7, #0]
20001512:	781b      	ldrb	r3, [r3, #0]
20001514:	2b00      	cmp	r3, #0
20001516:	d003      	beq.n	20001520 <lib_strcmp+0x4a>
20001518:	687b      	ldr	r3, [r7, #4]
2000151a:	781b      	ldrb	r3, [r3, #0]
2000151c:	2b00      	cmp	r3, #0
2000151e:	d1e0      	bne.n	200014e2 <lib_strcmp+0xc>
	}

    if (*dest && !*src) return 1;
20001520:	687b      	ldr	r3, [r7, #4]
20001522:	781b      	ldrb	r3, [r3, #0]
20001524:	2b00      	cmp	r3, #0
20001526:	d005      	beq.n	20001534 <lib_strcmp+0x5e>
20001528:	683b      	ldr	r3, [r7, #0]
2000152a:	781b      	ldrb	r3, [r3, #0]
2000152c:	2b00      	cmp	r3, #0
2000152e:	d101      	bne.n	20001534 <lib_strcmp+0x5e>
20001530:	2301      	movs	r3, #1
20001532:	e00b      	b.n	2000154c <lib_strcmp+0x76>
    if (!*dest && *src) return -1;
20001534:	687b      	ldr	r3, [r7, #4]
20001536:	781b      	ldrb	r3, [r3, #0]
20001538:	2b00      	cmp	r3, #0
2000153a:	d106      	bne.n	2000154a <lib_strcmp+0x74>
2000153c:	683b      	ldr	r3, [r7, #0]
2000153e:	781b      	ldrb	r3, [r3, #0]
20001540:	2b00      	cmp	r3, #0
20001542:	d002      	beq.n	2000154a <lib_strcmp+0x74>
20001544:	f04f 33ff 	mov.w	r3, #4294967295	@ 0xffffffff
20001548:	e000      	b.n	2000154c <lib_strcmp+0x76>
    return 0;
2000154a:	2300      	movs	r3, #0
}
2000154c:	4618      	mov	r0, r3
2000154e:	370c      	adds	r7, #12
20001550:	46bd      	mov	sp, r7
20001552:	f85d 7b04 	ldr.w	r7, [sp], #4
20001556:	4770      	bx	lr

20001558 <lib_strchr>:
    return 0;
}


char *lib_strchr(const char *dest,int c)
{
20001558:	b480      	push	{r7}
2000155a:	b083      	sub	sp, #12
2000155c:	af00      	add	r7, sp, #0
2000155e:	6078      	str	r0, [r7, #4]
20001560:	6039      	str	r1, [r7, #0]
    while (*dest) {
20001562:	e00a      	b.n	2000157a <lib_strchr+0x22>
	if (*dest == c) return (char *) dest;
20001564:	687b      	ldr	r3, [r7, #4]
20001566:	781b      	ldrb	r3, [r3, #0]
20001568:	461a      	mov	r2, r3
2000156a:	683b      	ldr	r3, [r7, #0]
2000156c:	4293      	cmp	r3, r2
2000156e:	d101      	bne.n	20001574 <lib_strchr+0x1c>
20001570:	687b      	ldr	r3, [r7, #4]
20001572:	e007      	b.n	20001584 <lib_strchr+0x2c>
	dest++;
20001574:	687b      	ldr	r3, [r7, #4]
20001576:	3301      	adds	r3, #1
20001578:	607b      	str	r3, [r7, #4]
    while (*dest) {
2000157a:	687b      	ldr	r3, [r7, #4]
2000157c:	781b      	ldrb	r3, [r3, #0]
2000157e:	2b00      	cmp	r3, #0
20001580:	d1f0      	bne.n	20001564 <lib_strchr+0xc>
	}
    return NULL;
20001582:	2300      	movs	r3, #0
}
20001584:	4618      	mov	r0, r3
20001586:	370c      	adds	r7, #12
20001588:	46bd      	mov	sp, r7
2000158a:	f85d 7b04 	ldr.w	r7, [sp], #4
2000158e:	4770      	bx	lr

20001590 <lib_memcmp>:
    return ret;
}


int lib_memcmp(const void *dest,const void *src,size_t cnt)
{
20001590:	b480      	push	{r7}
20001592:	b087      	sub	sp, #28
20001594:	af00      	add	r7, sp, #0
20001596:	60f8      	str	r0, [r7, #12]
20001598:	60b9      	str	r1, [r7, #8]
2000159a:	607a      	str	r2, [r7, #4]
    const unsigned char *d;
    const unsigned char *s;

    d = (const unsigned char *) dest;
2000159c:	68fb      	ldr	r3, [r7, #12]
2000159e:	617b      	str	r3, [r7, #20]
    s = (const unsigned char *) src;
200015a0:	68bb      	ldr	r3, [r7, #8]
200015a2:	613b      	str	r3, [r7, #16]

    while (cnt) {
200015a4:	e019      	b.n	200015da <lib_memcmp+0x4a>
	if (*d < *s) return -1;
200015a6:	697b      	ldr	r3, [r7, #20]
200015a8:	781a      	ldrb	r2, [r3, #0]
200015aa:	693b      	ldr	r3, [r7, #16]
200015ac:	781b      	ldrb	r3, [r3, #0]
200015ae:	429a      	cmp	r2, r3
200015b0:	d202      	bcs.n	200015b8 <lib_memcmp+0x28>
200015b2:	f04f 33ff 	mov.w	r3, #4294967295	@ 0xffffffff
200015b6:	e014      	b.n	200015e2 <lib_memcmp+0x52>
	if (*d > *s) return 1;
200015b8:	697b      	ldr	r3, [r7, #20]
200015ba:	781a      	ldrb	r2, [r3, #0]
200015bc:	693b      	ldr	r3, [r7, #16]
200015be:	781b      	ldrb	r3, [r3, #0]
200015c0:	429a      	cmp	r2, r3
200015c2:	d901      	bls.n	200015c8 <lib_memcmp+0x38>
200015c4:	2301      	movs	r3, #1
200015c6:	e00c      	b.n	200015e2 <lib_memcmp+0x52>
	d++; s++; cnt--;
200015c8:	697b      	ldr	r3, [r7, #20]
200015ca:	3301      	adds	r3, #1
200015cc:	617b      	str	r3, [r7, #20]
200015ce:	693b      	ldr	r3, [r7, #16]
200015d0:	3301      	adds	r3, #1
200015d2:	613b      	str	r3, [r7, #16]
200015d4:	687b      	ldr	r3, [r7, #4]
200015d6:	3b01      	subs	r3, #1
200015d8:	607b      	str	r3, [r7, #4]
    while (cnt) {
200015da:	687b      	ldr	r3, [r7, #4]
200015dc:	2b00      	cmp	r3, #0
200015de:	d1e2      	bne.n	200015a6 <lib_memcmp+0x16>
	}

    return 0;
200015e0:	2300      	movs	r3, #0
}
200015e2:	4618      	mov	r0, r3
200015e4:	371c      	adds	r7, #28
200015e6:	46bd      	mov	sp, r7
200015e8:	f85d 7b04 	ldr.w	r7, [sp], #4
200015ec:	4770      	bx	lr

200015ee <lib_memcpy>:

void *lib_memcpy(void *dest,const void *src,size_t cnt)
{
200015ee:	b480      	push	{r7}
200015f0:	b087      	sub	sp, #28
200015f2:	af00      	add	r7, sp, #0
200015f4:	60f8      	str	r0, [r7, #12]
200015f6:	60b9      	str	r1, [r7, #8]
200015f8:	607a      	str	r2, [r7, #4]
    unsigned char *d;
    const unsigned char *s;

    d = (unsigned char *) dest;
200015fa:	68fb      	ldr	r3, [r7, #12]
200015fc:	617b      	str	r3, [r7, #20]
    s = (const unsigned char *) src;
200015fe:	68bb      	ldr	r3, [r7, #8]
20001600:	613b      	str	r3, [r7, #16]

    while (cnt) {
20001602:	e00a      	b.n	2000161a <lib_memcpy+0x2c>
	*d++ = *s++;
20001604:	693a      	ldr	r2, [r7, #16]
20001606:	1c53      	adds	r3, r2, #1
20001608:	613b      	str	r3, [r7, #16]
2000160a:	697b      	ldr	r3, [r7, #20]
2000160c:	1c59      	adds	r1, r3, #1
2000160e:	6179      	str	r1, [r7, #20]
20001610:	7812      	ldrb	r2, [r2, #0]
20001612:	701a      	strb	r2, [r3, #0]
	cnt--;
20001614:	687b      	ldr	r3, [r7, #4]
20001616:	3b01      	subs	r3, #1
20001618:	607b      	str	r3, [r7, #4]
    while (cnt) {
2000161a:	687b      	ldr	r3, [r7, #4]
2000161c:	2b00      	cmp	r3, #0
2000161e:	d1f1      	bne.n	20001604 <lib_memcpy+0x16>
	}

    return dest;
20001620:	68fb      	ldr	r3, [r7, #12]
}
20001622:	4618      	mov	r0, r3
20001624:	371c      	adds	r7, #28
20001626:	46bd      	mov	sp, r7
20001628:	f85d 7b04 	ldr.w	r7, [sp], #4
2000162c:	4770      	bx	lr

2000162e <lib_memset>:

void *lib_memset(void *dest,int c,size_t cnt)
{
2000162e:	b480      	push	{r7}
20001630:	b087      	sub	sp, #28
20001632:	af00      	add	r7, sp, #0
20001634:	60f8      	str	r0, [r7, #12]
20001636:	60b9      	str	r1, [r7, #8]
20001638:	607a      	str	r2, [r7, #4]
    unsigned char *d;

    d = dest;
2000163a:	68fb      	ldr	r3, [r7, #12]
2000163c:	617b      	str	r3, [r7, #20]

    while (cnt) {
2000163e:	e008      	b.n	20001652 <lib_memset+0x24>
	*d++ = (unsigned char) c;
20001640:	697b      	ldr	r3, [r7, #20]
20001642:	1c5a      	adds	r2, r3, #1
20001644:	617a      	str	r2, [r7, #20]
20001646:	68ba      	ldr	r2, [r7, #8]
20001648:	b2d2      	uxtb	r2, r2
2000164a:	701a      	strb	r2, [r3, #0]
	cnt--;
2000164c:	687b      	ldr	r3, [r7, #4]
2000164e:	3b01      	subs	r3, #1
20001650:	607b      	str	r3, [r7, #4]
    while (cnt) {
20001652:	687b      	ldr	r3, [r7, #4]
20001654:	2b00      	cmp	r3, #0
20001656:	d1f3      	bne.n	20001640 <lib_memset+0x12>
	}

    return d;
20001658:	697b      	ldr	r3, [r7, #20]
}
2000165a:	4618      	mov	r0, r3
2000165c:	371c      	adds	r7, #28
2000165e:	46bd      	mov	sp, r7
20001660:	f85d 7b04 	ldr.w	r7, [sp], #4
20001664:	4770      	bx	lr

20001666 <lib_strcat>:
	str++;
	}
}

char *lib_strcat(char *dest,const char *src)
{
20001666:	b480      	push	{r7}
20001668:	b085      	sub	sp, #20
2000166a:	af00      	add	r7, sp, #0
2000166c:	6078      	str	r0, [r7, #4]
2000166e:	6039      	str	r1, [r7, #0]
    char *ptr = dest;
20001670:	687b      	ldr	r3, [r7, #4]
20001672:	60fb      	str	r3, [r7, #12]

    while (*ptr) ptr++;
20001674:	e002      	b.n	2000167c <lib_strcat+0x16>
20001676:	68fb      	ldr	r3, [r7, #12]
20001678:	3301      	adds	r3, #1
2000167a:	60fb      	str	r3, [r7, #12]
2000167c:	68fb      	ldr	r3, [r7, #12]
2000167e:	781b      	ldrb	r3, [r3, #0]
20001680:	2b00      	cmp	r3, #0
20001682:	d1f8      	bne.n	20001676 <lib_strcat+0x10>
    while (*src) *ptr++ = *src++;
20001684:	e007      	b.n	20001696 <lib_strcat+0x30>
20001686:	683a      	ldr	r2, [r7, #0]
20001688:	1c53      	adds	r3, r2, #1
2000168a:	603b      	str	r3, [r7, #0]
2000168c:	68fb      	ldr	r3, [r7, #12]
2000168e:	1c59      	adds	r1, r3, #1
20001690:	60f9      	str	r1, [r7, #12]
20001692:	7812      	ldrb	r2, [r2, #0]
20001694:	701a      	strb	r2, [r3, #0]
20001696:	683b      	ldr	r3, [r7, #0]
20001698:	781b      	ldrb	r3, [r3, #0]
2000169a:	2b00      	cmp	r3, #0
2000169c:	d1f3      	bne.n	20001686 <lib_strcat+0x20>
    *ptr = '\0';
2000169e:	68fb      	ldr	r3, [r7, #12]
200016a0:	2200      	movs	r2, #0
200016a2:	701a      	strb	r2, [r3, #0]

    return dest;
200016a4:	687b      	ldr	r3, [r7, #4]
}
200016a6:	4618      	mov	r0, r3
200016a8:	3714      	adds	r7, #20
200016aa:	46bd      	mov	sp, r7
200016ac:	f85d 7b04 	ldr.w	r7, [sp], #4
200016b0:	4770      	bx	lr

200016b2 <lib_gettoken>:

#define isspace(x) (((x) == ' ') || ((x) == '\t'))

char *lib_gettoken(char **ptr)
{
200016b2:	b480      	push	{r7}
200016b4:	b085      	sub	sp, #20
200016b6:	af00      	add	r7, sp, #0
200016b8:	6078      	str	r0, [r7, #4]
    char *p = *ptr;
200016ba:	687b      	ldr	r3, [r7, #4]
200016bc:	681b      	ldr	r3, [r3, #0]
200016be:	60fb      	str	r3, [r7, #12]
    char *ret;

    /* skip white space */

    while (*p && isspace(*p)) p++;
200016c0:	e002      	b.n	200016c8 <lib_gettoken+0x16>
200016c2:	68fb      	ldr	r3, [r7, #12]
200016c4:	3301      	adds	r3, #1
200016c6:	60fb      	str	r3, [r7, #12]
200016c8:	68fb      	ldr	r3, [r7, #12]
200016ca:	781b      	ldrb	r3, [r3, #0]
200016cc:	2b00      	cmp	r3, #0
200016ce:	d007      	beq.n	200016e0 <lib_gettoken+0x2e>
200016d0:	68fb      	ldr	r3, [r7, #12]
200016d2:	781b      	ldrb	r3, [r3, #0]
200016d4:	2b20      	cmp	r3, #32
200016d6:	d0f4      	beq.n	200016c2 <lib_gettoken+0x10>
200016d8:	68fb      	ldr	r3, [r7, #12]
200016da:	781b      	ldrb	r3, [r3, #0]
200016dc:	2b09      	cmp	r3, #9
200016de:	d0f0      	beq.n	200016c2 <lib_gettoken+0x10>
    ret = p;
200016e0:	68fb      	ldr	r3, [r7, #12]
200016e2:	60bb      	str	r3, [r7, #8]

    /* check for end of string */

    if (!*p) {
200016e4:	68fb      	ldr	r3, [r7, #12]
200016e6:	781b      	ldrb	r3, [r3, #0]
200016e8:	2b00      	cmp	r3, #0
200016ea:	d12b      	bne.n	20001744 <lib_gettoken+0x92>
	*ptr = p;
200016ec:	687b      	ldr	r3, [r7, #4]
200016ee:	68fa      	ldr	r2, [r7, #12]
200016f0:	601a      	str	r2, [r3, #0]
	return NULL;
200016f2:	2300      	movs	r3, #0
200016f4:	e037      	b.n	20001766 <lib_gettoken+0xb4>
	}

    /* skip non-whitespace */

    while (*p) {
	if (isspace(*p)) break;
200016f6:	68fb      	ldr	r3, [r7, #12]
200016f8:	781b      	ldrb	r3, [r3, #0]
200016fa:	2b20      	cmp	r3, #32
200016fc:	d026      	beq.n	2000174c <lib_gettoken+0x9a>
200016fe:	68fb      	ldr	r3, [r7, #12]
20001700:	781b      	ldrb	r3, [r3, #0]
20001702:	2b09      	cmp	r3, #9
20001704:	d022      	beq.n	2000174c <lib_gettoken+0x9a>

	/* do quoted strings */

	if (*p == '"') {
20001706:	68fb      	ldr	r3, [r7, #12]
20001708:	781b      	ldrb	r3, [r3, #0]
2000170a:	2b22      	cmp	r3, #34	@ 0x22
2000170c:	d117      	bne.n	2000173e <lib_gettoken+0x8c>
	    p++;
2000170e:	68fb      	ldr	r3, [r7, #12]
20001710:	3301      	adds	r3, #1
20001712:	60fb      	str	r3, [r7, #12]
	    ret = p;
20001714:	68fb      	ldr	r3, [r7, #12]
20001716:	60bb      	str	r3, [r7, #8]
	    while (*p && (*p != '"')) p++;
20001718:	e002      	b.n	20001720 <lib_gettoken+0x6e>
2000171a:	68fb      	ldr	r3, [r7, #12]
2000171c:	3301      	adds	r3, #1
2000171e:	60fb      	str	r3, [r7, #12]
20001720:	68fb      	ldr	r3, [r7, #12]
20001722:	781b      	ldrb	r3, [r3, #0]
20001724:	2b00      	cmp	r3, #0
20001726:	d003      	beq.n	20001730 <lib_gettoken+0x7e>
20001728:	68fb      	ldr	r3, [r7, #12]
2000172a:	781b      	ldrb	r3, [r3, #0]
2000172c:	2b22      	cmp	r3, #34	@ 0x22
2000172e:	d1f4      	bne.n	2000171a <lib_gettoken+0x68>
	    if (*p == '"') *p = '\0';
20001730:	68fb      	ldr	r3, [r7, #12]
20001732:	781b      	ldrb	r3, [r3, #0]
20001734:	2b22      	cmp	r3, #34	@ 0x22
20001736:	d102      	bne.n	2000173e <lib_gettoken+0x8c>
20001738:	68fb      	ldr	r3, [r7, #12]
2000173a:	2200      	movs	r2, #0
2000173c:	701a      	strb	r2, [r3, #0]
	    }

        p++;
2000173e:	68fb      	ldr	r3, [r7, #12]
20001740:	3301      	adds	r3, #1
20001742:	60fb      	str	r3, [r7, #12]
    while (*p) {
20001744:	68fb      	ldr	r3, [r7, #12]
20001746:	781b      	ldrb	r3, [r3, #0]
20001748:	2b00      	cmp	r3, #0
2000174a:	d1d4      	bne.n	200016f6 <lib_gettoken+0x44>

	}

    if (*p) {
2000174c:	68fb      	ldr	r3, [r7, #12]
2000174e:	781b      	ldrb	r3, [r3, #0]
20001750:	2b00      	cmp	r3, #0
20001752:	d004      	beq.n	2000175e <lib_gettoken+0xac>
        *p++ = '\0';
20001754:	68fb      	ldr	r3, [r7, #12]
20001756:	1c5a      	adds	r2, r3, #1
20001758:	60fa      	str	r2, [r7, #12]
2000175a:	2200      	movs	r2, #0
2000175c:	701a      	strb	r2, [r3, #0]
        }
    *ptr = p;
2000175e:	687b      	ldr	r3, [r7, #4]
20001760:	68fa      	ldr	r2, [r7, #12]
20001762:	601a      	str	r2, [r3, #0]

    return ret;
20001764:	68bb      	ldr	r3, [r7, #8]
}
20001766:	4618      	mov	r0, r3
20001768:	3714      	adds	r7, #20
2000176a:	46bd      	mov	sp, r7
2000176c:	f85d 7b04 	ldr.w	r7, [sp], #4
20001770:	4770      	bx	lr

20001772 <lib_atoi>:


int lib_atoi(const char *dest)
{
20001772:	b580      	push	{r7, lr}
20001774:	b084      	sub	sp, #16
20001776:	af00      	add	r7, sp, #0
20001778:	6078      	str	r0, [r7, #4]
    int x = 0;
2000177a:	2300      	movs	r3, #0
2000177c:	60fb      	str	r3, [r7, #12]
    int digit;

    if ((*dest == '0') && (*(dest+1) == 'x')) {
2000177e:	687b      	ldr	r3, [r7, #4]
20001780:	781b      	ldrb	r3, [r3, #0]
20001782:	2b30      	cmp	r3, #48	@ 0x30
20001784:	d124      	bne.n	200017d0 <lib_atoi+0x5e>
20001786:	687b      	ldr	r3, [r7, #4]
20001788:	3301      	adds	r3, #1
2000178a:	781b      	ldrb	r3, [r3, #0]
2000178c:	2b78      	cmp	r3, #120	@ 0x78
2000178e:	d11f      	bne.n	200017d0 <lib_atoi+0x5e>
	return lib_xtoi(dest+2);
20001790:	687b      	ldr	r3, [r7, #4]
20001792:	3302      	adds	r3, #2
20001794:	4618      	mov	r0, r3
20001796:	f000 f88a 	bl	200018ae <lib_xtoi>
2000179a:	4603      	mov	r3, r0
2000179c:	e01d      	b.n	200017da <lib_atoi+0x68>
	}

    while (*dest) {
	if ((*dest >= '0') && (*dest <= '9')) {
2000179e:	687b      	ldr	r3, [r7, #4]
200017a0:	781b      	ldrb	r3, [r3, #0]
200017a2:	2b2f      	cmp	r3, #47	@ 0x2f
200017a4:	d918      	bls.n	200017d8 <lib_atoi+0x66>
200017a6:	687b      	ldr	r3, [r7, #4]
200017a8:	781b      	ldrb	r3, [r3, #0]
200017aa:	2b39      	cmp	r3, #57	@ 0x39
200017ac:	d814      	bhi.n	200017d8 <lib_atoi+0x66>
	    digit = *dest - '0';
200017ae:	687b      	ldr	r3, [r7, #4]
200017b0:	781b      	ldrb	r3, [r3, #0]
200017b2:	3b30      	subs	r3, #48	@ 0x30
200017b4:	60bb      	str	r3, [r7, #8]
	    }
	else {
	    break;
	    }
	x *= 10;
200017b6:	68fa      	ldr	r2, [r7, #12]
200017b8:	4613      	mov	r3, r2
200017ba:	009b      	lsls	r3, r3, #2
200017bc:	4413      	add	r3, r2
200017be:	005b      	lsls	r3, r3, #1
200017c0:	60fb      	str	r3, [r7, #12]
	x += digit;
200017c2:	68fa      	ldr	r2, [r7, #12]
200017c4:	68bb      	ldr	r3, [r7, #8]
200017c6:	4413      	add	r3, r2
200017c8:	60fb      	str	r3, [r7, #12]
	dest++;
200017ca:	687b      	ldr	r3, [r7, #4]
200017cc:	3301      	adds	r3, #1
200017ce:	607b      	str	r3, [r7, #4]
    while (*dest) {
200017d0:	687b      	ldr	r3, [r7, #4]
200017d2:	781b      	ldrb	r3, [r3, #0]
200017d4:	2b00      	cmp	r3, #0
200017d6:	d1e2      	bne.n	2000179e <lib_atoi+0x2c>
	}

    return x;
200017d8:	68fb      	ldr	r3, [r7, #12]
}
200017da:	4618      	mov	r0, r3
200017dc:	3710      	adds	r7, #16
200017de:	46bd      	mov	sp, r7
200017e0:	bd80      	pop	{r7, pc}

200017e2 <lib_xtoq>:

uint64_t lib_xtoq(const char *dest)
{
200017e2:	e92d 03b0 	stmdb	sp!, {r4, r5, r7, r8, r9}
200017e6:	b087      	sub	sp, #28
200017e8:	af00      	add	r7, sp, #0
200017ea:	6078      	str	r0, [r7, #4]
    uint64_t x = 0;
200017ec:	f04f 0200 	mov.w	r2, #0
200017f0:	f04f 0300 	mov.w	r3, #0
200017f4:	e9c7 2304 	strd	r2, r3, [r7, #16]
    unsigned int digit;

    if ((*dest == '0') && (*(dest+1) == 'x')) dest += 2;
200017f8:	687b      	ldr	r3, [r7, #4]
200017fa:	781b      	ldrb	r3, [r3, #0]
200017fc:	2b30      	cmp	r3, #48	@ 0x30
200017fe:	d149      	bne.n	20001894 <lib_xtoq+0xb2>
20001800:	687b      	ldr	r3, [r7, #4]
20001802:	3301      	adds	r3, #1
20001804:	781b      	ldrb	r3, [r3, #0]
20001806:	2b78      	cmp	r3, #120	@ 0x78
20001808:	d144      	bne.n	20001894 <lib_xtoq+0xb2>
2000180a:	687b      	ldr	r3, [r7, #4]
2000180c:	3302      	adds	r3, #2
2000180e:	607b      	str	r3, [r7, #4]

    while (*dest) {
20001810:	e040      	b.n	20001894 <lib_xtoq+0xb2>
	if ((*dest >= '0') && (*dest <= '9')) {
20001812:	687b      	ldr	r3, [r7, #4]
20001814:	781b      	ldrb	r3, [r3, #0]
20001816:	2b2f      	cmp	r3, #47	@ 0x2f
20001818:	d908      	bls.n	2000182c <lib_xtoq+0x4a>
2000181a:	687b      	ldr	r3, [r7, #4]
2000181c:	781b      	ldrb	r3, [r3, #0]
2000181e:	2b39      	cmp	r3, #57	@ 0x39
20001820:	d804      	bhi.n	2000182c <lib_xtoq+0x4a>
	    digit = *dest - '0';
20001822:	687b      	ldr	r3, [r7, #4]
20001824:	781b      	ldrb	r3, [r3, #0]
20001826:	3b30      	subs	r3, #48	@ 0x30
20001828:	60fb      	str	r3, [r7, #12]
2000182a:	e018      	b.n	2000185e <lib_xtoq+0x7c>
	    }
	else if ((*dest >= 'A') && (*dest <= 'F')) {
2000182c:	687b      	ldr	r3, [r7, #4]
2000182e:	781b      	ldrb	r3, [r3, #0]
20001830:	2b40      	cmp	r3, #64	@ 0x40
20001832:	d908      	bls.n	20001846 <lib_xtoq+0x64>
20001834:	687b      	ldr	r3, [r7, #4]
20001836:	781b      	ldrb	r3, [r3, #0]
20001838:	2b46      	cmp	r3, #70	@ 0x46
2000183a:	d804      	bhi.n	20001846 <lib_xtoq+0x64>
	    digit = 10 + *dest - 'A';
2000183c:	687b      	ldr	r3, [r7, #4]
2000183e:	781b      	ldrb	r3, [r3, #0]
20001840:	3b37      	subs	r3, #55	@ 0x37
20001842:	60fb      	str	r3, [r7, #12]
20001844:	e00b      	b.n	2000185e <lib_xtoq+0x7c>
	    }
	else if ((*dest >= 'a') && (*dest <= 'f')) {
20001846:	687b      	ldr	r3, [r7, #4]
20001848:	781b      	ldrb	r3, [r3, #0]
2000184a:	2b60      	cmp	r3, #96	@ 0x60
2000184c:	d926      	bls.n	2000189c <lib_xtoq+0xba>
2000184e:	687b      	ldr	r3, [r7, #4]
20001850:	781b      	ldrb	r3, [r3, #0]
20001852:	2b66      	cmp	r3, #102	@ 0x66
20001854:	d822      	bhi.n	2000189c <lib_xtoq+0xba>
	    digit = 10 + *dest - 'a';
20001856:	687b      	ldr	r3, [r7, #4]
20001858:	781b      	ldrb	r3, [r3, #0]
2000185a:	3b57      	subs	r3, #87	@ 0x57
2000185c:	60fb      	str	r3, [r7, #12]
	    }
	else {
	    break;
	    }
	x *= 16;
2000185e:	e9d7 0104 	ldrd	r0, r1, [r7, #16]
20001862:	f04f 0200 	mov.w	r2, #0
20001866:	f04f 0300 	mov.w	r3, #0
2000186a:	010b      	lsls	r3, r1, #4
2000186c:	ea43 7310 	orr.w	r3, r3, r0, lsr #28
20001870:	0102      	lsls	r2, r0, #4
20001872:	e9c7 2304 	strd	r2, r3, [r7, #16]
	x += digit;
20001876:	68fb      	ldr	r3, [r7, #12]
20001878:	2200      	movs	r2, #0
2000187a:	461c      	mov	r4, r3
2000187c:	4615      	mov	r5, r2
2000187e:	e9d7 2304 	ldrd	r2, r3, [r7, #16]
20001882:	eb12 0804 	adds.w	r8, r2, r4
20001886:	eb43 0905 	adc.w	r9, r3, r5
2000188a:	e9c7 8904 	strd	r8, r9, [r7, #16]
	dest++;
2000188e:	687b      	ldr	r3, [r7, #4]
20001890:	3301      	adds	r3, #1
20001892:	607b      	str	r3, [r7, #4]
    while (*dest) {
20001894:	687b      	ldr	r3, [r7, #4]
20001896:	781b      	ldrb	r3, [r3, #0]
20001898:	2b00      	cmp	r3, #0
2000189a:	d1ba      	bne.n	20001812 <lib_xtoq+0x30>
	}

    return x;
2000189c:	e9d7 2304 	ldrd	r2, r3, [r7, #16]
}
200018a0:	4610      	mov	r0, r2
200018a2:	4619      	mov	r1, r3
200018a4:	371c      	adds	r7, #28
200018a6:	46bd      	mov	sp, r7
200018a8:	e8bd 03b0 	ldmia.w	sp!, {r4, r5, r7, r8, r9}
200018ac:	4770      	bx	lr

200018ae <lib_xtoi>:

int lib_xtoi(const char *dest)
{
200018ae:	b480      	push	{r7}
200018b0:	b085      	sub	sp, #20
200018b2:	af00      	add	r7, sp, #0
200018b4:	6078      	str	r0, [r7, #4]
    int x = 0;
200018b6:	2300      	movs	r3, #0
200018b8:	60fb      	str	r3, [r7, #12]
    int digit;

    if ((*dest == '0') && (*(dest+1) == 'x')) dest += 2;
200018ba:	687b      	ldr	r3, [r7, #4]
200018bc:	781b      	ldrb	r3, [r3, #0]
200018be:	2b30      	cmp	r3, #48	@ 0x30
200018c0:	d138      	bne.n	20001934 <lib_xtoi+0x86>
200018c2:	687b      	ldr	r3, [r7, #4]
200018c4:	3301      	adds	r3, #1
200018c6:	781b      	ldrb	r3, [r3, #0]
200018c8:	2b78      	cmp	r3, #120	@ 0x78
200018ca:	d133      	bne.n	20001934 <lib_xtoi+0x86>
200018cc:	687b      	ldr	r3, [r7, #4]
200018ce:	3302      	adds	r3, #2
200018d0:	607b      	str	r3, [r7, #4]

    while (*dest) {
200018d2:	e02f      	b.n	20001934 <lib_xtoi+0x86>
	if ((*dest >= '0') && (*dest <= '9')) {
200018d4:	687b      	ldr	r3, [r7, #4]
200018d6:	781b      	ldrb	r3, [r3, #0]
200018d8:	2b2f      	cmp	r3, #47	@ 0x2f
200018da:	d908      	bls.n	200018ee <lib_xtoi+0x40>
200018dc:	687b      	ldr	r3, [r7, #4]
200018de:	781b      	ldrb	r3, [r3, #0]
200018e0:	2b39      	cmp	r3, #57	@ 0x39
200018e2:	d804      	bhi.n	200018ee <lib_xtoi+0x40>
	    digit = *dest - '0';
200018e4:	687b      	ldr	r3, [r7, #4]
200018e6:	781b      	ldrb	r3, [r3, #0]
200018e8:	3b30      	subs	r3, #48	@ 0x30
200018ea:	60bb      	str	r3, [r7, #8]
200018ec:	e018      	b.n	20001920 <lib_xtoi+0x72>
	    }
	else if ((*dest >= 'A') && (*dest <= 'F')) {
200018ee:	687b      	ldr	r3, [r7, #4]
200018f0:	781b      	ldrb	r3, [r3, #0]
200018f2:	2b40      	cmp	r3, #64	@ 0x40
200018f4:	d908      	bls.n	20001908 <lib_xtoi+0x5a>
200018f6:	687b      	ldr	r3, [r7, #4]
200018f8:	781b      	ldrb	r3, [r3, #0]
200018fa:	2b46      	cmp	r3, #70	@ 0x46
200018fc:	d804      	bhi.n	20001908 <lib_xtoi+0x5a>
	    digit = 10 + *dest - 'A';
200018fe:	687b      	ldr	r3, [r7, #4]
20001900:	781b      	ldrb	r3, [r3, #0]
20001902:	3b37      	subs	r3, #55	@ 0x37
20001904:	60bb      	str	r3, [r7, #8]
20001906:	e00b      	b.n	20001920 <lib_xtoi+0x72>
	    }
	else if ((*dest >= 'a') && (*dest <= 'f')) {
20001908:	687b      	ldr	r3, [r7, #4]
2000190a:	781b      	ldrb	r3, [r3, #0]
2000190c:	2b60      	cmp	r3, #96	@ 0x60
2000190e:	d915      	bls.n	2000193c <lib_xtoi+0x8e>
20001910:	687b      	ldr	r3, [r7, #4]
20001912:	781b      	ldrb	r3, [r3, #0]
20001914:	2b66      	cmp	r3, #102	@ 0x66
20001916:	d811      	bhi.n	2000193c <lib_xtoi+0x8e>
	    digit = 10 + *dest - 'a';
20001918:	687b      	ldr	r3, [r7, #4]
2000191a:	781b      	ldrb	r3, [r3, #0]
2000191c:	3b57      	subs	r3, #87	@ 0x57
2000191e:	60bb      	str	r3, [r7, #8]
	    }
	else {
	    break;
	    }
	x *= 16;
20001920:	68fb      	ldr	r3, [r7, #12]
20001922:	011b      	lsls	r3, r3, #4
20001924:	60fb      	str	r3, [r7, #12]
	x += digit;
20001926:	68fa      	ldr	r2, [r7, #12]
20001928:	68bb      	ldr	r3, [r7, #8]
2000192a:	4413      	add	r3, r2
2000192c:	60fb      	str	r3, [r7, #12]
	dest++;
2000192e:	687b      	ldr	r3, [r7, #4]
20001930:	3301      	adds	r3, #1
20001932:	607b      	str	r3, [r7, #4]
    while (*dest) {
20001934:	687b      	ldr	r3, [r7, #4]
20001936:	781b      	ldrb	r3, [r3, #0]
20001938:	2b00      	cmp	r3, #0
2000193a:	d1cb      	bne.n	200018d4 <lib_xtoi+0x26>
	}

    return x;
2000193c:	68fb      	ldr	r3, [r7, #12]
}
2000193e:	4618      	mov	r0, r3
20001940:	3714      	adds	r7, #20
20001942:	46bd      	mov	sp, r7
20001944:	f85d 7b04 	ldr.w	r7, [sp], #4
20001948:	4770      	bx	lr
	...

2000194c <lib_strdup>:
#define _LIB_NO_MACROS_
#include "lib_string.h"


char *lib_strdup(char *str)
{
2000194c:	b580      	push	{r7, lr}
2000194e:	b084      	sub	sp, #16
20001950:	af00      	add	r7, sp, #0
20001952:	6078      	str	r0, [r7, #4]
    char *buf;

    buf = KMALLOC(lib_strlen(str)+1,0);
20001954:	6878      	ldr	r0, [r7, #4]
20001956:	f7ff fda6 	bl	200014a6 <lib_strlen>
2000195a:	4603      	mov	r3, r0
2000195c:	3301      	adds	r3, #1
2000195e:	2200      	movs	r2, #0
20001960:	4619      	mov	r1, r3
20001962:	4808      	ldr	r0, [pc, #32]	@ (20001984 <lib_strdup+0x38>)
20001964:	f7ff fbb8 	bl	200010d8 <kmalloc>
20001968:	60f8      	str	r0, [r7, #12]
    if (buf) {
2000196a:	68fb      	ldr	r3, [r7, #12]
2000196c:	2b00      	cmp	r3, #0
2000196e:	d003      	beq.n	20001978 <lib_strdup+0x2c>
	lib_strcpy(buf,str);
20001970:	6879      	ldr	r1, [r7, #4]
20001972:	68f8      	ldr	r0, [r7, #12]
20001974:	f7ff fd4f 	bl	20001416 <lib_strcpy>
	}

    return buf;
20001978:	68fb      	ldr	r3, [r7, #12]
}
2000197a:	4618      	mov	r0, r3
2000197c:	3710      	adds	r7, #16
2000197e:	46bd      	mov	sp, r7
20001980:	bd80      	pop	{r7, pc}
20001982:	bf00      	nop
20001984:	200091fc 	.word	0x200091fc

20001988 <exc_initialize_block>:
    *  	   
    *  Return value:
    *  	   jmpbuf_t structure, or NULL if no memory
    ********************************************************************* */
jmpbuf_t *exc_initialize_block(void)
{
20001988:	b580      	push	{r7, lr}
2000198a:	b082      	sub	sp, #8
2000198c:	af00      	add	r7, sp, #0
    jmpbuf_t *jmpbuf_local;

    exc_handler.catch_exc = 1;
2000198e:	4b0c      	ldr	r3, [pc, #48]	@ (200019c0 <exc_initialize_block+0x38>)
20001990:	2201      	movs	r2, #1
20001992:	601a      	str	r2, [r3, #0]
  
    /* Create the jmpbuf_t object */
    jmpbuf_local = (jmpbuf_t *) KMALLOC((sizeof(jmpbuf_t)),0);
20001994:	2200      	movs	r2, #0
20001996:	2160      	movs	r1, #96	@ 0x60
20001998:	480a      	ldr	r0, [pc, #40]	@ (200019c4 <exc_initialize_block+0x3c>)
2000199a:	f7ff fb9d 	bl	200010d8 <kmalloc>
2000199e:	6078      	str	r0, [r7, #4]

    if (jmpbuf_local == NULL) {
200019a0:	687b      	ldr	r3, [r7, #4]
200019a2:	2b00      	cmp	r3, #0
200019a4:	d101      	bne.n	200019aa <exc_initialize_block+0x22>
	return NULL;
200019a6:	2300      	movs	r3, #0
200019a8:	e005      	b.n	200019b6 <exc_initialize_block+0x2e>
	}

    q_enqueue( &(exc_handler.jmpbuf_stack), &((*jmpbuf_local).stack));
200019aa:	687b      	ldr	r3, [r7, #4]
200019ac:	4619      	mov	r1, r3
200019ae:	4806      	ldr	r0, [pc, #24]	@ (200019c8 <exc_initialize_block+0x40>)
200019b0:	f7ff fcca 	bl	20001348 <q_enqueue>

    return jmpbuf_local;
200019b4:	687b      	ldr	r3, [r7, #4]
}
200019b6:	4618      	mov	r0, r3
200019b8:	3708      	adds	r7, #8
200019ba:	46bd      	mov	sp, r7
200019bc:	bd80      	pop	{r7, pc}
200019be:	bf00      	nop
200019c0:	20009208 	.word	0x20009208
200019c4:	200091fc 	.word	0x200091fc
200019c8:	20009210 	.word	0x20009210

200019cc <cfe_finddev>:
    *  Return value:
    *  	   cfe_device_t pointer or NULL
    ********************************************************************* */

cfe_device_t *cfe_finddev(char *name)
{
200019cc:	b580      	push	{r7, lr}
200019ce:	b084      	sub	sp, #16
200019d0:	af00      	add	r7, sp, #0
200019d2:	6078      	str	r0, [r7, #4]
    queue_t *qb;
    cfe_device_t *dev;

    for (qb = cfe_devices.q_next; qb != &cfe_devices; qb = qb->q_next) {
200019d4:	4b0e      	ldr	r3, [pc, #56]	@ (20001a10 <cfe_finddev+0x44>)
200019d6:	681b      	ldr	r3, [r3, #0]
200019d8:	60fb      	str	r3, [r7, #12]
200019da:	e00f      	b.n	200019fc <cfe_finddev+0x30>
	dev = (cfe_device_t *) qb;
200019dc:	68fb      	ldr	r3, [r7, #12]
200019de:	60bb      	str	r3, [r7, #8]
	if (strcmp(dev->dev_fullname,name) == 0) {
200019e0:	68bb      	ldr	r3, [r7, #8]
200019e2:	689b      	ldr	r3, [r3, #8]
200019e4:	6879      	ldr	r1, [r7, #4]
200019e6:	4618      	mov	r0, r3
200019e8:	f7ff fd75 	bl	200014d6 <lib_strcmp>
200019ec:	4603      	mov	r3, r0
200019ee:	2b00      	cmp	r3, #0
200019f0:	d101      	bne.n	200019f6 <cfe_finddev+0x2a>
	    return dev;
200019f2:	68bb      	ldr	r3, [r7, #8]
200019f4:	e007      	b.n	20001a06 <cfe_finddev+0x3a>
    for (qb = cfe_devices.q_next; qb != &cfe_devices; qb = qb->q_next) {
200019f6:	68fb      	ldr	r3, [r7, #12]
200019f8:	681b      	ldr	r3, [r3, #0]
200019fa:	60fb      	str	r3, [r7, #12]
200019fc:	68fb      	ldr	r3, [r7, #12]
200019fe:	4a04      	ldr	r2, [pc, #16]	@ (20001a10 <cfe_finddev+0x44>)
20001a00:	4293      	cmp	r3, r2
20001a02:	d1eb      	bne.n	200019dc <cfe_finddev+0x10>
	    }
	}

    return NULL;
20001a04:	2300      	movs	r3, #0
}
20001a06:	4618      	mov	r0, r3
20001a08:	3710      	adds	r7, #16
20001a0a:	46bd      	mov	sp, r7
20001a0c:	bd80      	pop	{r7, pc}
20001a0e:	bf00      	nop
20001a10:	2000906c 	.word	0x2000906c

20001a14 <cfe_dev_enum>:
    *  	   0 if ok
    *  	   else -1
    ********************************************************************* */

int cfe_dev_enum(int idx,char *name,int *namelen)
{
20001a14:	b580      	push	{r7, lr}
20001a16:	b086      	sub	sp, #24
20001a18:	af00      	add	r7, sp, #0
20001a1a:	60f8      	str	r0, [r7, #12]
20001a1c:	60b9      	str	r1, [r7, #8]
20001a1e:	607a      	str	r2, [r7, #4]
    queue_t *qb;
    cfe_device_t *dev;

    for (qb = cfe_devices.q_next; qb != &cfe_devices; qb = qb->q_next) {
20001a20:	4b15      	ldr	r3, [pc, #84]	@ (20001a78 <cfe_dev_enum+0x64>)
20001a22:	681b      	ldr	r3, [r3, #0]
20001a24:	617b      	str	r3, [r7, #20]
20001a26:	e008      	b.n	20001a3a <cfe_dev_enum+0x26>
	if (idx == 0) break;
20001a28:	68fb      	ldr	r3, [r7, #12]
20001a2a:	2b00      	cmp	r3, #0
20001a2c:	d00a      	beq.n	20001a44 <cfe_dev_enum+0x30>
	idx--;
20001a2e:	68fb      	ldr	r3, [r7, #12]
20001a30:	3b01      	subs	r3, #1
20001a32:	60fb      	str	r3, [r7, #12]
    for (qb = cfe_devices.q_next; qb != &cfe_devices; qb = qb->q_next) {
20001a34:	697b      	ldr	r3, [r7, #20]
20001a36:	681b      	ldr	r3, [r3, #0]
20001a38:	617b      	str	r3, [r7, #20]
20001a3a:	697b      	ldr	r3, [r7, #20]
20001a3c:	4a0e      	ldr	r2, [pc, #56]	@ (20001a78 <cfe_dev_enum+0x64>)
20001a3e:	4293      	cmp	r3, r2
20001a40:	d1f2      	bne.n	20001a28 <cfe_dev_enum+0x14>
20001a42:	e000      	b.n	20001a46 <cfe_dev_enum+0x32>
	if (idx == 0) break;
20001a44:	bf00      	nop
	}

    if (qb == &cfe_devices) return (-1);
20001a46:	697b      	ldr	r3, [r7, #20]
20001a48:	4a0b      	ldr	r2, [pc, #44]	@ (20001a78 <cfe_dev_enum+0x64>)
20001a4a:	4293      	cmp	r3, r2
20001a4c:	d102      	bne.n	20001a54 <cfe_dev_enum+0x40>
20001a4e:	f04f 33ff 	mov.w	r3, #4294967295	@ 0xffffffff
20001a52:	e00d      	b.n	20001a70 <cfe_dev_enum+0x5c>
    dev = (cfe_device_t *) qb;
20001a54:	697b      	ldr	r3, [r7, #20]
20001a56:	613b      	str	r3, [r7, #16]

    *namelen = xstrncpy(name,dev->dev_fullname,*namelen);
20001a58:	693b      	ldr	r3, [r7, #16]
20001a5a:	6899      	ldr	r1, [r3, #8]
20001a5c:	687b      	ldr	r3, [r7, #4]
20001a5e:	681b      	ldr	r3, [r3, #0]
20001a60:	461a      	mov	r2, r3
20001a62:	68b8      	ldr	r0, [r7, #8]
20001a64:	f7ff fcf5 	bl	20001452 <lib_xstrncpy>
20001a68:	4602      	mov	r2, r0
20001a6a:	687b      	ldr	r3, [r7, #4]
20001a6c:	601a      	str	r2, [r3, #0]

    return 0;
20001a6e:	2300      	movs	r3, #0

}
20001a70:	4618      	mov	r0, r3
20001a72:	3718      	adds	r7, #24
20001a74:	46bd      	mov	sp, r7
20001a76:	bd80      	pop	{r7, pc}
20001a78:	2000906c 	.word	0x2000906c

20001a7c <cfe_attach_idx>:
    *  	   1 if we were successful.
    ********************************************************************* */

int cfe_attach_idx(cfe_driver_t *drv,int idx,void *softc,
		   char *bootinfo,char *description)
{
20001a7c:	b580      	push	{r7, lr}
20001a7e:	b096      	sub	sp, #88	@ 0x58
20001a80:	af00      	add	r7, sp, #0
20001a82:	60f8      	str	r0, [r7, #12]
20001a84:	60b9      	str	r1, [r7, #8]
20001a86:	607a      	str	r2, [r7, #4]
20001a88:	603b      	str	r3, [r7, #0]
    char name[64];
    cfe_device_t *dev;

    xsprintf(name,"%s%d",drv->drv_bootname,idx);
20001a8a:	68fb      	ldr	r3, [r7, #12]
20001a8c:	685a      	ldr	r2, [r3, #4]
20001a8e:	f107 0014 	add.w	r0, r7, #20
20001a92:	68bb      	ldr	r3, [r7, #8]
20001a94:	4928      	ldr	r1, [pc, #160]	@ (20001b38 <cfe_attach_idx+0xbc>)
20001a96:	f7ff f94f 	bl	20000d38 <xsprintf>

    if (bootinfo) {
20001a9a:	683b      	ldr	r3, [r7, #0]
20001a9c:	2b00      	cmp	r3, #0
20001a9e:	d00b      	beq.n	20001ab8 <cfe_attach_idx+0x3c>
	strcat(name,".");
20001aa0:	f107 0314 	add.w	r3, r7, #20
20001aa4:	4925      	ldr	r1, [pc, #148]	@ (20001b3c <cfe_attach_idx+0xc0>)
20001aa6:	4618      	mov	r0, r3
20001aa8:	f7ff fddd 	bl	20001666 <lib_strcat>
	strcat(name,bootinfo);
20001aac:	f107 0314 	add.w	r3, r7, #20
20001ab0:	6839      	ldr	r1, [r7, #0]
20001ab2:	4618      	mov	r0, r3
20001ab4:	f7ff fdd7 	bl	20001666 <lib_strcat>
	}

    if (cfe_finddev(name) != NULL) {
20001ab8:	f107 0314 	add.w	r3, r7, #20
20001abc:	4618      	mov	r0, r3
20001abe:	f7ff ff85 	bl	200019cc <cfe_finddev>
20001ac2:	4603      	mov	r3, r0
20001ac4:	2b00      	cmp	r3, #0
20001ac6:	d001      	beq.n	20001acc <cfe_attach_idx+0x50>
	return 0;
20001ac8:	2300      	movs	r3, #0
20001aca:	e031      	b.n	20001b30 <cfe_attach_idx+0xb4>
	}

    dev = (cfe_device_t *) KMALLOC(sizeof(cfe_device_t),0);
20001acc:	2200      	movs	r2, #0
20001ace:	2120      	movs	r1, #32
20001ad0:	481b      	ldr	r0, [pc, #108]	@ (20001b40 <cfe_attach_idx+0xc4>)
20001ad2:	f7ff fb01 	bl	200010d8 <kmalloc>
20001ad6:	6578      	str	r0, [r7, #84]	@ 0x54
    if (!dev) return -1;
20001ad8:	6d7b      	ldr	r3, [r7, #84]	@ 0x54
20001ada:	2b00      	cmp	r3, #0
20001adc:	d102      	bne.n	20001ae4 <cfe_attach_idx+0x68>
20001ade:	f04f 33ff 	mov.w	r3, #4294967295	@ 0xffffffff
20001ae2:	e025      	b.n	20001b30 <cfe_attach_idx+0xb4>

    dev->dev_fullname = strdup(name);
20001ae4:	f107 0314 	add.w	r3, r7, #20
20001ae8:	4618      	mov	r0, r3
20001aea:	f7ff ff2f 	bl	2000194c <lib_strdup>
20001aee:	4602      	mov	r2, r0
20001af0:	6d7b      	ldr	r3, [r7, #84]	@ 0x54
20001af2:	609a      	str	r2, [r3, #8]
    dev->dev_softc = softc;
20001af4:	6d7b      	ldr	r3, [r7, #84]	@ 0x54
20001af6:	687a      	ldr	r2, [r7, #4]
20001af8:	60da      	str	r2, [r3, #12]
    dev->dev_class = drv->drv_class;
20001afa:	68fb      	ldr	r3, [r7, #12]
20001afc:	689a      	ldr	r2, [r3, #8]
20001afe:	6d7b      	ldr	r3, [r7, #84]	@ 0x54
20001b00:	611a      	str	r2, [r3, #16]
    dev->dev_dispatch = drv->drv_dispatch;
20001b02:	68fb      	ldr	r3, [r7, #12]
20001b04:	68da      	ldr	r2, [r3, #12]
20001b06:	6d7b      	ldr	r3, [r7, #84]	@ 0x54
20001b08:	615a      	str	r2, [r3, #20]
    dev->dev_description = description ? strdup(description) : NULL;
20001b0a:	6e3b      	ldr	r3, [r7, #96]	@ 0x60
20001b0c:	2b00      	cmp	r3, #0
20001b0e:	d004      	beq.n	20001b1a <cfe_attach_idx+0x9e>
20001b10:	6e38      	ldr	r0, [r7, #96]	@ 0x60
20001b12:	f7ff ff1b 	bl	2000194c <lib_strdup>
20001b16:	4603      	mov	r3, r0
20001b18:	e000      	b.n	20001b1c <cfe_attach_idx+0xa0>
20001b1a:	2300      	movs	r3, #0
20001b1c:	6d7a      	ldr	r2, [r7, #84]	@ 0x54
20001b1e:	61d3      	str	r3, [r2, #28]
    dev->dev_opencount = 0;
20001b20:	6d7b      	ldr	r3, [r7, #84]	@ 0x54
20001b22:	2200      	movs	r2, #0
20001b24:	619a      	str	r2, [r3, #24]

    q_enqueue(&cfe_devices,(queue_t *) dev);
20001b26:	6d79      	ldr	r1, [r7, #84]	@ 0x54
20001b28:	4806      	ldr	r0, [pc, #24]	@ (20001b44 <cfe_attach_idx+0xc8>)
20001b2a:	f7ff fc0d 	bl	20001348 <q_enqueue>

    return 1;
20001b2e:	2301      	movs	r3, #1

}
20001b30:	4618      	mov	r0, r3
20001b32:	3758      	adds	r7, #88	@ 0x58
20001b34:	46bd      	mov	sp, r7
20001b36:	bd80      	pop	{r7, pc}
20001b38:	2000766c 	.word	0x2000766c
20001b3c:	20007674 	.word	0x20007674
20001b40:	200091fc 	.word	0x200091fc
20001b44:	2000906c 	.word	0x2000906c

20001b48 <cfe_attach>:
    ********************************************************************* */

void cfe_attach(cfe_driver_t *drv,void *softc,
		char *bootinfo,
		char *description)
{
20001b48:	b580      	push	{r7, lr}
20001b4a:	b088      	sub	sp, #32
20001b4c:	af02      	add	r7, sp, #8
20001b4e:	60f8      	str	r0, [r7, #12]
20001b50:	60b9      	str	r1, [r7, #8]
20001b52:	607a      	str	r2, [r7, #4]
20001b54:	603b      	str	r3, [r7, #0]
     * Try device indicies 0..CFE_MAX_DEVINST to assign a unique
     * device name for this device.  This is a really braindead way to 
     * do this, but how many devices are we expecting anyway?
     */

    for (idx = 0; idx < CFE_MAX_DEVINST; idx++) {
20001b56:	2300      	movs	r3, #0
20001b58:	617b      	str	r3, [r7, #20]
20001b5a:	e011      	b.n	20001b80 <cfe_attach+0x38>

	res = cfe_attach_idx(drv,idx,softc,bootinfo,description);
20001b5c:	683b      	ldr	r3, [r7, #0]
20001b5e:	9300      	str	r3, [sp, #0]
20001b60:	687b      	ldr	r3, [r7, #4]
20001b62:	68ba      	ldr	r2, [r7, #8]
20001b64:	6979      	ldr	r1, [r7, #20]
20001b66:	68f8      	ldr	r0, [r7, #12]
20001b68:	f7ff ff88 	bl	20001a7c <cfe_attach_idx>
20001b6c:	6138      	str	r0, [r7, #16]

	if (res < 0) break;	/* out of memory or other badness */
20001b6e:	693b      	ldr	r3, [r7, #16]
20001b70:	2b00      	cmp	r3, #0
20001b72:	db09      	blt.n	20001b88 <cfe_attach+0x40>
	if (res > 0) break;	/* success! */
20001b74:	693b      	ldr	r3, [r7, #16]
20001b76:	2b00      	cmp	r3, #0
20001b78:	dc08      	bgt.n	20001b8c <cfe_attach+0x44>
    for (idx = 0; idx < CFE_MAX_DEVINST; idx++) {
20001b7a:	697b      	ldr	r3, [r7, #20]
20001b7c:	3301      	adds	r3, #1
20001b7e:	617b      	str	r3, [r7, #20]
20001b80:	697b      	ldr	r3, [r7, #20]
20001b82:	2b3f      	cmp	r3, #63	@ 0x3f
20001b84:	ddea      	ble.n	20001b5c <cfe_attach+0x14>
	/* otherwise, try again, slot is taken */
	}

}
20001b86:	e002      	b.n	20001b8e <cfe_attach+0x46>
	if (res < 0) break;	/* out of memory or other badness */
20001b88:	bf00      	nop
20001b8a:	e000      	b.n	20001b8e <cfe_attach+0x46>
	if (res > 0) break;	/* success! */
20001b8c:	bf00      	nop
}
20001b8e:	bf00      	nop
20001b90:	3718      	adds	r7, #24
20001b92:	46bd      	mov	sp, r7
20001b94:	bd80      	pop	{r7, pc}
	...

20001b98 <cfe_attach_init>:
    *  	  
    *  Return value:
    *  	   nothing
    ********************************************************************* */
void cfe_attach_init(void)
{
20001b98:	b480      	push	{r7}
20001b9a:	af00      	add	r7, sp, #0
    q_init(&(cfe_devices));
20001b9c:	4b05      	ldr	r3, [pc, #20]	@ (20001bb4 <cfe_attach_init+0x1c>)
20001b9e:	4a05      	ldr	r2, [pc, #20]	@ (20001bb4 <cfe_attach_init+0x1c>)
20001ba0:	605a      	str	r2, [r3, #4]
20001ba2:	4b04      	ldr	r3, [pc, #16]	@ (20001bb4 <cfe_attach_init+0x1c>)
20001ba4:	4a03      	ldr	r2, [pc, #12]	@ (20001bb4 <cfe_attach_init+0x1c>)
20001ba6:	601a      	str	r2, [r3, #0]
}
20001ba8:	bf00      	nop
20001baa:	46bd      	mov	sp, r7
20001bac:	f85d 7b04 	ldr.w	r7, [sp], #4
20001bb0:	4770      	bx	lr
20001bb2:	bf00      	nop
20001bb4:	2000906c 	.word	0x2000906c

20001bb8 <cfe_bg_init>:
    *  Return value:
    *  	   nothing
    ********************************************************************* */

void cfe_bg_init(void)
{
20001bb8:	b580      	push	{r7, lr}
20001bba:	af00      	add	r7, sp, #0
    memset(cfe_bg_tasklist,0,sizeof(cfe_bg_tasklist));
20001bbc:	2240      	movs	r2, #64	@ 0x40
20001bbe:	2100      	movs	r1, #0
20001bc0:	4802      	ldr	r0, [pc, #8]	@ (20001bcc <cfe_bg_init+0x14>)
20001bc2:	f7ff fd34 	bl	2000162e <lib_memset>
}
20001bc6:	bf00      	nop
20001bc8:	bd80      	pop	{r7, pc}
20001bca:	bf00      	nop
20001bcc:	20009218 	.word	0x20009218

20001bd0 <cfe_bg_add>:
    *  Return value:
    *  	   nothing
    ********************************************************************* */

void cfe_bg_add(void (*func)(void *x),void *arg)
{
20001bd0:	b480      	push	{r7}
20001bd2:	b085      	sub	sp, #20
20001bd4:	af00      	add	r7, sp, #0
20001bd6:	6078      	str	r0, [r7, #4]
20001bd8:	6039      	str	r1, [r7, #0]
    int idx;

    for (idx = 0; idx < MAX_BACKGROUND_TASKS; idx++) {
20001bda:	2300      	movs	r3, #0
20001bdc:	60fb      	str	r3, [r7, #12]
20001bde:	e013      	b.n	20001c08 <cfe_bg_add+0x38>
	if (cfe_bg_tasklist[idx] == NULL) {
20001be0:	4a0d      	ldr	r2, [pc, #52]	@ (20001c18 <cfe_bg_add+0x48>)
20001be2:	68fb      	ldr	r3, [r7, #12]
20001be4:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
20001be8:	2b00      	cmp	r3, #0
20001bea:	d10a      	bne.n	20001c02 <cfe_bg_add+0x32>
	    cfe_bg_tasklist[idx] = func;
20001bec:	490a      	ldr	r1, [pc, #40]	@ (20001c18 <cfe_bg_add+0x48>)
20001bee:	68fb      	ldr	r3, [r7, #12]
20001bf0:	687a      	ldr	r2, [r7, #4]
20001bf2:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
	    cfe_bg_args[idx] = arg;
20001bf6:	4909      	ldr	r1, [pc, #36]	@ (20001c1c <cfe_bg_add+0x4c>)
20001bf8:	68fb      	ldr	r3, [r7, #12]
20001bfa:	683a      	ldr	r2, [r7, #0]
20001bfc:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
	    return;
20001c00:	e005      	b.n	20001c0e <cfe_bg_add+0x3e>
    for (idx = 0; idx < MAX_BACKGROUND_TASKS; idx++) {
20001c02:	68fb      	ldr	r3, [r7, #12]
20001c04:	3301      	adds	r3, #1
20001c06:	60fb      	str	r3, [r7, #12]
20001c08:	68fb      	ldr	r3, [r7, #12]
20001c0a:	2b0f      	cmp	r3, #15
20001c0c:	dde8      	ble.n	20001be0 <cfe_bg_add+0x10>
	    }
	}
}
20001c0e:	3714      	adds	r7, #20
20001c10:	46bd      	mov	sp, r7
20001c12:	f85d 7b04 	ldr.w	r7, [sp], #4
20001c16:	4770      	bx	lr
20001c18:	20009218 	.word	0x20009218
20001c1c:	20009258 	.word	0x20009258

20001c20 <background>:
    *  Return value:
    *  	   nothing
    ********************************************************************* */

void background(void)
{
20001c20:	b580      	push	{r7, lr}
20001c22:	b082      	sub	sp, #8
20001c24:	af00      	add	r7, sp, #0
    int idx;
    void (*func)(void *arg);

    for (idx = 0; idx < MAX_BACKGROUND_TASKS; idx++) {
20001c26:	2300      	movs	r3, #0
20001c28:	607b      	str	r3, [r7, #4]
20001c2a:	e011      	b.n	20001c50 <background+0x30>
	func = cfe_bg_tasklist[idx];
20001c2c:	4a0d      	ldr	r2, [pc, #52]	@ (20001c64 <background+0x44>)
20001c2e:	687b      	ldr	r3, [r7, #4]
20001c30:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
20001c34:	603b      	str	r3, [r7, #0]
	if (func == NULL) break;
20001c36:	683b      	ldr	r3, [r7, #0]
20001c38:	2b00      	cmp	r3, #0
20001c3a:	d00d      	beq.n	20001c58 <background+0x38>
	(*func)(cfe_bg_args[idx]);
20001c3c:	4a0a      	ldr	r2, [pc, #40]	@ (20001c68 <background+0x48>)
20001c3e:	687b      	ldr	r3, [r7, #4]
20001c40:	f852 2023 	ldr.w	r2, [r2, r3, lsl #2]
20001c44:	683b      	ldr	r3, [r7, #0]
20001c46:	4610      	mov	r0, r2
20001c48:	4798      	blx	r3
    for (idx = 0; idx < MAX_BACKGROUND_TASKS; idx++) {
20001c4a:	687b      	ldr	r3, [r7, #4]
20001c4c:	3301      	adds	r3, #1
20001c4e:	607b      	str	r3, [r7, #4]
20001c50:	687b      	ldr	r3, [r7, #4]
20001c52:	2b0f      	cmp	r3, #15
20001c54:	ddea      	ble.n	20001c2c <background+0xc>
	}
}
20001c56:	e000      	b.n	20001c5a <background+0x3a>
	if (func == NULL) break;
20001c58:	bf00      	nop
}
20001c5a:	bf00      	nop
20001c5c:	3708      	adds	r7, #8
20001c5e:	46bd      	mov	sp, r7
20001c60:	bd80      	pop	{r7, pc}
20001c62:	bf00      	nop
20001c64:	20009218 	.word	0x20009218
20001c68:	20009258 	.word	0x20009258

20001c6c <console_open>:
    *  	   0 if ok, else return code.  
    *  	   console_handle contains the console's handle
    ********************************************************************* */

int console_open(char *name)
{
20001c6c:	b580      	push	{r7, lr}
20001c6e:	b084      	sub	sp, #16
20001c70:	af00      	add	r7, sp, #0
20001c72:	6078      	str	r0, [r7, #4]

#else

    int flushbuf;

    console_name = NULL;
20001c74:	4b14      	ldr	r3, [pc, #80]	@ (20001cc8 <console_open+0x5c>)
20001c76:	2200      	movs	r2, #0
20001c78:	601a      	str	r2, [r3, #0]

    if (console_handle != -1) {
20001c7a:	4b14      	ldr	r3, [pc, #80]	@ (20001ccc <console_open+0x60>)
20001c7c:	681b      	ldr	r3, [r3, #0]
20001c7e:	f1b3 3fff 	cmp.w	r3, #4294967295	@ 0xffffffff
20001c82:	d001      	beq.n	20001c88 <console_open+0x1c>
	console_close();
20001c84:	f000 f826 	bl	20001cd4 <console_close>
	}

    flushbuf = console_buffer_flg;
20001c88:	4b11      	ldr	r3, [pc, #68]	@ (20001cd0 <console_open+0x64>)
20001c8a:	681b      	ldr	r3, [r3, #0]
20001c8c:	60fb      	str	r3, [r7, #12]
    console_buffer_flg = 0;
20001c8e:	4b10      	ldr	r3, [pc, #64]	@ (20001cd0 <console_open+0x64>)
20001c90:	2200      	movs	r2, #0
20001c92:	601a      	str	r2, [r3, #0]

    console_handle = cfe_open(name);
20001c94:	6878      	ldr	r0, [r7, #4]
20001c96:	f001 f842 	bl	20002d1e <cfe_open>
20001c9a:	4603      	mov	r3, r0
20001c9c:	4a0b      	ldr	r2, [pc, #44]	@ (20001ccc <console_open+0x60>)
20001c9e:	6013      	str	r3, [r2, #0]
    if (console_handle < 0) return CFE_ERR_DEVNOTFOUND;
20001ca0:	4b0a      	ldr	r3, [pc, #40]	@ (20001ccc <console_open+0x60>)
20001ca2:	681b      	ldr	r3, [r3, #0]
20001ca4:	2b00      	cmp	r3, #0
20001ca6:	da02      	bge.n	20001cae <console_open+0x42>
20001ca8:	f06f 0305 	mvn.w	r3, #5
20001cac:	e008      	b.n	20001cc0 <console_open+0x54>

    console_name = name;
20001cae:	4a06      	ldr	r2, [pc, #24]	@ (20001cc8 <console_open+0x5c>)
20001cb0:	687b      	ldr	r3, [r7, #4]
20001cb2:	6013      	str	r3, [r2, #0]
    if (flushbuf) console_flushbuffer();
20001cb4:	68fb      	ldr	r3, [r7, #12]
20001cb6:	2b00      	cmp	r3, #0
20001cb8:	d001      	beq.n	20001cbe <console_open+0x52>
20001cba:	f000 f8f9 	bl	20001eb0 <console_flushbuffer>
#endif

    return 0;
20001cbe:	2300      	movs	r3, #0
}
20001cc0:	4618      	mov	r0, r3
20001cc2:	3710      	adds	r7, #16
20001cc4:	46bd      	mov	sp, r7
20001cc6:	bd80      	pop	{r7, pc}
20001cc8:	20009320 	.word	0x20009320
20001ccc:	2000907c 	.word	0x2000907c
20001cd0:	20009318 	.word	0x20009318

20001cd4 <console_close>:
    *  Return value:
    *  	   0
    ********************************************************************* */

int console_close(void)
{
20001cd4:	b580      	push	{r7, lr}
20001cd6:	af00      	add	r7, sp, #0
    if (console_handle != -1) {
20001cd8:	4b08      	ldr	r3, [pc, #32]	@ (20001cfc <console_close+0x28>)
20001cda:	681b      	ldr	r3, [r3, #0]
20001cdc:	f1b3 3fff 	cmp.w	r3, #4294967295	@ 0xffffffff
20001ce0:	d004      	beq.n	20001cec <console_close+0x18>
	cfe_close(console_handle);
20001ce2:	4b06      	ldr	r3, [pc, #24]	@ (20001cfc <console_close+0x28>)
20001ce4:	681b      	ldr	r3, [r3, #0]
20001ce6:	4618      	mov	r0, r3
20001ce8:	f001 f843 	bl	20002d72 <cfe_close>
	}

    console_handle = -1;
20001cec:	4b03      	ldr	r3, [pc, #12]	@ (20001cfc <console_close+0x28>)
20001cee:	f04f 32ff 	mov.w	r2, #4294967295	@ 0xffffffff
20001cf2:	601a      	str	r2, [r3, #0]

    return 0;
20001cf4:	2300      	movs	r3, #0
}
20001cf6:	4618      	mov	r0, r3
20001cf8:	bd80      	pop	{r7, pc}
20001cfa:	bf00      	nop
20001cfc:	2000907c 	.word	0x2000907c

20001d00 <console_read>:
    *  Return value:
    *  	   number of characters received, or <0 if error code
    ********************************************************************* */

int console_read(unsigned char *buffer,int length)
{
20001d00:	b580      	push	{r7, lr}
20001d02:	b082      	sub	sp, #8
20001d04:	af00      	add	r7, sp, #0
20001d06:	6078      	str	r0, [r7, #4]
20001d08:	6039      	str	r1, [r7, #0]
    if (console_handle == -1) return -1;
20001d0a:	4b0a      	ldr	r3, [pc, #40]	@ (20001d34 <console_read+0x34>)
20001d0c:	681b      	ldr	r3, [r3, #0]
20001d0e:	f1b3 3fff 	cmp.w	r3, #4294967295	@ 0xffffffff
20001d12:	d102      	bne.n	20001d1a <console_read+0x1a>
20001d14:	f04f 33ff 	mov.w	r3, #4294967295	@ 0xffffffff
20001d18:	e007      	b.n	20001d2a <console_read+0x2a>

    return cfe_read(console_handle,PTR2HSADDR(buffer),length);
20001d1a:	4b06      	ldr	r3, [pc, #24]	@ (20001d34 <console_read+0x34>)
20001d1c:	681b      	ldr	r3, [r3, #0]
20001d1e:	6879      	ldr	r1, [r7, #4]
20001d20:	683a      	ldr	r2, [r7, #0]
20001d22:	4618      	mov	r0, r3
20001d24:	f001 f866 	bl	20002df4 <cfe_read>
20001d28:	4603      	mov	r3, r0
}
20001d2a:	4618      	mov	r0, r3
20001d2c:	3708      	adds	r7, #8
20001d2e:	46bd      	mov	sp, r7
20001d30:	bd80      	pop	{r7, pc}
20001d32:	bf00      	nop
20001d34:	2000907c 	.word	0x2000907c

20001d38 <console_write>:
    *  Return value:
    *  	   number of characters written or <0 if error
    ********************************************************************* */

int console_write(unsigned char *buffer,int length)
{
20001d38:	b580      	push	{r7, lr}
20001d3a:	b084      	sub	sp, #16
20001d3c:	af00      	add	r7, sp, #0
20001d3e:	6078      	str	r0, [r7, #4]
20001d40:	6039      	str	r1, [r7, #0]

#if !CFG_MINIMAL_SIZE
    /*
     * Buffer text if requested
     */
    if (console_buffer_flg) {
20001d42:	4b1b      	ldr	r3, [pc, #108]	@ (20001db0 <console_write+0x78>)
20001d44:	681b      	ldr	r3, [r3, #0]
20001d46:	2b00      	cmp	r3, #0
20001d48:	d005      	beq.n	20001d56 <console_write+0x1e>
	console_save(buffer,length);
20001d4a:	6839      	ldr	r1, [r7, #0]
20001d4c:	6878      	ldr	r0, [r7, #4]
20001d4e:	f000 f8eb 	bl	20001f28 <console_save>
	return length;
20001d52:	683b      	ldr	r3, [r7, #0]
20001d54:	e028      	b.n	20001da8 <console_write+0x70>

    /*
     * Do nothing if no console
     */

    if (console_handle == -1) return -1;
20001d56:	4b17      	ldr	r3, [pc, #92]	@ (20001db4 <console_write+0x7c>)
20001d58:	681b      	ldr	r3, [r3, #0]
20001d5a:	f1b3 3fff 	cmp.w	r3, #4294967295	@ 0xffffffff
20001d5e:	d102      	bne.n	20001d66 <console_write+0x2e>
20001d60:	f04f 33ff 	mov.w	r3, #4294967295	@ 0xffffffff
20001d64:	e020      	b.n	20001da8 <console_write+0x70>
    /*
     * Write text to device
     */

    for (;;) {
	res = cfe_write(console_handle,PTR2HSADDR(buffer),length);
20001d66:	4b13      	ldr	r3, [pc, #76]	@ (20001db4 <console_write+0x7c>)
20001d68:	681b      	ldr	r3, [r3, #0]
20001d6a:	6879      	ldr	r1, [r7, #4]
20001d6c:	683a      	ldr	r2, [r7, #0]
20001d6e:	4618      	mov	r0, r3
20001d70:	f001 f87f 	bl	20002e72 <cfe_write>
20001d74:	60f8      	str	r0, [r7, #12]
	if (res < 0) break;
20001d76:	68fb      	ldr	r3, [r7, #12]
20001d78:	2b00      	cmp	r3, #0
20001d7a:	db0b      	blt.n	20001d94 <console_write+0x5c>
	buffer += res;
20001d7c:	68fb      	ldr	r3, [r7, #12]
20001d7e:	687a      	ldr	r2, [r7, #4]
20001d80:	4413      	add	r3, r2
20001d82:	607b      	str	r3, [r7, #4]
	length -= res;
20001d84:	683a      	ldr	r2, [r7, #0]
20001d86:	68fb      	ldr	r3, [r7, #12]
20001d88:	1ad3      	subs	r3, r2, r3
20001d8a:	603b      	str	r3, [r7, #0]
	if (length == 0) break;
20001d8c:	683b      	ldr	r3, [r7, #0]
20001d8e:	2b00      	cmp	r3, #0
20001d90:	d002      	beq.n	20001d98 <console_write+0x60>
	res = cfe_write(console_handle,PTR2HSADDR(buffer),length);
20001d92:	e7e8      	b.n	20001d66 <console_write+0x2e>
	if (res < 0) break;
20001d94:	bf00      	nop
20001d96:	e000      	b.n	20001d9a <console_write+0x62>
	if (length == 0) break;
20001d98:	bf00      	nop
	}

    if (res < 0) return -1;
20001d9a:	68fb      	ldr	r3, [r7, #12]
20001d9c:	2b00      	cmp	r3, #0
20001d9e:	da02      	bge.n	20001da6 <console_write+0x6e>
20001da0:	f04f 33ff 	mov.w	r3, #4294967295	@ 0xffffffff
20001da4:	e000      	b.n	20001da8 <console_write+0x70>
    return 0;			 
20001da6:	2300      	movs	r3, #0
}
20001da8:	4618      	mov	r0, r3
20001daa:	3710      	adds	r7, #16
20001dac:	46bd      	mov	sp, r7
20001dae:	bd80      	pop	{r7, pc}
20001db0:	20009318 	.word	0x20009318
20001db4:	2000907c 	.word	0x2000907c

20001db8 <console_status>:
    *  	   0 if no characters are available
    *  	   1 if characters are available.
    ********************************************************************* */

int console_status(void)
{
20001db8:	b580      	push	{r7, lr}
20001dba:	af00      	add	r7, sp, #0
    if (console_handle == -1) return 0;
20001dbc:	4b07      	ldr	r3, [pc, #28]	@ (20001ddc <console_status+0x24>)
20001dbe:	681b      	ldr	r3, [r3, #0]
20001dc0:	f1b3 3fff 	cmp.w	r3, #4294967295	@ 0xffffffff
20001dc4:	d101      	bne.n	20001dca <console_status+0x12>
20001dc6:	2300      	movs	r3, #0
20001dc8:	e005      	b.n	20001dd6 <console_status+0x1e>

    return cfe_inpstat(console_handle);
20001dca:	4b04      	ldr	r3, [pc, #16]	@ (20001ddc <console_status+0x24>)
20001dcc:	681b      	ldr	r3, [r3, #0]
20001dce:	4618      	mov	r0, r3
20001dd0:	f001 f865 	bl	20002e9e <cfe_inpstat>
20001dd4:	4603      	mov	r3, r0
}
20001dd6:	4618      	mov	r0, r3
20001dd8:	bd80      	pop	{r7, pc}
20001dda:	bf00      	nop
20001ddc:	2000907c 	.word	0x2000907c

20001de0 <console_xprint>:
    *  Return value:
    *  	   number of characters written
    ********************************************************************* */

static int console_xprint(const char *str)
{
20001de0:	b580      	push	{r7, lr}
20001de2:	b086      	sub	sp, #24
20001de4:	af00      	add	r7, sp, #0
20001de6:	6078      	str	r0, [r7, #4]
    int count = 0;	
20001de8:	2300      	movs	r3, #0
20001dea:	617b      	str	r3, [r7, #20]
    int len;
    const char *p;

    /* Convert CR to CRLF as we write things out */

    while ((p = strchr(str,'\n'))) {
20001dec:	e013      	b.n	20001e16 <console_xprint+0x36>
	console_write((unsigned char *) str,p-str);
20001dee:	693a      	ldr	r2, [r7, #16]
20001df0:	687b      	ldr	r3, [r7, #4]
20001df2:	1ad3      	subs	r3, r2, r3
20001df4:	4619      	mov	r1, r3
20001df6:	6878      	ldr	r0, [r7, #4]
20001df8:	f7ff ff9e 	bl	20001d38 <console_write>
	console_write((unsigned char *)"\r\n",2);
20001dfc:	2102      	movs	r1, #2
20001dfe:	4812      	ldr	r0, [pc, #72]	@ (20001e48 <console_xprint+0x68>)
20001e00:	f7ff ff9a 	bl	20001d38 <console_write>
	count += (p-str);
20001e04:	693a      	ldr	r2, [r7, #16]
20001e06:	687b      	ldr	r3, [r7, #4]
20001e08:	1ad3      	subs	r3, r2, r3
20001e0a:	697a      	ldr	r2, [r7, #20]
20001e0c:	4413      	add	r3, r2
20001e0e:	617b      	str	r3, [r7, #20]
	str = p + 1;
20001e10:	693b      	ldr	r3, [r7, #16]
20001e12:	3301      	adds	r3, #1
20001e14:	607b      	str	r3, [r7, #4]
    while ((p = strchr(str,'\n'))) {
20001e16:	210a      	movs	r1, #10
20001e18:	6878      	ldr	r0, [r7, #4]
20001e1a:	f7ff fb9d 	bl	20001558 <lib_strchr>
20001e1e:	6138      	str	r0, [r7, #16]
20001e20:	693b      	ldr	r3, [r7, #16]
20001e22:	2b00      	cmp	r3, #0
20001e24:	d1e3      	bne.n	20001dee <console_xprint+0xe>
	}

    len = strlen(str);
20001e26:	6878      	ldr	r0, [r7, #4]
20001e28:	f7ff fb3d 	bl	200014a6 <lib_strlen>
20001e2c:	60f8      	str	r0, [r7, #12]
    console_write((unsigned char *) str, len);
20001e2e:	68f9      	ldr	r1, [r7, #12]
20001e30:	6878      	ldr	r0, [r7, #4]
20001e32:	f7ff ff81 	bl	20001d38 <console_write>
    count += len;
20001e36:	697a      	ldr	r2, [r7, #20]
20001e38:	68fb      	ldr	r3, [r7, #12]
20001e3a:	4413      	add	r3, r2
20001e3c:	617b      	str	r3, [r7, #20]

    return count;
20001e3e:	697b      	ldr	r3, [r7, #20]
}
20001e40:	4618      	mov	r0, r3
20001e42:	3718      	adds	r7, #24
20001e44:	46bd      	mov	sp, r7
20001e46:	bd80      	pop	{r7, pc}
20001e48:	20007684 	.word	0x20007684

20001e4c <cfe_set_console>:
    *  	   0 if ok
    *  	   else error code
    ********************************************************************* */

int cfe_set_console(char *name)
{
20001e4c:	b580      	push	{r7, lr}
20001e4e:	b084      	sub	sp, #16
20001e50:	af00      	add	r7, sp, #0
20001e52:	6078      	str	r0, [r7, #4]
    xprinthook = console_xprint;
20001e54:	4b11      	ldr	r3, [pc, #68]	@ (20001e9c <cfe_set_console+0x50>)
20001e56:	4a12      	ldr	r2, [pc, #72]	@ (20001ea0 <cfe_set_console+0x54>)
20001e58:	601a      	str	r2, [r3, #0]

#if !CFG_MINIMAL_SIZE
    if (strcmp(name,CFE_BUFFER_CONSOLE) == 0) {
20001e5a:	4912      	ldr	r1, [pc, #72]	@ (20001ea4 <cfe_set_console+0x58>)
20001e5c:	6878      	ldr	r0, [r7, #4]
20001e5e:	f7ff fb3a 	bl	200014d6 <lib_strcmp>
20001e62:	4603      	mov	r3, r0
20001e64:	2b00      	cmp	r3, #0
20001e66:	d104      	bne.n	20001e72 <cfe_set_console+0x26>
	console_buffer_flg = 1;
20001e68:	4b0f      	ldr	r3, [pc, #60]	@ (20001ea8 <cfe_set_console+0x5c>)
20001e6a:	2201      	movs	r2, #1
20001e6c:	601a      	str	r2, [r3, #0]
	return 0;
20001e6e:	2300      	movs	r3, #0
20001e70:	e010      	b.n	20001e94 <cfe_set_console+0x48>
	}
#endif

    if (name) {
20001e72:	687b      	ldr	r3, [r7, #4]
20001e74:	2b00      	cmp	r3, #0
20001e76:	d00b      	beq.n	20001e90 <cfe_set_console+0x44>
	int res;
	res = env_setenv("BOOT_CONSOLE",name,
20001e78:	f240 1203 	movw	r2, #259	@ 0x103
20001e7c:	6879      	ldr	r1, [r7, #4]
20001e7e:	480b      	ldr	r0, [pc, #44]	@ (20001eac <cfe_set_console+0x60>)
20001e80:	f001 feb8 	bl	20003bf4 <env_setenv>
20001e84:	60f8      	str	r0, [r7, #12]
		   ENV_FLG_BUILTIN | ENV_FLG_READONLY | ENV_FLG_ADMIN);
	return console_open(name);
20001e86:	6878      	ldr	r0, [r7, #4]
20001e88:	f7ff fef0 	bl	20001c6c <console_open>
20001e8c:	4603      	mov	r3, r0
20001e8e:	e001      	b.n	20001e94 <cfe_set_console+0x48>
	}
    return -1;
20001e90:	f04f 33ff 	mov.w	r3, #4294967295	@ 0xffffffff
}
20001e94:	4618      	mov	r0, r3
20001e96:	3710      	adds	r7, #16
20001e98:	46bd      	mov	sp, r7
20001e9a:	bd80      	pop	{r7, pc}
20001e9c:	200091f8 	.word	0x200091f8
20001ea0:	20001de1 	.word	0x20001de1
20001ea4:	20007694 	.word	0x20007694
20001ea8:	20009318 	.word	0x20009318
20001eac:	2000769c 	.word	0x2000769c

20001eb0 <console_flushbuffer>:
    *  Return value:
    *  	   nothing
    ********************************************************************* */

static void console_flushbuffer(void)
{
20001eb0:	b580      	push	{r7, lr}
20001eb2:	b084      	sub	sp, #16
20001eb4:	af00      	add	r7, sp, #0

    /*
     * Remove console messages from the queue 
     */

    while ((msg = (msgqueue_t *) q_deqnext(&console_msgq))) {
20001eb6:	e025      	b.n	20001f04 <console_flushbuffer+0x54>

	buffer = msg->data;
20001eb8:	687b      	ldr	r3, [r7, #4]
20001eba:	330c      	adds	r3, #12
20001ebc:	60fb      	str	r3, [r7, #12]
	length = msg->len;
20001ebe:	687b      	ldr	r3, [r7, #4]
20001ec0:	689b      	ldr	r3, [r3, #8]
20001ec2:	60bb      	str	r3, [r7, #8]
	res = 0;
20001ec4:	2300      	movs	r3, #0
20001ec6:	603b      	str	r3, [r7, #0]
	/*
	 * Write each message to the console 
	 */

	for (;;) {
	    res = cfe_write(console_handle,PTR2HSADDR(buffer),length);
20001ec8:	4b14      	ldr	r3, [pc, #80]	@ (20001f1c <console_flushbuffer+0x6c>)
20001eca:	681b      	ldr	r3, [r3, #0]
20001ecc:	68f9      	ldr	r1, [r7, #12]
20001ece:	68ba      	ldr	r2, [r7, #8]
20001ed0:	4618      	mov	r0, r3
20001ed2:	f000 ffce 	bl	20002e72 <cfe_write>
20001ed6:	6038      	str	r0, [r7, #0]
	    if (res < 0) break;
20001ed8:	683b      	ldr	r3, [r7, #0]
20001eda:	2b00      	cmp	r3, #0
20001edc:	db0b      	blt.n	20001ef6 <console_flushbuffer+0x46>
	    buffer += res;
20001ede:	683b      	ldr	r3, [r7, #0]
20001ee0:	68fa      	ldr	r2, [r7, #12]
20001ee2:	4413      	add	r3, r2
20001ee4:	60fb      	str	r3, [r7, #12]
	    length -= res;
20001ee6:	68ba      	ldr	r2, [r7, #8]
20001ee8:	683b      	ldr	r3, [r7, #0]
20001eea:	1ad3      	subs	r3, r2, r3
20001eec:	60bb      	str	r3, [r7, #8]
	    if (length == 0) break;
20001eee:	68bb      	ldr	r3, [r7, #8]
20001ef0:	2b00      	cmp	r3, #0
20001ef2:	d002      	beq.n	20001efa <console_flushbuffer+0x4a>
	    res = cfe_write(console_handle,PTR2HSADDR(buffer),length);
20001ef4:	e7e8      	b.n	20001ec8 <console_flushbuffer+0x18>
	    if (res < 0) break;
20001ef6:	bf00      	nop
20001ef8:	e000      	b.n	20001efc <console_flushbuffer+0x4c>
	    if (length == 0) break;
20001efa:	bf00      	nop

	/*
	 * Free the storage
	 */

	KFREE(msg);
20001efc:	6879      	ldr	r1, [r7, #4]
20001efe:	4808      	ldr	r0, [pc, #32]	@ (20001f20 <console_flushbuffer+0x70>)
20001f00:	f7ff f8b6 	bl	20001070 <kfree>
    while ((msg = (msgqueue_t *) q_deqnext(&console_msgq))) {
20001f04:	4807      	ldr	r0, [pc, #28]	@ (20001f24 <console_flushbuffer+0x74>)
20001f06:	f7ff fa4c 	bl	200013a2 <q_deqnext>
20001f0a:	6078      	str	r0, [r7, #4]
20001f0c:	687b      	ldr	r3, [r7, #4]
20001f0e:	2b00      	cmp	r3, #0
20001f10:	d1d2      	bne.n	20001eb8 <console_flushbuffer+0x8>
	}
}
20001f12:	bf00      	nop
20001f14:	bf00      	nop
20001f16:	3710      	adds	r7, #16
20001f18:	46bd      	mov	sp, r7
20001f1a:	bd80      	pop	{r7, pc}
20001f1c:	2000907c 	.word	0x2000907c
20001f20:	200091fc 	.word	0x200091fc
20001f24:	20009074 	.word	0x20009074

20001f28 <console_save>:
    *  Return value:
    *  	   nothing
    ********************************************************************* */

static void console_save(unsigned char *buffer,int length)
{
20001f28:	b580      	push	{r7, lr}
20001f2a:	b084      	sub	sp, #16
20001f2c:	af00      	add	r7, sp, #0
20001f2e:	6078      	str	r0, [r7, #4]
20001f30:	6039      	str	r1, [r7, #0]
    /*
     * Get a pointer to the last message in the queue.  If 
     * it's full, preprare to allocate a new one
     */

    msg = (msgqueue_t *) console_msgq.q_prev;
20001f32:	4b2a      	ldr	r3, [pc, #168]	@ (20001fdc <console_save+0xb4>)
20001f34:	685b      	ldr	r3, [r3, #4]
20001f36:	60fb      	str	r3, [r7, #12]
    if (q_isempty(&(console_msgq)) || (msg->len == MSGQUEUESIZE)) {
20001f38:	4b28      	ldr	r3, [pc, #160]	@ (20001fdc <console_save+0xb4>)
20001f3a:	681b      	ldr	r3, [r3, #0]
20001f3c:	4a27      	ldr	r2, [pc, #156]	@ (20001fdc <console_save+0xb4>)
20001f3e:	4293      	cmp	r3, r2
20001f40:	d004      	beq.n	20001f4c <console_save+0x24>
20001f42:	68fb      	ldr	r3, [r7, #12]
20001f44:	689b      	ldr	r3, [r3, #8]
20001f46:	f5b3 7f80 	cmp.w	r3, #256	@ 0x100
20001f4a:	d13f      	bne.n	20001fcc <console_save+0xa4>
	msg = NULL;
20001f4c:	2300      	movs	r3, #0
20001f4e:	60fb      	str	r3, [r7, #12]

    /*
     * Stuff characters into message chunks till we're done
     */

    while (length) {
20001f50:	e03c      	b.n	20001fcc <console_save+0xa4>

	/*
	 * New chunk 
	 */
	if (msg == NULL) {
20001f52:	68fb      	ldr	r3, [r7, #12]
20001f54:	2b00      	cmp	r3, #0
20001f56:	d122      	bne.n	20001f9e <console_save+0x76>

	    msg = (msgqueue_t *) KMALLOC(sizeof(msgqueue_t),0);
20001f58:	2200      	movs	r2, #0
20001f5a:	f44f 7186 	mov.w	r1, #268	@ 0x10c
20001f5e:	4820      	ldr	r0, [pc, #128]	@ (20001fe0 <console_save+0xb8>)
20001f60:	f7ff f8ba 	bl	200010d8 <kmalloc>
20001f64:	60f8      	str	r0, [r7, #12]
	    if (msg == NULL) return;
20001f66:	68fb      	ldr	r3, [r7, #12]
20001f68:	2b00      	cmp	r3, #0
20001f6a:	d033      	beq.n	20001fd4 <console_save+0xac>
	    msg->len = 0;
20001f6c:	68fb      	ldr	r3, [r7, #12]
20001f6e:	2200      	movs	r2, #0
20001f70:	609a      	str	r2, [r3, #8]
	    q_enqueue(&console_msgq,(queue_t *) msg);
20001f72:	68f9      	ldr	r1, [r7, #12]
20001f74:	4819      	ldr	r0, [pc, #100]	@ (20001fdc <console_save+0xb4>)
20001f76:	f7ff f9e7 	bl	20001348 <q_enqueue>

	    /*
	     * Remove chunks to prevent chewing too much memory
	     */

	    while (q_count(&console_msgq) > MSGQUEUEMAX) {
20001f7a:	e00a      	b.n	20001f92 <console_save+0x6a>
		msgqueue_t *dropmsg;
		dropmsg = (msgqueue_t *) q_deqnext(&console_msgq);
20001f7c:	4817      	ldr	r0, [pc, #92]	@ (20001fdc <console_save+0xb4>)
20001f7e:	f7ff fa10 	bl	200013a2 <q_deqnext>
20001f82:	60b8      	str	r0, [r7, #8]
		if (dropmsg) KFREE(dropmsg);
20001f84:	68bb      	ldr	r3, [r7, #8]
20001f86:	2b00      	cmp	r3, #0
20001f88:	d003      	beq.n	20001f92 <console_save+0x6a>
20001f8a:	68b9      	ldr	r1, [r7, #8]
20001f8c:	4814      	ldr	r0, [pc, #80]	@ (20001fe0 <console_save+0xb8>)
20001f8e:	f7ff f86f 	bl	20001070 <kfree>
	    while (q_count(&console_msgq) > MSGQUEUEMAX) {
20001f92:	4812      	ldr	r0, [pc, #72]	@ (20001fdc <console_save+0xb4>)
20001f94:	f7ff fa24 	bl	200013e0 <q_count>
20001f98:	4603      	mov	r3, r0
20001f9a:	2b0a      	cmp	r3, #10
20001f9c:	dcee      	bgt.n	20001f7c <console_save+0x54>

	/*
	 * Save text.  If we run off the end of the buffer, prepare
	 * to allocate a new one
	 */
	msg->data[msg->len++] = *buffer++;
20001f9e:	687a      	ldr	r2, [r7, #4]
20001fa0:	1c53      	adds	r3, r2, #1
20001fa2:	607b      	str	r3, [r7, #4]
20001fa4:	68fb      	ldr	r3, [r7, #12]
20001fa6:	689b      	ldr	r3, [r3, #8]
20001fa8:	1c58      	adds	r0, r3, #1
20001faa:	68f9      	ldr	r1, [r7, #12]
20001fac:	6088      	str	r0, [r1, #8]
20001fae:	7811      	ldrb	r1, [r2, #0]
20001fb0:	68fa      	ldr	r2, [r7, #12]
20001fb2:	4413      	add	r3, r2
20001fb4:	460a      	mov	r2, r1
20001fb6:	731a      	strb	r2, [r3, #12]
	length--;
20001fb8:	683b      	ldr	r3, [r7, #0]
20001fba:	3b01      	subs	r3, #1
20001fbc:	603b      	str	r3, [r7, #0]
	if (msg->len == MSGQUEUESIZE) msg = NULL;
20001fbe:	68fb      	ldr	r3, [r7, #12]
20001fc0:	689b      	ldr	r3, [r3, #8]
20001fc2:	f5b3 7f80 	cmp.w	r3, #256	@ 0x100
20001fc6:	d101      	bne.n	20001fcc <console_save+0xa4>
20001fc8:	2300      	movs	r3, #0
20001fca:	60fb      	str	r3, [r7, #12]
    while (length) {
20001fcc:	683b      	ldr	r3, [r7, #0]
20001fce:	2b00      	cmp	r3, #0
20001fd0:	d1bf      	bne.n	20001f52 <console_save+0x2a>
20001fd2:	e000      	b.n	20001fd6 <console_save+0xae>
	    if (msg == NULL) return;
20001fd4:	bf00      	nop
	}
}
20001fd6:	3710      	adds	r7, #16
20001fd8:	46bd      	mov	sp, r7
20001fda:	bd80      	pop	{r7, pc}
20001fdc:	20009074 	.word	0x20009074
20001fe0:	200091fc 	.word	0x200091fc

20001fe4 <console_readnum>:
    *  Return value:
    *  	   nothing
    ********************************************************************* */

static void console_readnum(int *num,unsigned char *ch)
{
20001fe4:	b580      	push	{r7, lr}
20001fe6:	b084      	sub	sp, #16
20001fe8:	af00      	add	r7, sp, #0
20001fea:	6078      	str	r0, [r7, #4]
20001fec:	6039      	str	r1, [r7, #0]
    int total = 0;
20001fee:	2300      	movs	r3, #0
20001ff0:	60fb      	str	r3, [r7, #12]

    for (;;) {
	total = (total * 10) + (*ch - '0');
20001ff2:	68fa      	ldr	r2, [r7, #12]
20001ff4:	4613      	mov	r3, r2
20001ff6:	009b      	lsls	r3, r3, #2
20001ff8:	4413      	add	r3, r2
20001ffa:	005b      	lsls	r3, r3, #1
20001ffc:	461a      	mov	r2, r3
20001ffe:	683b      	ldr	r3, [r7, #0]
20002000:	781b      	ldrb	r3, [r3, #0]
20002002:	3b30      	subs	r3, #48	@ 0x30
20002004:	4413      	add	r3, r2
20002006:	60fb      	str	r3, [r7, #12]
	while (console_read(ch,1) != 1) { POLL(); }
20002008:	e001      	b.n	2000200e <console_readnum+0x2a>
2000200a:	f7ff fe09 	bl	20001c20 <background>
2000200e:	2101      	movs	r1, #1
20002010:	6838      	ldr	r0, [r7, #0]
20002012:	f7ff fe75 	bl	20001d00 <console_read>
20002016:	4603      	mov	r3, r0
20002018:	2b01      	cmp	r3, #1
2000201a:	d1f6      	bne.n	2000200a <console_readnum+0x26>
	if (!((*ch >= '0') && (*ch <= '9'))) break;
2000201c:	683b      	ldr	r3, [r7, #0]
2000201e:	781b      	ldrb	r3, [r3, #0]
20002020:	2b2f      	cmp	r3, #47	@ 0x2f
20002022:	d904      	bls.n	2000202e <console_readnum+0x4a>
20002024:	683b      	ldr	r3, [r7, #0]
20002026:	781b      	ldrb	r3, [r3, #0]
20002028:	2b39      	cmp	r3, #57	@ 0x39
2000202a:	d800      	bhi.n	2000202e <console_readnum+0x4a>
	total = (total * 10) + (*ch - '0');
2000202c:	e7e1      	b.n	20001ff2 <console_readnum+0xe>
	}

    *num = total;
2000202e:	687b      	ldr	r3, [r7, #4]
20002030:	68fa      	ldr	r2, [r7, #12]
20002032:	601a      	str	r2, [r3, #0]
}
20002034:	bf00      	nop
20002036:	3710      	adds	r7, #16
20002038:	46bd      	mov	sp, r7
2000203a:	bd80      	pop	{r7, pc}

2000203c <console_readkey>:
    *  Return value:
    *  	   virtual key code
    ********************************************************************* */

int console_readkey(void)
{
2000203c:	b580      	push	{r7, lr}
2000203e:	b082      	sub	sp, #8
20002040:	af00      	add	r7, sp, #0
    unsigned char ch;
    int num;

    GETCHAR(ch);
20002042:	e001      	b.n	20002048 <console_readkey+0xc>
20002044:	f7ff fdec 	bl	20001c20 <background>
20002048:	1dfb      	adds	r3, r7, #7
2000204a:	2101      	movs	r1, #1
2000204c:	4618      	mov	r0, r3
2000204e:	f7ff fe57 	bl	20001d00 <console_read>
20002052:	4603      	mov	r3, r0
20002054:	2b01      	cmp	r3, #1
20002056:	d1f5      	bne.n	20002044 <console_readkey+0x8>

    switch (ch) {
20002058:	79fb      	ldrb	r3, [r7, #7]
2000205a:	2b1b      	cmp	r3, #27
2000205c:	f040 80f6 	bne.w	2000224c <console_readkey+0x210>
	case VKEY_ESC:
	    GETCHAR(ch);
20002060:	e001      	b.n	20002066 <console_readkey+0x2a>
20002062:	f7ff fddd 	bl	20001c20 <background>
20002066:	1dfb      	adds	r3, r7, #7
20002068:	2101      	movs	r1, #1
2000206a:	4618      	mov	r0, r3
2000206c:	f7ff fe48 	bl	20001d00 <console_read>
20002070:	4603      	mov	r3, r0
20002072:	2b01      	cmp	r3, #1
20002074:	d1f5      	bne.n	20002062 <console_readkey+0x26>
	    switch (ch) {
20002076:	79fb      	ldrb	r3, [r7, #7]
20002078:	2b4f      	cmp	r3, #79	@ 0x4f
2000207a:	d004      	beq.n	20002086 <console_readkey+0x4a>
2000207c:	2b5b      	cmp	r3, #91	@ 0x5b
2000207e:	d029      	beq.n	200020d4 <console_readkey+0x98>
20002080:	e0e2      	b.n	20002248 <console_readkey+0x20c>
		case 'O':
		    GETCHAR(ch);
20002082:	f7ff fdcd 	bl	20001c20 <background>
20002086:	1dfb      	adds	r3, r7, #7
20002088:	2101      	movs	r1, #1
2000208a:	4618      	mov	r0, r3
2000208c:	f7ff fe38 	bl	20001d00 <console_read>
20002090:	4603      	mov	r3, r0
20002092:	2b01      	cmp	r3, #1
20002094:	d1f5      	bne.n	20002082 <console_readkey+0x46>
		    switch (ch) {
20002096:	79fb      	ldrb	r3, [r7, #7]
20002098:	3b50      	subs	r3, #80	@ 0x50
2000209a:	2b03      	cmp	r3, #3
2000209c:	d816      	bhi.n	200020cc <console_readkey+0x90>
2000209e:	a201      	add	r2, pc, #4	@ (adr r2, 200020a4 <console_readkey+0x68>)
200020a0:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
200020a4:	200020b5 	.word	0x200020b5
200020a8:	200020bb 	.word	0x200020bb
200020ac:	200020c1 	.word	0x200020c1
200020b0:	200020c7 	.word	0x200020c7
			case 'P':
			    return VKEY_F1;
200020b4:	f44f 7388 	mov.w	r3, #272	@ 0x110
200020b8:	e0c9      	b.n	2000224e <console_readkey+0x212>
			case 'Q':
			    return VKEY_F2;
200020ba:	f240 1311 	movw	r3, #273	@ 0x111
200020be:	e0c6      	b.n	2000224e <console_readkey+0x212>
			case 'R':
			    return VKEY_F3;
200020c0:	f44f 7389 	mov.w	r3, #274	@ 0x112
200020c4:	e0c3      	b.n	2000224e <console_readkey+0x212>
			case 'S':
			    return VKEY_F4;
200020c6:	f240 1313 	movw	r3, #275	@ 0x113
200020ca:	e0c0      	b.n	2000224e <console_readkey+0x212>
			}
		    return (int)ch;
200020cc:	79fb      	ldrb	r3, [r7, #7]
200020ce:	e0be      	b.n	2000224e <console_readkey+0x212>

		case '[':
		    GETCHAR(ch);
200020d0:	f7ff fda6 	bl	20001c20 <background>
200020d4:	1dfb      	adds	r3, r7, #7
200020d6:	2101      	movs	r1, #1
200020d8:	4618      	mov	r0, r3
200020da:	f7ff fe11 	bl	20001d00 <console_read>
200020de:	4603      	mov	r3, r0
200020e0:	2b01      	cmp	r3, #1
200020e2:	d1f5      	bne.n	200020d0 <console_readkey+0x94>
		    if ((ch >= '0') && (ch <= '9')) {
200020e4:	79fb      	ldrb	r3, [r7, #7]
200020e6:	2b2f      	cmp	r3, #47	@ 0x2f
200020e8:	f240 8082 	bls.w	200021f0 <console_readkey+0x1b4>
200020ec:	79fb      	ldrb	r3, [r7, #7]
200020ee:	2b39      	cmp	r3, #57	@ 0x39
200020f0:	d87e      	bhi.n	200021f0 <console_readkey+0x1b4>
			console_readnum(&num,&ch);
200020f2:	1dfa      	adds	r2, r7, #7
200020f4:	463b      	mov	r3, r7
200020f6:	4611      	mov	r1, r2
200020f8:	4618      	mov	r0, r3
200020fa:	f7ff ff73 	bl	20001fe4 <console_readnum>
			if (ch == '~') {
200020fe:	79fb      	ldrb	r3, [r7, #7]
20002100:	2b7e      	cmp	r3, #126	@ 0x7e
20002102:	f040 80a1 	bne.w	20002248 <console_readkey+0x20c>
			    switch (num) {
20002106:	683b      	ldr	r3, [r7, #0]
20002108:	3b02      	subs	r3, #2
2000210a:	2b16      	cmp	r3, #22
2000210c:	d86e      	bhi.n	200021ec <console_readkey+0x1b0>
2000210e:	a201      	add	r2, pc, #4	@ (adr r2, 20002114 <console_readkey+0xd8>)
20002110:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
20002114:	20002171 	.word	0x20002171
20002118:	20002177 	.word	0x20002177
2000211c:	200021ed 	.word	0x200021ed
20002120:	2000217d 	.word	0x2000217d
20002124:	20002191 	.word	0x20002191
20002128:	200021ed 	.word	0x200021ed
2000212c:	200021ed 	.word	0x200021ed
20002130:	200021ed 	.word	0x200021ed
20002134:	200021ed 	.word	0x200021ed
20002138:	200021a5 	.word	0x200021a5
2000213c:	200021ab 	.word	0x200021ab
20002140:	200021b1 	.word	0x200021b1
20002144:	200021b7 	.word	0x200021b7
20002148:	200021bd 	.word	0x200021bd
2000214c:	200021ed 	.word	0x200021ed
20002150:	200021c3 	.word	0x200021c3
20002154:	200021c9 	.word	0x200021c9
20002158:	200021cf 	.word	0x200021cf
2000215c:	200021d5 	.word	0x200021d5
20002160:	200021db 	.word	0x200021db
20002164:	200021ed 	.word	0x200021ed
20002168:	200021e1 	.word	0x200021e1
2000216c:	200021e7 	.word	0x200021e7
				case 2:
				    return VKEY_HOME;
20002170:	f240 1307 	movw	r3, #263	@ 0x107
20002174:	e06b      	b.n	2000224e <console_readkey+0x212>
				case 3:
				    return VKEY_PGUP;
20002176:	f240 1305 	movw	r3, #261	@ 0x105
2000217a:	e068      	b.n	2000224e <console_readkey+0x212>
				case 5:
				    if (console_mode == XTERM) return VKEY_PGUP;
2000217c:	4b36      	ldr	r3, [pc, #216]	@ (20002258 <console_readkey+0x21c>)
2000217e:	681b      	ldr	r3, [r3, #0]
20002180:	2b00      	cmp	r3, #0
20002182:	d102      	bne.n	2000218a <console_readkey+0x14e>
20002184:	f240 1305 	movw	r3, #261	@ 0x105
20002188:	e061      	b.n	2000224e <console_readkey+0x212>
				    return VKEY_END;
2000218a:	f44f 7384 	mov.w	r3, #264	@ 0x108
2000218e:	e05e      	b.n	2000224e <console_readkey+0x212>
				case 6:
				    if (console_mode == XTERM) return VKEY_PGDN;
20002190:	4b31      	ldr	r3, [pc, #196]	@ (20002258 <console_readkey+0x21c>)
20002192:	681b      	ldr	r3, [r3, #0]
20002194:	2b00      	cmp	r3, #0
20002196:	d102      	bne.n	2000219e <console_readkey+0x162>
20002198:	f44f 7383 	mov.w	r3, #262	@ 0x106
2000219c:	e057      	b.n	2000224e <console_readkey+0x212>
				    return VKEY_PGDN;
2000219e:	f44f 7383 	mov.w	r3, #262	@ 0x106
200021a2:	e054      	b.n	2000224e <console_readkey+0x212>
				case 11:
				    return VKEY_F1;
200021a4:	f44f 7388 	mov.w	r3, #272	@ 0x110
200021a8:	e051      	b.n	2000224e <console_readkey+0x212>
				case 12:
				    return VKEY_F2;
200021aa:	f240 1311 	movw	r3, #273	@ 0x111
200021ae:	e04e      	b.n	2000224e <console_readkey+0x212>
				case 13:
				    return VKEY_F3;
200021b0:	f44f 7389 	mov.w	r3, #274	@ 0x112
200021b4:	e04b      	b.n	2000224e <console_readkey+0x212>
				case 14:
				    return VKEY_F4;
200021b6:	f240 1313 	movw	r3, #275	@ 0x113
200021ba:	e048      	b.n	2000224e <console_readkey+0x212>
				case 15:
				    return VKEY_F5;
200021bc:	f44f 738a 	mov.w	r3, #276	@ 0x114
200021c0:	e045      	b.n	2000224e <console_readkey+0x212>
				case 17:
				    return VKEY_F6;
200021c2:	f240 1315 	movw	r3, #277	@ 0x115
200021c6:	e042      	b.n	2000224e <console_readkey+0x212>
				case 18:
				    return VKEY_F7;
200021c8:	f44f 738b 	mov.w	r3, #278	@ 0x116
200021cc:	e03f      	b.n	2000224e <console_readkey+0x212>
				case 19:
				    return VKEY_F8;
200021ce:	f240 1317 	movw	r3, #279	@ 0x117
200021d2:	e03c      	b.n	2000224e <console_readkey+0x212>
				case 20:
				    return VKEY_F9;
200021d4:	f44f 738c 	mov.w	r3, #280	@ 0x118
200021d8:	e039      	b.n	2000224e <console_readkey+0x212>
				case 21:
				    return VKEY_F10;
200021da:	f240 1319 	movw	r3, #281	@ 0x119
200021de:	e036      	b.n	2000224e <console_readkey+0x212>
				case 23:
				    return VKEY_F11;
200021e0:	f44f 738d 	mov.w	r3, #282	@ 0x11a
200021e4:	e033      	b.n	2000224e <console_readkey+0x212>
				case 24:
				    return VKEY_F12;
200021e6:	f240 131b 	movw	r3, #283	@ 0x11b
200021ea:	e030      	b.n	2000224e <console_readkey+0x212>
				}
			    return (int)ch;
200021ec:	79fb      	ldrb	r3, [r7, #7]
200021ee:	e02e      	b.n	2000224e <console_readkey+0x212>
			    }
			}
		    else {
			switch (ch) {
200021f0:	79fb      	ldrb	r3, [r7, #7]
200021f2:	3b41      	subs	r3, #65	@ 0x41
200021f4:	2b07      	cmp	r3, #7
200021f6:	d825      	bhi.n	20002244 <console_readkey+0x208>
200021f8:	a201      	add	r2, pc, #4	@ (adr r2, 20002200 <console_readkey+0x1c4>)
200021fa:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
200021fe:	bf00      	nop
20002200:	20002221 	.word	0x20002221
20002204:	20002227 	.word	0x20002227
20002208:	2000222d 	.word	0x2000222d
2000220c:	20002233 	.word	0x20002233
20002210:	20002245 	.word	0x20002245
20002214:	20002239 	.word	0x20002239
20002218:	20002245 	.word	0x20002245
2000221c:	2000223f 	.word	0x2000223f
			    case 'A':
				return VKEY_UP;
20002220:	f240 1301 	movw	r3, #257	@ 0x101
20002224:	e013      	b.n	2000224e <console_readkey+0x212>
			    case 'B':
				return VKEY_DOWN;
20002226:	f44f 7381 	mov.w	r3, #258	@ 0x102
2000222a:	e010      	b.n	2000224e <console_readkey+0x212>
			    case 'C':
				return VKEY_RIGHT;
2000222c:	f44f 7382 	mov.w	r3, #260	@ 0x104
20002230:	e00d      	b.n	2000224e <console_readkey+0x212>
			    case 'D':
				return VKEY_LEFT;
20002232:	f240 1303 	movw	r3, #259	@ 0x103
20002236:	e00a      	b.n	2000224e <console_readkey+0x212>
			    case 'F':
				return VKEY_HOME;
20002238:	f240 1307 	movw	r3, #263	@ 0x107
2000223c:	e007      	b.n	2000224e <console_readkey+0x212>
			    case 'H':
				return VKEY_END;
2000223e:	f44f 7384 	mov.w	r3, #264	@ 0x108
20002242:	e004      	b.n	2000224e <console_readkey+0x212>
			    default:
				return (int) ch;
20002244:	79fb      	ldrb	r3, [r7, #7]
20002246:	e002      	b.n	2000224e <console_readkey+0x212>
			    }
			}
		default:
		    return (int)ch;
20002248:	79fb      	ldrb	r3, [r7, #7]
2000224a:	e000      	b.n	2000224e <console_readkey+0x212>
	
		}
	default:
	    return (int) ch;
2000224c:	79fb      	ldrb	r3, [r7, #7]
	}
}
2000224e:	4618      	mov	r0, r3
20002250:	3708      	adds	r7, #8
20002252:	46bd      	mov	sp, r7
20002254:	bd80      	pop	{r7, pc}
20002256:	bf00      	nop
20002258:	2000931c 	.word	0x2000931c

2000225c <console_backspace>:
    *  Return value:
    *  	   nothing
    ********************************************************************* */

static void console_backspace(int n)
{
2000225c:	b580      	push	{r7, lr}
2000225e:	b084      	sub	sp, #16
20002260:	af00      	add	r7, sp, #0
20002262:	6078      	str	r0, [r7, #4]
    int t;

    for (t = 0; t < n; t++) console_write((unsigned char *)"\b",1);
20002264:	2300      	movs	r3, #0
20002266:	60fb      	str	r3, [r7, #12]
20002268:	e006      	b.n	20002278 <console_backspace+0x1c>
2000226a:	2101      	movs	r1, #1
2000226c:	4807      	ldr	r0, [pc, #28]	@ (2000228c <console_backspace+0x30>)
2000226e:	f7ff fd63 	bl	20001d38 <console_write>
20002272:	68fb      	ldr	r3, [r7, #12]
20002274:	3301      	adds	r3, #1
20002276:	60fb      	str	r3, [r7, #12]
20002278:	68fa      	ldr	r2, [r7, #12]
2000227a:	687b      	ldr	r3, [r7, #4]
2000227c:	429a      	cmp	r2, r3
2000227e:	dbf4      	blt.n	2000226a <console_backspace+0xe>
}
20002280:	bf00      	nop
20002282:	bf00      	nop
20002284:	3710      	adds	r7, #16
20002286:	46bd      	mov	sp, r7
20002288:	bd80      	pop	{r7, pc}
2000228a:	bf00      	nop
2000228c:	200076ac 	.word	0x200076ac

20002290 <console_whiteout>:

static void console_whiteout(int n)
{
20002290:	b580      	push	{r7, lr}
20002292:	b084      	sub	sp, #16
20002294:	af00      	add	r7, sp, #0
20002296:	6078      	str	r0, [r7, #4]
    int t;

    for (t = 0; t < n; t++) console_write((unsigned char *)" ",1);
20002298:	2300      	movs	r3, #0
2000229a:	60fb      	str	r3, [r7, #12]
2000229c:	e006      	b.n	200022ac <console_whiteout+0x1c>
2000229e:	2101      	movs	r1, #1
200022a0:	480e      	ldr	r0, [pc, #56]	@ (200022dc <console_whiteout+0x4c>)
200022a2:	f7ff fd49 	bl	20001d38 <console_write>
200022a6:	68fb      	ldr	r3, [r7, #12]
200022a8:	3301      	adds	r3, #1
200022aa:	60fb      	str	r3, [r7, #12]
200022ac:	68fa      	ldr	r2, [r7, #12]
200022ae:	687b      	ldr	r3, [r7, #4]
200022b0:	429a      	cmp	r2, r3
200022b2:	dbf4      	blt.n	2000229e <console_whiteout+0xe>
    for (t = 0; t < n; t++) console_write((unsigned char *)"\b",1);
200022b4:	2300      	movs	r3, #0
200022b6:	60fb      	str	r3, [r7, #12]
200022b8:	e006      	b.n	200022c8 <console_whiteout+0x38>
200022ba:	2101      	movs	r1, #1
200022bc:	4808      	ldr	r0, [pc, #32]	@ (200022e0 <console_whiteout+0x50>)
200022be:	f7ff fd3b 	bl	20001d38 <console_write>
200022c2:	68fb      	ldr	r3, [r7, #12]
200022c4:	3301      	adds	r3, #1
200022c6:	60fb      	str	r3, [r7, #12]
200022c8:	68fa      	ldr	r2, [r7, #12]
200022ca:	687b      	ldr	r3, [r7, #4]
200022cc:	429a      	cmp	r2, r3
200022ce:	dbf4      	blt.n	200022ba <console_whiteout+0x2a>
}
200022d0:	bf00      	nop
200022d2:	bf00      	nop
200022d4:	3710      	adds	r7, #16
200022d6:	46bd      	mov	sp, r7
200022d8:	bd80      	pop	{r7, pc}
200022da:	bf00      	nop
200022dc:	200076b0 	.word	0x200076b0
200022e0:	200076ac 	.word	0x200076ac

200022e4 <console_eraseeol>:


static void console_eraseeol(void)
{
200022e4:	b580      	push	{r7, lr}
200022e6:	af00      	add	r7, sp, #0
    console_write((unsigned char *)"\033[K",3);
200022e8:	2103      	movs	r1, #3
200022ea:	4802      	ldr	r0, [pc, #8]	@ (200022f4 <console_eraseeol+0x10>)
200022ec:	f7ff fd24 	bl	20001d38 <console_write>
}
200022f0:	bf00      	nop
200022f2:	bd80      	pop	{r7, pc}
200022f4:	200076b4 	.word	0x200076b4

200022f8 <console_crlf>:

static void console_crlf(void)
{
200022f8:	b580      	push	{r7, lr}
200022fa:	af00      	add	r7, sp, #0
    console_write((unsigned char *)"\r\n",2);
200022fc:	2102      	movs	r1, #2
200022fe:	4802      	ldr	r0, [pc, #8]	@ (20002308 <console_crlf+0x10>)
20002300:	f7ff fd1a 	bl	20001d38 <console_write>
}
20002304:	bf00      	nop
20002306:	bd80      	pop	{r7, pc}
20002308:	20007684 	.word	0x20007684

2000230c <console_readline_default>:
    *  	   number of characters read (terminating newline is not
    *  	   placed in the buffer)
    ********************************************************************* */

int console_readline_default(char *prompt,char *str,int maxlen)
{
2000230c:	b590      	push	{r4, r7, lr}
2000230e:	b091      	sub	sp, #68	@ 0x44
20002310:	af00      	add	r7, sp, #0
20002312:	60f8      	str	r0, [r7, #12]
20002314:	60b9      	str	r1, [r7, #8]
20002316:	607a      	str	r2, [r7, #4]
    int reading = 1;
20002318:	2301      	movs	r3, #1
2000231a:	63fb      	str	r3, [r7, #60]	@ 0x3c
    int ch;
    int idx = 0;
2000231c:	2300      	movs	r3, #0
2000231e:	63bb      	str	r3, [r7, #56]	@ 0x38
    int len = 0;
20002320:	2300      	movs	r3, #0
20002322:	637b      	str	r3, [r7, #52]	@ 0x34
    int t;
    int klen;
    int recall;
    int nosave = 0;
20002324:	2300      	movs	r3, #0
20002326:	62bb      	str	r3, [r7, #40]	@ 0x28
    char *x;
    char env[10];

    console_inreadline++;
20002328:	4b5d      	ldr	r3, [pc, #372]	@ (200024a0 <console_readline_default+0x194>)
2000232a:	681b      	ldr	r3, [r3, #0]
2000232c:	3301      	adds	r3, #1
2000232e:	4a5c      	ldr	r2, [pc, #368]	@ (200024a0 <console_readline_default+0x194>)
20002330:	6013      	str	r3, [r2, #0]
    recall = console_nextsave;
20002332:	4b5c      	ldr	r3, [pc, #368]	@ (200024a4 <console_readline_default+0x198>)
20002334:	681b      	ldr	r3, [r3, #0]
20002336:	62fb      	str	r3, [r7, #44]	@ 0x2c

    if (console_savedlines[console_nextsave]) {
20002338:	4b5a      	ldr	r3, [pc, #360]	@ (200024a4 <console_readline_default+0x198>)
2000233a:	681b      	ldr	r3, [r3, #0]
2000233c:	4a5a      	ldr	r2, [pc, #360]	@ (200024a8 <console_readline_default+0x19c>)
2000233e:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
20002342:	2b00      	cmp	r3, #0
20002344:	d00e      	beq.n	20002364 <console_readline_default+0x58>
	KFREE(console_savedlines[console_nextsave]);
20002346:	4b57      	ldr	r3, [pc, #348]	@ (200024a4 <console_readline_default+0x198>)
20002348:	681b      	ldr	r3, [r3, #0]
2000234a:	4a57      	ldr	r2, [pc, #348]	@ (200024a8 <console_readline_default+0x19c>)
2000234c:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
20002350:	4619      	mov	r1, r3
20002352:	4856      	ldr	r0, [pc, #344]	@ (200024ac <console_readline_default+0x1a0>)
20002354:	f7fe fe8c 	bl	20001070 <kfree>
	console_savedlines[console_nextsave] = NULL;
20002358:	4b52      	ldr	r3, [pc, #328]	@ (200024a4 <console_readline_default+0x198>)
2000235a:	681b      	ldr	r3, [r3, #0]
2000235c:	4a52      	ldr	r2, [pc, #328]	@ (200024a8 <console_readline_default+0x19c>)
2000235e:	2100      	movs	r1, #0
20002360:	f842 1023 	str.w	r1, [r2, r3, lsl #2]
	}
    console_savedlines[console_nextsave] = strdup("");
20002364:	4b4f      	ldr	r3, [pc, #316]	@ (200024a4 <console_readline_default+0x198>)
20002366:	681c      	ldr	r4, [r3, #0]
20002368:	4851      	ldr	r0, [pc, #324]	@ (200024b0 <console_readline_default+0x1a4>)
2000236a:	f7ff faef 	bl	2000194c <lib_strdup>
2000236e:	4603      	mov	r3, r0
20002370:	4a4d      	ldr	r2, [pc, #308]	@ (200024a8 <console_readline_default+0x19c>)
20002372:	f842 3024 	str.w	r3, [r2, r4, lsl #2]

    idx = len = strlen(str);
20002376:	68b8      	ldr	r0, [r7, #8]
20002378:	f7ff f895 	bl	200014a6 <lib_strlen>
2000237c:	6378      	str	r0, [r7, #52]	@ 0x34
2000237e:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
20002380:	63bb      	str	r3, [r7, #56]	@ 0x38

    if (prompt && *prompt) console_write((unsigned char *)prompt,strlen(prompt));
20002382:	68fb      	ldr	r3, [r7, #12]
20002384:	2b00      	cmp	r3, #0
20002386:	d00b      	beq.n	200023a0 <console_readline_default+0x94>
20002388:	68fb      	ldr	r3, [r7, #12]
2000238a:	781b      	ldrb	r3, [r3, #0]
2000238c:	2b00      	cmp	r3, #0
2000238e:	d007      	beq.n	200023a0 <console_readline_default+0x94>
20002390:	68f8      	ldr	r0, [r7, #12]
20002392:	f7ff f888 	bl	200014a6 <lib_strlen>
20002396:	4603      	mov	r3, r0
20002398:	4619      	mov	r1, r3
2000239a:	68f8      	ldr	r0, [r7, #12]
2000239c:	f7ff fccc 	bl	20001d38 <console_write>
    console_write((unsigned char *)str,idx);
200023a0:	6bb9      	ldr	r1, [r7, #56]	@ 0x38
200023a2:	68b8      	ldr	r0, [r7, #8]
200023a4:	f7ff fcc8 	bl	20001d38 <console_write>

    POLL();
200023a8:	f7ff fc3a 	bl	20001c20 <background>
    while (reading) {
200023ac:	f000 bc39 	b.w	20002c22 <console_readline_default+0x916>
	/*
	 * If someone used console_log (above) or hit Control-C (below),
	 * redisplay the prompt and the string we've got so far.
	 */

	if (console_redisplay) {
200023b0:	4b40      	ldr	r3, [pc, #256]	@ (200024b4 <console_readline_default+0x1a8>)
200023b2:	681b      	ldr	r3, [r3, #0]
200023b4:	2b00      	cmp	r3, #0
200023b6:	d017      	beq.n	200023e8 <console_readline_default+0xdc>
	    if (prompt && *prompt) console_write((unsigned char *)prompt,strlen(prompt));
200023b8:	68fb      	ldr	r3, [r7, #12]
200023ba:	2b00      	cmp	r3, #0
200023bc:	d00b      	beq.n	200023d6 <console_readline_default+0xca>
200023be:	68fb      	ldr	r3, [r7, #12]
200023c0:	781b      	ldrb	r3, [r3, #0]
200023c2:	2b00      	cmp	r3, #0
200023c4:	d007      	beq.n	200023d6 <console_readline_default+0xca>
200023c6:	68f8      	ldr	r0, [r7, #12]
200023c8:	f7ff f86d 	bl	200014a6 <lib_strlen>
200023cc:	4603      	mov	r3, r0
200023ce:	4619      	mov	r1, r3
200023d0:	68f8      	ldr	r0, [r7, #12]
200023d2:	f7ff fcb1 	bl	20001d38 <console_write>
	    console_write((unsigned char *)str,idx);
200023d6:	6bb9      	ldr	r1, [r7, #56]	@ 0x38
200023d8:	68b8      	ldr	r0, [r7, #8]
200023da:	f7ff fcad 	bl	20001d38 <console_write>
	    console_redisplay = 0;
200023de:	4b35      	ldr	r3, [pc, #212]	@ (200024b4 <console_readline_default+0x1a8>)
200023e0:	2200      	movs	r2, #0
200023e2:	601a      	str	r2, [r3, #0]
	    continue;
200023e4:	f000 bc1d 	b.w	20002c22 <console_readline_default+0x916>

	/*
	 * if nobody's typed anything, keep polling
	 */

	if (console_status() == 0) {
200023e8:	f7ff fce6 	bl	20001db8 <console_status>
200023ec:	4603      	mov	r3, r0
200023ee:	2b00      	cmp	r3, #0
200023f0:	d103      	bne.n	200023fa <console_readline_default+0xee>
	    POLL();
200023f2:	f7ff fc15 	bl	20001c20 <background>
	    continue;
200023f6:	f000 bc14 	b.w	20002c22 <console_readline_default+0x916>

	/*
	 * Get the char from the keyboard
	 */

	ch = console_readkey();
200023fa:	f7ff fe1f 	bl	2000203c <console_readkey>
200023fe:	6278      	str	r0, [r7, #36]	@ 0x24
	if (ch < 0) break;
20002400:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
20002402:	2b00      	cmp	r3, #0
20002404:	f2c0 841a 	blt.w	20002c3c <console_readline_default+0x930>
	if (ch == 0) continue;
20002408:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
2000240a:	2b00      	cmp	r3, #0
2000240c:	f000 83ee 	beq.w	20002bec <console_readline_default+0x8e0>

	/*
	 * And dispatch it.  Lots of yucky character manipulation follows
	 */

	switch (ch) {
20002410:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
20002412:	2b7f      	cmp	r3, #127	@ 0x7f
20002414:	f300 8156 	bgt.w	200026c4 <console_readline_default+0x3b8>
20002418:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
2000241a:	2b00      	cmp	r3, #0
2000241c:	dc4c      	bgt.n	200024b8 <console_readline_default+0x1ac>
2000241e:	e3a7      	b.n	20002b70 <console_readline_default+0x864>
20002420:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
20002422:	f2a3 1301 	subw	r3, r3, #257	@ 0x101
20002426:	2b1a      	cmp	r3, #26
20002428:	f200 83a2 	bhi.w	20002b70 <console_readline_default+0x864>
2000242c:	a201      	add	r2, pc, #4	@ (adr r2, 20002434 <console_readline_default+0x128>)
2000242e:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
20002432:	bf00      	nop
20002434:	200029b9 	.word	0x200029b9
20002438:	20002a43 	.word	0x20002a43
2000243c:	200027d7 	.word	0x200027d7
20002440:	200027ed 	.word	0x200027ed
20002444:	20002b71 	.word	0x20002b71
20002448:	20002b71 	.word	0x20002b71
2000244c:	20002b71 	.word	0x20002b71
20002450:	20002b71 	.word	0x20002b71
20002454:	20002b71 	.word	0x20002b71
20002458:	20002b71 	.word	0x20002b71
2000245c:	20002b71 	.word	0x20002b71
20002460:	20002b71 	.word	0x20002b71
20002464:	20002b71 	.word	0x20002b71
20002468:	20002b71 	.word	0x20002b71
2000246c:	20002b71 	.word	0x20002b71
20002470:	20002aa5 	.word	0x20002aa5
20002474:	20002aa5 	.word	0x20002aa5
20002478:	20002aa5 	.word	0x20002aa5
2000247c:	20002aa5 	.word	0x20002aa5
20002480:	20002aa5 	.word	0x20002aa5
20002484:	20002aa5 	.word	0x20002aa5
20002488:	20002aa5 	.word	0x20002aa5
2000248c:	20002aa5 	.word	0x20002aa5
20002490:	20002aa5 	.word	0x20002aa5
20002494:	20002aa5 	.word	0x20002aa5
20002498:	20002aa5 	.word	0x20002aa5
2000249c:	20002aa5 	.word	0x20002aa5
200024a0:	20009324 	.word	0x20009324
200024a4:	20009298 	.word	0x20009298
200024a8:	2000929c 	.word	0x2000929c
200024ac:	200091fc 	.word	0x200091fc
200024b0:	200076b8 	.word	0x200076b8
200024b4:	20009328 	.word	0x20009328
200024b8:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
200024ba:	3b01      	subs	r3, #1
200024bc:	2b7e      	cmp	r3, #126	@ 0x7e
200024be:	f200 8357 	bhi.w	20002b70 <console_readline_default+0x864>
200024c2:	a201      	add	r2, pc, #4	@ (adr r2, 200024c8 <console_readline_default+0x1bc>)
200024c4:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
200024c8:	2000280d 	.word	0x2000280d
200024cc:	200027d7 	.word	0x200027d7
200024d0:	200026db 	.word	0x200026db
200024d4:	2000276f 	.word	0x2000276f
200024d8:	20002819 	.word	0x20002819
200024dc:	200027ed 	.word	0x200027ed
200024e0:	20002b71 	.word	0x20002b71
200024e4:	200026f3 	.word	0x200026f3
200024e8:	20002b71 	.word	0x20002b71
200024ec:	200029af 	.word	0x200029af
200024f0:	2000283b 	.word	0x2000283b
200024f4:	20002b71 	.word	0x20002b71
200024f8:	200029af 	.word	0x200029af
200024fc:	20002a43 	.word	0x20002a43
20002500:	20002b71 	.word	0x20002b71
20002504:	200029b9 	.word	0x200029b9
20002508:	20002b71 	.word	0x20002b71
2000250c:	2000295d 	.word	0x2000295d
20002510:	20002b71 	.word	0x20002b71
20002514:	20002b71 	.word	0x20002b71
20002518:	20002991 	.word	0x20002991
2000251c:	20002b71 	.word	0x20002b71
20002520:	20002b71 	.word	0x20002b71
20002524:	20002b71 	.word	0x20002b71
20002528:	2000288b 	.word	0x2000288b
2000252c:	20002b71 	.word	0x20002b71
20002530:	20002b71 	.word	0x20002b71
20002534:	20002b71 	.word	0x20002b71
20002538:	20002b71 	.word	0x20002b71
2000253c:	20002b71 	.word	0x20002b71
20002540:	20002b71 	.word	0x20002b71
20002544:	20002b71 	.word	0x20002b71
20002548:	20002b71 	.word	0x20002b71
2000254c:	20002b71 	.word	0x20002b71
20002550:	20002b71 	.word	0x20002b71
20002554:	20002b71 	.word	0x20002b71
20002558:	20002b71 	.word	0x20002b71
2000255c:	20002b71 	.word	0x20002b71
20002560:	20002b71 	.word	0x20002b71
20002564:	20002b71 	.word	0x20002b71
20002568:	20002b71 	.word	0x20002b71
2000256c:	20002b71 	.word	0x20002b71
20002570:	20002b71 	.word	0x20002b71
20002574:	20002b71 	.word	0x20002b71
20002578:	20002b71 	.word	0x20002b71
2000257c:	20002b71 	.word	0x20002b71
20002580:	20002b71 	.word	0x20002b71
20002584:	20002b71 	.word	0x20002b71
20002588:	20002b71 	.word	0x20002b71
2000258c:	20002b71 	.word	0x20002b71
20002590:	20002b71 	.word	0x20002b71
20002594:	20002b71 	.word	0x20002b71
20002598:	20002b71 	.word	0x20002b71
2000259c:	20002b71 	.word	0x20002b71
200025a0:	20002b71 	.word	0x20002b71
200025a4:	20002b71 	.word	0x20002b71
200025a8:	20002b71 	.word	0x20002b71
200025ac:	20002b71 	.word	0x20002b71
200025b0:	20002b71 	.word	0x20002b71
200025b4:	20002b71 	.word	0x20002b71
200025b8:	20002b71 	.word	0x20002b71
200025bc:	20002b71 	.word	0x20002b71
200025c0:	20002b71 	.word	0x20002b71
200025c4:	20002b71 	.word	0x20002b71
200025c8:	20002b71 	.word	0x20002b71
200025cc:	20002b71 	.word	0x20002b71
200025d0:	20002b71 	.word	0x20002b71
200025d4:	20002b71 	.word	0x20002b71
200025d8:	20002b71 	.word	0x20002b71
200025dc:	20002b71 	.word	0x20002b71
200025e0:	20002b71 	.word	0x20002b71
200025e4:	20002b71 	.word	0x20002b71
200025e8:	20002b71 	.word	0x20002b71
200025ec:	20002b71 	.word	0x20002b71
200025f0:	20002b71 	.word	0x20002b71
200025f4:	20002b71 	.word	0x20002b71
200025f8:	20002b71 	.word	0x20002b71
200025fc:	20002b71 	.word	0x20002b71
20002600:	20002b71 	.word	0x20002b71
20002604:	20002b71 	.word	0x20002b71
20002608:	20002b71 	.word	0x20002b71
2000260c:	20002b71 	.word	0x20002b71
20002610:	20002b71 	.word	0x20002b71
20002614:	20002b71 	.word	0x20002b71
20002618:	20002b71 	.word	0x20002b71
2000261c:	20002b71 	.word	0x20002b71
20002620:	20002b71 	.word	0x20002b71
20002624:	20002b71 	.word	0x20002b71
20002628:	20002b71 	.word	0x20002b71
2000262c:	20002b71 	.word	0x20002b71
20002630:	20002b71 	.word	0x20002b71
20002634:	20002b71 	.word	0x20002b71
20002638:	20002b71 	.word	0x20002b71
2000263c:	20002b71 	.word	0x20002b71
20002640:	20002b71 	.word	0x20002b71
20002644:	20002b71 	.word	0x20002b71
20002648:	20002b71 	.word	0x20002b71
2000264c:	20002b71 	.word	0x20002b71
20002650:	20002b71 	.word	0x20002b71
20002654:	20002b71 	.word	0x20002b71
20002658:	20002b71 	.word	0x20002b71
2000265c:	20002b71 	.word	0x20002b71
20002660:	20002b71 	.word	0x20002b71
20002664:	20002b71 	.word	0x20002b71
20002668:	20002b71 	.word	0x20002b71
2000266c:	20002b71 	.word	0x20002b71
20002670:	20002b71 	.word	0x20002b71
20002674:	20002b71 	.word	0x20002b71
20002678:	20002b71 	.word	0x20002b71
2000267c:	20002b71 	.word	0x20002b71
20002680:	20002b71 	.word	0x20002b71
20002684:	20002b71 	.word	0x20002b71
20002688:	20002b71 	.word	0x20002b71
2000268c:	20002b71 	.word	0x20002b71
20002690:	20002b71 	.word	0x20002b71
20002694:	20002b71 	.word	0x20002b71
20002698:	20002b71 	.word	0x20002b71
2000269c:	20002b71 	.word	0x20002b71
200026a0:	20002b71 	.word	0x20002b71
200026a4:	20002b71 	.word	0x20002b71
200026a8:	20002b71 	.word	0x20002b71
200026ac:	20002b71 	.word	0x20002b71
200026b0:	20002b71 	.word	0x20002b71
200026b4:	20002b71 	.word	0x20002b71
200026b8:	20002b71 	.word	0x20002b71
200026bc:	20002b71 	.word	0x20002b71
200026c0:	200026f3 	.word	0x200026f3
200026c4:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
200026c6:	f5b3 7f8e 	cmp.w	r3, #284	@ 0x11c
200026ca:	f280 8251 	bge.w	20002b70 <console_readline_default+0x864>
200026ce:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
200026d0:	f5b3 7f80 	cmp.w	r3, #256	@ 0x100
200026d4:	f73f aea4 	bgt.w	20002420 <console_readline_default+0x114>
200026d8:	e24a      	b.n	20002b70 <console_readline_default+0x864>

		case CTRL('C'):			/* Ctrl-C - cancel line */
		console_write((unsigned char *)"^C\r\n",4);
200026da:	2104      	movs	r1, #4
200026dc:	489a      	ldr	r0, [pc, #616]	@ (20002948 <console_readline_default+0x63c>)
200026de:	f7ff fb2b 	bl	20001d38 <console_write>
		console_redisplay = 1;
200026e2:	4b9a      	ldr	r3, [pc, #616]	@ (2000294c <console_readline_default+0x640>)
200026e4:	2201      	movs	r2, #1
200026e6:	601a      	str	r2, [r3, #0]
		nosave = 1;
200026e8:	2301      	movs	r3, #1
200026ea:	62bb      	str	r3, [r7, #40]	@ 0x28
		idx = 0;
200026ec:	2300      	movs	r3, #0
200026ee:	63bb      	str	r3, [r7, #56]	@ 0x38
		break;
200026f0:	e297      	b.n	20002c22 <console_readline_default+0x916>

	    case 0x7f:				/* Backspace, Delete */
	    case CTRL('H'):
		if (idx > 0) {
200026f2:	6bbb      	ldr	r3, [r7, #56]	@ 0x38
200026f4:	2b00      	cmp	r3, #0
200026f6:	f340 827b 	ble.w	20002bf0 <console_readline_default+0x8e4>
		    nosave = 0;
200026fa:	2300      	movs	r3, #0
200026fc:	62bb      	str	r3, [r7, #40]	@ 0x28
		    len--;
200026fe:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
20002700:	3b01      	subs	r3, #1
20002702:	637b      	str	r3, [r7, #52]	@ 0x34
		    idx--;
20002704:	6bbb      	ldr	r3, [r7, #56]	@ 0x38
20002706:	3b01      	subs	r3, #1
20002708:	63bb      	str	r3, [r7, #56]	@ 0x38
		    console_write((unsigned char *)"\b",1);
2000270a:	2101      	movs	r1, #1
2000270c:	4890      	ldr	r0, [pc, #576]	@ (20002950 <console_readline_default+0x644>)
2000270e:	f7ff fb13 	bl	20001d38 <console_write>
		    if (len != idx) {
20002712:	6b7a      	ldr	r2, [r7, #52]	@ 0x34
20002714:	6bbb      	ldr	r3, [r7, #56]	@ 0x38
20002716:	429a      	cmp	r2, r3
20002718:	d025      	beq.n	20002766 <console_readline_default+0x45a>
			for (t = idx; t < len; t++) str[t] = str[t+1];
2000271a:	6bbb      	ldr	r3, [r7, #56]	@ 0x38
2000271c:	633b      	str	r3, [r7, #48]	@ 0x30
2000271e:	e00b      	b.n	20002738 <console_readline_default+0x42c>
20002720:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
20002722:	3301      	adds	r3, #1
20002724:	68ba      	ldr	r2, [r7, #8]
20002726:	441a      	add	r2, r3
20002728:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
2000272a:	68b9      	ldr	r1, [r7, #8]
2000272c:	440b      	add	r3, r1
2000272e:	7812      	ldrb	r2, [r2, #0]
20002730:	701a      	strb	r2, [r3, #0]
20002732:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
20002734:	3301      	adds	r3, #1
20002736:	633b      	str	r3, [r7, #48]	@ 0x30
20002738:	6b3a      	ldr	r2, [r7, #48]	@ 0x30
2000273a:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
2000273c:	429a      	cmp	r2, r3
2000273e:	dbef      	blt.n	20002720 <console_readline_default+0x414>
			console_write((unsigned char *)&str[idx],len-idx);
20002740:	6bbb      	ldr	r3, [r7, #56]	@ 0x38
20002742:	68ba      	ldr	r2, [r7, #8]
20002744:	18d0      	adds	r0, r2, r3
20002746:	6b7a      	ldr	r2, [r7, #52]	@ 0x34
20002748:	6bbb      	ldr	r3, [r7, #56]	@ 0x38
2000274a:	1ad3      	subs	r3, r2, r3
2000274c:	4619      	mov	r1, r3
2000274e:	f7ff faf3 	bl	20001d38 <console_write>
			console_whiteout(1);
20002752:	2001      	movs	r0, #1
20002754:	f7ff fd9c 	bl	20002290 <console_whiteout>
			console_backspace(len-idx);
20002758:	6b7a      	ldr	r2, [r7, #52]	@ 0x34
2000275a:	6bbb      	ldr	r3, [r7, #56]	@ 0x38
2000275c:	1ad3      	subs	r3, r2, r3
2000275e:	4618      	mov	r0, r3
20002760:	f7ff fd7c 	bl	2000225c <console_backspace>
			}
		    else {
			console_whiteout(1);
			}
		    }
		break;
20002764:	e244      	b.n	20002bf0 <console_readline_default+0x8e4>
			console_whiteout(1);
20002766:	2001      	movs	r0, #1
20002768:	f7ff fd92 	bl	20002290 <console_whiteout>
		break;
2000276c:	e240      	b.n	20002bf0 <console_readline_default+0x8e4>

	    case CTRL('D'):			/* Ctrl-D */
		if ((idx >= 0) && (len != idx)) {
2000276e:	6bbb      	ldr	r3, [r7, #56]	@ 0x38
20002770:	2b00      	cmp	r3, #0
20002772:	f2c0 823f 	blt.w	20002bf4 <console_readline_default+0x8e8>
20002776:	6b7a      	ldr	r2, [r7, #52]	@ 0x34
20002778:	6bbb      	ldr	r3, [r7, #56]	@ 0x38
2000277a:	429a      	cmp	r2, r3
2000277c:	f000 823a 	beq.w	20002bf4 <console_readline_default+0x8e8>
		    nosave = 0;
20002780:	2300      	movs	r3, #0
20002782:	62bb      	str	r3, [r7, #40]	@ 0x28
		    len--;
20002784:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
20002786:	3b01      	subs	r3, #1
20002788:	637b      	str	r3, [r7, #52]	@ 0x34
		    for (t = idx; t < len; t++) str[t] = str[t+1];
2000278a:	6bbb      	ldr	r3, [r7, #56]	@ 0x38
2000278c:	633b      	str	r3, [r7, #48]	@ 0x30
2000278e:	e00b      	b.n	200027a8 <console_readline_default+0x49c>
20002790:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
20002792:	3301      	adds	r3, #1
20002794:	68ba      	ldr	r2, [r7, #8]
20002796:	441a      	add	r2, r3
20002798:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
2000279a:	68b9      	ldr	r1, [r7, #8]
2000279c:	440b      	add	r3, r1
2000279e:	7812      	ldrb	r2, [r2, #0]
200027a0:	701a      	strb	r2, [r3, #0]
200027a2:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
200027a4:	3301      	adds	r3, #1
200027a6:	633b      	str	r3, [r7, #48]	@ 0x30
200027a8:	6b3a      	ldr	r2, [r7, #48]	@ 0x30
200027aa:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
200027ac:	429a      	cmp	r2, r3
200027ae:	dbef      	blt.n	20002790 <console_readline_default+0x484>
		    console_write((unsigned char *)&str[idx],len-idx);
200027b0:	6bbb      	ldr	r3, [r7, #56]	@ 0x38
200027b2:	68ba      	ldr	r2, [r7, #8]
200027b4:	18d0      	adds	r0, r2, r3
200027b6:	6b7a      	ldr	r2, [r7, #52]	@ 0x34
200027b8:	6bbb      	ldr	r3, [r7, #56]	@ 0x38
200027ba:	1ad3      	subs	r3, r2, r3
200027bc:	4619      	mov	r1, r3
200027be:	f7ff fabb 	bl	20001d38 <console_write>
		    console_whiteout(1);
200027c2:	2001      	movs	r0, #1
200027c4:	f7ff fd64 	bl	20002290 <console_whiteout>
		    console_backspace(len-idx);
200027c8:	6b7a      	ldr	r2, [r7, #52]	@ 0x34
200027ca:	6bbb      	ldr	r3, [r7, #56]	@ 0x38
200027cc:	1ad3      	subs	r3, r2, r3
200027ce:	4618      	mov	r0, r3
200027d0:	f7ff fd44 	bl	2000225c <console_backspace>
		    }
		break;
200027d4:	e20e      	b.n	20002bf4 <console_readline_default+0x8e8>

	    case CTRL('B'):			/* cursor left */
	    case VKEY_LEFT:
		if (idx > 0) {
200027d6:	6bbb      	ldr	r3, [r7, #56]	@ 0x38
200027d8:	2b00      	cmp	r3, #0
200027da:	f340 820d 	ble.w	20002bf8 <console_readline_default+0x8ec>
		    idx--;
200027de:	6bbb      	ldr	r3, [r7, #56]	@ 0x38
200027e0:	3b01      	subs	r3, #1
200027e2:	63bb      	str	r3, [r7, #56]	@ 0x38
		    console_backspace(1);
200027e4:	2001      	movs	r0, #1
200027e6:	f7ff fd39 	bl	2000225c <console_backspace>
		    }
		break;
200027ea:	e205      	b.n	20002bf8 <console_readline_default+0x8ec>

	    case CTRL('F'):			/* cursor right */
	    case VKEY_RIGHT:
		if (idx < len) {
200027ec:	6bba      	ldr	r2, [r7, #56]	@ 0x38
200027ee:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
200027f0:	429a      	cmp	r2, r3
200027f2:	f280 8203 	bge.w	20002bfc <console_readline_default+0x8f0>
		    console_write((unsigned char *)&str[idx],1);
200027f6:	6bbb      	ldr	r3, [r7, #56]	@ 0x38
200027f8:	68ba      	ldr	r2, [r7, #8]
200027fa:	4413      	add	r3, r2
200027fc:	2101      	movs	r1, #1
200027fe:	4618      	mov	r0, r3
20002800:	f7ff fa9a 	bl	20001d38 <console_write>
		    idx++;
20002804:	6bbb      	ldr	r3, [r7, #56]	@ 0x38
20002806:	3301      	adds	r3, #1
20002808:	63bb      	str	r3, [r7, #56]	@ 0x38
		    }
		break;
2000280a:	e1f7      	b.n	20002bfc <console_readline_default+0x8f0>

	    case CTRL('A'):			/* cursor to BOL */
		console_backspace(idx);
2000280c:	6bb8      	ldr	r0, [r7, #56]	@ 0x38
2000280e:	f7ff fd25 	bl	2000225c <console_backspace>
		idx = 0;
20002812:	2300      	movs	r3, #0
20002814:	63bb      	str	r3, [r7, #56]	@ 0x38
		break;
20002816:	e204      	b.n	20002c22 <console_readline_default+0x916>

	    case CTRL('E'):			/* cursor to EOL */
		if (len-idx > 0) console_write((unsigned char *)&str[idx],len-idx);
20002818:	6b7a      	ldr	r2, [r7, #52]	@ 0x34
2000281a:	6bbb      	ldr	r3, [r7, #56]	@ 0x38
2000281c:	1ad3      	subs	r3, r2, r3
2000281e:	2b00      	cmp	r3, #0
20002820:	dd08      	ble.n	20002834 <console_readline_default+0x528>
20002822:	6bbb      	ldr	r3, [r7, #56]	@ 0x38
20002824:	68ba      	ldr	r2, [r7, #8]
20002826:	18d0      	adds	r0, r2, r3
20002828:	6b7a      	ldr	r2, [r7, #52]	@ 0x34
2000282a:	6bbb      	ldr	r3, [r7, #56]	@ 0x38
2000282c:	1ad3      	subs	r3, r2, r3
2000282e:	4619      	mov	r1, r3
20002830:	f7ff fa82 	bl	20001d38 <console_write>
		idx = len;
20002834:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
20002836:	63bb      	str	r3, [r7, #56]	@ 0x38
		break;
20002838:	e1f3      	b.n	20002c22 <console_readline_default+0x916>

	    case CTRL('K'):			/* Kill to EOL */
		if (idx != len) {
2000283a:	6bba      	ldr	r2, [r7, #56]	@ 0x38
2000283c:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
2000283e:	429a      	cmp	r2, r3
20002840:	f000 81de 	beq.w	20002c00 <console_readline_default+0x8f4>
		    str[len] = '\0';
20002844:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
20002846:	68ba      	ldr	r2, [r7, #8]
20002848:	4413      	add	r3, r2
2000284a:	2200      	movs	r2, #0
2000284c:	701a      	strb	r2, [r3, #0]
		    if (console_killbuffer) KFREE(console_killbuffer);
2000284e:	4b41      	ldr	r3, [pc, #260]	@ (20002954 <console_readline_default+0x648>)
20002850:	681b      	ldr	r3, [r3, #0]
20002852:	2b00      	cmp	r3, #0
20002854:	d005      	beq.n	20002862 <console_readline_default+0x556>
20002856:	4b3f      	ldr	r3, [pc, #252]	@ (20002954 <console_readline_default+0x648>)
20002858:	681b      	ldr	r3, [r3, #0]
2000285a:	4619      	mov	r1, r3
2000285c:	483e      	ldr	r0, [pc, #248]	@ (20002958 <console_readline_default+0x64c>)
2000285e:	f7fe fc07 	bl	20001070 <kfree>
		    console_killbuffer = strdup(&str[idx]);
20002862:	6bbb      	ldr	r3, [r7, #56]	@ 0x38
20002864:	68ba      	ldr	r2, [r7, #8]
20002866:	4413      	add	r3, r2
20002868:	4618      	mov	r0, r3
2000286a:	f7ff f86f 	bl	2000194c <lib_strdup>
2000286e:	4603      	mov	r3, r0
20002870:	4a38      	ldr	r2, [pc, #224]	@ (20002954 <console_readline_default+0x648>)
20002872:	6013      	str	r3, [r2, #0]
		    console_whiteout(len-idx);
20002874:	6b7a      	ldr	r2, [r7, #52]	@ 0x34
20002876:	6bbb      	ldr	r3, [r7, #56]	@ 0x38
20002878:	1ad3      	subs	r3, r2, r3
2000287a:	4618      	mov	r0, r3
2000287c:	f7ff fd08 	bl	20002290 <console_whiteout>
		    len = idx;
20002880:	6bbb      	ldr	r3, [r7, #56]	@ 0x38
20002882:	637b      	str	r3, [r7, #52]	@ 0x34
		    nosave = 0;
20002884:	2300      	movs	r3, #0
20002886:	62bb      	str	r3, [r7, #40]	@ 0x28
		    }
		break;
20002888:	e1ba      	b.n	20002c00 <console_readline_default+0x8f4>

	    case CTRL('Y'):			/* Yank killed data */
		if (console_killbuffer == NULL) break;
2000288a:	4b32      	ldr	r3, [pc, #200]	@ (20002954 <console_readline_default+0x648>)
2000288c:	681b      	ldr	r3, [r3, #0]
2000288e:	2b00      	cmp	r3, #0
20002890:	f000 81b8 	beq.w	20002c04 <console_readline_default+0x8f8>
		klen = strlen(console_killbuffer);
20002894:	4b2f      	ldr	r3, [pc, #188]	@ (20002954 <console_readline_default+0x648>)
20002896:	681b      	ldr	r3, [r3, #0]
20002898:	4618      	mov	r0, r3
2000289a:	f7fe fe04 	bl	200014a6 <lib_strlen>
2000289e:	61f8      	str	r0, [r7, #28]
		if (klen == 0) break;
200028a0:	69fb      	ldr	r3, [r7, #28]
200028a2:	2b00      	cmp	r3, #0
200028a4:	f000 81b0 	beq.w	20002c08 <console_readline_default+0x8fc>
		if (len + klen > maxlen) break;
200028a8:	6b7a      	ldr	r2, [r7, #52]	@ 0x34
200028aa:	69fb      	ldr	r3, [r7, #28]
200028ac:	4413      	add	r3, r2
200028ae:	687a      	ldr	r2, [r7, #4]
200028b0:	429a      	cmp	r2, r3
200028b2:	f2c0 81ab 	blt.w	20002c0c <console_readline_default+0x900>
		nosave = 0;
200028b6:	2300      	movs	r3, #0
200028b8:	62bb      	str	r3, [r7, #40]	@ 0x28
		for (t = len + klen; t > idx; t--) {
200028ba:	6b7a      	ldr	r2, [r7, #52]	@ 0x34
200028bc:	69fb      	ldr	r3, [r7, #28]
200028be:	4413      	add	r3, r2
200028c0:	633b      	str	r3, [r7, #48]	@ 0x30
200028c2:	e00e      	b.n	200028e2 <console_readline_default+0x5d6>
		    str[t-1] = str[t-klen-1];
200028c4:	6b3a      	ldr	r2, [r7, #48]	@ 0x30
200028c6:	69fb      	ldr	r3, [r7, #28]
200028c8:	1ad3      	subs	r3, r2, r3
200028ca:	3b01      	subs	r3, #1
200028cc:	68ba      	ldr	r2, [r7, #8]
200028ce:	441a      	add	r2, r3
200028d0:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
200028d2:	3b01      	subs	r3, #1
200028d4:	68b9      	ldr	r1, [r7, #8]
200028d6:	440b      	add	r3, r1
200028d8:	7812      	ldrb	r2, [r2, #0]
200028da:	701a      	strb	r2, [r3, #0]
		for (t = len + klen; t > idx; t--) {
200028dc:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
200028de:	3b01      	subs	r3, #1
200028e0:	633b      	str	r3, [r7, #48]	@ 0x30
200028e2:	6b3a      	ldr	r2, [r7, #48]	@ 0x30
200028e4:	6bbb      	ldr	r3, [r7, #56]	@ 0x38
200028e6:	429a      	cmp	r2, r3
200028e8:	dcec      	bgt.n	200028c4 <console_readline_default+0x5b8>
		    }
		for (t = 0; t < klen; t++) str[t+idx] = console_killbuffer[t];
200028ea:	2300      	movs	r3, #0
200028ec:	633b      	str	r3, [r7, #48]	@ 0x30
200028ee:	e00e      	b.n	2000290e <console_readline_default+0x602>
200028f0:	4b18      	ldr	r3, [pc, #96]	@ (20002954 <console_readline_default+0x648>)
200028f2:	681a      	ldr	r2, [r3, #0]
200028f4:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
200028f6:	441a      	add	r2, r3
200028f8:	6b39      	ldr	r1, [r7, #48]	@ 0x30
200028fa:	6bbb      	ldr	r3, [r7, #56]	@ 0x38
200028fc:	440b      	add	r3, r1
200028fe:	4619      	mov	r1, r3
20002900:	68bb      	ldr	r3, [r7, #8]
20002902:	440b      	add	r3, r1
20002904:	7812      	ldrb	r2, [r2, #0]
20002906:	701a      	strb	r2, [r3, #0]
20002908:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
2000290a:	3301      	adds	r3, #1
2000290c:	633b      	str	r3, [r7, #48]	@ 0x30
2000290e:	6b3a      	ldr	r2, [r7, #48]	@ 0x30
20002910:	69fb      	ldr	r3, [r7, #28]
20002912:	429a      	cmp	r2, r3
20002914:	dbec      	blt.n	200028f0 <console_readline_default+0x5e4>
		len += klen;
20002916:	6b7a      	ldr	r2, [r7, #52]	@ 0x34
20002918:	69fb      	ldr	r3, [r7, #28]
2000291a:	4413      	add	r3, r2
2000291c:	637b      	str	r3, [r7, #52]	@ 0x34
		console_write((unsigned char *)&str[idx],len-idx);
2000291e:	6bbb      	ldr	r3, [r7, #56]	@ 0x38
20002920:	68ba      	ldr	r2, [r7, #8]
20002922:	18d0      	adds	r0, r2, r3
20002924:	6b7a      	ldr	r2, [r7, #52]	@ 0x34
20002926:	6bbb      	ldr	r3, [r7, #56]	@ 0x38
20002928:	1ad3      	subs	r3, r2, r3
2000292a:	4619      	mov	r1, r3
2000292c:	f7ff fa04 	bl	20001d38 <console_write>
		idx += klen;
20002930:	6bba      	ldr	r2, [r7, #56]	@ 0x38
20002932:	69fb      	ldr	r3, [r7, #28]
20002934:	4413      	add	r3, r2
20002936:	63bb      	str	r3, [r7, #56]	@ 0x38
		console_backspace(len-idx-1);
20002938:	6b7a      	ldr	r2, [r7, #52]	@ 0x34
2000293a:	6bbb      	ldr	r3, [r7, #56]	@ 0x38
2000293c:	1ad3      	subs	r3, r2, r3
2000293e:	3b01      	subs	r3, #1
20002940:	4618      	mov	r0, r3
20002942:	f7ff fc8b 	bl	2000225c <console_backspace>
		break;
20002946:	e16c      	b.n	20002c22 <console_readline_default+0x916>
20002948:	20007688 	.word	0x20007688
2000294c:	20009328 	.word	0x20009328
20002950:	200076ac 	.word	0x200076ac
20002954:	20009314 	.word	0x20009314
20002958:	200091fc 	.word	0x200091fc

	    case CTRL('R'):			/* Redisplay line */
		str[len] = 0;
2000295c:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
2000295e:	68ba      	ldr	r2, [r7, #8]
20002960:	4413      	add	r3, r2
20002962:	2200      	movs	r2, #0
20002964:	701a      	strb	r2, [r3, #0]
		console_crlf();
20002966:	f7ff fcc7 	bl	200022f8 <console_crlf>
		console_write((unsigned char *)prompt,strlen(prompt));
2000296a:	68f8      	ldr	r0, [r7, #12]
2000296c:	f7fe fd9b 	bl	200014a6 <lib_strlen>
20002970:	4603      	mov	r3, r0
20002972:	4619      	mov	r1, r3
20002974:	68f8      	ldr	r0, [r7, #12]
20002976:	f7ff f9df 	bl	20001d38 <console_write>
		console_write((unsigned char *)str,len);
2000297a:	6b79      	ldr	r1, [r7, #52]	@ 0x34
2000297c:	68b8      	ldr	r0, [r7, #8]
2000297e:	f7ff f9db 	bl	20001d38 <console_write>
		console_backspace(len-idx);
20002982:	6b7a      	ldr	r2, [r7, #52]	@ 0x34
20002984:	6bbb      	ldr	r3, [r7, #56]	@ 0x38
20002986:	1ad3      	subs	r3, r2, r3
20002988:	4618      	mov	r0, r3
2000298a:	f7ff fc67 	bl	2000225c <console_backspace>
		break;
2000298e:	e148      	b.n	20002c22 <console_readline_default+0x916>

	    case CTRL('U'):			/* Cancel line */
		console_backspace(idx);
20002990:	6bb8      	ldr	r0, [r7, #56]	@ 0x38
20002992:	f7ff fc63 	bl	2000225c <console_backspace>
		console_eraseeol();
20002996:	f7ff fca5 	bl	200022e4 <console_eraseeol>
		if (len > 0) nosave = 1;
2000299a:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
2000299c:	2b00      	cmp	r3, #0
2000299e:	dd01      	ble.n	200029a4 <console_readline_default+0x698>
200029a0:	2301      	movs	r3, #1
200029a2:	62bb      	str	r3, [r7, #40]	@ 0x28
		idx = 0;
200029a4:	2300      	movs	r3, #0
200029a6:	63bb      	str	r3, [r7, #56]	@ 0x38
		len = 0;
200029a8:	2300      	movs	r3, #0
200029aa:	637b      	str	r3, [r7, #52]	@ 0x34
		break;
200029ac:	e139      	b.n	20002c22 <console_readline_default+0x916>

	    case CTRL('M'):			/* terminate */
	    case CTRL('J'):
		console_crlf();
200029ae:	f7ff fca3 	bl	200022f8 <console_crlf>
		reading = 0;
200029b2:	2300      	movs	r3, #0
200029b4:	63fb      	str	r3, [r7, #60]	@ 0x3c
		break;
200029b6:	e134      	b.n	20002c22 <console_readline_default+0x916>

	    case CTRL('P'):
	    case VKEY_UP:			/* recall previous line */
		t = recall;
200029b8:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
200029ba:	633b      	str	r3, [r7, #48]	@ 0x30
		t--;
200029bc:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
200029be:	3b01      	subs	r3, #1
200029c0:	633b      	str	r3, [r7, #48]	@ 0x30
		if (t < 0) t = MAXSAVELINES-1;
200029c2:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
200029c4:	2b00      	cmp	r3, #0
200029c6:	da01      	bge.n	200029cc <console_readline_default+0x6c0>
200029c8:	231d      	movs	r3, #29
200029ca:	633b      	str	r3, [r7, #48]	@ 0x30
		if (console_savedlines[t] == NULL) break;
200029cc:	4a97      	ldr	r2, [pc, #604]	@ (20002c2c <console_readline_default+0x920>)
200029ce:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
200029d0:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
200029d4:	2b00      	cmp	r3, #0
200029d6:	f000 811b 	beq.w	20002c10 <console_readline_default+0x904>
		recall = t;
200029da:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
200029dc:	62fb      	str	r3, [r7, #44]	@ 0x2c
		console_backspace(idx);
200029de:	6bb8      	ldr	r0, [r7, #56]	@ 0x38
200029e0:	f7ff fc3c 	bl	2000225c <console_backspace>
		strcpy(str,console_savedlines[recall]);
200029e4:	4a91      	ldr	r2, [pc, #580]	@ (20002c2c <console_readline_default+0x920>)
200029e6:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
200029e8:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
200029ec:	4619      	mov	r1, r3
200029ee:	68b8      	ldr	r0, [r7, #8]
200029f0:	f7fe fd11 	bl	20001416 <lib_strcpy>
		len = idx = strlen(console_savedlines[recall]);
200029f4:	4a8d      	ldr	r2, [pc, #564]	@ (20002c2c <console_readline_default+0x920>)
200029f6:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
200029f8:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
200029fc:	4618      	mov	r0, r3
200029fe:	f7fe fd52 	bl	200014a6 <lib_strlen>
20002a02:	63b8      	str	r0, [r7, #56]	@ 0x38
20002a04:	6bbb      	ldr	r3, [r7, #56]	@ 0x38
20002a06:	637b      	str	r3, [r7, #52]	@ 0x34
		console_eraseeol();
20002a08:	f7ff fc6c 	bl	200022e4 <console_eraseeol>
		console_write((unsigned char *)str,len);
20002a0c:	6b79      	ldr	r1, [r7, #52]	@ 0x34
20002a0e:	68b8      	ldr	r0, [r7, #8]
20002a10:	f7ff f992 	bl	20001d38 <console_write>
		nosave = (t == ((console_nextsave - 1) % MAXSAVELINES));
20002a14:	4b86      	ldr	r3, [pc, #536]	@ (20002c30 <console_readline_default+0x924>)
20002a16:	681b      	ldr	r3, [r3, #0]
20002a18:	1e5a      	subs	r2, r3, #1
20002a1a:	4b86      	ldr	r3, [pc, #536]	@ (20002c34 <console_readline_default+0x928>)
20002a1c:	fb83 1302 	smull	r1, r3, r3, r2
20002a20:	4413      	add	r3, r2
20002a22:	1119      	asrs	r1, r3, #4
20002a24:	17d3      	asrs	r3, r2, #31
20002a26:	1ac9      	subs	r1, r1, r3
20002a28:	460b      	mov	r3, r1
20002a2a:	011b      	lsls	r3, r3, #4
20002a2c:	1a5b      	subs	r3, r3, r1
20002a2e:	005b      	lsls	r3, r3, #1
20002a30:	1ad1      	subs	r1, r2, r3
20002a32:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
20002a34:	428b      	cmp	r3, r1
20002a36:	bf0c      	ite	eq
20002a38:	2301      	moveq	r3, #1
20002a3a:	2300      	movne	r3, #0
20002a3c:	b2db      	uxtb	r3, r3
20002a3e:	62bb      	str	r3, [r7, #40]	@ 0x28
		break;
20002a40:	e0ef      	b.n	20002c22 <console_readline_default+0x916>
		
	    case CTRL('N'):
	    case VKEY_DOWN:			/* Recall next line */
		t = recall; 
20002a42:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
20002a44:	633b      	str	r3, [r7, #48]	@ 0x30
		t++;
20002a46:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
20002a48:	3301      	adds	r3, #1
20002a4a:	633b      	str	r3, [r7, #48]	@ 0x30
		if (t == MAXSAVELINES) t = 0;
20002a4c:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
20002a4e:	2b1e      	cmp	r3, #30
20002a50:	d101      	bne.n	20002a56 <console_readline_default+0x74a>
20002a52:	2300      	movs	r3, #0
20002a54:	633b      	str	r3, [r7, #48]	@ 0x30
		if (console_savedlines[t] == NULL) break;
20002a56:	4a75      	ldr	r2, [pc, #468]	@ (20002c2c <console_readline_default+0x920>)
20002a58:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
20002a5a:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
20002a5e:	2b00      	cmp	r3, #0
20002a60:	f000 80d8 	beq.w	20002c14 <console_readline_default+0x908>
		recall = t;
20002a64:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
20002a66:	62fb      	str	r3, [r7, #44]	@ 0x2c
		console_backspace(idx);
20002a68:	6bb8      	ldr	r0, [r7, #56]	@ 0x38
20002a6a:	f7ff fbf7 	bl	2000225c <console_backspace>
		strcpy(str,console_savedlines[recall]);
20002a6e:	4a6f      	ldr	r2, [pc, #444]	@ (20002c2c <console_readline_default+0x920>)
20002a70:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
20002a72:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
20002a76:	4619      	mov	r1, r3
20002a78:	68b8      	ldr	r0, [r7, #8]
20002a7a:	f7fe fccc 	bl	20001416 <lib_strcpy>
		len = idx = strlen(console_savedlines[recall]);
20002a7e:	4a6b      	ldr	r2, [pc, #428]	@ (20002c2c <console_readline_default+0x920>)
20002a80:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
20002a82:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
20002a86:	4618      	mov	r0, r3
20002a88:	f7fe fd0d 	bl	200014a6 <lib_strlen>
20002a8c:	63b8      	str	r0, [r7, #56]	@ 0x38
20002a8e:	6bbb      	ldr	r3, [r7, #56]	@ 0x38
20002a90:	637b      	str	r3, [r7, #52]	@ 0x34
		console_eraseeol();
20002a92:	f7ff fc27 	bl	200022e4 <console_eraseeol>
		console_write((unsigned char *)str,len);
20002a96:	6b79      	ldr	r1, [r7, #52]	@ 0x34
20002a98:	68b8      	ldr	r0, [r7, #8]
20002a9a:	f7ff f94d 	bl	20001d38 <console_write>
		nosave = 1;
20002a9e:	2301      	movs	r3, #1
20002aa0:	62bb      	str	r3, [r7, #40]	@ 0x28
		break;
20002aa2:	e0be      	b.n	20002c22 <console_readline_default+0x916>
	    case VKEY_F8:
	    case VKEY_F9:
	    case VKEY_F10:
	    case VKEY_F11:
	    case VKEY_F12:
		sprintf(env,"F%d",ch-VKEY_F1+1);
20002aa4:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
20002aa6:	f2a3 120f 	subw	r2, r3, #271	@ 0x10f
20002aaa:	f107 0310 	add.w	r3, r7, #16
20002aae:	4962      	ldr	r1, [pc, #392]	@ (20002c38 <console_readline_default+0x92c>)
20002ab0:	4618      	mov	r0, r3
20002ab2:	f7fe f941 	bl	20000d38 <xsprintf>
		x = env_getenv(env);
20002ab6:	f107 0310 	add.w	r3, r7, #16
20002aba:	4618      	mov	r0, r3
20002abc:	f001 f886 	bl	20003bcc <env_getenv>
20002ac0:	6238      	str	r0, [r7, #32]
		if (x) {
20002ac2:	6a3b      	ldr	r3, [r7, #32]
20002ac4:	2b00      	cmp	r3, #0
20002ac6:	d019      	beq.n	20002afc <console_readline_default+0x7f0>
		    console_backspace(idx);
20002ac8:	6bb8      	ldr	r0, [r7, #56]	@ 0x38
20002aca:	f7ff fbc7 	bl	2000225c <console_backspace>
		    strcpy(str,x);
20002ace:	6a39      	ldr	r1, [r7, #32]
20002ad0:	68b8      	ldr	r0, [r7, #8]
20002ad2:	f7fe fca0 	bl	20001416 <lib_strcpy>
		    idx = len = strlen(str);
20002ad6:	68b8      	ldr	r0, [r7, #8]
20002ad8:	f7fe fce5 	bl	200014a6 <lib_strlen>
20002adc:	6378      	str	r0, [r7, #52]	@ 0x34
20002ade:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
20002ae0:	63bb      	str	r3, [r7, #56]	@ 0x38
		    console_eraseeol();
20002ae2:	f7ff fbff 	bl	200022e4 <console_eraseeol>
		    console_write((unsigned char *)str,len);
20002ae6:	6b79      	ldr	r1, [r7, #52]	@ 0x34
20002ae8:	68b8      	ldr	r0, [r7, #8]
20002aea:	f7ff f925 	bl	20001d38 <console_write>
		    console_crlf();
20002aee:	f7ff fc03 	bl	200022f8 <console_crlf>
		    reading = 0;
20002af2:	2300      	movs	r3, #0
20002af4:	63fb      	str	r3, [r7, #60]	@ 0x3c
		    nosave = 1;
20002af6:	2301      	movs	r3, #1
20002af8:	62bb      	str	r3, [r7, #40]	@ 0x28
		    console_write((unsigned char *)str,len);
		    console_crlf();
		    reading = 0;
		    nosave = 1;
		    }
		break;
20002afa:	e08d      	b.n	20002c18 <console_readline_default+0x90c>
		else if (ch == VKEY_F12) {
20002afc:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
20002afe:	f240 121b 	movw	r2, #283	@ 0x11b
20002b02:	4293      	cmp	r3, r2
20002b04:	f040 8088 	bne.w	20002c18 <console_readline_default+0x90c>
		    t = recall;
20002b08:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
20002b0a:	633b      	str	r3, [r7, #48]	@ 0x30
		    t--;
20002b0c:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
20002b0e:	3b01      	subs	r3, #1
20002b10:	633b      	str	r3, [r7, #48]	@ 0x30
		    if (t < 0) t = MAXSAVELINES-1;
20002b12:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
20002b14:	2b00      	cmp	r3, #0
20002b16:	da01      	bge.n	20002b1c <console_readline_default+0x810>
20002b18:	231d      	movs	r3, #29
20002b1a:	633b      	str	r3, [r7, #48]	@ 0x30
		    if (console_savedlines[t] == NULL) break;
20002b1c:	4a43      	ldr	r2, [pc, #268]	@ (20002c2c <console_readline_default+0x920>)
20002b1e:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
20002b20:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
20002b24:	2b00      	cmp	r3, #0
20002b26:	d079      	beq.n	20002c1c <console_readline_default+0x910>
		    recall = t;
20002b28:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
20002b2a:	62fb      	str	r3, [r7, #44]	@ 0x2c
		    console_backspace(idx);
20002b2c:	6bb8      	ldr	r0, [r7, #56]	@ 0x38
20002b2e:	f7ff fb95 	bl	2000225c <console_backspace>
		    strcpy(str,console_savedlines[recall]);
20002b32:	4a3e      	ldr	r2, [pc, #248]	@ (20002c2c <console_readline_default+0x920>)
20002b34:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
20002b36:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
20002b3a:	4619      	mov	r1, r3
20002b3c:	68b8      	ldr	r0, [r7, #8]
20002b3e:	f7fe fc6a 	bl	20001416 <lib_strcpy>
		    len = idx = strlen(console_savedlines[recall]);
20002b42:	4a3a      	ldr	r2, [pc, #232]	@ (20002c2c <console_readline_default+0x920>)
20002b44:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
20002b46:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
20002b4a:	4618      	mov	r0, r3
20002b4c:	f7fe fcab 	bl	200014a6 <lib_strlen>
20002b50:	63b8      	str	r0, [r7, #56]	@ 0x38
20002b52:	6bbb      	ldr	r3, [r7, #56]	@ 0x38
20002b54:	637b      	str	r3, [r7, #52]	@ 0x34
		    console_eraseeol();
20002b56:	f7ff fbc5 	bl	200022e4 <console_eraseeol>
		    console_write((unsigned char *)str,len);
20002b5a:	6b79      	ldr	r1, [r7, #52]	@ 0x34
20002b5c:	68b8      	ldr	r0, [r7, #8]
20002b5e:	f7ff f8eb 	bl	20001d38 <console_write>
		    console_crlf();
20002b62:	f7ff fbc9 	bl	200022f8 <console_crlf>
		    reading = 0;
20002b66:	2300      	movs	r3, #0
20002b68:	63fb      	str	r3, [r7, #60]	@ 0x3c
		    nosave = 1;
20002b6a:	2301      	movs	r3, #1
20002b6c:	62bb      	str	r3, [r7, #40]	@ 0x28
		break;
20002b6e:	e053      	b.n	20002c18 <console_readline_default+0x90c>

	    default:				/* insert character */
		if (ch >= ' ') {
20002b70:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
20002b72:	2b1f      	cmp	r3, #31
20002b74:	dd54      	ble.n	20002c20 <console_readline_default+0x914>
		    if (idx < (maxlen-1)) {
20002b76:	687b      	ldr	r3, [r7, #4]
20002b78:	3b01      	subs	r3, #1
20002b7a:	6bba      	ldr	r2, [r7, #56]	@ 0x38
20002b7c:	429a      	cmp	r2, r3
20002b7e:	da4f      	bge.n	20002c20 <console_readline_default+0x914>
			nosave = 0;
20002b80:	2300      	movs	r3, #0
20002b82:	62bb      	str	r3, [r7, #40]	@ 0x28
			for (t = len; t > idx; t--) {
20002b84:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
20002b86:	633b      	str	r3, [r7, #48]	@ 0x30
20002b88:	e00b      	b.n	20002ba2 <console_readline_default+0x896>
			    str[t] = str[t-1];
20002b8a:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
20002b8c:	3b01      	subs	r3, #1
20002b8e:	68ba      	ldr	r2, [r7, #8]
20002b90:	441a      	add	r2, r3
20002b92:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
20002b94:	68b9      	ldr	r1, [r7, #8]
20002b96:	440b      	add	r3, r1
20002b98:	7812      	ldrb	r2, [r2, #0]
20002b9a:	701a      	strb	r2, [r3, #0]
			for (t = len; t > idx; t--) {
20002b9c:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
20002b9e:	3b01      	subs	r3, #1
20002ba0:	633b      	str	r3, [r7, #48]	@ 0x30
20002ba2:	6b3a      	ldr	r2, [r7, #48]	@ 0x30
20002ba4:	6bbb      	ldr	r3, [r7, #56]	@ 0x38
20002ba6:	429a      	cmp	r2, r3
20002ba8:	dcef      	bgt.n	20002b8a <console_readline_default+0x87e>
			    }
			str[idx] = ch;
20002baa:	6bbb      	ldr	r3, [r7, #56]	@ 0x38
20002bac:	68ba      	ldr	r2, [r7, #8]
20002bae:	4413      	add	r3, r2
20002bb0:	6a7a      	ldr	r2, [r7, #36]	@ 0x24
20002bb2:	b2d2      	uxtb	r2, r2
20002bb4:	701a      	strb	r2, [r3, #0]
			len++;
20002bb6:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
20002bb8:	3301      	adds	r3, #1
20002bba:	637b      	str	r3, [r7, #52]	@ 0x34
			if (len != idx) {
20002bbc:	6b7a      	ldr	r2, [r7, #52]	@ 0x34
20002bbe:	6bbb      	ldr	r3, [r7, #56]	@ 0x38
20002bc0:	429a      	cmp	r2, r3
20002bc2:	d00f      	beq.n	20002be4 <console_readline_default+0x8d8>
			    console_write((unsigned char *)&str[idx],len-idx);
20002bc4:	6bbb      	ldr	r3, [r7, #56]	@ 0x38
20002bc6:	68ba      	ldr	r2, [r7, #8]
20002bc8:	18d0      	adds	r0, r2, r3
20002bca:	6b7a      	ldr	r2, [r7, #52]	@ 0x34
20002bcc:	6bbb      	ldr	r3, [r7, #56]	@ 0x38
20002bce:	1ad3      	subs	r3, r2, r3
20002bd0:	4619      	mov	r1, r3
20002bd2:	f7ff f8b1 	bl	20001d38 <console_write>
			    console_backspace(len-idx-1);
20002bd6:	6b7a      	ldr	r2, [r7, #52]	@ 0x34
20002bd8:	6bbb      	ldr	r3, [r7, #56]	@ 0x38
20002bda:	1ad3      	subs	r3, r2, r3
20002bdc:	3b01      	subs	r3, #1
20002bde:	4618      	mov	r0, r3
20002be0:	f7ff fb3c 	bl	2000225c <console_backspace>
			    }
			idx++;
20002be4:	6bbb      	ldr	r3, [r7, #56]	@ 0x38
20002be6:	3301      	adds	r3, #1
20002be8:	63bb      	str	r3, [r7, #56]	@ 0x38
			}
		    }
		break;
20002bea:	e019      	b.n	20002c20 <console_readline_default+0x914>
	if (ch == 0) continue;
20002bec:	bf00      	nop
20002bee:	e018      	b.n	20002c22 <console_readline_default+0x916>
		break;
20002bf0:	bf00      	nop
20002bf2:	e016      	b.n	20002c22 <console_readline_default+0x916>
		break;
20002bf4:	bf00      	nop
20002bf6:	e014      	b.n	20002c22 <console_readline_default+0x916>
		break;
20002bf8:	bf00      	nop
20002bfa:	e012      	b.n	20002c22 <console_readline_default+0x916>
		break;
20002bfc:	bf00      	nop
20002bfe:	e010      	b.n	20002c22 <console_readline_default+0x916>
		break;
20002c00:	bf00      	nop
20002c02:	e00e      	b.n	20002c22 <console_readline_default+0x916>
		if (console_killbuffer == NULL) break;
20002c04:	bf00      	nop
20002c06:	e00c      	b.n	20002c22 <console_readline_default+0x916>
		if (klen == 0) break;
20002c08:	bf00      	nop
20002c0a:	e00a      	b.n	20002c22 <console_readline_default+0x916>
		if (len + klen > maxlen) break;
20002c0c:	bf00      	nop
20002c0e:	e008      	b.n	20002c22 <console_readline_default+0x916>
		if (console_savedlines[t] == NULL) break;
20002c10:	bf00      	nop
20002c12:	e006      	b.n	20002c22 <console_readline_default+0x916>
		if (console_savedlines[t] == NULL) break;
20002c14:	bf00      	nop
20002c16:	e004      	b.n	20002c22 <console_readline_default+0x916>
		break;
20002c18:	bf00      	nop
20002c1a:	e002      	b.n	20002c22 <console_readline_default+0x916>
		    if (console_savedlines[t] == NULL) break;
20002c1c:	bf00      	nop
20002c1e:	e000      	b.n	20002c22 <console_readline_default+0x916>
		break;
20002c20:	bf00      	nop
    while (reading) {
20002c22:	6bfb      	ldr	r3, [r7, #60]	@ 0x3c
20002c24:	2b00      	cmp	r3, #0
20002c26:	f47f abc3 	bne.w	200023b0 <console_readline_default+0xa4>
20002c2a:	e008      	b.n	20002c3e <console_readline_default+0x932>
20002c2c:	2000929c 	.word	0x2000929c
20002c30:	20009298 	.word	0x20009298
20002c34:	88888889 	.word	0x88888889
20002c38:	200076bc 	.word	0x200076bc
	if (ch < 0) break;
20002c3c:	bf00      	nop
	    }
	}
    POLL();
20002c3e:	f7fe ffef 	bl	20001c20 <background>

    console_inreadline--;
20002c42:	4b1d      	ldr	r3, [pc, #116]	@ (20002cb8 <console_readline_default+0x9ac>)
20002c44:	681b      	ldr	r3, [r3, #0]
20002c46:	3b01      	subs	r3, #1
20002c48:	4a1b      	ldr	r2, [pc, #108]	@ (20002cb8 <console_readline_default+0x9ac>)
20002c4a:	6013      	str	r3, [r2, #0]

    str[len] = 0;
20002c4c:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
20002c4e:	68ba      	ldr	r2, [r7, #8]
20002c50:	4413      	add	r3, r2
20002c52:	2200      	movs	r2, #0
20002c54:	701a      	strb	r2, [r3, #0]

    if ((len != 0) && !nosave) {
20002c56:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
20002c58:	2b00      	cmp	r3, #0
20002c5a:	d027      	beq.n	20002cac <console_readline_default+0x9a0>
20002c5c:	6abb      	ldr	r3, [r7, #40]	@ 0x28
20002c5e:	2b00      	cmp	r3, #0
20002c60:	d124      	bne.n	20002cac <console_readline_default+0x9a0>
	if (console_savedlines[console_nextsave]) {
20002c62:	4b16      	ldr	r3, [pc, #88]	@ (20002cbc <console_readline_default+0x9b0>)
20002c64:	681b      	ldr	r3, [r3, #0]
20002c66:	4a16      	ldr	r2, [pc, #88]	@ (20002cc0 <console_readline_default+0x9b4>)
20002c68:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
20002c6c:	2b00      	cmp	r3, #0
20002c6e:	d008      	beq.n	20002c82 <console_readline_default+0x976>
	    KFREE(console_savedlines[console_nextsave]);
20002c70:	4b12      	ldr	r3, [pc, #72]	@ (20002cbc <console_readline_default+0x9b0>)
20002c72:	681b      	ldr	r3, [r3, #0]
20002c74:	4a12      	ldr	r2, [pc, #72]	@ (20002cc0 <console_readline_default+0x9b4>)
20002c76:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
20002c7a:	4619      	mov	r1, r3
20002c7c:	4811      	ldr	r0, [pc, #68]	@ (20002cc4 <console_readline_default+0x9b8>)
20002c7e:	f7fe f9f7 	bl	20001070 <kfree>
	    }
	console_savedlines[console_nextsave] = strdup(str);
20002c82:	4b0e      	ldr	r3, [pc, #56]	@ (20002cbc <console_readline_default+0x9b0>)
20002c84:	681c      	ldr	r4, [r3, #0]
20002c86:	68b8      	ldr	r0, [r7, #8]
20002c88:	f7fe fe60 	bl	2000194c <lib_strdup>
20002c8c:	4603      	mov	r3, r0
20002c8e:	4a0c      	ldr	r2, [pc, #48]	@ (20002cc0 <console_readline_default+0x9b4>)
20002c90:	f842 3024 	str.w	r3, [r2, r4, lsl #2]
	console_nextsave++;
20002c94:	4b09      	ldr	r3, [pc, #36]	@ (20002cbc <console_readline_default+0x9b0>)
20002c96:	681b      	ldr	r3, [r3, #0]
20002c98:	3301      	adds	r3, #1
20002c9a:	4a08      	ldr	r2, [pc, #32]	@ (20002cbc <console_readline_default+0x9b0>)
20002c9c:	6013      	str	r3, [r2, #0]
	if (console_nextsave == MAXSAVELINES) console_nextsave = 0;
20002c9e:	4b07      	ldr	r3, [pc, #28]	@ (20002cbc <console_readline_default+0x9b0>)
20002ca0:	681b      	ldr	r3, [r3, #0]
20002ca2:	2b1e      	cmp	r3, #30
20002ca4:	d102      	bne.n	20002cac <console_readline_default+0x9a0>
20002ca6:	4b05      	ldr	r3, [pc, #20]	@ (20002cbc <console_readline_default+0x9b0>)
20002ca8:	2200      	movs	r2, #0
20002caa:	601a      	str	r2, [r3, #0]
	}

    return len;
20002cac:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
}
20002cae:	4618      	mov	r0, r3
20002cb0:	3744      	adds	r7, #68	@ 0x44
20002cb2:	46bd      	mov	sp, r7
20002cb4:	bd90      	pop	{r4, r7, pc}
20002cb6:	bf00      	nop
20002cb8:	20009324 	.word	0x20009324
20002cbc:	20009298 	.word	0x20009298
20002cc0:	2000929c 	.word	0x2000929c
20002cc4:	200091fc 	.word	0x200091fc

20002cc8 <console_readline>:

int console_readline(char *prompt,char *str,int maxlen)
{
20002cc8:	b580      	push	{r7, lr}
20002cca:	b084      	sub	sp, #16
20002ccc:	af00      	add	r7, sp, #0
20002cce:	60f8      	str	r0, [r7, #12]
20002cd0:	60b9      	str	r1, [r7, #8]
20002cd2:	607a      	str	r2, [r7, #4]
    str[0] = '\0';
20002cd4:	68bb      	ldr	r3, [r7, #8]
20002cd6:	2200      	movs	r2, #0
20002cd8:	701a      	strb	r2, [r3, #0]
    return console_readline_default(prompt,str,maxlen);
20002cda:	687a      	ldr	r2, [r7, #4]
20002cdc:	68b9      	ldr	r1, [r7, #8]
20002cde:	68f8      	ldr	r0, [r7, #12]
20002ce0:	f7ff fb14 	bl	2000230c <console_readline_default>
20002ce4:	4603      	mov	r3, r0
}
20002ce6:	4618      	mov	r0, r3
20002ce8:	3710      	adds	r7, #16
20002cea:	46bd      	mov	sp, r7
20002cec:	bd80      	pop	{r7, pc}

20002cee <cfe_strlen>:
#include "cfe.h"

extern int cfe_iocb_dispatch(cfe_iocb_t *iocb);

static int cfe_strlen(char *name)
{
20002cee:	b480      	push	{r7}
20002cf0:	b085      	sub	sp, #20
20002cf2:	af00      	add	r7, sp, #0
20002cf4:	6078      	str	r0, [r7, #4]
    int count = 0;
20002cf6:	2300      	movs	r3, #0
20002cf8:	60fb      	str	r3, [r7, #12]

    while (*name) {
20002cfa:	e005      	b.n	20002d08 <cfe_strlen+0x1a>
	count++;
20002cfc:	68fb      	ldr	r3, [r7, #12]
20002cfe:	3301      	adds	r3, #1
20002d00:	60fb      	str	r3, [r7, #12]
	name++;
20002d02:	687b      	ldr	r3, [r7, #4]
20002d04:	3301      	adds	r3, #1
20002d06:	607b      	str	r3, [r7, #4]
    while (*name) {
20002d08:	687b      	ldr	r3, [r7, #4]
20002d0a:	781b      	ldrb	r3, [r3, #0]
20002d0c:	2b00      	cmp	r3, #0
20002d0e:	d1f5      	bne.n	20002cfc <cfe_strlen+0xe>
	}

    return count;
20002d10:	68fb      	ldr	r3, [r7, #12]
}
20002d12:	4618      	mov	r0, r3
20002d14:	3714      	adds	r7, #20
20002d16:	46bd      	mov	sp, r7
20002d18:	f85d 7b04 	ldr.w	r7, [sp], #4
20002d1c:	4770      	bx	lr

20002d1e <cfe_open>:

int cfe_open(char *name)
{
20002d1e:	b580      	push	{r7, lr}
20002d20:	b09c      	sub	sp, #112	@ 0x70
20002d22:	af00      	add	r7, sp, #0
20002d24:	6078      	str	r0, [r7, #4]
    cfe_iocb_t iocb;

    iocb.iocb_fcode = CFE_CMD_DEV_OPEN;
20002d26:	230b      	movs	r3, #11
20002d28:	60bb      	str	r3, [r7, #8]
    iocb.iocb_status = 0;
20002d2a:	2300      	movs	r3, #0
20002d2c:	60fb      	str	r3, [r7, #12]
    iocb.iocb_handle = 0;
20002d2e:	2300      	movs	r3, #0
20002d30:	613b      	str	r3, [r7, #16]
    iocb.iocb_flags = 0;
20002d32:	2300      	movs	r3, #0
20002d34:	617b      	str	r3, [r7, #20]
    iocb.iocb_psize = sizeof(iocb_buffer_t);
20002d36:	2318      	movs	r3, #24
20002d38:	61bb      	str	r3, [r7, #24]
    iocb.plist.iocb_buffer.buf_offset = 0;
20002d3a:	f04f 0200 	mov.w	r2, #0
20002d3e:	f04f 0300 	mov.w	r3, #0
20002d42:	e9c7 2308 	strd	r2, r3, [r7, #32]
    iocb.plist.iocb_buffer.buf_ptr = PTR2HSADDR(name);
20002d46:	687b      	ldr	r3, [r7, #4]
20002d48:	62bb      	str	r3, [r7, #40]	@ 0x28
    iocb.plist.iocb_buffer.buf_length = cfe_strlen(name);
20002d4a:	6878      	ldr	r0, [r7, #4]
20002d4c:	f7ff ffcf 	bl	20002cee <cfe_strlen>
20002d50:	4603      	mov	r3, r0
20002d52:	62fb      	str	r3, [r7, #44]	@ 0x2c

    cfe_iocb_dispatch(&iocb);
20002d54:	f107 0308 	add.w	r3, r7, #8
20002d58:	4618      	mov	r0, r3
20002d5a:	f000 f92f 	bl	20002fbc <cfe_iocb_dispatch>

    return (iocb.iocb_status < 0) ? iocb.iocb_status : iocb.iocb_handle;
20002d5e:	68fb      	ldr	r3, [r7, #12]
20002d60:	2b00      	cmp	r3, #0
20002d62:	da01      	bge.n	20002d68 <cfe_open+0x4a>
20002d64:	68fb      	ldr	r3, [r7, #12]
20002d66:	e000      	b.n	20002d6a <cfe_open+0x4c>
20002d68:	693b      	ldr	r3, [r7, #16]
}
20002d6a:	4618      	mov	r0, r3
20002d6c:	3770      	adds	r7, #112	@ 0x70
20002d6e:	46bd      	mov	sp, r7
20002d70:	bd80      	pop	{r7, pc}

20002d72 <cfe_close>:

int cfe_close(int handle)
{
20002d72:	b580      	push	{r7, lr}
20002d74:	b09c      	sub	sp, #112	@ 0x70
20002d76:	af00      	add	r7, sp, #0
20002d78:	6078      	str	r0, [r7, #4]
    cfe_iocb_t iocb;

    iocb.iocb_fcode = CFE_CMD_DEV_CLOSE;
20002d7a:	2310      	movs	r3, #16
20002d7c:	60bb      	str	r3, [r7, #8]
    iocb.iocb_status = 0;
20002d7e:	2300      	movs	r3, #0
20002d80:	60fb      	str	r3, [r7, #12]
    iocb.iocb_handle = handle;
20002d82:	687b      	ldr	r3, [r7, #4]
20002d84:	613b      	str	r3, [r7, #16]
    iocb.iocb_flags = 0;
20002d86:	2300      	movs	r3, #0
20002d88:	617b      	str	r3, [r7, #20]
    iocb.iocb_psize = 0;
20002d8a:	2300      	movs	r3, #0
20002d8c:	61bb      	str	r3, [r7, #24]

    cfe_iocb_dispatch(&iocb);
20002d8e:	f107 0308 	add.w	r3, r7, #8
20002d92:	4618      	mov	r0, r3
20002d94:	f000 f912 	bl	20002fbc <cfe_iocb_dispatch>

    return (iocb.iocb_status);
20002d98:	68fb      	ldr	r3, [r7, #12]

}
20002d9a:	4618      	mov	r0, r3
20002d9c:	3770      	adds	r7, #112	@ 0x70
20002d9e:	46bd      	mov	sp, r7
20002da0:	bd80      	pop	{r7, pc}

20002da2 <cfe_readblk>:

int cfe_readblk(int handle,cfe_offset_t offset,hsaddr_t buffer,int length)
{
20002da2:	b580      	push	{r7, lr}
20002da4:	b09e      	sub	sp, #120	@ 0x78
20002da6:	af00      	add	r7, sp, #0
20002da8:	60f8      	str	r0, [r7, #12]
20002daa:	e9c7 2300 	strd	r2, r3, [r7]
    cfe_iocb_t iocb;

    iocb.iocb_fcode = CFE_CMD_DEV_READ;
20002dae:	230d      	movs	r3, #13
20002db0:	613b      	str	r3, [r7, #16]
    iocb.iocb_status = 0;
20002db2:	2300      	movs	r3, #0
20002db4:	617b      	str	r3, [r7, #20]
    iocb.iocb_handle = handle;
20002db6:	68fb      	ldr	r3, [r7, #12]
20002db8:	61bb      	str	r3, [r7, #24]
    iocb.iocb_flags = 0;
20002dba:	2300      	movs	r3, #0
20002dbc:	61fb      	str	r3, [r7, #28]
    iocb.iocb_psize = sizeof(iocb_buffer_t);
20002dbe:	2318      	movs	r3, #24
20002dc0:	623b      	str	r3, [r7, #32]
    iocb.plist.iocb_buffer.buf_offset = offset;
20002dc2:	e9d7 2300 	ldrd	r2, r3, [r7]
20002dc6:	e9c7 230a 	strd	r2, r3, [r7, #40]	@ 0x28
    iocb.plist.iocb_buffer.buf_ptr = buffer;
20002dca:	f8d7 3080 	ldr.w	r3, [r7, #128]	@ 0x80
20002dce:	633b      	str	r3, [r7, #48]	@ 0x30
    iocb.plist.iocb_buffer.buf_length = length;
20002dd0:	f8d7 3084 	ldr.w	r3, [r7, #132]	@ 0x84
20002dd4:	637b      	str	r3, [r7, #52]	@ 0x34

    cfe_iocb_dispatch(&iocb);
20002dd6:	f107 0310 	add.w	r3, r7, #16
20002dda:	4618      	mov	r0, r3
20002ddc:	f000 f8ee 	bl	20002fbc <cfe_iocb_dispatch>

    return (iocb.iocb_status < 0) ? iocb.iocb_status : iocb.plist.iocb_buffer.buf_retlen;
20002de0:	697b      	ldr	r3, [r7, #20]
20002de2:	2b00      	cmp	r3, #0
20002de4:	da01      	bge.n	20002dea <cfe_readblk+0x48>
20002de6:	697b      	ldr	r3, [r7, #20]
20002de8:	e000      	b.n	20002dec <cfe_readblk+0x4a>
20002dea:	6bbb      	ldr	r3, [r7, #56]	@ 0x38
}
20002dec:	4618      	mov	r0, r3
20002dee:	3778      	adds	r7, #120	@ 0x78
20002df0:	46bd      	mov	sp, r7
20002df2:	bd80      	pop	{r7, pc}

20002df4 <cfe_read>:

int cfe_read(int handle,hsaddr_t buffer,int length)
{
20002df4:	b580      	push	{r7, lr}
20002df6:	b086      	sub	sp, #24
20002df8:	af02      	add	r7, sp, #8
20002dfa:	60f8      	str	r0, [r7, #12]
20002dfc:	60b9      	str	r1, [r7, #8]
20002dfe:	607a      	str	r2, [r7, #4]
    return cfe_readblk(handle,0,buffer,length);
20002e00:	687b      	ldr	r3, [r7, #4]
20002e02:	9301      	str	r3, [sp, #4]
20002e04:	68bb      	ldr	r3, [r7, #8]
20002e06:	9300      	str	r3, [sp, #0]
20002e08:	f04f 0200 	mov.w	r2, #0
20002e0c:	f04f 0300 	mov.w	r3, #0
20002e10:	68f8      	ldr	r0, [r7, #12]
20002e12:	f7ff ffc6 	bl	20002da2 <cfe_readblk>
20002e16:	4603      	mov	r3, r0
}
20002e18:	4618      	mov	r0, r3
20002e1a:	3710      	adds	r7, #16
20002e1c:	46bd      	mov	sp, r7
20002e1e:	bd80      	pop	{r7, pc}

20002e20 <cfe_writeblk>:


int cfe_writeblk(int handle,cfe_offset_t offset,hsaddr_t buffer,int length)
{
20002e20:	b580      	push	{r7, lr}
20002e22:	b09e      	sub	sp, #120	@ 0x78
20002e24:	af00      	add	r7, sp, #0
20002e26:	60f8      	str	r0, [r7, #12]
20002e28:	e9c7 2300 	strd	r2, r3, [r7]
    cfe_iocb_t iocb;

    iocb.iocb_fcode = CFE_CMD_DEV_WRITE;
20002e2c:	230e      	movs	r3, #14
20002e2e:	613b      	str	r3, [r7, #16]
    iocb.iocb_status = 0;
20002e30:	2300      	movs	r3, #0
20002e32:	617b      	str	r3, [r7, #20]
    iocb.iocb_handle = handle;
20002e34:	68fb      	ldr	r3, [r7, #12]
20002e36:	61bb      	str	r3, [r7, #24]
    iocb.iocb_flags = 0;
20002e38:	2300      	movs	r3, #0
20002e3a:	61fb      	str	r3, [r7, #28]
    iocb.iocb_psize = sizeof(iocb_buffer_t);
20002e3c:	2318      	movs	r3, #24
20002e3e:	623b      	str	r3, [r7, #32]
    iocb.plist.iocb_buffer.buf_offset = offset;
20002e40:	e9d7 2300 	ldrd	r2, r3, [r7]
20002e44:	e9c7 230a 	strd	r2, r3, [r7, #40]	@ 0x28
    iocb.plist.iocb_buffer.buf_ptr = buffer;
20002e48:	f8d7 3080 	ldr.w	r3, [r7, #128]	@ 0x80
20002e4c:	633b      	str	r3, [r7, #48]	@ 0x30
    iocb.plist.iocb_buffer.buf_length = length;
20002e4e:	f8d7 3084 	ldr.w	r3, [r7, #132]	@ 0x84
20002e52:	637b      	str	r3, [r7, #52]	@ 0x34

    cfe_iocb_dispatch(&iocb);
20002e54:	f107 0310 	add.w	r3, r7, #16
20002e58:	4618      	mov	r0, r3
20002e5a:	f000 f8af 	bl	20002fbc <cfe_iocb_dispatch>

    return (iocb.iocb_status < 0) ? iocb.iocb_status : iocb.plist.iocb_buffer.buf_retlen;
20002e5e:	697b      	ldr	r3, [r7, #20]
20002e60:	2b00      	cmp	r3, #0
20002e62:	da01      	bge.n	20002e68 <cfe_writeblk+0x48>
20002e64:	697b      	ldr	r3, [r7, #20]
20002e66:	e000      	b.n	20002e6a <cfe_writeblk+0x4a>
20002e68:	6bbb      	ldr	r3, [r7, #56]	@ 0x38
}
20002e6a:	4618      	mov	r0, r3
20002e6c:	3778      	adds	r7, #120	@ 0x78
20002e6e:	46bd      	mov	sp, r7
20002e70:	bd80      	pop	{r7, pc}

20002e72 <cfe_write>:

int cfe_write(int handle,hsaddr_t buffer,int length)
{
20002e72:	b580      	push	{r7, lr}
20002e74:	b086      	sub	sp, #24
20002e76:	af02      	add	r7, sp, #8
20002e78:	60f8      	str	r0, [r7, #12]
20002e7a:	60b9      	str	r1, [r7, #8]
20002e7c:	607a      	str	r2, [r7, #4]
    return cfe_writeblk(handle,0,buffer,length);
20002e7e:	687b      	ldr	r3, [r7, #4]
20002e80:	9301      	str	r3, [sp, #4]
20002e82:	68bb      	ldr	r3, [r7, #8]
20002e84:	9300      	str	r3, [sp, #0]
20002e86:	f04f 0200 	mov.w	r2, #0
20002e8a:	f04f 0300 	mov.w	r3, #0
20002e8e:	68f8      	ldr	r0, [r7, #12]
20002e90:	f7ff ffc6 	bl	20002e20 <cfe_writeblk>
20002e94:	4603      	mov	r3, r0
}
20002e96:	4618      	mov	r0, r3
20002e98:	3710      	adds	r7, #16
20002e9a:	46bd      	mov	sp, r7
20002e9c:	bd80      	pop	{r7, pc}

20002e9e <cfe_inpstat>:
    if (retlen) *retlen = iocb.plist.iocb_buffer.buf_retlen;
    return iocb.iocb_status;
}

int cfe_inpstat(int handle)
{
20002e9e:	b580      	push	{r7, lr}
20002ea0:	b09c      	sub	sp, #112	@ 0x70
20002ea2:	af00      	add	r7, sp, #0
20002ea4:	6078      	str	r0, [r7, #4]
    cfe_iocb_t iocb;

    iocb.iocb_fcode = CFE_CMD_DEV_INPSTAT;
20002ea6:	230c      	movs	r3, #12
20002ea8:	60bb      	str	r3, [r7, #8]
    iocb.iocb_status = 0;
20002eaa:	2300      	movs	r3, #0
20002eac:	60fb      	str	r3, [r7, #12]
    iocb.iocb_handle = handle;
20002eae:	687b      	ldr	r3, [r7, #4]
20002eb0:	613b      	str	r3, [r7, #16]
    iocb.iocb_flags = 0;
20002eb2:	2300      	movs	r3, #0
20002eb4:	617b      	str	r3, [r7, #20]
    iocb.iocb_psize = sizeof(iocb_inpstat_t);
20002eb6:	2304      	movs	r3, #4
20002eb8:	61bb      	str	r3, [r7, #24]
    iocb.plist.iocb_inpstat.inp_status = 0;
20002eba:	2300      	movs	r3, #0
20002ebc:	623b      	str	r3, [r7, #32]

    cfe_iocb_dispatch(&iocb);
20002ebe:	f107 0308 	add.w	r3, r7, #8
20002ec2:	4618      	mov	r0, r3
20002ec4:	f000 f87a 	bl	20002fbc <cfe_iocb_dispatch>

    if (iocb.iocb_status < 0) return iocb.iocb_status;
20002ec8:	68fb      	ldr	r3, [r7, #12]
20002eca:	2b00      	cmp	r3, #0
20002ecc:	da01      	bge.n	20002ed2 <cfe_inpstat+0x34>
20002ece:	68fb      	ldr	r3, [r7, #12]
20002ed0:	e000      	b.n	20002ed4 <cfe_inpstat+0x36>

    return iocb.plist.iocb_inpstat.inp_status;
20002ed2:	6a3b      	ldr	r3, [r7, #32]

}
20002ed4:	4618      	mov	r0, r3
20002ed6:	3770      	adds	r7, #112	@ 0x70
20002ed8:	46bd      	mov	sp, r7
20002eda:	bd80      	pop	{r7, pc}

20002edc <cfe_getdevinfo>:

    return iocb.iocb_status;
}

int cfe_getdevinfo(char *name)
{
20002edc:	b580      	push	{r7, lr}
20002ede:	b09c      	sub	sp, #112	@ 0x70
20002ee0:	af00      	add	r7, sp, #0
20002ee2:	6078      	str	r0, [r7, #4]
    cfe_iocb_t iocb;

    iocb.iocb_fcode = CFE_CMD_DEV_GETINFO;
20002ee4:	2311      	movs	r3, #17
20002ee6:	60bb      	str	r3, [r7, #8]
    iocb.iocb_status = 0;
20002ee8:	2300      	movs	r3, #0
20002eea:	60fb      	str	r3, [r7, #12]
    iocb.iocb_handle = 0;
20002eec:	2300      	movs	r3, #0
20002eee:	613b      	str	r3, [r7, #16]
    iocb.iocb_flags = 0;
20002ef0:	2300      	movs	r3, #0
20002ef2:	617b      	str	r3, [r7, #20]
    iocb.iocb_psize = sizeof(iocb_buffer_t);
20002ef4:	2318      	movs	r3, #24
20002ef6:	61bb      	str	r3, [r7, #24]
    iocb.plist.iocb_buffer.buf_offset = 0;
20002ef8:	f04f 0200 	mov.w	r2, #0
20002efc:	f04f 0300 	mov.w	r3, #0
20002f00:	e9c7 2308 	strd	r2, r3, [r7, #32]
    iocb.plist.iocb_buffer.buf_ptr = PTR2HSADDR(name);
20002f04:	687b      	ldr	r3, [r7, #4]
20002f06:	62bb      	str	r3, [r7, #40]	@ 0x28
    iocb.plist.iocb_buffer.buf_length = cfe_strlen(name);
20002f08:	6878      	ldr	r0, [r7, #4]
20002f0a:	f7ff fef0 	bl	20002cee <cfe_strlen>
20002f0e:	4603      	mov	r3, r0
20002f10:	62fb      	str	r3, [r7, #44]	@ 0x2c

    cfe_iocb_dispatch(&iocb);
20002f12:	f107 0308 	add.w	r3, r7, #8
20002f16:	4618      	mov	r0, r3
20002f18:	f000 f850 	bl	20002fbc <cfe_iocb_dispatch>

    return (iocb.iocb_status < 0) ? iocb.iocb_status : (int)iocb.plist.iocb_buffer.buf_devflags;
20002f1c:	68fb      	ldr	r3, [r7, #12]
20002f1e:	2b00      	cmp	r3, #0
20002f20:	da01      	bge.n	20002f26 <cfe_getdevinfo+0x4a>
20002f22:	68fb      	ldr	r3, [r7, #12]
20002f24:	e000      	b.n	20002f28 <cfe_getdevinfo+0x4c>
20002f26:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
}
20002f28:	4618      	mov	r0, r3
20002f2a:	3770      	adds	r7, #112	@ 0x70
20002f2c:	46bd      	mov	sp, r7
20002f2e:	bd80      	pop	{r7, pc}

20002f30 <cfe_errortext>:
    *  Return value:
    *  	   string description of error
    ********************************************************************* */

const char *cfe_errortext(int err)
{
20002f30:	b480      	push	{r7}
20002f32:	b085      	sub	sp, #20
20002f34:	af00      	add	r7, sp, #0
20002f36:	6078      	str	r0, [r7, #4]
    errmap_t *e = cfe_errorstrings;
20002f38:	4b0c      	ldr	r3, [pc, #48]	@ (20002f6c <cfe_errortext+0x3c>)
20002f3a:	60fb      	str	r3, [r7, #12]

    while (e->string) {
20002f3c:	e00a      	b.n	20002f54 <cfe_errortext+0x24>
	if (e->errcode == err) return e->string;
20002f3e:	68fb      	ldr	r3, [r7, #12]
20002f40:	681b      	ldr	r3, [r3, #0]
20002f42:	687a      	ldr	r2, [r7, #4]
20002f44:	429a      	cmp	r2, r3
20002f46:	d102      	bne.n	20002f4e <cfe_errortext+0x1e>
20002f48:	68fb      	ldr	r3, [r7, #12]
20002f4a:	685b      	ldr	r3, [r3, #4]
20002f4c:	e007      	b.n	20002f5e <cfe_errortext+0x2e>
	e++;
20002f4e:	68fb      	ldr	r3, [r7, #12]
20002f50:	3308      	adds	r3, #8
20002f52:	60fb      	str	r3, [r7, #12]
    while (e->string) {
20002f54:	68fb      	ldr	r3, [r7, #12]
20002f56:	685b      	ldr	r3, [r3, #4]
20002f58:	2b00      	cmp	r3, #0
20002f5a:	d1f0      	bne.n	20002f3e <cfe_errortext+0xe>
	}

    return (const char *) "Unknown error";
20002f5c:	4b04      	ldr	r3, [pc, #16]	@ (20002f70 <cfe_errortext+0x40>)
}
20002f5e:	4618      	mov	r0, r3
20002f60:	3714      	adds	r7, #20
20002f62:	46bd      	mov	sp, r7
20002f64:	f85d 7b04 	ldr.w	r7, [sp], #4
20002f68:	4770      	bx	lr
20002f6a:	bf00      	nop
20002f6c:	20009080 	.word	0x20009080
20002f70:	20007ab4 	.word	0x20007ab4

20002f74 <hsgetstr>:
    *  	   nothing
    ********************************************************************* */


static void hsgetstr(char *dest,hsaddr_t src,int len)
{
20002f74:	b480      	push	{r7}
20002f76:	b087      	sub	sp, #28
20002f78:	af00      	add	r7, sp, #0
20002f7a:	60f8      	str	r0, [r7, #12]
20002f7c:	60b9      	str	r1, [r7, #8]
20002f7e:	607a      	str	r2, [r7, #4]
    char b;

    while (len > 0) {
20002f80:	e010      	b.n	20002fa4 <hsgetstr+0x30>
	b = hs_read8(src);
20002f82:	68bb      	ldr	r3, [r7, #8]
20002f84:	781b      	ldrb	r3, [r3, #0]
20002f86:	75fb      	strb	r3, [r7, #23]
	src++;
20002f88:	68bb      	ldr	r3, [r7, #8]
20002f8a:	3301      	adds	r3, #1
20002f8c:	60bb      	str	r3, [r7, #8]
	*dest++ = b;
20002f8e:	68fb      	ldr	r3, [r7, #12]
20002f90:	1c5a      	adds	r2, r3, #1
20002f92:	60fa      	str	r2, [r7, #12]
20002f94:	7dfa      	ldrb	r2, [r7, #23]
20002f96:	701a      	strb	r2, [r3, #0]
	if (b == 0) break;
20002f98:	7dfb      	ldrb	r3, [r7, #23]
20002f9a:	2b00      	cmp	r3, #0
20002f9c:	d006      	beq.n	20002fac <hsgetstr+0x38>
	len--;
20002f9e:	687b      	ldr	r3, [r7, #4]
20002fa0:	3b01      	subs	r3, #1
20002fa2:	607b      	str	r3, [r7, #4]
    while (len > 0) {
20002fa4:	687b      	ldr	r3, [r7, #4]
20002fa6:	2b00      	cmp	r3, #0
20002fa8:	dceb      	bgt.n	20002f82 <hsgetstr+0xe>
	}
}
20002faa:	e000      	b.n	20002fae <hsgetstr+0x3a>
	if (b == 0) break;
20002fac:	bf00      	nop
}
20002fae:	bf00      	nop
20002fb0:	371c      	adds	r7, #28
20002fb2:	46bd      	mov	sp, r7
20002fb4:	f85d 7b04 	ldr.w	r7, [sp], #4
20002fb8:	4770      	bx	lr
	...

20002fbc <cfe_iocb_dispatch>:
	    }
	}
}

int cfe_iocb_dispatch(cfe_iocb_t *iocb)
{
20002fbc:	b580      	push	{r7, lr}
20002fbe:	b086      	sub	sp, #24
20002fc0:	af00      	add	r7, sp, #0
20002fc2:	6078      	str	r0, [r7, #4]

    /*
     * Check for commands codes out of range
     */

    if ((iocb->iocb_fcode < 0) || (iocb->iocb_fcode >= CFE_CMD_MAX)) {
20002fc4:	687b      	ldr	r3, [r7, #4]
20002fc6:	681b      	ldr	r3, [r3, #0]
20002fc8:	2b1f      	cmp	r3, #31
20002fca:	d906      	bls.n	20002fda <cfe_iocb_dispatch+0x1e>
	iocb->iocb_status = CFE_ERR_INV_COMMAND;
20002fcc:	687b      	ldr	r3, [r7, #4]
20002fce:	f06f 0201 	mvn.w	r2, #1
20002fd2:	605a      	str	r2, [r3, #4]
	return iocb->iocb_status;
20002fd4:	687b      	ldr	r3, [r7, #4]
20002fd6:	685b      	ldr	r3, [r3, #4]
20002fd8:	e04f      	b.n	2000307a <cfe_iocb_dispatch+0xbe>

    /*
     * Check for command codes in range but invalid
     */

    disp = &cfe_cmd_dispatch_table[iocb->iocb_fcode];
20002fda:	687b      	ldr	r3, [r7, #4]
20002fdc:	681a      	ldr	r2, [r3, #0]
20002fde:	4613      	mov	r3, r2
20002fe0:	005b      	lsls	r3, r3, #1
20002fe2:	4413      	add	r3, r2
20002fe4:	009b      	lsls	r3, r3, #2
20002fe6:	4a27      	ldr	r2, [pc, #156]	@ (20003084 <cfe_iocb_dispatch+0xc8>)
20002fe8:	4413      	add	r3, r2
20002fea:	613b      	str	r3, [r7, #16]

    if (disp->plistsize < 0) {
20002fec:	693b      	ldr	r3, [r7, #16]
20002fee:	681b      	ldr	r3, [r3, #0]
20002ff0:	2b00      	cmp	r3, #0
20002ff2:	da06      	bge.n	20003002 <cfe_iocb_dispatch+0x46>
	iocb->iocb_status = CFE_ERR_INV_COMMAND;
20002ff4:	687b      	ldr	r3, [r7, #4]
20002ff6:	f06f 0201 	mvn.w	r2, #1
20002ffa:	605a      	str	r2, [r3, #4]
	return iocb->iocb_status;
20002ffc:	687b      	ldr	r3, [r7, #4]
20002ffe:	685b      	ldr	r3, [r3, #4]
20003000:	e03b      	b.n	2000307a <cfe_iocb_dispatch+0xbe>

    /*
     * Check for invalid parameter list size
     */

    if (disp->plistsize != iocb->iocb_psize) {
20003002:	693b      	ldr	r3, [r7, #16]
20003004:	681b      	ldr	r3, [r3, #0]
20003006:	461a      	mov	r2, r3
20003008:	687b      	ldr	r3, [r7, #4]
2000300a:	691b      	ldr	r3, [r3, #16]
2000300c:	429a      	cmp	r2, r3
2000300e:	d006      	beq.n	2000301e <cfe_iocb_dispatch+0x62>
	iocb->iocb_status = CFE_ERR_INV_PARAM;
20003010:	687b      	ldr	r3, [r7, #4]
20003012:	f06f 0207 	mvn.w	r2, #7
20003016:	605a      	str	r2, [r3, #4]
	return iocb->iocb_status;
20003018:	687b      	ldr	r3, [r7, #4]
2000301a:	685b      	ldr	r3, [r3, #4]
2000301c:	e02d      	b.n	2000307a <cfe_iocb_dispatch+0xbe>

    /*
     * Determine handle
     */
    
    ctx = NULL;
2000301e:	2300      	movs	r3, #0
20003020:	617b      	str	r3, [r7, #20]
    if (disp->flags & HV) {
20003022:	693b      	ldr	r3, [r7, #16]
20003024:	685b      	ldr	r3, [r3, #4]
20003026:	f003 0301 	and.w	r3, r3, #1
2000302a:	2b00      	cmp	r3, #0
2000302c:	d01b      	beq.n	20003066 <cfe_iocb_dispatch+0xaa>
	if ((iocb->iocb_handle >= CFE_MAX_HANDLE) || 
2000302e:	687b      	ldr	r3, [r7, #4]
20003030:	689b      	ldr	r3, [r3, #8]
20003032:	2b3f      	cmp	r3, #63	@ 0x3f
20003034:	dc0a      	bgt.n	2000304c <cfe_iocb_dispatch+0x90>
	    (iocb->iocb_handle < 0) ||
20003036:	687b      	ldr	r3, [r7, #4]
20003038:	689b      	ldr	r3, [r3, #8]
	if ((iocb->iocb_handle >= CFE_MAX_HANDLE) || 
2000303a:	2b00      	cmp	r3, #0
2000303c:	db06      	blt.n	2000304c <cfe_iocb_dispatch+0x90>
	    (cfe_handle_table[iocb->iocb_handle] == NULL)){
2000303e:	687b      	ldr	r3, [r7, #4]
20003040:	689b      	ldr	r3, [r3, #8]
20003042:	4a11      	ldr	r2, [pc, #68]	@ (20003088 <cfe_iocb_dispatch+0xcc>)
20003044:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
	    (iocb->iocb_handle < 0) ||
20003048:	2b00      	cmp	r3, #0
2000304a:	d106      	bne.n	2000305a <cfe_iocb_dispatch+0x9e>
	    iocb->iocb_status = CFE_ERR_INV_PARAM;
2000304c:	687b      	ldr	r3, [r7, #4]
2000304e:	f06f 0207 	mvn.w	r2, #7
20003052:	605a      	str	r2, [r3, #4]
	    return iocb->iocb_status;
20003054:	687b      	ldr	r3, [r7, #4]
20003056:	685b      	ldr	r3, [r3, #4]
20003058:	e00f      	b.n	2000307a <cfe_iocb_dispatch+0xbe>
	    }
	ctx = cfe_handle_table[iocb->iocb_handle];
2000305a:	687b      	ldr	r3, [r7, #4]
2000305c:	689b      	ldr	r3, [r3, #8]
2000305e:	4a0a      	ldr	r2, [pc, #40]	@ (20003088 <cfe_iocb_dispatch+0xcc>)
20003060:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
20003064:	617b      	str	r3, [r7, #20]

    /*
     * Dispatch to handler routine
     */

    res = (*disp->func)(ctx,iocb);
20003066:	693b      	ldr	r3, [r7, #16]
20003068:	689b      	ldr	r3, [r3, #8]
2000306a:	6879      	ldr	r1, [r7, #4]
2000306c:	6978      	ldr	r0, [r7, #20]
2000306e:	4798      	blx	r3
20003070:	60f8      	str	r0, [r7, #12]

    iocb->iocb_status = res;
20003072:	687b      	ldr	r3, [r7, #4]
20003074:	68fa      	ldr	r2, [r7, #12]
20003076:	605a      	str	r2, [r3, #4]
    return res;
20003078:	68fb      	ldr	r3, [r7, #12]
}
2000307a:	4618      	mov	r0, r3
2000307c:	3718      	adds	r7, #24
2000307e:	46bd      	mov	sp, r7
20003080:	bd80      	pop	{r7, pc}
20003082:	bf00      	nop
20003084:	20008ed0 	.word	0x20008ed0
20003088:	2000932c 	.word	0x2000932c

2000308c <cfe_newhandle>:

static int cfe_newhandle(void)
{
2000308c:	b480      	push	{r7}
2000308e:	b083      	sub	sp, #12
20003090:	af00      	add	r7, sp, #0
    int idx;

    for (idx = 0; idx < CFE_MAX_HANDLE; idx++) {
20003092:	2300      	movs	r3, #0
20003094:	607b      	str	r3, [r7, #4]
20003096:	e008      	b.n	200030aa <cfe_newhandle+0x1e>
	if (cfe_handle_table[idx] == NULL) break;
20003098:	4a0d      	ldr	r2, [pc, #52]	@ (200030d0 <cfe_newhandle+0x44>)
2000309a:	687b      	ldr	r3, [r7, #4]
2000309c:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
200030a0:	2b00      	cmp	r3, #0
200030a2:	d006      	beq.n	200030b2 <cfe_newhandle+0x26>
    for (idx = 0; idx < CFE_MAX_HANDLE; idx++) {
200030a4:	687b      	ldr	r3, [r7, #4]
200030a6:	3301      	adds	r3, #1
200030a8:	607b      	str	r3, [r7, #4]
200030aa:	687b      	ldr	r3, [r7, #4]
200030ac:	2b3f      	cmp	r3, #63	@ 0x3f
200030ae:	ddf3      	ble.n	20003098 <cfe_newhandle+0xc>
200030b0:	e000      	b.n	200030b4 <cfe_newhandle+0x28>
	if (cfe_handle_table[idx] == NULL) break;
200030b2:	bf00      	nop
	}

    if (idx == CFE_MAX_HANDLE) return -1;
200030b4:	687b      	ldr	r3, [r7, #4]
200030b6:	2b40      	cmp	r3, #64	@ 0x40
200030b8:	d102      	bne.n	200030c0 <cfe_newhandle+0x34>
200030ba:	f04f 33ff 	mov.w	r3, #4294967295	@ 0xffffffff
200030be:	e000      	b.n	200030c2 <cfe_newhandle+0x36>

    return idx;
200030c0:	687b      	ldr	r3, [r7, #4]
}
200030c2:	4618      	mov	r0, r3
200030c4:	370c      	adds	r7, #12
200030c6:	46bd      	mov	sp, r7
200030c8:	f85d 7b04 	ldr.w	r7, [sp], #4
200030cc:	4770      	bx	lr
200030ce:	bf00      	nop
200030d0:	2000932c 	.word	0x2000932c

200030d4 <cfe_cmd_fw_getinfo>:
/*  *********************************************************************
    *  Implementation routines for each IOCB function
    ********************************************************************* */

static int cfe_cmd_fw_getinfo(cfe_devctx_t *ctx,cfe_iocb_t *iocb)
{
200030d4:	e92d 03b0 	stmdb	sp!, {r4, r5, r7, r8, r9}
200030d8:	b085      	sub	sp, #20
200030da:	af00      	add	r7, sp, #0
200030dc:	6078      	str	r0, [r7, #4]
200030de:	6039      	str	r1, [r7, #0]
    iocb_fwinfo_t *info = &iocb->plist.iocb_fwinfo;
200030e0:	683b      	ldr	r3, [r7, #0]
200030e2:	3318      	adds	r3, #24
200030e4:	60fb      	str	r3, [r7, #12]

    info->fwi_version = (CFE_VER_MAJOR << 16) |
200030e6:	68f9      	ldr	r1, [r7, #12]
200030e8:	f44f 7281 	mov.w	r2, #258	@ 0x102
200030ec:	f04f 0300 	mov.w	r3, #0
200030f0:	e9c1 2300 	strd	r2, r3, [r1]
	(CFE_VER_MINOR << 8) |
	(CFE_VER_BUILD);
    //info->fwi_totalmem = ((cfe_int64_t) mem_totalsize) << 20;
    info->fwi_flags = 
200030f4:	68f9      	ldr	r1, [r7, #12]
200030f6:	f04f 020a 	mov.w	r2, #10
200030fa:	f04f 0300 	mov.w	r3, #0
200030fe:	e9c1 2304 	strd	r2, r3, [r1, #16]
#ifdef _FUNCSIM_
	CFE_FWI_FUNCSIM |
#endif
	0;

    info->fwi_boardid = CFG_BOARD_ID;
20003102:	68f9      	ldr	r1, [r7, #12]
20003104:	f04f 0200 	mov.w	r2, #0
20003108:	f04f 0300 	mov.w	r3, #0
2000310c:	e9c1 2306 	strd	r2, r3, [r1, #24]
    info->fwi_bootarea_pa = (cfe_int64_t) mem_bootarea_start;
20003110:	4b19      	ldr	r3, [pc, #100]	@ (20003178 <cfe_cmd_fw_getinfo+0xa4>)
20003112:	681b      	ldr	r3, [r3, #0]
20003114:	2200      	movs	r2, #0
20003116:	4698      	mov	r8, r3
20003118:	4691      	mov	r9, r2
2000311a:	68fb      	ldr	r3, [r7, #12]
2000311c:	e9c3 890a 	strd	r8, r9, [r3, #40]	@ 0x28
    info->fwi_bootarea_va = BOOT_START_ADDRESS;
20003120:	68f9      	ldr	r1, [r7, #12]
20003122:	f04f 5200 	mov.w	r2, #536870912	@ 0x20000000
20003126:	f04f 0300 	mov.w	r3, #0
2000312a:	e9c1 2308 	strd	r2, r3, [r1, #32]
    info->fwi_bootarea_size = (cfe_int64_t) mem_bootarea_size;
2000312e:	4b13      	ldr	r3, [pc, #76]	@ (2000317c <cfe_cmd_fw_getinfo+0xa8>)
20003130:	681b      	ldr	r3, [r3, #0]
20003132:	2200      	movs	r2, #0
20003134:	461c      	mov	r4, r3
20003136:	4615      	mov	r5, r2
20003138:	68fb      	ldr	r3, [r7, #12]
2000313a:	e9c3 450c 	strd	r4, r5, [r3, #48]	@ 0x30
    info->fwi_reserved1 = 0;
2000313e:	68f9      	ldr	r1, [r7, #12]
20003140:	f04f 0200 	mov.w	r2, #0
20003144:	f04f 0300 	mov.w	r3, #0
20003148:	e9c1 230e 	strd	r2, r3, [r1, #56]	@ 0x38
    info->fwi_reserved2 = 0;
2000314c:	68f9      	ldr	r1, [r7, #12]
2000314e:	f04f 0200 	mov.w	r2, #0
20003152:	f04f 0300 	mov.w	r3, #0
20003156:	e9c1 2310 	strd	r2, r3, [r1, #64]	@ 0x40
    info->fwi_reserved3 = 0;
2000315a:	68f9      	ldr	r1, [r7, #12]
2000315c:	f04f 0200 	mov.w	r2, #0
20003160:	f04f 0300 	mov.w	r3, #0
20003164:	e9c1 2312 	strd	r2, r3, [r1, #72]	@ 0x48

    return CFE_OK;
20003168:	2300      	movs	r3, #0
}
2000316a:	4618      	mov	r0, r3
2000316c:	3714      	adds	r7, #20
2000316e:	46bd      	mov	sp, r7
20003170:	e8bd 03b0 	ldmia.w	sp!, {r4, r5, r7, r8, r9}
20003174:	4770      	bx	lr
20003176:	bf00      	nop
20003178:	20009448 	.word	0x20009448
2000317c:	2000944c 	.word	0x2000944c

20003180 <cfe_cmd_fw_restart>:

static int cfe_cmd_fw_restart(cfe_devctx_t *ctx,cfe_iocb_t *iocb)
{
20003180:	b480      	push	{r7}
20003182:	b083      	sub	sp, #12
20003184:	af00      	add	r7, sp, #0
20003186:	6078      	str	r0, [r7, #4]
20003188:	6039      	str	r1, [r7, #0]

    return CFE_OK;
2000318a:	2300      	movs	r3, #0
}
2000318c:	4618      	mov	r0, r3
2000318e:	370c      	adds	r7, #12
20003190:	46bd      	mov	sp, r7
20003192:	f85d 7b04 	ldr.w	r7, [sp], #4
20003196:	4770      	bx	lr

20003198 <cfe_cmd_fw_boot>:

static int cfe_cmd_fw_boot(cfe_devctx_t *ctx,cfe_iocb_t *iocb)
{
20003198:	b480      	push	{r7}
2000319a:	b083      	sub	sp, #12
2000319c:	af00      	add	r7, sp, #0
2000319e:	6078      	str	r0, [r7, #4]
200031a0:	6039      	str	r1, [r7, #0]
    return CFE_ERR_INV_COMMAND;		/* not implemented yet */
200031a2:	f06f 0301 	mvn.w	r3, #1
}
200031a6:	4618      	mov	r0, r3
200031a8:	370c      	adds	r7, #12
200031aa:	46bd      	mov	sp, r7
200031ac:	f85d 7b04 	ldr.w	r7, [sp], #4
200031b0:	4770      	bx	lr

200031b2 <cfe_cmd_fw_cpuctl>:

static int cfe_cmd_fw_cpuctl(cfe_devctx_t *ctx,cfe_iocb_t *iocb)
{
200031b2:	b480      	push	{r7}
200031b4:	b083      	sub	sp, #12
200031b6:	af00      	add	r7, sp, #0
200031b8:	6078      	str	r0, [r7, #4]
200031ba:	6039      	str	r1, [r7, #0]
	    res = CFE_ERR_INV_PARAM;
	}

    return res;
#else
    return CFE_ERR_INV_COMMAND;
200031bc:	f06f 0301 	mvn.w	r3, #1
#endif
}
200031c0:	4618      	mov	r0, r3
200031c2:	370c      	adds	r7, #12
200031c4:	46bd      	mov	sp, r7
200031c6:	f85d 7b04 	ldr.w	r7, [sp], #4
200031ca:	4770      	bx	lr

200031cc <cfe_cmd_fw_gettime>:

static int cfe_cmd_fw_gettime(cfe_devctx_t *ctx,cfe_iocb_t *iocb)
{
200031cc:	b580      	push	{r7, lr}
200031ce:	b082      	sub	sp, #8
200031d0:	af00      	add	r7, sp, #0
200031d2:	6078      	str	r0, [r7, #4]
200031d4:	6039      	str	r1, [r7, #0]
    POLL();
200031d6:	f7fe fd23 	bl	20001c20 <background>

    iocb->plist.iocb_time.ticks = cfe_ticks;
200031da:	4b05      	ldr	r3, [pc, #20]	@ (200031f0 <cfe_cmd_fw_gettime+0x24>)
200031dc:	e9d3 2300 	ldrd	r2, r3, [r3]
200031e0:	6839      	ldr	r1, [r7, #0]
200031e2:	e9c1 2306 	strd	r2, r3, [r1, #24]

    return CFE_OK;
200031e6:	2300      	movs	r3, #0
}
200031e8:	4618      	mov	r0, r3
200031ea:	3708      	adds	r7, #8
200031ec:	46bd      	mov	sp, r7
200031ee:	bd80      	pop	{r7, pc}
200031f0:	20009450 	.word	0x20009450

200031f4 <cfe_cmd_fw_memenum>:

static int cfe_cmd_fw_memenum(cfe_devctx_t *ctx,cfe_iocb_t *iocb)
{
200031f4:	b590      	push	{r4, r7, lr}
200031f6:	b08b      	sub	sp, #44	@ 0x2c
200031f8:	af02      	add	r7, sp, #8
200031fa:	6078      	str	r0, [r7, #4]
200031fc:	6039      	str	r1, [r7, #0]
    int type;
    int res;
    uint64_t addr,size;

    res = cfe_arena_enum(iocb->plist.iocb_meminfo.mi_idx,
200031fe:	683b      	ldr	r3, [r7, #0]
20003200:	6998      	ldr	r0, [r3, #24]
			 &type,
			 &addr,
			 &size,
			 (iocb->iocb_flags & CFE_FLG_FULL_ARENA) ? TRUE : FALSE);
20003202:	683b      	ldr	r3, [r7, #0]
20003204:	68db      	ldr	r3, [r3, #12]
    res = cfe_arena_enum(iocb->plist.iocb_meminfo.mi_idx,
20003206:	f003 0301 	and.w	r3, r3, #1
2000320a:	f107 0408 	add.w	r4, r7, #8
2000320e:	f107 0210 	add.w	r2, r7, #16
20003212:	f107 0118 	add.w	r1, r7, #24
20003216:	9300      	str	r3, [sp, #0]
20003218:	4623      	mov	r3, r4
2000321a:	f000 fb33 	bl	20003884 <cfe_arena_enum>
2000321e:	61f8      	str	r0, [r7, #28]

    iocb->plist.iocb_meminfo.mi_addr = addr;
20003220:	e9d7 2304 	ldrd	r2, r3, [r7, #16]
20003224:	6839      	ldr	r1, [r7, #0]
20003226:	e9c1 2308 	strd	r2, r3, [r1, #32]
    iocb->plist.iocb_meminfo.mi_size = size;
2000322a:	e9d7 2302 	ldrd	r2, r3, [r7, #8]
2000322e:	6839      	ldr	r1, [r7, #0]
20003230:	e9c1 230a 	strd	r2, r3, [r1, #40]	@ 0x28
    iocb->plist.iocb_meminfo.mi_type = type;
20003234:	69ba      	ldr	r2, [r7, #24]
20003236:	683b      	ldr	r3, [r7, #0]
20003238:	61da      	str	r2, [r3, #28]

    if (res == 0) {
2000323a:	69fb      	ldr	r3, [r7, #28]
2000323c:	2b00      	cmp	r3, #0
2000323e:	d109      	bne.n	20003254 <cfe_cmd_fw_memenum+0x60>
	if (type == MEMTYPE_DRAM_AVAILABLE) {
20003240:	69bb      	ldr	r3, [r7, #24]
20003242:	2b01      	cmp	r3, #1
20003244:	d103      	bne.n	2000324e <cfe_cmd_fw_memenum+0x5a>
	    iocb->plist.iocb_meminfo.mi_type = CFE_MI_AVAILABLE;
20003246:	683b      	ldr	r3, [r7, #0]
20003248:	2201      	movs	r2, #1
2000324a:	61da      	str	r2, [r3, #28]
2000324c:	e002      	b.n	20003254 <cfe_cmd_fw_memenum+0x60>
	    }
	else {
	    iocb->plist.iocb_meminfo.mi_type = CFE_MI_RESERVED;
2000324e:	683b      	ldr	r3, [r7, #0]
20003250:	2200      	movs	r2, #0
20003252:	61da      	str	r2, [r3, #28]
	    }
	}

    return res;
20003254:	69fb      	ldr	r3, [r7, #28]
}
20003256:	4618      	mov	r0, r3
20003258:	3724      	adds	r7, #36	@ 0x24
2000325a:	46bd      	mov	sp, r7
2000325c:	bd90      	pop	{r4, r7, pc}

2000325e <cfe_cmd_fw_flushcache>:

static int cfe_cmd_fw_flushcache(cfe_devctx_t *ctx,cfe_iocb_t *iocb)
{
2000325e:	b480      	push	{r7}
20003260:	b083      	sub	sp, #12
20003262:	af00      	add	r7, sp, #0
20003264:	6078      	str	r0, [r7, #4]
20003266:	6039      	str	r1, [r7, #0]
  //  _cfe_flushcache(iocb->iocb_flags);
    return CFE_OK;
20003268:	2300      	movs	r3, #0
}
2000326a:	4618      	mov	r0, r3
2000326c:	370c      	adds	r7, #12
2000326e:	46bd      	mov	sp, r7
20003270:	f85d 7b04 	ldr.w	r7, [sp], #4
20003274:	4770      	bx	lr

20003276 <cfe_cmd_dev_enum>:

static int cfe_cmd_dev_enum(cfe_devctx_t *ctx,cfe_iocb_t *iocb)
{
20003276:	b580      	push	{r7, lr}
20003278:	b084      	sub	sp, #16
2000327a:	af00      	add	r7, sp, #0
2000327c:	6078      	str	r0, [r7, #4]
2000327e:	6039      	str	r1, [r7, #0]
    int namelen,res;

    namelen = iocb->plist.iocb_envbuf.name_length;
20003280:	683b      	ldr	r3, [r7, #0]
20003282:	6a1b      	ldr	r3, [r3, #32]
20003284:	60bb      	str	r3, [r7, #8]

    res = cfe_dev_enum(iocb->plist.iocb_envbuf.enum_idx,
20003286:	683b      	ldr	r3, [r7, #0]
20003288:	6998      	ldr	r0, [r3, #24]
		   (char *)iocb->plist.iocb_envbuf.name_ptr,
2000328a:	683b      	ldr	r3, [r7, #0]
2000328c:	69db      	ldr	r3, [r3, #28]
    res = cfe_dev_enum(iocb->plist.iocb_envbuf.enum_idx,
2000328e:	f107 0208 	add.w	r2, r7, #8
20003292:	4619      	mov	r1, r3
20003294:	f7fe fbbe 	bl	20001a14 <cfe_dev_enum>
20003298:	60f8      	str	r0, [r7, #12]
		   &namelen);

    if (res < 0) return CFE_ERR_DEVNOTFOUND;
2000329a:	68fb      	ldr	r3, [r7, #12]
2000329c:	2b00      	cmp	r3, #0
2000329e:	da02      	bge.n	200032a6 <cfe_cmd_dev_enum+0x30>
200032a0:	f06f 0305 	mvn.w	r3, #5
200032a4:	e003      	b.n	200032ae <cfe_cmd_dev_enum+0x38>

	iocb->plist.iocb_envbuf.name_length = namelen;
200032a6:	68ba      	ldr	r2, [r7, #8]
200032a8:	683b      	ldr	r3, [r7, #0]
200032aa:	621a      	str	r2, [r3, #32]

    return CFE_OK;
200032ac:	2300      	movs	r3, #0
}
200032ae:	4618      	mov	r0, r3
200032b0:	3710      	adds	r7, #16
200032b2:	46bd      	mov	sp, r7
200032b4:	bd80      	pop	{r7, pc}
	...

200032b8 <cfe_cmd_dev_gethandle>:

static int cfe_cmd_dev_gethandle(cfe_devctx_t *ctx,cfe_iocb_t *iocb)
{
200032b8:	b480      	push	{r7}
200032ba:	b083      	sub	sp, #12
200032bc:	af00      	add	r7, sp, #0
200032be:	6078      	str	r0, [r7, #4]
200032c0:	6039      	str	r1, [r7, #0]
    switch (iocb->iocb_flags) {
200032c2:	683b      	ldr	r3, [r7, #0]
200032c4:	68db      	ldr	r3, [r3, #12]
200032c6:	2b00      	cmp	r3, #0
200032c8:	d10d      	bne.n	200032e6 <cfe_cmd_dev_gethandle+0x2e>
	case CFE_STDHANDLE_CONSOLE:
	    if (console_handle == -1) return CFE_ERR_DEVNOTFOUND;
200032ca:	4b0b      	ldr	r3, [pc, #44]	@ (200032f8 <cfe_cmd_dev_gethandle+0x40>)
200032cc:	681b      	ldr	r3, [r3, #0]
200032ce:	f1b3 3fff 	cmp.w	r3, #4294967295	@ 0xffffffff
200032d2:	d102      	bne.n	200032da <cfe_cmd_dev_gethandle+0x22>
200032d4:	f06f 0305 	mvn.w	r3, #5
200032d8:	e007      	b.n	200032ea <cfe_cmd_dev_gethandle+0x32>
	    iocb->iocb_handle = console_handle;
200032da:	4b07      	ldr	r3, [pc, #28]	@ (200032f8 <cfe_cmd_dev_gethandle+0x40>)
200032dc:	681a      	ldr	r2, [r3, #0]
200032de:	683b      	ldr	r3, [r7, #0]
200032e0:	609a      	str	r2, [r3, #8]
	    return CFE_OK;
200032e2:	2300      	movs	r3, #0
200032e4:	e001      	b.n	200032ea <cfe_cmd_dev_gethandle+0x32>
	    break;
	default:
	    return CFE_ERR_INV_PARAM;
200032e6:	f06f 0307 	mvn.w	r3, #7
	}
}
200032ea:	4618      	mov	r0, r3
200032ec:	370c      	adds	r7, #12
200032ee:	46bd      	mov	sp, r7
200032f0:	f85d 7b04 	ldr.w	r7, [sp], #4
200032f4:	4770      	bx	lr
200032f6:	bf00      	nop
200032f8:	2000907c 	.word	0x2000907c

200032fc <cfe_cmd_dev_open>:

static int cfe_cmd_dev_open(cfe_devctx_t *ctx,cfe_iocb_t *iocb)
{
200032fc:	b580      	push	{r7, lr}
200032fe:	b096      	sub	sp, #88	@ 0x58
20003300:	af00      	add	r7, sp, #0
20003302:	6078      	str	r0, [r7, #4]
20003304:	6039      	str	r1, [r7, #0]

    /*
     * Get device name
     */

    hsgetstr(devname,iocb->plist.iocb_buffer.buf_ptr,sizeof(devname));
20003306:	683b      	ldr	r3, [r7, #0]
20003308:	6a19      	ldr	r1, [r3, #32]
2000330a:	f107 030c 	add.w	r3, r7, #12
2000330e:	2240      	movs	r2, #64	@ 0x40
20003310:	4618      	mov	r0, r3
20003312:	f7ff fe2f 	bl	20002f74 <hsgetstr>

    /*
     * Find device in device table
     */

    dev = cfe_finddev(devname);
20003316:	f107 030c 	add.w	r3, r7, #12
2000331a:	4618      	mov	r0, r3
2000331c:	f7fe fb56 	bl	200019cc <cfe_finddev>
20003320:	6578      	str	r0, [r7, #84]	@ 0x54
    if (!dev) return CFE_ERR_DEVNOTFOUND;
20003322:	6d7b      	ldr	r3, [r7, #84]	@ 0x54
20003324:	2b00      	cmp	r3, #0
20003326:	d102      	bne.n	2000332e <cfe_cmd_dev_open+0x32>
20003328:	f06f 0305 	mvn.w	r3, #5
2000332c:	e047      	b.n	200033be <cfe_cmd_dev_open+0xc2>

    /*
     * Fail if someone else already has the device open
     */

    if (dev->dev_opencount > 0) return CFE_ERR_DEVOPEN;
2000332e:	6d7b      	ldr	r3, [r7, #84]	@ 0x54
20003330:	699b      	ldr	r3, [r3, #24]
20003332:	2b00      	cmp	r3, #0
20003334:	dd02      	ble.n	2000333c <cfe_cmd_dev_open+0x40>
20003336:	f06f 0306 	mvn.w	r3, #6
2000333a:	e040      	b.n	200033be <cfe_cmd_dev_open+0xc2>

    /*
     * Generate a new handle
     */

    h = cfe_newhandle();
2000333c:	f7ff fea6 	bl	2000308c <cfe_newhandle>
20003340:	6538      	str	r0, [r7, #80]	@ 0x50
    if (h < 0) return CFE_ERR_NOMEM;
20003342:	6d3b      	ldr	r3, [r7, #80]	@ 0x50
20003344:	2b00      	cmp	r3, #0
20003346:	da02      	bge.n	2000334e <cfe_cmd_dev_open+0x52>
20003348:	f06f 0304 	mvn.w	r3, #4
2000334c:	e037      	b.n	200033be <cfe_cmd_dev_open+0xc2>

    /*
     * Allocate a context
     */

    ctx = (cfe_devctx_t *) KMALLOC(sizeof(cfe_devctx_t),0);
2000334e:	2200      	movs	r2, #0
20003350:	210c      	movs	r1, #12
20003352:	481d      	ldr	r0, [pc, #116]	@ (200033c8 <cfe_cmd_dev_open+0xcc>)
20003354:	f7fd fec0 	bl	200010d8 <kmalloc>
20003358:	6078      	str	r0, [r7, #4]
    if (ctx == NULL) return CFE_ERR_NOMEM;
2000335a:	687b      	ldr	r3, [r7, #4]
2000335c:	2b00      	cmp	r3, #0
2000335e:	d102      	bne.n	20003366 <cfe_cmd_dev_open+0x6a>
20003360:	f06f 0304 	mvn.w	r3, #4
20003364:	e02b      	b.n	200033be <cfe_cmd_dev_open+0xc2>

    /*
     * Fill in the context
     */

    ctx->dev_dev = dev;
20003366:	687b      	ldr	r3, [r7, #4]
20003368:	6d7a      	ldr	r2, [r7, #84]	@ 0x54
2000336a:	601a      	str	r2, [r3, #0]
    ctx->dev_softc = dev->dev_softc;
2000336c:	6d7b      	ldr	r3, [r7, #84]	@ 0x54
2000336e:	68da      	ldr	r2, [r3, #12]
20003370:	687b      	ldr	r3, [r7, #4]
20003372:	605a      	str	r2, [r3, #4]
    ctx->dev_openinfo = NULL;
20003374:	687b      	ldr	r3, [r7, #4]
20003376:	2200      	movs	r2, #0
20003378:	609a      	str	r2, [r3, #8]
    /*
     * Call driver's open func.  First claim the device number in case
     * the open routine itself calls cfe_newhandle().
     */

    cfe_handle_table[h] = ctx;
2000337a:	4914      	ldr	r1, [pc, #80]	@ (200033cc <cfe_cmd_dev_open+0xd0>)
2000337c:	6d3b      	ldr	r3, [r7, #80]	@ 0x50
2000337e:	687a      	ldr	r2, [r7, #4]
20003380:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
    res = dev->dev_dispatch->dev_open(ctx);
20003384:	6d7b      	ldr	r3, [r7, #84]	@ 0x54
20003386:	695b      	ldr	r3, [r3, #20]
20003388:	681b      	ldr	r3, [r3, #0]
2000338a:	6878      	ldr	r0, [r7, #4]
2000338c:	4798      	blx	r3
2000338e:	64f8      	str	r0, [r7, #76]	@ 0x4c

    if (res != 0) {
20003390:	6cfb      	ldr	r3, [r7, #76]	@ 0x4c
20003392:	2b00      	cmp	r3, #0
20003394:	d00a      	beq.n	200033ac <cfe_cmd_dev_open+0xb0>
	cfe_handle_table[h] = NULL;
20003396:	4a0d      	ldr	r2, [pc, #52]	@ (200033cc <cfe_cmd_dev_open+0xd0>)
20003398:	6d3b      	ldr	r3, [r7, #80]	@ 0x50
2000339a:	2100      	movs	r1, #0
2000339c:	f842 1023 	str.w	r1, [r2, r3, lsl #2]
	KFREE(ctx);
200033a0:	6879      	ldr	r1, [r7, #4]
200033a2:	4809      	ldr	r0, [pc, #36]	@ (200033c8 <cfe_cmd_dev_open+0xcc>)
200033a4:	f7fd fe64 	bl	20001070 <kfree>
	return res;
200033a8:	6cfb      	ldr	r3, [r7, #76]	@ 0x4c
200033aa:	e008      	b.n	200033be <cfe_cmd_dev_open+0xc2>

    /*
     * Increment refcnt
     */

    dev->dev_opencount++;
200033ac:	6d7b      	ldr	r3, [r7, #84]	@ 0x54
200033ae:	699b      	ldr	r3, [r3, #24]
200033b0:	1c5a      	adds	r2, r3, #1
200033b2:	6d7b      	ldr	r3, [r7, #84]	@ 0x54
200033b4:	619a      	str	r2, [r3, #24]
    iocb->iocb_handle = h;
200033b6:	683b      	ldr	r3, [r7, #0]
200033b8:	6d3a      	ldr	r2, [r7, #80]	@ 0x50
200033ba:	609a      	str	r2, [r3, #8]

    /*
     * Success!
     */

    return CFE_OK;
200033bc:	2300      	movs	r3, #0
}
200033be:	4618      	mov	r0, r3
200033c0:	3758      	adds	r7, #88	@ 0x58
200033c2:	46bd      	mov	sp, r7
200033c4:	bd80      	pop	{r7, pc}
200033c6:	bf00      	nop
200033c8:	200091fc 	.word	0x200091fc
200033cc:	2000932c 	.word	0x2000932c

200033d0 <cfe_cmd_dev_inpstat>:

static int cfe_cmd_dev_inpstat(cfe_devctx_t *ctx,cfe_iocb_t *iocb)
{
200033d0:	b580      	push	{r7, lr}
200033d2:	b084      	sub	sp, #16
200033d4:	af00      	add	r7, sp, #0
200033d6:	6078      	str	r0, [r7, #4]
200033d8:	6039      	str	r1, [r7, #0]
    int status;

    status = ctx->dev_dev->dev_dispatch->dev_inpstat(ctx,&(iocb->plist.iocb_inpstat));
200033da:	687b      	ldr	r3, [r7, #4]
200033dc:	681b      	ldr	r3, [r3, #0]
200033de:	695b      	ldr	r3, [r3, #20]
200033e0:	689b      	ldr	r3, [r3, #8]
200033e2:	683a      	ldr	r2, [r7, #0]
200033e4:	3218      	adds	r2, #24
200033e6:	4611      	mov	r1, r2
200033e8:	6878      	ldr	r0, [r7, #4]
200033ea:	4798      	blx	r3
200033ec:	60f8      	str	r0, [r7, #12]

    return status;
200033ee:	68fb      	ldr	r3, [r7, #12]
}
200033f0:	4618      	mov	r0, r3
200033f2:	3710      	adds	r7, #16
200033f4:	46bd      	mov	sp, r7
200033f6:	bd80      	pop	{r7, pc}

200033f8 <cfe_cmd_dev_read>:

static int cfe_cmd_dev_read(cfe_devctx_t *ctx,cfe_iocb_t *iocb)
{
200033f8:	b580      	push	{r7, lr}
200033fa:	b084      	sub	sp, #16
200033fc:	af00      	add	r7, sp, #0
200033fe:	6078      	str	r0, [r7, #4]
20003400:	6039      	str	r1, [r7, #0]
    int status;

    status = ctx->dev_dev->dev_dispatch->dev_read(ctx,&(iocb->plist.iocb_buffer));
20003402:	687b      	ldr	r3, [r7, #4]
20003404:	681b      	ldr	r3, [r3, #0]
20003406:	695b      	ldr	r3, [r3, #20]
20003408:	685b      	ldr	r3, [r3, #4]
2000340a:	683a      	ldr	r2, [r7, #0]
2000340c:	3218      	adds	r2, #24
2000340e:	4611      	mov	r1, r2
20003410:	6878      	ldr	r0, [r7, #4]
20003412:	4798      	blx	r3
20003414:	60f8      	str	r0, [r7, #12]

    return status;
20003416:	68fb      	ldr	r3, [r7, #12]
}
20003418:	4618      	mov	r0, r3
2000341a:	3710      	adds	r7, #16
2000341c:	46bd      	mov	sp, r7
2000341e:	bd80      	pop	{r7, pc}

20003420 <cfe_cmd_dev_write>:

static int cfe_cmd_dev_write(cfe_devctx_t *ctx,cfe_iocb_t *iocb)
{
20003420:	b580      	push	{r7, lr}
20003422:	b084      	sub	sp, #16
20003424:	af00      	add	r7, sp, #0
20003426:	6078      	str	r0, [r7, #4]
20003428:	6039      	str	r1, [r7, #0]
    int status;

    status = ctx->dev_dev->dev_dispatch->dev_write(ctx,&(iocb->plist.iocb_buffer));
2000342a:	687b      	ldr	r3, [r7, #4]
2000342c:	681b      	ldr	r3, [r3, #0]
2000342e:	695b      	ldr	r3, [r3, #20]
20003430:	68db      	ldr	r3, [r3, #12]
20003432:	683a      	ldr	r2, [r7, #0]
20003434:	3218      	adds	r2, #24
20003436:	4611      	mov	r1, r2
20003438:	6878      	ldr	r0, [r7, #4]
2000343a:	4798      	blx	r3
2000343c:	60f8      	str	r0, [r7, #12]

    return status;
2000343e:	68fb      	ldr	r3, [r7, #12]
}
20003440:	4618      	mov	r0, r3
20003442:	3710      	adds	r7, #16
20003444:	46bd      	mov	sp, r7
20003446:	bd80      	pop	{r7, pc}

20003448 <cfe_cmd_dev_ioctl>:

static int cfe_cmd_dev_ioctl(cfe_devctx_t *ctx,cfe_iocb_t *iocb)
{
20003448:	b580      	push	{r7, lr}
2000344a:	b084      	sub	sp, #16
2000344c:	af00      	add	r7, sp, #0
2000344e:	6078      	str	r0, [r7, #4]
20003450:	6039      	str	r1, [r7, #0]
    int status;

    status = ctx->dev_dev->dev_dispatch->dev_ioctl(ctx,&(iocb->plist.iocb_buffer));
20003452:	687b      	ldr	r3, [r7, #4]
20003454:	681b      	ldr	r3, [r3, #0]
20003456:	695b      	ldr	r3, [r3, #20]
20003458:	691b      	ldr	r3, [r3, #16]
2000345a:	683a      	ldr	r2, [r7, #0]
2000345c:	3218      	adds	r2, #24
2000345e:	4611      	mov	r1, r2
20003460:	6878      	ldr	r0, [r7, #4]
20003462:	4798      	blx	r3
20003464:	60f8      	str	r0, [r7, #12]

    return status;
20003466:	68fb      	ldr	r3, [r7, #12]
}
20003468:	4618      	mov	r0, r3
2000346a:	3710      	adds	r7, #16
2000346c:	46bd      	mov	sp, r7
2000346e:	bd80      	pop	{r7, pc}

20003470 <cfe_cmd_dev_close>:

static int cfe_cmd_dev_close(cfe_devctx_t *ctx,cfe_iocb_t *iocb)
{
20003470:	b580      	push	{r7, lr}
20003472:	b082      	sub	sp, #8
20003474:	af00      	add	r7, sp, #0
20003476:	6078      	str	r0, [r7, #4]
20003478:	6039      	str	r1, [r7, #0]
    /*
     * Call device close function
     */

    ctx->dev_dev->dev_dispatch->dev_close(ctx);
2000347a:	687b      	ldr	r3, [r7, #4]
2000347c:	681b      	ldr	r3, [r3, #0]
2000347e:	695b      	ldr	r3, [r3, #20]
20003480:	695b      	ldr	r3, [r3, #20]
20003482:	6878      	ldr	r0, [r7, #4]
20003484:	4798      	blx	r3

    /*
     * Decrement refcnt
     */

    ctx->dev_dev->dev_opencount--;
20003486:	687b      	ldr	r3, [r7, #4]
20003488:	681b      	ldr	r3, [r3, #0]
2000348a:	699a      	ldr	r2, [r3, #24]
2000348c:	3a01      	subs	r2, #1
2000348e:	619a      	str	r2, [r3, #24]

    /*
     * Wipe out handle
     */

    cfe_handle_table[iocb->iocb_handle] = NULL;
20003490:	683b      	ldr	r3, [r7, #0]
20003492:	689b      	ldr	r3, [r3, #8]
20003494:	4a06      	ldr	r2, [pc, #24]	@ (200034b0 <cfe_cmd_dev_close+0x40>)
20003496:	2100      	movs	r1, #0
20003498:	f842 1023 	str.w	r1, [r2, r3, lsl #2]

    /*
     * Release device context
     */

    KFREE(ctx);
2000349c:	6879      	ldr	r1, [r7, #4]
2000349e:	4805      	ldr	r0, [pc, #20]	@ (200034b4 <cfe_cmd_dev_close+0x44>)
200034a0:	f7fd fde6 	bl	20001070 <kfree>

    return CFE_OK;
200034a4:	2300      	movs	r3, #0
}
200034a6:	4618      	mov	r0, r3
200034a8:	3708      	adds	r7, #8
200034aa:	46bd      	mov	sp, r7
200034ac:	bd80      	pop	{r7, pc}
200034ae:	bf00      	nop
200034b0:	2000932c 	.word	0x2000932c
200034b4:	200091fc 	.word	0x200091fc

200034b8 <cfe_cmd_dev_getinfo>:

static int cfe_cmd_dev_getinfo(cfe_devctx_t *ctx,cfe_iocb_t *iocb)
{
200034b8:	b580      	push	{r7, lr}
200034ba:	b094      	sub	sp, #80	@ 0x50
200034bc:	af00      	add	r7, sp, #0
200034be:	6078      	str	r0, [r7, #4]
200034c0:	6039      	str	r1, [r7, #0]

    /*
     * Get device name
     */

    hsgetstr(devname,iocb->plist.iocb_buffer.buf_ptr,sizeof(devname));
200034c2:	683b      	ldr	r3, [r7, #0]
200034c4:	6a19      	ldr	r1, [r3, #32]
200034c6:	f107 0308 	add.w	r3, r7, #8
200034ca:	2240      	movs	r2, #64	@ 0x40
200034cc:	4618      	mov	r0, r3
200034ce:	f7ff fd51 	bl	20002f74 <hsgetstr>

    /*
     * Find device in device table
     */

    if ((x = strchr(devname,':'))) *x = '\0';
200034d2:	f107 0308 	add.w	r3, r7, #8
200034d6:	213a      	movs	r1, #58	@ 0x3a
200034d8:	4618      	mov	r0, r3
200034da:	f7fe f83d 	bl	20001558 <lib_strchr>
200034de:	64f8      	str	r0, [r7, #76]	@ 0x4c
200034e0:	6cfb      	ldr	r3, [r7, #76]	@ 0x4c
200034e2:	2b00      	cmp	r3, #0
200034e4:	d002      	beq.n	200034ec <cfe_cmd_dev_getinfo+0x34>
200034e6:	6cfb      	ldr	r3, [r7, #76]	@ 0x4c
200034e8:	2200      	movs	r2, #0
200034ea:	701a      	strb	r2, [r3, #0]
    dev = cfe_finddev(devname);
200034ec:	f107 0308 	add.w	r3, r7, #8
200034f0:	4618      	mov	r0, r3
200034f2:	f7fe fa6b 	bl	200019cc <cfe_finddev>
200034f6:	64b8      	str	r0, [r7, #72]	@ 0x48
    if (!dev) return CFE_ERR_DEVNOTFOUND;
200034f8:	6cbb      	ldr	r3, [r7, #72]	@ 0x48
200034fa:	2b00      	cmp	r3, #0
200034fc:	d102      	bne.n	20003504 <cfe_cmd_dev_getinfo+0x4c>
200034fe:	f06f 0305 	mvn.w	r3, #5
20003502:	e005      	b.n	20003510 <cfe_cmd_dev_getinfo+0x58>

    /*
     * Return device class
     */

    iocb->plist.iocb_buffer.buf_devflags = dev->dev_class;
20003504:	6cbb      	ldr	r3, [r7, #72]	@ 0x48
20003506:	691b      	ldr	r3, [r3, #16]
20003508:	461a      	mov	r2, r3
2000350a:	683b      	ldr	r3, [r7, #0]
2000350c:	62da      	str	r2, [r3, #44]	@ 0x2c

    return CFE_OK;
2000350e:	2300      	movs	r3, #0
}
20003510:	4618      	mov	r0, r3
20003512:	3750      	adds	r7, #80	@ 0x50
20003514:	46bd      	mov	sp, r7
20003516:	bd80      	pop	{r7, pc}

20003518 <cfe_cmd_env_enum>:

static int cfe_cmd_env_enum(cfe_devctx_t *ctx,cfe_iocb_t *iocb)
{
20003518:	b590      	push	{r4, r7, lr}
2000351a:	b089      	sub	sp, #36	@ 0x24
2000351c:	af02      	add	r7, sp, #8
2000351e:	6078      	str	r0, [r7, #4]
20003520:	6039      	str	r1, [r7, #0]
    int vallen,namelen,res;

    namelen = iocb->plist.iocb_envbuf.name_length;
20003522:	683b      	ldr	r3, [r7, #0]
20003524:	6a1b      	ldr	r3, [r3, #32]
20003526:	60fb      	str	r3, [r7, #12]
    vallen  = iocb->plist.iocb_envbuf.val_length;
20003528:	683b      	ldr	r3, [r7, #0]
2000352a:	6a9b      	ldr	r3, [r3, #40]	@ 0x28
2000352c:	613b      	str	r3, [r7, #16]

    res = env_enum(iocb->plist.iocb_envbuf.enum_idx,
2000352e:	683b      	ldr	r3, [r7, #0]
20003530:	6998      	ldr	r0, [r3, #24]
		   (char *)iocb->plist.iocb_envbuf.name_ptr,
20003532:	683b      	ldr	r3, [r7, #0]
20003534:	69d9      	ldr	r1, [r3, #28]
		   &namelen,
		   (char *)iocb->plist.iocb_envbuf.val_ptr,
20003536:	683b      	ldr	r3, [r7, #0]
20003538:	6a5c      	ldr	r4, [r3, #36]	@ 0x24
    res = env_enum(iocb->plist.iocb_envbuf.enum_idx,
2000353a:	f107 020c 	add.w	r2, r7, #12
2000353e:	f107 0310 	add.w	r3, r7, #16
20003542:	9300      	str	r3, [sp, #0]
20003544:	4623      	mov	r3, r4
20003546:	f000 fac9 	bl	20003adc <env_enum>
2000354a:	6178      	str	r0, [r7, #20]
		   &vallen);

    if (res < 0) return CFE_ERR_ENVNOTFOUND;
2000354c:	697b      	ldr	r3, [r7, #20]
2000354e:	2b00      	cmp	r3, #0
20003550:	da02      	bge.n	20003558 <cfe_cmd_env_enum+0x40>
20003552:	f06f 0308 	mvn.w	r3, #8
20003556:	e000      	b.n	2000355a <cfe_cmd_env_enum+0x42>

    return CFE_OK;
20003558:	2300      	movs	r3, #0
}
2000355a:	4618      	mov	r0, r3
2000355c:	371c      	adds	r7, #28
2000355e:	46bd      	mov	sp, r7
20003560:	bd90      	pop	{r4, r7, pc}

20003562 <cfe_cmd_env_get>:


static int cfe_cmd_env_get(cfe_devctx_t *ctx,cfe_iocb_t *iocb)
{
20003562:	b580      	push	{r7, lr}
20003564:	b084      	sub	sp, #16
20003566:	af00      	add	r7, sp, #0
20003568:	6078      	str	r0, [r7, #4]
2000356a:	6039      	str	r1, [r7, #0]
    char *env;

    env = env_getenv((char *)iocb->plist.iocb_envbuf.name_ptr);
2000356c:	683b      	ldr	r3, [r7, #0]
2000356e:	69db      	ldr	r3, [r3, #28]
20003570:	4618      	mov	r0, r3
20003572:	f000 fb2b 	bl	20003bcc <env_getenv>
20003576:	60f8      	str	r0, [r7, #12]

    if (env == NULL) return CFE_ERR_ENVNOTFOUND;
20003578:	68fb      	ldr	r3, [r7, #12]
2000357a:	2b00      	cmp	r3, #0
2000357c:	d102      	bne.n	20003584 <cfe_cmd_env_get+0x22>
2000357e:	f06f 0308 	mvn.w	r3, #8
20003582:	e008      	b.n	20003596 <cfe_cmd_env_get+0x34>

    xstrncpy((char *)iocb->plist.iocb_envbuf.val_ptr,
20003584:	683b      	ldr	r3, [r7, #0]
20003586:	6a58      	ldr	r0, [r3, #36]	@ 0x24
20003588:	683b      	ldr	r3, [r7, #0]
2000358a:	6a9b      	ldr	r3, [r3, #40]	@ 0x28
2000358c:	461a      	mov	r2, r3
2000358e:	68f9      	ldr	r1, [r7, #12]
20003590:	f7fd ff5f 	bl	20001452 <lib_xstrncpy>
	     env,
	     iocb->plist.iocb_envbuf.val_length);

    return CFE_OK;
20003594:	2300      	movs	r3, #0
}
20003596:	4618      	mov	r0, r3
20003598:	3710      	adds	r7, #16
2000359a:	46bd      	mov	sp, r7
2000359c:	bd80      	pop	{r7, pc}

2000359e <cfe_cmd_env_set>:

static int cfe_cmd_env_set(cfe_devctx_t *ctx,cfe_iocb_t *iocb)
{
2000359e:	b580      	push	{r7, lr}
200035a0:	b084      	sub	sp, #16
200035a2:	af00      	add	r7, sp, #0
200035a4:	6078      	str	r0, [r7, #4]
200035a6:	6039      	str	r1, [r7, #0]
    int res;
    int flg;


    flg = (iocb->iocb_flags & CFE_FLG_ENV_PERMANENT) ? 
200035a8:	683b      	ldr	r3, [r7, #0]
200035aa:	68db      	ldr	r3, [r3, #12]
200035ac:	f003 0301 	and.w	r3, r3, #1
	ENV_FLG_NORMAL : ENV_FLG_BUILTIN;
200035b0:	2b00      	cmp	r3, #0
200035b2:	bf0c      	ite	eq
200035b4:	2301      	moveq	r3, #1
200035b6:	2300      	movne	r3, #0
200035b8:	b2db      	uxtb	r3, r3
    flg = (iocb->iocb_flags & CFE_FLG_ENV_PERMANENT) ? 
200035ba:	60bb      	str	r3, [r7, #8]

    res = env_setenv((char *)iocb->plist.iocb_envbuf.name_ptr,
200035bc:	683b      	ldr	r3, [r7, #0]
200035be:	69d8      	ldr	r0, [r3, #28]
		     (char *)iocb->plist.iocb_envbuf.val_ptr,
200035c0:	683b      	ldr	r3, [r7, #0]
200035c2:	6a5b      	ldr	r3, [r3, #36]	@ 0x24
    res = env_setenv((char *)iocb->plist.iocb_envbuf.name_ptr,
200035c4:	68ba      	ldr	r2, [r7, #8]
200035c6:	4619      	mov	r1, r3
200035c8:	f000 fb14 	bl	20003bf4 <env_setenv>
200035cc:	60f8      	str	r0, [r7, #12]
		     flg);

    if (res == 0) {
200035ce:	68fb      	ldr	r3, [r7, #12]
200035d0:	2b00      	cmp	r3, #0
200035d2:	d108      	bne.n	200035e6 <cfe_cmd_env_set+0x48>
	if (iocb->iocb_flags & CFE_FLG_ENV_PERMANENT) res = env_save();
200035d4:	683b      	ldr	r3, [r7, #0]
200035d6:	68db      	ldr	r3, [r3, #12]
200035d8:	f003 0301 	and.w	r3, r3, #1
200035dc:	2b00      	cmp	r3, #0
200035de:	d002      	beq.n	200035e6 <cfe_cmd_env_set+0x48>
200035e0:	f000 fb6c 	bl	20003cbc <env_save>
200035e4:	60f8      	str	r0, [r7, #12]
	}

    if (res < 0) return res;
200035e6:	68fb      	ldr	r3, [r7, #12]
200035e8:	2b00      	cmp	r3, #0
200035ea:	da01      	bge.n	200035f0 <cfe_cmd_env_set+0x52>
200035ec:	68fb      	ldr	r3, [r7, #12]
200035ee:	e000      	b.n	200035f2 <cfe_cmd_env_set+0x54>

    return CFE_OK;
200035f0:	2300      	movs	r3, #0
}
200035f2:	4618      	mov	r0, r3
200035f4:	3710      	adds	r7, #16
200035f6:	46bd      	mov	sp, r7
200035f8:	bd80      	pop	{r7, pc}

200035fa <cfe_cmd_env_del>:

static int cfe_cmd_env_del(cfe_devctx_t *ctx,cfe_iocb_t *iocb)
{
200035fa:	b580      	push	{r7, lr}
200035fc:	b084      	sub	sp, #16
200035fe:	af00      	add	r7, sp, #0
20003600:	6078      	str	r0, [r7, #4]
20003602:	6039      	str	r1, [r7, #0]
    int res;
    int type;
    
    type = env_envtype((char *)iocb->plist.iocb_envbuf.name_ptr);
20003604:	683b      	ldr	r3, [r7, #0]
20003606:	69db      	ldr	r3, [r3, #28]
20003608:	4618      	mov	r0, r3
2000360a:	f000 faa7 	bl	20003b5c <env_envtype>
2000360e:	60f8      	str	r0, [r7, #12]

    /* 
     * Make sure we remove from NVRAM device, if it's there.
     */
    if ((res = env_delenv((char *)iocb->plist.iocb_envbuf.name_ptr)) == 0 ) {
20003610:	683b      	ldr	r3, [r7, #0]
20003612:	69db      	ldr	r3, [r3, #28]
20003614:	4618      	mov	r0, r3
20003616:	f000 fab5 	bl	20003b84 <env_delenv>
2000361a:	60b8      	str	r0, [r7, #8]
2000361c:	68bb      	ldr	r3, [r7, #8]
2000361e:	2b00      	cmp	r3, #0
20003620:	d107      	bne.n	20003632 <cfe_cmd_env_del+0x38>
	if ((type >= 0) && (type != ENV_FLG_BUILTIN)) env_save();
20003622:	68fb      	ldr	r3, [r7, #12]
20003624:	2b00      	cmp	r3, #0
20003626:	db04      	blt.n	20003632 <cfe_cmd_env_del+0x38>
20003628:	68fb      	ldr	r3, [r7, #12]
2000362a:	2b01      	cmp	r3, #1
2000362c:	d001      	beq.n	20003632 <cfe_cmd_env_del+0x38>
2000362e:	f000 fb45 	bl	20003cbc <env_save>
	}

    return res;
20003632:	68bb      	ldr	r3, [r7, #8]
}
20003634:	4618      	mov	r0, r3
20003636:	3710      	adds	r7, #16
20003638:	46bd      	mov	sp, r7
2000363a:	bd80      	pop	{r7, pc}

2000363c <cfe_setup_default_env>:
    ********************************************************************* */

uint32_t mem_totalsize = 0x1000000;

static void cfe_setup_default_env(void)
{
2000363c:	b580      	push	{r7, lr}
2000363e:	b096      	sub	sp, #88	@ 0x58
20003640:	af02      	add	r7, sp, #8
    char buffer[80];

    xsprintf(buffer,"%s%d.%d.%d",CFE_VER_PREFIX,CFE_VER_MAJOR,CFE_VER_MINOR,CFE_VER_BUILD);
20003642:	4638      	mov	r0, r7
20003644:	2302      	movs	r3, #2
20003646:	9301      	str	r3, [sp, #4]
20003648:	2301      	movs	r3, #1
2000364a:	9300      	str	r3, [sp, #0]
2000364c:	2300      	movs	r3, #0
2000364e:	4a13      	ldr	r2, [pc, #76]	@ (2000369c <cfe_setup_default_env+0x60>)
20003650:	4913      	ldr	r1, [pc, #76]	@ (200036a0 <cfe_setup_default_env+0x64>)
20003652:	f7fd fb71 	bl	20000d38 <xsprintf>
    env_setenv("CFE_VERSION",buffer,ENV_FLG_BUILTIN | ENV_FLG_READONLY);
20003656:	463b      	mov	r3, r7
20003658:	2203      	movs	r2, #3
2000365a:	4619      	mov	r1, r3
2000365c:	4811      	ldr	r0, [pc, #68]	@ (200036a4 <cfe_setup_default_env+0x68>)
2000365e:	f000 fac9 	bl	20003bf4 <env_setenv>

    if (cfe_boardname) {
20003662:	4b11      	ldr	r3, [pc, #68]	@ (200036a8 <cfe_setup_default_env+0x6c>)
20003664:	681b      	ldr	r3, [r3, #0]
20003666:	2b00      	cmp	r3, #0
20003668:	d006      	beq.n	20003678 <cfe_setup_default_env+0x3c>
	env_setenv("CFE_BOARDNAME",(char *) cfe_boardname,
2000366a:	4b0f      	ldr	r3, [pc, #60]	@ (200036a8 <cfe_setup_default_env+0x6c>)
2000366c:	681b      	ldr	r3, [r3, #0]
2000366e:	2203      	movs	r2, #3
20003670:	4619      	mov	r1, r3
20003672:	480e      	ldr	r0, [pc, #56]	@ (200036ac <cfe_setup_default_env+0x70>)
20003674:	f000 fabe 	bl	20003bf4 <env_setenv>
		   ENV_FLG_BUILTIN | ENV_FLG_READONLY);
	}

    xsprintf(buffer,"%d",mem_totalsize);
20003678:	4b0d      	ldr	r3, [pc, #52]	@ (200036b0 <cfe_setup_default_env+0x74>)
2000367a:	681a      	ldr	r2, [r3, #0]
2000367c:	463b      	mov	r3, r7
2000367e:	490d      	ldr	r1, [pc, #52]	@ (200036b4 <cfe_setup_default_env+0x78>)
20003680:	4618      	mov	r0, r3
20003682:	f7fd fb59 	bl	20000d38 <xsprintf>
    env_setenv("CFE_MEMORYSIZE",buffer,ENV_FLG_BUILTIN | ENV_FLG_READONLY);
20003686:	463b      	mov	r3, r7
20003688:	2203      	movs	r2, #3
2000368a:	4619      	mov	r1, r3
2000368c:	480a      	ldr	r0, [pc, #40]	@ (200036b8 <cfe_setup_default_env+0x7c>)
2000368e:	f000 fab1 	bl	20003bf4 <env_setenv>

}
20003692:	bf00      	nop
20003694:	3750      	adds	r7, #80	@ 0x50
20003696:	46bd      	mov	sp, r7
20003698:	bd80      	pop	{r7, pc}
2000369a:	bf00      	nop
2000369c:	20007ad8 	.word	0x20007ad8
200036a0:	20007adc 	.word	0x20007adc
200036a4:	20007ae8 	.word	0x20007ae8
200036a8:	200091d0 	.word	0x200091d0
200036ac:	20007af4 	.word	0x20007af4
200036b0:	200091d4 	.word	0x200091d4
200036b4:	20007b04 	.word	0x20007b04
200036b8:	20007b08 	.word	0x20007b08

200036bc <cfe_init_ui>:
#else
#define OPTIONAL(x) x
#endif

static void cfe_init_ui(void)
{
200036bc:	b580      	push	{r7, lr}
200036be:	af00      	add	r7, sp, #0
    ui_init_cmddisp();
200036c0:	f000 fb9a 	bl	20003df8 <ui_init_cmddisp>



  //  OPTIONAL(ui_init_examcmds());

    OPTIONAL(ui_init_misccmds());
200036c4:	f002 fe0c 	bl	200062e0 <ui_init_misccmds>
    OPTIONAL(ui_init_examcmds());
200036c8:	f002 fda0 	bl	2000620c <ui_init_examcmds>
}
200036cc:	bf00      	nop
200036ce:	bd80      	pop	{r7, pc}

200036d0 <cfe_leds>:
    *  Return value:
    *  	   nothing
    ********************************************************************* */

void cfe_leds(unsigned int val)
{
200036d0:	b480      	push	{r7}
200036d2:	b083      	sub	sp, #12
200036d4:	af00      	add	r7, sp, #0
200036d6:	6078      	str	r0, [r7, #4]

}
200036d8:	bf00      	nop
200036da:	370c      	adds	r7, #12
200036dc:	46bd      	mov	sp, r7
200036de:	f85d 7b04 	ldr.w	r7, [sp], #4
200036e2:	4770      	bx	lr

200036e4 <cfe_ledstr>:
void cfe_ledstr(const char *leds)
{
200036e4:	b580      	push	{r7, lr}
200036e6:	b084      	sub	sp, #16
200036e8:	af00      	add	r7, sp, #0
200036ea:	6078      	str	r0, [r7, #4]
    unsigned int val;

    val = ((((unsigned int) leds[0]) << 24) |
200036ec:	687b      	ldr	r3, [r7, #4]
200036ee:	781b      	ldrb	r3, [r3, #0]
200036f0:	061a      	lsls	r2, r3, #24
	   (((unsigned int) leds[1]) << 16) |
200036f2:	687b      	ldr	r3, [r7, #4]
200036f4:	3301      	adds	r3, #1
200036f6:	781b      	ldrb	r3, [r3, #0]
200036f8:	041b      	lsls	r3, r3, #16
    val = ((((unsigned int) leds[0]) << 24) |
200036fa:	431a      	orrs	r2, r3
	   (((unsigned int) leds[2]) << 8) |
200036fc:	687b      	ldr	r3, [r7, #4]
200036fe:	3302      	adds	r3, #2
20003700:	781b      	ldrb	r3, [r3, #0]
20003702:	021b      	lsls	r3, r3, #8
	   (((unsigned int) leds[1]) << 16) |
20003704:	4313      	orrs	r3, r2
	   ((unsigned int) leds[3]));
20003706:	687a      	ldr	r2, [r7, #4]
20003708:	3203      	adds	r2, #3
2000370a:	7812      	ldrb	r2, [r2, #0]
    val = ((((unsigned int) leds[0]) << 24) |
2000370c:	4313      	orrs	r3, r2
2000370e:	60fb      	str	r3, [r7, #12]

    cfe_leds(val);
20003710:	68f8      	ldr	r0, [r7, #12]
20003712:	f7ff ffdd 	bl	200036d0 <cfe_leds>
}
20003716:	bf00      	nop
20003718:	3710      	adds	r7, #16
2000371a:	46bd      	mov	sp, r7
2000371c:	bd80      	pop	{r7, pc}
	...

20003720 <cfe_say_hello>:
    *  	   nothing
    ********************************************************************* */


static void cfe_say_hello(void)
{
20003720:	b580      	push	{r7, lr}
20003722:	af00      	add	r7, sp, #0

    printf("Copyright (C) 2000,2001,2002,2003,2004,2005 Broadcom Corporation.\n");
20003724:	4803      	ldr	r0, [pc, #12]	@ (20003734 <cfe_say_hello+0x14>)
20003726:	f7fd fb1d 	bl	20000d64 <printf>
    printf("\n");
2000372a:	4803      	ldr	r0, [pc, #12]	@ (20003738 <cfe_say_hello+0x18>)
2000372c:	f7fd fb1a 	bl	20000d64 <printf>
}
20003730:	bf00      	nop
20003732:	bd80      	pop	{r7, pc}
20003734:	20007b18 	.word	0x20007b18
20003738:	20007b5c 	.word	0x20007b5c

2000373c <cfe_startup_info>:
#define RELOCTEXT(x) ((x)-mem_textreloc)
#define RELOCDATA(x) ((x)-mem_datareloc)
#endif

static void cfe_startup_info(void)
{
2000373c:	b480      	push	{r7}
2000373e:	af00      	add	r7, sp, #0

}
20003740:	bf00      	nop
20003742:	46bd      	mov	sp, r7
20003744:	f85d 7b04 	ldr.w	r7, [sp], #4
20003748:	4770      	bx	lr
	...

2000374c <cfe_main>:
    *  Return value:
    *  	   does not return
    ********************************************************************* */

void cfe_main(int a,int b)
{
2000374c:	b580      	push	{r7, lr}
2000374e:	b082      	sub	sp, #8
20003750:	af00      	add	r7, sp, #0
20003752:	6078      	str	r0, [r7, #4]
20003754:	6039      	str	r1, [r7, #0]
     * 4. BSS has been zeroed.
     * 5. The data has been moved to R/W space.
     * 6. The "C" Stack has been initialized.
     */

    cfe_cpu_speed = 1000;
20003756:	4b21      	ldr	r3, [pc, #132]	@ (200037dc <cfe_main+0x90>)
20003758:	f44f 727a 	mov.w	r2, #1000	@ 0x3e8
2000375c:	601a      	str	r2, [r3, #0]
    printf("Initializing Arena.\n");
2000375e:	4820      	ldr	r0, [pc, #128]	@ (200037e0 <cfe_main+0x94>)
20003760:	f7fd fb00 	bl	20000d64 <printf>

    cfe_bg_init();		       		/* init background processing */
20003764:	f7fe fa28 	bl	20001bb8 <cfe_bg_init>
    cfe_attach_init();
20003768:	f7fe fa16 	bl	20001b98 <cfe_attach_init>
    cfe_timer_init(cfe_cpu_speed);		/* Timer process */
2000376c:	4b1b      	ldr	r3, [pc, #108]	@ (200037dc <cfe_main+0x90>)
2000376e:	681b      	ldr	r3, [r3, #0]
20003770:	4618      	mov	r0, r3
20003772:	f000 f933 	bl	200039dc <cfe_timer_init>
    /*
     * Initialize the memory allocator
     */

    extern uintptr_t _ebss;
    SETLEDS("KMEM");
20003776:	481b      	ldr	r0, [pc, #108]	@ (200037e4 <cfe_main+0x98>)
20003778:	f7ff ffb4 	bl	200036e4 <cfe_ledstr>
    KMEMINIT((unsigned char *) (uintptr_t) &_ebss,
2000377c:	f44f 3280 	mov.w	r2, #65536	@ 0x10000
20003780:	4919      	ldr	r1, [pc, #100]	@ (200037e8 <cfe_main+0x9c>)
20003782:	481a      	ldr	r0, [pc, #104]	@ (200037ec <cfe_main+0xa0>)
20003784:	f7fd fc02 	bl	20000f8c <kmeminit>
     * Initialize the console.  It is done before the other devices
     * get turned on.  The console init also sets the variable that
     * contains the CPU speed.
     */

    SETLEDS("CONS");
20003788:	4819      	ldr	r0, [pc, #100]	@ (200037f0 <cfe_main+0xa4>)
2000378a:	f7ff ffab 	bl	200036e4 <cfe_ledstr>

    board_init();
2000378e:	f7fd fbeb 	bl	20000f68 <board_init>

    /*
     * Say hello.
     */

    SETLEDS("CIOK");
20003792:	4818      	ldr	r0, [pc, #96]	@ (200037f4 <cfe_main+0xa8>)
20003794:	f7ff ffa6 	bl	200036e4 <cfe_ledstr>
    cfe_say_hello();
20003798:	f7ff ffc2 	bl	20003720 <cfe_say_hello>

    /*
     * Initialize the other devices.
     */

    SETLEDS("AREN");
2000379c:	4816      	ldr	r0, [pc, #88]	@ (200037f8 <cfe_main+0xac>)
2000379e:	f7ff ffa1 	bl	200036e4 <cfe_ledstr>
    printf("Initializing Arena.\n");
200037a2:	480f      	ldr	r0, [pc, #60]	@ (200037e0 <cfe_main+0x94>)
200037a4:	f7fd fade 	bl	20000d64 <printf>
    cfe_arena_init();
200037a8:	f000 f864 	bl	20003874 <cfe_arena_init>


    SETLEDS("DEVI");
200037ac:	4813      	ldr	r0, [pc, #76]	@ (200037fc <cfe_main+0xb0>)
200037ae:	f7ff ff99 	bl	200036e4 <cfe_ledstr>
    printf("Initializing Devices.\n");
200037b2:	4813      	ldr	r0, [pc, #76]	@ (20003800 <cfe_main+0xb4>)
200037b4:	f7fd fad6 	bl	20000d64 <printf>
  //  board_device_init();

    cfe_startup_info();
200037b8:	f7ff ffc0 	bl	2000373c <cfe_startup_info>
    SETLEDS("ENVI");
200037bc:	4811      	ldr	r0, [pc, #68]	@ (20003804 <cfe_main+0xb8>)
200037be:	f7ff ff91 	bl	200036e4 <cfe_ledstr>
    cfe_setup_default_env();
200037c2:	f7ff ff3b 	bl	2000363c <cfe_setup_default_env>

    printf("\n");
200037c6:	4810      	ldr	r0, [pc, #64]	@ (20003808 <cfe_main+0xbc>)
200037c8:	f7fd facc 	bl	20000d64 <printf>


    cfe_init_ui();
200037cc:	f7ff ff76 	bl	200036bc <cfe_init_ui>

  //  board_final_init();


   // cfe_autostart();
    cfe_command_loop();
200037d0:	f000 f81c 	bl	2000380c <cfe_command_loop>

}
200037d4:	bf00      	nop
200037d6:	3708      	adds	r7, #8
200037d8:	46bd      	mov	sp, r7
200037da:	bd80      	pop	{r7, pc}
200037dc:	20009458 	.word	0x20009458
200037e0:	20007b68 	.word	0x20007b68
200037e4:	20007b80 	.word	0x20007b80
200037e8:	2000947c 	.word	0x2000947c
200037ec:	200091fc 	.word	0x200091fc
200037f0:	20007b88 	.word	0x20007b88
200037f4:	20007b90 	.word	0x20007b90
200037f8:	20007b98 	.word	0x20007b98
200037fc:	20007ba0 	.word	0x20007ba0
20003800:	20007ba8 	.word	0x20007ba8
20003804:	20007bc0 	.word	0x20007bc0
20003808:	20007b5c 	.word	0x20007b5c

2000380c <cfe_command_loop>:
    *  Return value:
    *  	   does not return
    ********************************************************************* */

void cfe_command_loop()
{
2000380c:	b580      	push	{r7, lr}
2000380e:	b0ce      	sub	sp, #312	@ 0x138
20003810:	af00      	add	r7, sp, #0

    char buffer[300];
    int status;
    char *prompt;

    SETLEDS("CFE ");
20003812:	4814      	ldr	r0, [pc, #80]	@ (20003864 <cfe_command_loop+0x58>)
20003814:	f7ff ff66 	bl	200036e4 <cfe_ledstr>

    for (;;) {
	prompt = env_getenv("PROMPT");
20003818:	4813      	ldr	r0, [pc, #76]	@ (20003868 <cfe_command_loop+0x5c>)
2000381a:	f000 f9d7 	bl	20003bcc <env_getenv>
2000381e:	f8c7 0134 	str.w	r0, [r7, #308]	@ 0x134

	if (!prompt) prompt = "CFE> ";
20003822:	f8d7 3134 	ldr.w	r3, [r7, #308]	@ 0x134
20003826:	2b00      	cmp	r3, #0
20003828:	d102      	bne.n	20003830 <cfe_command_loop+0x24>
2000382a:	4b10      	ldr	r3, [pc, #64]	@ (2000386c <cfe_command_loop+0x60>)
2000382c:	f8c7 3134 	str.w	r3, [r7, #308]	@ 0x134

	console_readline(prompt,buffer,sizeof(buffer));
20003830:	1d3b      	adds	r3, r7, #4
20003832:	f44f 7296 	mov.w	r2, #300	@ 0x12c
20003836:	4619      	mov	r1, r3
20003838:	f8d7 0134 	ldr.w	r0, [r7, #308]	@ 0x134
2000383c:	f7ff fa44 	bl	20002cc8 <console_readline>

	status = ui_docommands(buffer);
20003840:	1d3b      	adds	r3, r7, #4
20003842:	4618      	mov	r0, r3
20003844:	f000 fb54 	bl	20003ef0 <ui_docommands>
20003848:	f8c7 0130 	str.w	r0, [r7, #304]	@ 0x130

	if (status != CMD_ERR_BLANK) {
2000384c:	f8d7 3130 	ldr.w	r3, [r7, #304]	@ 0x130
20003850:	f113 0f03 	cmn.w	r3, #3
20003854:	d0e0      	beq.n	20003818 <cfe_command_loop+0xc>
	    printf("*** command status = %d\n", status);
20003856:	f8d7 1130 	ldr.w	r1, [r7, #304]	@ 0x130
2000385a:	4805      	ldr	r0, [pc, #20]	@ (20003870 <cfe_command_loop+0x64>)
2000385c:	f7fd fa82 	bl	20000d64 <printf>
	prompt = env_getenv("PROMPT");
20003860:	e7da      	b.n	20003818 <cfe_command_loop+0xc>
20003862:	bf00      	nop
20003864:	20007be8 	.word	0x20007be8
20003868:	20007bf0 	.word	0x20007bf0
2000386c:	20007bf8 	.word	0x20007bf8
20003870:	20007c00 	.word	0x20007c00

20003874 <cfe_arena_init>:
    *  Return value:
    *  	   nothing
    ********************************************************************* */

void cfe_arena_init(void)
{
20003874:	b480      	push	{r7}
20003876:	af00      	add	r7, sp, #0
    //memlo = PHYSADDR(mem_bottomofmem) & ~4095;




}
20003878:	bf00      	nop
2000387a:	46bd      	mov	sp, r7
2000387c:	f85d 7b04 	ldr.w	r7, [sp], #4
20003880:	4770      	bx	lr
	...

20003884 <cfe_arena_enum>:
    *  	   0 if ok
    *  	   CFE_ERR_NOMORE if idx is beyond the last entry
    ********************************************************************* */

int cfe_arena_enum(int idx,int *type,uint64_t *start,uint64_t *size,int allrecs)
{
20003884:	b480      	push	{r7}
20003886:	b089      	sub	sp, #36	@ 0x24
20003888:	af00      	add	r7, sp, #0
2000388a:	60f8      	str	r0, [r7, #12]
2000388c:	60b9      	str	r1, [r7, #8]
2000388e:	607a      	str	r2, [r7, #4]
20003890:	603b      	str	r3, [r7, #0]
    arena_node_t *node;
    queue_t *qb;
    arena_t *arena = &cfe_arena;
20003892:	4b1c      	ldr	r3, [pc, #112]	@ (20003904 <cfe_arena_enum+0x80>)
20003894:	61bb      	str	r3, [r7, #24]


    for (qb = (arena->arena_list.q_next); qb != &(arena->arena_list);
20003896:	69bb      	ldr	r3, [r7, #24]
20003898:	681b      	ldr	r3, [r3, #0]
2000389a:	61fb      	str	r3, [r7, #28]
2000389c:	e026      	b.n	200038ec <cfe_arena_enum+0x68>
	 qb = qb->q_next) {
	node = (arena_node_t *) qb;
2000389e:	69fb      	ldr	r3, [r7, #28]
200038a0:	617b      	str	r3, [r7, #20]

	if (allrecs || (!allrecs && (node->an_type == MEMTYPE_DRAM_AVAILABLE))) {
200038a2:	6abb      	ldr	r3, [r7, #40]	@ 0x28
200038a4:	2b00      	cmp	r3, #0
200038a6:	d106      	bne.n	200038b6 <cfe_arena_enum+0x32>
200038a8:	6abb      	ldr	r3, [r7, #40]	@ 0x28
200038aa:	2b00      	cmp	r3, #0
200038ac:	d11b      	bne.n	200038e6 <cfe_arena_enum+0x62>
200038ae:	697b      	ldr	r3, [r7, #20]
200038b0:	699b      	ldr	r3, [r3, #24]
200038b2:	2b01      	cmp	r3, #1
200038b4:	d117      	bne.n	200038e6 <cfe_arena_enum+0x62>
	    if (idx == 0) {
200038b6:	68fb      	ldr	r3, [r7, #12]
200038b8:	2b00      	cmp	r3, #0
200038ba:	d111      	bne.n	200038e0 <cfe_arena_enum+0x5c>
		*type = node->an_type;
200038bc:	697b      	ldr	r3, [r7, #20]
200038be:	699a      	ldr	r2, [r3, #24]
200038c0:	68bb      	ldr	r3, [r7, #8]
200038c2:	601a      	str	r2, [r3, #0]
		*start = node->an_address;
200038c4:	697b      	ldr	r3, [r7, #20]
200038c6:	e9d3 2302 	ldrd	r2, r3, [r3, #8]
200038ca:	6879      	ldr	r1, [r7, #4]
200038cc:	e9c1 2300 	strd	r2, r3, [r1]
		*size = node->an_length;
200038d0:	697b      	ldr	r3, [r7, #20]
200038d2:	e9d3 2304 	ldrd	r2, r3, [r3, #16]
200038d6:	6839      	ldr	r1, [r7, #0]
200038d8:	e9c1 2300 	strd	r2, r3, [r1]
		return 0;
200038dc:	2300      	movs	r3, #0
200038de:	e00b      	b.n	200038f8 <cfe_arena_enum+0x74>
		}
	    idx--;
200038e0:	68fb      	ldr	r3, [r7, #12]
200038e2:	3b01      	subs	r3, #1
200038e4:	60fb      	str	r3, [r7, #12]
	 qb = qb->q_next) {
200038e6:	69fb      	ldr	r3, [r7, #28]
200038e8:	681b      	ldr	r3, [r3, #0]
200038ea:	61fb      	str	r3, [r7, #28]
    for (qb = (arena->arena_list.q_next); qb != &(arena->arena_list);
200038ec:	69bb      	ldr	r3, [r7, #24]
200038ee:	69fa      	ldr	r2, [r7, #28]
200038f0:	429a      	cmp	r2, r3
200038f2:	d1d4      	bne.n	2000389e <cfe_arena_enum+0x1a>
	    }
	}

    return CFE_ERR_NOMORE;
200038f4:	f06f 031b 	mvn.w	r3, #27

}
200038f8:	4618      	mov	r0, r3
200038fa:	3724      	adds	r7, #36	@ 0x24
200038fc:	46bd      	mov	sp, r7
200038fe:	f85d 7b04 	ldr.w	r7, [sp], #4
20003902:	4770      	bx	lr
20003904:	20009430 	.word	0x20009430

20003908 <_getticks>:
    *  Return value:
    *  	   nothing
    ********************************************************************* */

uint32_t _getticks()
{
20003908:	b480      	push	{r7}
2000390a:	af00      	add	r7, sp, #0
	return 1000;
2000390c:	f44f 737a 	mov.w	r3, #1000	@ 0x3e8
}
20003910:	4618      	mov	r0, r3
20003912:	46bd      	mov	sp, r7
20003914:	f85d 7b04 	ldr.w	r7, [sp], #4
20003918:	4770      	bx	lr
	...

2000391c <cfe_timer_task>:
static void cfe_timer_task(void *arg)
{
2000391c:	e92d 4fb0 	stmdb	sp!, {r4, r5, r7, r8, r9, sl, fp, lr}
20003920:	b086      	sub	sp, #24
20003922:	af00      	add	r7, sp, #0
20003924:	6078      	str	r0, [r7, #4]
    uint32_t count;
    uint32_t deltaticks;
    uint32_t clockspertick;

    clockspertick = cfe_clocks_per_tick;
20003926:	4b29      	ldr	r3, [pc, #164]	@ (200039cc <cfe_timer_task+0xb0>)
20003928:	681b      	ldr	r3, [r3, #0]
2000392a:	617b      	str	r3, [r7, #20]

    count = _getticks();
2000392c:	f7ff ffec 	bl	20003908 <_getticks>
20003930:	6138      	str	r0, [r7, #16]
    deltaticks    = (count - cfe_oldcount);
20003932:	4b27      	ldr	r3, [pc, #156]	@ (200039d0 <cfe_timer_task+0xb4>)
20003934:	681b      	ldr	r3, [r3, #0]
20003936:	693a      	ldr	r2, [r7, #16]
20003938:	1ad3      	subs	r3, r2, r3
2000393a:	60fb      	str	r3, [r7, #12]
    cfe_remticks += deltaticks;
2000393c:	4b25      	ldr	r3, [pc, #148]	@ (200039d4 <cfe_timer_task+0xb8>)
2000393e:	681a      	ldr	r2, [r3, #0]
20003940:	68fb      	ldr	r3, [r7, #12]
20003942:	4413      	add	r3, r2
20003944:	4a23      	ldr	r2, [pc, #140]	@ (200039d4 <cfe_timer_task+0xb8>)
20003946:	6013      	str	r3, [r2, #0]
     * assume it only moved by one tick and use a simple
     * loop to update it.  This loop probably will not
     * execute more than once.
     */

    if (cfe_remticks > (clockspertick << 4)) {
20003948:	697b      	ldr	r3, [r7, #20]
2000394a:	011a      	lsls	r2, r3, #4
2000394c:	4b21      	ldr	r3, [pc, #132]	@ (200039d4 <cfe_timer_task+0xb8>)
2000394e:	681b      	ldr	r3, [r3, #0]
20003950:	429a      	cmp	r2, r3
20003952:	d22d      	bcs.n	200039b0 <cfe_timer_task+0x94>
        cfe_ticks += (cfe_remticks / clockspertick);
20003954:	4b1f      	ldr	r3, [pc, #124]	@ (200039d4 <cfe_timer_task+0xb8>)
20003956:	681a      	ldr	r2, [r3, #0]
20003958:	697b      	ldr	r3, [r7, #20]
2000395a:	fbb2 f3f3 	udiv	r3, r2, r3
2000395e:	2200      	movs	r2, #0
20003960:	461c      	mov	r4, r3
20003962:	4615      	mov	r5, r2
20003964:	4b1c      	ldr	r3, [pc, #112]	@ (200039d8 <cfe_timer_task+0xbc>)
20003966:	e9d3 2300 	ldrd	r2, r3, [r3]
2000396a:	eb14 0a02 	adds.w	sl, r4, r2
2000396e:	eb45 0b03 	adc.w	fp, r5, r3
20003972:	4b19      	ldr	r3, [pc, #100]	@ (200039d8 <cfe_timer_task+0xbc>)
20003974:	e9c3 ab00 	strd	sl, fp, [r3]
        cfe_remticks %= clockspertick;
20003978:	4b16      	ldr	r3, [pc, #88]	@ (200039d4 <cfe_timer_task+0xb8>)
2000397a:	681b      	ldr	r3, [r3, #0]
2000397c:	697a      	ldr	r2, [r7, #20]
2000397e:	fbb3 f2f2 	udiv	r2, r3, r2
20003982:	6979      	ldr	r1, [r7, #20]
20003984:	fb01 f202 	mul.w	r2, r1, r2
20003988:	1a9b      	subs	r3, r3, r2
2000398a:	4a12      	ldr	r2, [pc, #72]	@ (200039d4 <cfe_timer_task+0xb8>)
2000398c:	6013      	str	r3, [r2, #0]
2000398e:	e014      	b.n	200039ba <cfe_timer_task+0x9e>
        }
    else {
        while (cfe_remticks > clockspertick) {
            cfe_remticks -= clockspertick;
20003990:	4b10      	ldr	r3, [pc, #64]	@ (200039d4 <cfe_timer_task+0xb8>)
20003992:	681a      	ldr	r2, [r3, #0]
20003994:	697b      	ldr	r3, [r7, #20]
20003996:	1ad3      	subs	r3, r2, r3
20003998:	4a0e      	ldr	r2, [pc, #56]	@ (200039d4 <cfe_timer_task+0xb8>)
2000399a:	6013      	str	r3, [r2, #0]
            cfe_ticks++;
2000399c:	4b0e      	ldr	r3, [pc, #56]	@ (200039d8 <cfe_timer_task+0xbc>)
2000399e:	e9d3 2300 	ldrd	r2, r3, [r3]
200039a2:	f112 0801 	adds.w	r8, r2, #1
200039a6:	f143 0900 	adc.w	r9, r3, #0
200039aa:	4b0b      	ldr	r3, [pc, #44]	@ (200039d8 <cfe_timer_task+0xbc>)
200039ac:	e9c3 8900 	strd	r8, r9, [r3]
        while (cfe_remticks > clockspertick) {
200039b0:	4b08      	ldr	r3, [pc, #32]	@ (200039d4 <cfe_timer_task+0xb8>)
200039b2:	681b      	ldr	r3, [r3, #0]
200039b4:	697a      	ldr	r2, [r7, #20]
200039b6:	429a      	cmp	r2, r3
200039b8:	d3ea      	bcc.n	20003990 <cfe_timer_task+0x74>
            }
        }

    cfe_oldcount = count;
200039ba:	4a05      	ldr	r2, [pc, #20]	@ (200039d0 <cfe_timer_task+0xb4>)
200039bc:	693b      	ldr	r3, [r7, #16]
200039be:	6013      	str	r3, [r2, #0]
}
200039c0:	bf00      	nop
200039c2:	3718      	adds	r7, #24
200039c4:	46bd      	mov	sp, r7
200039c6:	e8bd 8fb0 	ldmia.w	sp!, {r4, r5, r7, r8, r9, sl, fp, pc}
200039ca:	bf00      	nop
200039cc:	20009464 	.word	0x20009464
200039d0:	20009468 	.word	0x20009468
200039d4:	2000946c 	.word	0x2000946c
200039d8:	20009450 	.word	0x20009450

200039dc <cfe_timer_init>:
    *  Return value:
    *  	   nothing
    ********************************************************************* */

void cfe_timer_init(unsigned int cpu_speed)
{
200039dc:	b580      	push	{r7, lr}
200039de:	b082      	sub	sp, #8
200039e0:	af00      	add	r7, sp, #0
200039e2:	6078      	str	r0, [r7, #4]
    cfe_clocks_per_tick = CFE_CLOCKSPERTICK(cpu_speed);
200039e4:	687b      	ldr	r3, [r7, #4]
200039e6:	4a1e      	ldr	r2, [pc, #120]	@ (20003a60 <cfe_timer_init+0x84>)
200039e8:	fba2 2303 	umull	r2, r3, r2, r3
200039ec:	08db      	lsrs	r3, r3, #3
200039ee:	4a1d      	ldr	r2, [pc, #116]	@ (20003a64 <cfe_timer_init+0x88>)
200039f0:	6013      	str	r3, [r2, #0]
    cfe_clocks_per_Kns = CFE_CLOCKSPERKNS(cpu_speed);
200039f2:	687b      	ldr	r3, [r7, #4]
200039f4:	4a1c      	ldr	r2, [pc, #112]	@ (20003a68 <cfe_timer_init+0x8c>)
200039f6:	fba2 2303 	umull	r2, r3, r2, r3
200039fa:	0cdb      	lsrs	r3, r3, #19
200039fc:	4a1b      	ldr	r2, [pc, #108]	@ (20003a6c <cfe_timer_init+0x90>)
200039fe:	6013      	str	r3, [r2, #0]
    if (cfe_clocks_per_Kns == 0)
20003a00:	4b1a      	ldr	r3, [pc, #104]	@ (20003a6c <cfe_timer_init+0x90>)
20003a02:	681b      	ldr	r3, [r3, #0]
20003a04:	2b00      	cmp	r3, #0
20003a06:	d102      	bne.n	20003a0e <cfe_timer_init+0x32>
	cfe_clocks_per_Kns = 1;    /* for the simulator */
20003a08:	4b18      	ldr	r3, [pc, #96]	@ (20003a6c <cfe_timer_init+0x90>)
20003a0a:	2201      	movs	r2, #1
20003a0c:	601a      	str	r2, [r3, #0]
    cfe_clocks_per_usec = CFE_CLOCKSPERUSEC(cpu_speed);
20003a0e:	687b      	ldr	r3, [r7, #4]
20003a10:	4a17      	ldr	r2, [pc, #92]	@ (20003a70 <cfe_timer_init+0x94>)
20003a12:	fba2 2303 	umull	r2, r3, r2, r3
20003a16:	0c9b      	lsrs	r3, r3, #18
20003a18:	4a16      	ldr	r2, [pc, #88]	@ (20003a74 <cfe_timer_init+0x98>)
20003a1a:	6013      	str	r3, [r2, #0]
    if (cfe_clocks_per_usec == 0)
20003a1c:	4b15      	ldr	r3, [pc, #84]	@ (20003a74 <cfe_timer_init+0x98>)
20003a1e:	681b      	ldr	r3, [r3, #0]
20003a20:	2b00      	cmp	r3, #0
20003a22:	d102      	bne.n	20003a2a <cfe_timer_init+0x4e>
	cfe_clocks_per_usec = 1;    /* for the simulator */
20003a24:	4b13      	ldr	r3, [pc, #76]	@ (20003a74 <cfe_timer_init+0x98>)
20003a26:	2201      	movs	r2, #1
20003a28:	601a      	str	r2, [r3, #0]

    cfe_oldcount = _getticks();		/* get current COUNT register */
20003a2a:	f7ff ff6d 	bl	20003908 <_getticks>
20003a2e:	4603      	mov	r3, r0
20003a30:	4a11      	ldr	r2, [pc, #68]	@ (20003a78 <cfe_timer_init+0x9c>)
20003a32:	6013      	str	r3, [r2, #0]
    cfe_ticks = 0;
20003a34:	4911      	ldr	r1, [pc, #68]	@ (20003a7c <cfe_timer_init+0xa0>)
20003a36:	f04f 0200 	mov.w	r2, #0
20003a3a:	f04f 0300 	mov.w	r3, #0
20003a3e:	e9c1 2300 	strd	r2, r3, [r1]

    if (!cfe_timer_initflg) {
20003a42:	4b0f      	ldr	r3, [pc, #60]	@ (20003a80 <cfe_timer_init+0xa4>)
20003a44:	681b      	ldr	r3, [r3, #0]
20003a46:	2b00      	cmp	r3, #0
20003a48:	d106      	bne.n	20003a58 <cfe_timer_init+0x7c>
	cfe_bg_add(cfe_timer_task,NULL); /* add task for background polling */
20003a4a:	2100      	movs	r1, #0
20003a4c:	480d      	ldr	r0, [pc, #52]	@ (20003a84 <cfe_timer_init+0xa8>)
20003a4e:	f7fe f8bf 	bl	20001bd0 <cfe_bg_add>
	cfe_timer_initflg = 1;
20003a52:	4b0b      	ldr	r3, [pc, #44]	@ (20003a80 <cfe_timer_init+0xa4>)
20003a54:	2201      	movs	r2, #1
20003a56:	601a      	str	r2, [r3, #0]
	}
}
20003a58:	bf00      	nop
20003a5a:	3708      	adds	r7, #8
20003a5c:	46bd      	mov	sp, r7
20003a5e:	bd80      	pop	{r7, pc}
20003a60:	cccccccd 	.word	0xcccccccd
20003a64:	20009464 	.word	0x20009464
20003a68:	89705aa5 	.word	0x89705aa5
20003a6c:	2000945c 	.word	0x2000945c
20003a70:	431bde83 	.word	0x431bde83
20003a74:	20009460 	.word	0x20009460
20003a78:	20009468 	.word	0x20009468
20003a7c:	20009450 	.word	0x20009450
20003a80:	20009470 	.word	0x20009470
20003a84:	2000391d 	.word	0x2000391d

20003a88 <env_findenv>:
    *  Return value:
    *  	   cfe_envvar_t pointer, or NULL if not found
    ********************************************************************* */

static cfe_envvar_t *env_findenv(const char *name)
{
20003a88:	b580      	push	{r7, lr}
20003a8a:	b084      	sub	sp, #16
20003a8c:	af00      	add	r7, sp, #0
20003a8e:	6078      	str	r0, [r7, #4]
    queue_t *qb;
    cfe_envvar_t *env;

    for (qb = env_envvars.q_next; qb != &env_envvars; qb = qb->q_next) {
20003a90:	4b11      	ldr	r3, [pc, #68]	@ (20003ad8 <env_findenv+0x50>)
20003a92:	681b      	ldr	r3, [r3, #0]
20003a94:	60fb      	str	r3, [r7, #12]
20003a96:	e00d      	b.n	20003ab4 <env_findenv+0x2c>
	env = (cfe_envvar_t *) qb;
20003a98:	68fb      	ldr	r3, [r7, #12]
20003a9a:	60bb      	str	r3, [r7, #8]
	if (strcmp(env->name,name) == 0) break;
20003a9c:	68bb      	ldr	r3, [r7, #8]
20003a9e:	68db      	ldr	r3, [r3, #12]
20003aa0:	6879      	ldr	r1, [r7, #4]
20003aa2:	4618      	mov	r0, r3
20003aa4:	f7fd fd17 	bl	200014d6 <lib_strcmp>
20003aa8:	4603      	mov	r3, r0
20003aaa:	2b00      	cmp	r3, #0
20003aac:	d007      	beq.n	20003abe <env_findenv+0x36>
    for (qb = env_envvars.q_next; qb != &env_envvars; qb = qb->q_next) {
20003aae:	68fb      	ldr	r3, [r7, #12]
20003ab0:	681b      	ldr	r3, [r3, #0]
20003ab2:	60fb      	str	r3, [r7, #12]
20003ab4:	68fb      	ldr	r3, [r7, #12]
20003ab6:	4a08      	ldr	r2, [pc, #32]	@ (20003ad8 <env_findenv+0x50>)
20003ab8:	4293      	cmp	r3, r2
20003aba:	d1ed      	bne.n	20003a98 <env_findenv+0x10>
20003abc:	e000      	b.n	20003ac0 <env_findenv+0x38>
	if (strcmp(env->name,name) == 0) break;
20003abe:	bf00      	nop
	}

    if (qb == &env_envvars) return NULL;
20003ac0:	68fb      	ldr	r3, [r7, #12]
20003ac2:	4a05      	ldr	r2, [pc, #20]	@ (20003ad8 <env_findenv+0x50>)
20003ac4:	4293      	cmp	r3, r2
20003ac6:	d101      	bne.n	20003acc <env_findenv+0x44>
20003ac8:	2300      	movs	r3, #0
20003aca:	e000      	b.n	20003ace <env_findenv+0x46>

    return (cfe_envvar_t *) qb;
20003acc:	68fb      	ldr	r3, [r7, #12]

}
20003ace:	4618      	mov	r0, r3
20003ad0:	3710      	adds	r7, #16
20003ad2:	46bd      	mov	sp, r7
20003ad4:	bd80      	pop	{r7, pc}
20003ad6:	bf00      	nop
20003ad8:	200091d8 	.word	0x200091d8

20003adc <env_enum>:
    *  	   0 if ok
    *  	   else error code
    ********************************************************************* */

int env_enum(int idx,char *name,int *namelen,char *val,int *vallen)
{
20003adc:	b580      	push	{r7, lr}
20003ade:	b086      	sub	sp, #24
20003ae0:	af00      	add	r7, sp, #0
20003ae2:	60f8      	str	r0, [r7, #12]
20003ae4:	60b9      	str	r1, [r7, #8]
20003ae6:	607a      	str	r2, [r7, #4]
20003ae8:	603b      	str	r3, [r7, #0]
    queue_t *qb;
    cfe_envvar_t *env;

    for (qb = env_envvars.q_next; qb != &env_envvars; qb = qb->q_next) {
20003aea:	4b1b      	ldr	r3, [pc, #108]	@ (20003b58 <env_enum+0x7c>)
20003aec:	681b      	ldr	r3, [r3, #0]
20003aee:	617b      	str	r3, [r7, #20]
20003af0:	e008      	b.n	20003b04 <env_enum+0x28>
	if (idx == 0) break;
20003af2:	68fb      	ldr	r3, [r7, #12]
20003af4:	2b00      	cmp	r3, #0
20003af6:	d00a      	beq.n	20003b0e <env_enum+0x32>
	idx--;
20003af8:	68fb      	ldr	r3, [r7, #12]
20003afa:	3b01      	subs	r3, #1
20003afc:	60fb      	str	r3, [r7, #12]
    for (qb = env_envvars.q_next; qb != &env_envvars; qb = qb->q_next) {
20003afe:	697b      	ldr	r3, [r7, #20]
20003b00:	681b      	ldr	r3, [r3, #0]
20003b02:	617b      	str	r3, [r7, #20]
20003b04:	697b      	ldr	r3, [r7, #20]
20003b06:	4a14      	ldr	r2, [pc, #80]	@ (20003b58 <env_enum+0x7c>)
20003b08:	4293      	cmp	r3, r2
20003b0a:	d1f2      	bne.n	20003af2 <env_enum+0x16>
20003b0c:	e000      	b.n	20003b10 <env_enum+0x34>
	if (idx == 0) break;
20003b0e:	bf00      	nop
	}

    if (qb == &env_envvars) return CFE_ERR_ENVNOTFOUND;
20003b10:	697b      	ldr	r3, [r7, #20]
20003b12:	4a11      	ldr	r2, [pc, #68]	@ (20003b58 <env_enum+0x7c>)
20003b14:	4293      	cmp	r3, r2
20003b16:	d102      	bne.n	20003b1e <env_enum+0x42>
20003b18:	f06f 0308 	mvn.w	r3, #8
20003b1c:	e018      	b.n	20003b50 <env_enum+0x74>
    env = (cfe_envvar_t *) qb;
20003b1e:	697b      	ldr	r3, [r7, #20]
20003b20:	613b      	str	r3, [r7, #16]

    *namelen = xstrncpy(name,env->name,*namelen);
20003b22:	693b      	ldr	r3, [r7, #16]
20003b24:	68d9      	ldr	r1, [r3, #12]
20003b26:	687b      	ldr	r3, [r7, #4]
20003b28:	681b      	ldr	r3, [r3, #0]
20003b2a:	461a      	mov	r2, r3
20003b2c:	68b8      	ldr	r0, [r7, #8]
20003b2e:	f7fd fc90 	bl	20001452 <lib_xstrncpy>
20003b32:	4602      	mov	r2, r0
20003b34:	687b      	ldr	r3, [r7, #4]
20003b36:	601a      	str	r2, [r3, #0]
    *vallen  = xstrncpy(val,env->value,*vallen);
20003b38:	693b      	ldr	r3, [r7, #16]
20003b3a:	6919      	ldr	r1, [r3, #16]
20003b3c:	6a3b      	ldr	r3, [r7, #32]
20003b3e:	681b      	ldr	r3, [r3, #0]
20003b40:	461a      	mov	r2, r3
20003b42:	6838      	ldr	r0, [r7, #0]
20003b44:	f7fd fc85 	bl	20001452 <lib_xstrncpy>
20003b48:	4602      	mov	r2, r0
20003b4a:	6a3b      	ldr	r3, [r7, #32]
20003b4c:	601a      	str	r2, [r3, #0]

    return 0;
20003b4e:	2300      	movs	r3, #0

}
20003b50:	4618      	mov	r0, r3
20003b52:	3718      	adds	r7, #24
20003b54:	46bd      	mov	sp, r7
20003b56:	bd80      	pop	{r7, pc}
20003b58:	200091d8 	.word	0x200091d8

20003b5c <env_envtype>:
    *  	   
    *  Return value:
    *  	   flags, or <0 if error occured
    ********************************************************************* */
int env_envtype(const char *name)
{
20003b5c:	b580      	push	{r7, lr}
20003b5e:	b084      	sub	sp, #16
20003b60:	af00      	add	r7, sp, #0
20003b62:	6078      	str	r0, [r7, #4]
    cfe_envvar_t *env;

    env = env_findenv(name);
20003b64:	6878      	ldr	r0, [r7, #4]
20003b66:	f7ff ff8f 	bl	20003a88 <env_findenv>
20003b6a:	60f8      	str	r0, [r7, #12]

    if (env) {
20003b6c:	68fb      	ldr	r3, [r7, #12]
20003b6e:	2b00      	cmp	r3, #0
20003b70:	d002      	beq.n	20003b78 <env_envtype+0x1c>
	return env->flags;
20003b72:	68fb      	ldr	r3, [r7, #12]
20003b74:	689b      	ldr	r3, [r3, #8]
20003b76:	e001      	b.n	20003b7c <env_envtype+0x20>
	}

    return CFE_ERR_ENVNOTFOUND;
20003b78:	f06f 0308 	mvn.w	r3, #8
}
20003b7c:	4618      	mov	r0, r3
20003b7e:	3710      	adds	r7, #16
20003b80:	46bd      	mov	sp, r7
20003b82:	bd80      	pop	{r7, pc}

20003b84 <env_delenv>:
    *  	   0 if ok
    *  	   else error code
    ********************************************************************* */

int env_delenv(const char *name)
{
20003b84:	b580      	push	{r7, lr}
20003b86:	b084      	sub	sp, #16
20003b88:	af00      	add	r7, sp, #0
20003b8a:	6078      	str	r0, [r7, #4]
    cfe_envvar_t *env;

    env = env_findenv(name);
20003b8c:	6878      	ldr	r0, [r7, #4]
20003b8e:	f7ff ff7b 	bl	20003a88 <env_findenv>
20003b92:	60f8      	str	r0, [r7, #12]

    if (!env) return 0;
20003b94:	68fb      	ldr	r3, [r7, #12]
20003b96:	2b00      	cmp	r3, #0
20003b98:	d101      	bne.n	20003b9e <env_delenv+0x1a>
20003b9a:	2300      	movs	r3, #0
20003b9c:	e010      	b.n	20003bc0 <env_delenv+0x3c>

    if (!(env->flags & ENV_FLG_READONLY)) {
20003b9e:	68fb      	ldr	r3, [r7, #12]
20003ba0:	689b      	ldr	r3, [r3, #8]
20003ba2:	f003 0302 	and.w	r3, r3, #2
20003ba6:	2b00      	cmp	r3, #0
20003ba8:	d108      	bne.n	20003bbc <env_delenv+0x38>
	q_dequeue((queue_t *) env);
20003baa:	68f8      	ldr	r0, [r7, #12]
20003bac:	f7fd fbe5 	bl	2000137a <q_dequeue>
	KFREE(env);
20003bb0:	68f9      	ldr	r1, [r7, #12]
20003bb2:	4805      	ldr	r0, [pc, #20]	@ (20003bc8 <env_delenv+0x44>)
20003bb4:	f7fd fa5c 	bl	20001070 <kfree>
	return 0;
20003bb8:	2300      	movs	r3, #0
20003bba:	e001      	b.n	20003bc0 <env_delenv+0x3c>
	}

    return CFE_ERR_ENVNOTFOUND;
20003bbc:	f06f 0308 	mvn.w	r3, #8
}
20003bc0:	4618      	mov	r0, r3
20003bc2:	3710      	adds	r7, #16
20003bc4:	46bd      	mov	sp, r7
20003bc6:	bd80      	pop	{r7, pc}
20003bc8:	200091fc 	.word	0x200091fc

20003bcc <env_getenv>:
    *  Return value:
    *  	   value, or NULL if variable is not found
    ********************************************************************* */

char *env_getenv(const char *name)
{
20003bcc:	b580      	push	{r7, lr}
20003bce:	b084      	sub	sp, #16
20003bd0:	af00      	add	r7, sp, #0
20003bd2:	6078      	str	r0, [r7, #4]
    cfe_envvar_t *env;

    env = env_findenv(name);
20003bd4:	6878      	ldr	r0, [r7, #4]
20003bd6:	f7ff ff57 	bl	20003a88 <env_findenv>
20003bda:	60f8      	str	r0, [r7, #12]

    if (env) {
20003bdc:	68fb      	ldr	r3, [r7, #12]
20003bde:	2b00      	cmp	r3, #0
20003be0:	d002      	beq.n	20003be8 <env_getenv+0x1c>
	return env->value;
20003be2:	68fb      	ldr	r3, [r7, #12]
20003be4:	691b      	ldr	r3, [r3, #16]
20003be6:	e000      	b.n	20003bea <env_getenv+0x1e>
	}

    return NULL;
20003be8:	2300      	movs	r3, #0
}
20003bea:	4618      	mov	r0, r3
20003bec:	3710      	adds	r7, #16
20003bee:	46bd      	mov	sp, r7
20003bf0:	bd80      	pop	{r7, pc}
	...

20003bf4 <env_setenv>:
    *  	   0 if ok
    *  	   else error code
    ********************************************************************* */

int env_setenv(const char *name,char *value,int flags)
{
20003bf4:	b580      	push	{r7, lr}
20003bf6:	b086      	sub	sp, #24
20003bf8:	af00      	add	r7, sp, #0
20003bfa:	60f8      	str	r0, [r7, #12]
20003bfc:	60b9      	str	r1, [r7, #8]
20003bfe:	607a      	str	r2, [r7, #4]
    cfe_envvar_t *env;
    int namelen;

    env = env_findenv(name);
20003c00:	68f8      	ldr	r0, [r7, #12]
20003c02:	f7ff ff41 	bl	20003a88 <env_findenv>
20003c06:	6178      	str	r0, [r7, #20]
    if (env) {
20003c08:	697b      	ldr	r3, [r7, #20]
20003c0a:	2b00      	cmp	r3, #0
20003c0c:	d014      	beq.n	20003c38 <env_setenv+0x44>
	if (!(flags & ENV_FLG_ADMIN)) {
20003c0e:	687b      	ldr	r3, [r7, #4]
20003c10:	f403 7380 	and.w	r3, r3, #256	@ 0x100
20003c14:	2b00      	cmp	r3, #0
20003c16:	d108      	bne.n	20003c2a <env_setenv+0x36>
	    if (env->flags & ENV_FLG_READONLY) return CFE_ERR_ENVREADONLY;
20003c18:	697b      	ldr	r3, [r7, #20]
20003c1a:	689b      	ldr	r3, [r3, #8]
20003c1c:	f003 0302 	and.w	r3, r3, #2
20003c20:	2b00      	cmp	r3, #0
20003c22:	d002      	beq.n	20003c2a <env_setenv+0x36>
20003c24:	f06f 0309 	mvn.w	r3, #9
20003c28:	e03f      	b.n	20003caa <env_setenv+0xb6>
	    }
	q_dequeue((queue_t *) env);
20003c2a:	6978      	ldr	r0, [r7, #20]
20003c2c:	f7fd fba5 	bl	2000137a <q_dequeue>
	KFREE(env);
20003c30:	6979      	ldr	r1, [r7, #20]
20003c32:	4820      	ldr	r0, [pc, #128]	@ (20003cb4 <env_setenv+0xc0>)
20003c34:	f7fd fa1c 	bl	20001070 <kfree>
	}

    namelen = strlen(name);
20003c38:	68f8      	ldr	r0, [r7, #12]
20003c3a:	f7fd fc34 	bl	200014a6 <lib_strlen>
20003c3e:	6138      	str	r0, [r7, #16]

    env = KMALLOC(sizeof(cfe_envvar_t) + namelen + 1 + strlen(value) + 1,0);
20003c40:	68b8      	ldr	r0, [r7, #8]
20003c42:	f7fd fc30 	bl	200014a6 <lib_strlen>
20003c46:	4603      	mov	r3, r0
20003c48:	461a      	mov	r2, r3
20003c4a:	693b      	ldr	r3, [r7, #16]
20003c4c:	4413      	add	r3, r2
20003c4e:	3316      	adds	r3, #22
20003c50:	2200      	movs	r2, #0
20003c52:	4619      	mov	r1, r3
20003c54:	4817      	ldr	r0, [pc, #92]	@ (20003cb4 <env_setenv+0xc0>)
20003c56:	f7fd fa3f 	bl	200010d8 <kmalloc>
20003c5a:	6178      	str	r0, [r7, #20]
    if (!env) return CFE_ERR_NOMEM;
20003c5c:	697b      	ldr	r3, [r7, #20]
20003c5e:	2b00      	cmp	r3, #0
20003c60:	d102      	bne.n	20003c68 <env_setenv+0x74>
20003c62:	f06f 0304 	mvn.w	r3, #4
20003c66:	e020      	b.n	20003caa <env_setenv+0xb6>

    env->name = (char *) (env+1);
20003c68:	697b      	ldr	r3, [r7, #20]
20003c6a:	f103 0214 	add.w	r2, r3, #20
20003c6e:	697b      	ldr	r3, [r7, #20]
20003c70:	60da      	str	r2, [r3, #12]
    env->value = env->name + namelen + 1;
20003c72:	697b      	ldr	r3, [r7, #20]
20003c74:	68da      	ldr	r2, [r3, #12]
20003c76:	693b      	ldr	r3, [r7, #16]
20003c78:	3301      	adds	r3, #1
20003c7a:	441a      	add	r2, r3
20003c7c:	697b      	ldr	r3, [r7, #20]
20003c7e:	611a      	str	r2, [r3, #16]
    env->flags = (flags & ENV_FLG_MASK);
20003c80:	687b      	ldr	r3, [r7, #4]
20003c82:	b2da      	uxtb	r2, r3
20003c84:	697b      	ldr	r3, [r7, #20]
20003c86:	609a      	str	r2, [r3, #8]

    strcpy(env->name,name);
20003c88:	697b      	ldr	r3, [r7, #20]
20003c8a:	68db      	ldr	r3, [r3, #12]
20003c8c:	68f9      	ldr	r1, [r7, #12]
20003c8e:	4618      	mov	r0, r3
20003c90:	f7fd fbc1 	bl	20001416 <lib_strcpy>
    strcpy(env->value,value);
20003c94:	697b      	ldr	r3, [r7, #20]
20003c96:	691b      	ldr	r3, [r3, #16]
20003c98:	68b9      	ldr	r1, [r7, #8]
20003c9a:	4618      	mov	r0, r3
20003c9c:	f7fd fbbb 	bl	20001416 <lib_strcpy>

    q_enqueue(&env_envvars,(queue_t *) env);
20003ca0:	6979      	ldr	r1, [r7, #20]
20003ca2:	4805      	ldr	r0, [pc, #20]	@ (20003cb8 <env_setenv+0xc4>)
20003ca4:	f7fd fb50 	bl	20001348 <q_enqueue>

    return 0;
20003ca8:	2300      	movs	r3, #0
}
20003caa:	4618      	mov	r0, r3
20003cac:	3718      	adds	r7, #24
20003cae:	46bd      	mov	sp, r7
20003cb0:	bd80      	pop	{r7, pc}
20003cb2:	bf00      	nop
20003cb4:	200091fc 	.word	0x200091fc
20003cb8:	200091d8 	.word	0x200091d8

20003cbc <env_save>:
    *  Return value:
    *  	   0 if ok, else error code
    ********************************************************************* */

int env_save(void)
{
20003cbc:	b480      	push	{r7}
20003cbe:	af00      	add	r7, sp, #0
   return 0;
20003cc0:	2300      	movs	r3, #0

}
20003cc2:	4618      	mov	r0, r3
20003cc4:	46bd      	mov	sp, r7
20003cc6:	f85d 7b04 	ldr.w	r7, [sp], #4
20003cca:	4770      	bx	lr

20003ccc <ui_errstring>:
    *  Return value:
    *  	   string describing error code
    ********************************************************************* */

const char *ui_errstring(int errcode)
{
20003ccc:	b580      	push	{r7, lr}
20003cce:	b082      	sub	sp, #8
20003cd0:	af00      	add	r7, sp, #0
20003cd2:	6078      	str	r0, [r7, #4]
    return cfe_errortext(errcode);
20003cd4:	6878      	ldr	r0, [r7, #4]
20003cd6:	f7ff f92b 	bl	20002f30 <cfe_errortext>
20003cda:	4603      	mov	r3, r0
}
20003cdc:	4618      	mov	r0, r3
20003cde:	3708      	adds	r7, #8
20003ce0:	46bd      	mov	sp, r7
20003ce2:	bd80      	pop	{r7, pc}

20003ce4 <ui_showerror>:
    *  Return value:
    *  	   errcode
    ********************************************************************* */

int ui_showerror(int errcode,char *tmplt,...)
{
20003ce4:	b40e      	push	{r1, r2, r3}
20003ce6:	b580      	push	{r7, lr}
20003ce8:	b085      	sub	sp, #20
20003cea:	af00      	add	r7, sp, #0
20003cec:	6078      	str	r0, [r7, #4]
    va_list marker;

    va_start(marker,tmplt);
20003cee:	f107 0320 	add.w	r3, r7, #32
20003cf2:	60fb      	str	r3, [r7, #12]
    printf(tmplt,marker);
20003cf4:	68f9      	ldr	r1, [r7, #12]
20003cf6:	69f8      	ldr	r0, [r7, #28]
20003cf8:	f7fd f834 	bl	20000d64 <printf>
    va_end(marker);
    printf(": %s\n",ui_errstring(errcode));
20003cfc:	6878      	ldr	r0, [r7, #4]
20003cfe:	f7ff ffe5 	bl	20003ccc <ui_errstring>
20003d02:	4603      	mov	r3, r0
20003d04:	4619      	mov	r1, r3
20003d06:	4805      	ldr	r0, [pc, #20]	@ (20003d1c <ui_showerror+0x38>)
20003d08:	f7fd f82c 	bl	20000d64 <printf>

    return errcode;
20003d0c:	687b      	ldr	r3, [r7, #4]
}
20003d0e:	4618      	mov	r0, r3
20003d10:	3714      	adds	r7, #20
20003d12:	46bd      	mov	sp, r7
20003d14:	e8bd 4080 	ldmia.w	sp!, {r7, lr}
20003d18:	b003      	add	sp, #12
20003d1a:	4770      	bx	lr
20003d1c:	20007c1c 	.word	0x20007c1c

20003d20 <ui_do_one_command>:
    *  	   return value from CFE UI function
    ********************************************************************* */


static int ui_do_one_command(queue_t *head)
{
20003d20:	b590      	push	{r4, r7, lr}
20003d22:	b0fb      	sub	sp, #492	@ 0x1ec
20003d24:	af00      	add	r7, sp, #0
20003d26:	f507 73f4 	add.w	r3, r7, #488	@ 0x1e8
20003d2a:	f5a3 73f2 	sub.w	r3, r3, #484	@ 0x1e4
20003d2e:	6018      	str	r0, [r3, #0]
    int res;
    ui_cmdline_t cmd;

    res = cmd_lookup(head, &cmd);
20003d30:	f107 0208 	add.w	r2, r7, #8
20003d34:	f507 73f4 	add.w	r3, r7, #488	@ 0x1e8
20003d38:	f5a3 73f2 	sub.w	r3, r3, #484	@ 0x1e4
20003d3c:	4611      	mov	r1, r2
20003d3e:	6818      	ldr	r0, [r3, #0]
20003d40:	f000 fe44 	bl	200049cc <cmd_lookup>
20003d44:	f8c7 01e4 	str.w	r0, [r7, #484]	@ 0x1e4

    if (res == 0) {
20003d48:	f8d7 31e4 	ldr.w	r3, [r7, #484]	@ 0x1e4
20003d4c:	2b00      	cmp	r3, #0
20003d4e:	d144      	bne.n	20003dda <ui_do_one_command+0xba>

	res = cmd_sw_validate(&cmd,cmd.switches);
20003d50:	f507 73f4 	add.w	r3, r7, #488	@ 0x1e8
20003d54:	f5a3 73f0 	sub.w	r3, r3, #480	@ 0x1e0
20003d58:	f8d3 21d8 	ldr.w	r2, [r3, #472]	@ 0x1d8
20003d5c:	f107 0308 	add.w	r3, r7, #8
20003d60:	4611      	mov	r1, r2
20003d62:	4618      	mov	r0, r3
20003d64:	f000 f9dc 	bl	20004120 <cmd_sw_validate>
20003d68:	f8c7 01e4 	str.w	r0, [r7, #484]	@ 0x1e4
	if (res != -1) {
20003d6c:	f8d7 31e4 	ldr.w	r3, [r7, #484]	@ 0x1e4
20003d70:	f1b3 3fff 	cmp.w	r3, #4294967295	@ 0xffffffff
20003d74:	d00e      	beq.n	20003d94 <ui_do_one_command+0x74>
	    printf("Invalid switch: %s\n",
20003d76:	f107 0308 	add.w	r3, r7, #8
20003d7a:	f8d7 11e4 	ldr.w	r1, [r7, #484]	@ 0x1e4
20003d7e:	4618      	mov	r0, r3
20003d80:	f000 f924 	bl	20003fcc <cmd_sw_name>
20003d84:	4603      	mov	r3, r0
20003d86:	4619      	mov	r1, r3
20003d88:	481a      	ldr	r0, [pc, #104]	@ (20003df4 <ui_do_one_command+0xd4>)
20003d8a:	f7fc ffeb 	bl	20000d64 <printf>
		    cmd_sw_name(&cmd,res));
	    return CFE_ERR_INV_PARAM;
20003d8e:	f06f 0307 	mvn.w	r3, #7
20003d92:	e029      	b.n	20003de8 <ui_do_one_command+0xc8>
	    }

//	if (lib_setjmp(ui_jmpbuf) != 0) return -1;
	res = (*cmd.func)(&cmd,cmd.argc-cmd.argidx,
20003d94:	f507 73f4 	add.w	r3, r7, #488	@ 0x1e8
20003d98:	f5a3 73f0 	sub.w	r3, r3, #480	@ 0x1e0
20003d9c:	f8d3 31c8 	ldr.w	r3, [r3, #456]	@ 0x1c8
20003da0:	f507 72f4 	add.w	r2, r7, #488	@ 0x1e8
20003da4:	f5a2 72f0 	sub.w	r2, r2, #480	@ 0x1e0
20003da8:	6811      	ldr	r1, [r2, #0]
20003daa:	f507 72f4 	add.w	r2, r7, #488	@ 0x1e8
20003dae:	f5a2 72f0 	sub.w	r2, r2, #480	@ 0x1e0
20003db2:	f8d2 21cc 	ldr.w	r2, [r2, #460]	@ 0x1cc
20003db6:	1a8c      	subs	r4, r1, r2
		    &(cmd.argv[cmd.argidx]));
20003db8:	f507 72f4 	add.w	r2, r7, #488	@ 0x1e8
20003dbc:	f5a2 72f0 	sub.w	r2, r2, #480	@ 0x1e0
20003dc0:	f8d2 21cc 	ldr.w	r2, [r2, #460]	@ 0x1cc
	res = (*cmd.func)(&cmd,cmd.argc-cmd.argidx,
20003dc4:	f107 0108 	add.w	r1, r7, #8
20003dc8:	0092      	lsls	r2, r2, #2
20003dca:	440a      	add	r2, r1
20003dcc:	3204      	adds	r2, #4
20003dce:	f107 0008 	add.w	r0, r7, #8
20003dd2:	4621      	mov	r1, r4
20003dd4:	4798      	blx	r3
20003dd6:	f8c7 01e4 	str.w	r0, [r7, #484]	@ 0x1e4
	}
    cmd_free(&cmd);
20003dda:	f107 0308 	add.w	r3, r7, #8
20003dde:	4618      	mov	r0, r3
20003de0:	f000 f95e 	bl	200040a0 <cmd_free>
    return res;
20003de4:	f8d7 31e4 	ldr.w	r3, [r7, #484]	@ 0x1e4
}
20003de8:	4618      	mov	r0, r3
20003dea:	f507 77f6 	add.w	r7, r7, #492	@ 0x1ec
20003dee:	46bd      	mov	sp, r7
20003df0:	bd90      	pop	{r4, r7, pc}
20003df2:	bf00      	nop
20003df4:	20007c24 	.word	0x20007c24

20003df8 <ui_init_cmddisp>:
    *  Return value:
    *  	   0
    ********************************************************************* */

int ui_init_cmddisp(void)
{
20003df8:	b580      	push	{r7, lr}
20003dfa:	af00      	add	r7, sp, #0
    cmd_init();
20003dfc:	f000 fdc6 	bl	2000498c <cmd_init>

    return 0;
20003e00:	2300      	movs	r3, #0
}
20003e02:	4618      	mov	r0, r3
20003e04:	bd80      	pop	{r7, pc}

20003e06 <ui_showusage>:
    *  Return value:
    *  	   CFE_ERR_INV_COMMAND
    ********************************************************************* */

int ui_showusage(ui_cmdline_t *cmd)
{
20003e06:	b580      	push	{r7, lr}
20003e08:	b082      	sub	sp, #8
20003e0a:	af00      	add	r7, sp, #0
20003e0c:	6078      	str	r0, [r7, #4]
    cmd_showusage(cmd);
20003e0e:	6878      	ldr	r0, [r7, #4]
20003e10:	f000 fe7e 	bl	20004b10 <cmd_showusage>

    return CFE_ERR_INV_COMMAND;
20003e14:	f06f 0301 	mvn.w	r3, #1
}
20003e18:	4618      	mov	r0, r3
20003e1a:	3708      	adds	r7, #8
20003e1c:	46bd      	mov	sp, r7
20003e1e:	bd80      	pop	{r7, pc}

20003e20 <ui_docommands_internal>:
    *  	   
    *  Return value:
    *  	   exit status of first command that failed, or null
    ********************************************************************* */
static int ui_docommands_internal(queue_t *head)
{
20003e20:	b580      	push	{r7, lr}
20003e22:	b088      	sub	sp, #32
20003e24:	af00      	add	r7, sp, #0
20003e26:	6078      	str	r0, [r7, #4]
    queue_t cmdqueue;
    ui_command_t *cmd;
    int status = CMD_ERR_BLANK;
20003e28:	f06f 0302 	mvn.w	r3, #2
20003e2c:	61fb      	str	r3, [r7, #28]
    int term;

    q_init(&cmdqueue);
20003e2e:	f107 030c 	add.w	r3, r7, #12
20003e32:	613b      	str	r3, [r7, #16]
20003e34:	f107 030c 	add.w	r3, r7, #12
20003e38:	60fb      	str	r3, [r7, #12]

    /*
     * Find all the individual commands
     */

    while ((cmd = cmd_readcommand(head))) {
20003e3a:	e00b      	b.n	20003e54 <ui_docommands_internal+0x34>

	if (cmd == NULL) {
20003e3c:	69bb      	ldr	r3, [r7, #24]
20003e3e:	2b00      	cmp	r3, #0
20003e40:	d102      	bne.n	20003e48 <ui_docommands_internal+0x28>
	    return CMD_ERR_BLANK;
20003e42:	f06f 0302 	mvn.w	r3, #2
20003e46:	e04d      	b.n	20003ee4 <ui_docommands_internal+0xc4>
	    }

	q_enqueue(&cmdqueue,(queue_t *) cmd);
20003e48:	f107 030c 	add.w	r3, r7, #12
20003e4c:	69b9      	ldr	r1, [r7, #24]
20003e4e:	4618      	mov	r0, r3
20003e50:	f7fd fa7a 	bl	20001348 <q_enqueue>
    while ((cmd = cmd_readcommand(head))) {
20003e54:	6878      	ldr	r0, [r7, #4]
20003e56:	f000 fea5 	bl	20004ba4 <cmd_readcommand>
20003e5a:	61b8      	str	r0, [r7, #24]
20003e5c:	69bb      	ldr	r3, [r7, #24]
20003e5e:	2b00      	cmp	r3, #0
20003e60:	d1ec      	bne.n	20003e3c <ui_docommands_internal+0x1c>

    /*
     * Do each command
     */

    while ((cmd = (ui_command_t *) q_deqnext(&(cmdqueue)))) {
20003e62:	e01e      	b.n	20003ea2 <ui_docommands_internal+0x82>
	status = ui_do_one_command(&(cmd->head));
20003e64:	69bb      	ldr	r3, [r7, #24]
20003e66:	3310      	adds	r3, #16
20003e68:	4618      	mov	r0, r3
20003e6a:	f7ff ff59 	bl	20003d20 <ui_do_one_command>
20003e6e:	61f8      	str	r0, [r7, #28]
	term = cmd->term;
20003e70:	69bb      	ldr	r3, [r7, #24]
20003e72:	689b      	ldr	r3, [r3, #8]
20003e74:	617b      	str	r3, [r7, #20]
	KFREE(cmd);
20003e76:	69b9      	ldr	r1, [r7, #24]
20003e78:	481c      	ldr	r0, [pc, #112]	@ (20003eec <ui_docommands_internal+0xcc>)
20003e7a:	f7fd f8f9 	bl	20001070 <kfree>
	if (status == CMD_ERR_BLANK) continue;
20003e7e:	69fb      	ldr	r3, [r7, #28]
20003e80:	f113 0f03 	cmn.w	r3, #3
20003e84:	d00c      	beq.n	20003ea0 <ui_docommands_internal+0x80>

	/*
	 * And causes us to stop at the first failure.
	 */
	if ((term == CMD_TERM_AND) && (status != 0)) break;
20003e86:	697b      	ldr	r3, [r7, #20]
20003e88:	2b02      	cmp	r3, #2
20003e8a:	d102      	bne.n	20003e92 <ui_docommands_internal+0x72>
20003e8c:	69fb      	ldr	r3, [r7, #28]
20003e8e:	2b00      	cmp	r3, #0
20003e90:	d111      	bne.n	20003eb6 <ui_docommands_internal+0x96>

	/*
	 * OR causes us to stop at the first success.
	 */

	if ((term == CMD_TERM_OR) && (status == 0)) break;
20003e92:	697b      	ldr	r3, [r7, #20]
20003e94:	2b03      	cmp	r3, #3
20003e96:	d104      	bne.n	20003ea2 <ui_docommands_internal+0x82>
20003e98:	69fb      	ldr	r3, [r7, #28]
20003e9a:	2b00      	cmp	r3, #0
20003e9c:	d00d      	beq.n	20003eba <ui_docommands_internal+0x9a>
20003e9e:	e000      	b.n	20003ea2 <ui_docommands_internal+0x82>
	if (status == CMD_ERR_BLANK) continue;
20003ea0:	bf00      	nop
    while ((cmd = (ui_command_t *) q_deqnext(&(cmdqueue)))) {
20003ea2:	f107 030c 	add.w	r3, r7, #12
20003ea6:	4618      	mov	r0, r3
20003ea8:	f7fd fa7b 	bl	200013a2 <q_deqnext>
20003eac:	61b8      	str	r0, [r7, #24]
20003eae:	69bb      	ldr	r3, [r7, #24]
20003eb0:	2b00      	cmp	r3, #0
20003eb2:	d1d7      	bne.n	20003e64 <ui_docommands_internal+0x44>
20003eb4:	e00c      	b.n	20003ed0 <ui_docommands_internal+0xb0>
	if ((term == CMD_TERM_AND) && (status != 0)) break;
20003eb6:	bf00      	nop
20003eb8:	e00a      	b.n	20003ed0 <ui_docommands_internal+0xb0>
	if ((term == CMD_TERM_OR) && (status == 0)) break;
20003eba:	bf00      	nop

    /*
     * Free any remaining tokens and commands that we did not do
     */

    while ((cmd = (ui_command_t *) q_deqnext(&(cmdqueue)))) {
20003ebc:	e008      	b.n	20003ed0 <ui_docommands_internal+0xb0>
	cmd_free_tokens(&(cmd->head));
20003ebe:	69bb      	ldr	r3, [r7, #24]
20003ec0:	3310      	adds	r3, #16
20003ec2:	4618      	mov	r0, r3
20003ec4:	f001 f926 	bl	20005114 <cmd_free_tokens>
	KFREE(cmd);
20003ec8:	69b9      	ldr	r1, [r7, #24]
20003eca:	4808      	ldr	r0, [pc, #32]	@ (20003eec <ui_docommands_internal+0xcc>)
20003ecc:	f7fd f8d0 	bl	20001070 <kfree>
    while ((cmd = (ui_command_t *) q_deqnext(&(cmdqueue)))) {
20003ed0:	f107 030c 	add.w	r3, r7, #12
20003ed4:	4618      	mov	r0, r3
20003ed6:	f7fd fa64 	bl	200013a2 <q_deqnext>
20003eda:	61b8      	str	r0, [r7, #24]
20003edc:	69bb      	ldr	r3, [r7, #24]
20003ede:	2b00      	cmp	r3, #0
20003ee0:	d1ed      	bne.n	20003ebe <ui_docommands_internal+0x9e>
	}

    return status;
20003ee2:	69fb      	ldr	r3, [r7, #28]
}
20003ee4:	4618      	mov	r0, r3
20003ee6:	3720      	adds	r7, #32
20003ee8:	46bd      	mov	sp, r7
20003eea:	bd80      	pop	{r7, pc}
20003eec:	200091fc 	.word	0x200091fc

20003ef0 <ui_docommands>:
    *  	   return value of failing command, or 0 if all commands
    *  	   succeeded
    ********************************************************************* */

int ui_docommands(char *str)
{
20003ef0:	b580      	push	{r7, lr}
20003ef2:	b086      	sub	sp, #24
20003ef4:	af00      	add	r7, sp, #0
20003ef6:	6078      	str	r0, [r7, #4]
    queue_t cmd_list;
    int res;

    /* Convert the command into a token list */
    cmd_build_list(&cmd_list,str);
20003ef8:	f107 030c 	add.w	r3, r7, #12
20003efc:	6879      	ldr	r1, [r7, #4]
20003efe:	4618      	mov	r0, r3
20003f00:	f000 fefc 	bl	20004cfc <cmd_build_list>

    /* Walk the list and expand environment variables */
    cmd_walk_and_expand(&cmd_list);
20003f04:	f107 030c 	add.w	r3, r7, #12
20003f08:	4618      	mov	r0, r3
20003f0a:	f001 f879 	bl	20005000 <cmd_walk_and_expand>

    /* Process each command.  This removes tokens from the list */
    res = ui_docommands_internal(&cmd_list);
20003f0e:	f107 030c 	add.w	r3, r7, #12
20003f12:	4618      	mov	r0, r3
20003f14:	f7ff ff84 	bl	20003e20 <ui_docommands_internal>
20003f18:	6178      	str	r0, [r7, #20]

    /* Free any leftover tokens.  There should not be any. */
    cmd_free_tokens(&cmd_list);
20003f1a:	f107 030c 	add.w	r3, r7, #12
20003f1e:	4618      	mov	r0, r3
20003f20:	f001 f8f8 	bl	20005114 <cmd_free_tokens>

    return res;
20003f24:	697b      	ldr	r3, [r7, #20]
}
20003f26:	4618      	mov	r0, r3
20003f28:	3718      	adds	r7, #24
20003f2a:	46bd      	mov	sp, r7
20003f2c:	bd80      	pop	{r7, pc}
	...

20003f30 <is_white_space>:

static char *cmd_eat_quoted_arg(queue_t *head,ui_token_t *t);


static inline int is_white_space(ui_token_t *t) 
{
20003f30:	b580      	push	{r7, lr}
20003f32:	b082      	sub	sp, #8
20003f34:	af00      	add	r7, sp, #0
20003f36:	6078      	str	r0, [r7, #4]
    return (strchr(spacechars,t->token) != NULL);
20003f38:	4b08      	ldr	r3, [pc, #32]	@ (20003f5c <is_white_space+0x2c>)
20003f3a:	681a      	ldr	r2, [r3, #0]
20003f3c:	687b      	ldr	r3, [r7, #4]
20003f3e:	7a1b      	ldrb	r3, [r3, #8]
20003f40:	4619      	mov	r1, r3
20003f42:	4610      	mov	r0, r2
20003f44:	f7fd fb08 	bl	20001558 <lib_strchr>
20003f48:	4603      	mov	r3, r0
20003f4a:	2b00      	cmp	r3, #0
20003f4c:	bf14      	ite	ne
20003f4e:	2301      	movne	r3, #1
20003f50:	2300      	moveq	r3, #0
20003f52:	b2db      	uxtb	r3, r3
}
20003f54:	4618      	mov	r0, r3
20003f56:	3708      	adds	r7, #8
20003f58:	46bd      	mov	sp, r7
20003f5a:	bd80      	pop	{r7, pc}
20003f5c:	200091e4 	.word	0x200091e4

20003f60 <cmd_sw_value>:

int cmd_sw_value(ui_cmdline_t *cmd,char *swname,char **swvalue)
{
20003f60:	b580      	push	{r7, lr}
20003f62:	b086      	sub	sp, #24
20003f64:	af00      	add	r7, sp, #0
20003f66:	60f8      	str	r0, [r7, #12]
20003f68:	60b9      	str	r1, [r7, #8]
20003f6a:	607a      	str	r2, [r7, #4]
    int idx;

    for (idx = 0; idx < cmd->swc; idx++) {
20003f6c:	2300      	movs	r3, #0
20003f6e:	617b      	str	r3, [r7, #20]
20003f70:	e021      	b.n	20003fb6 <cmd_sw_value+0x56>
	if (strcmp(swname,cmd->swv[idx].swname) == 0) {
20003f72:	68f9      	ldr	r1, [r7, #12]
20003f74:	697a      	ldr	r2, [r7, #20]
20003f76:	4613      	mov	r3, r2
20003f78:	005b      	lsls	r3, r3, #1
20003f7a:	4413      	add	r3, r2
20003f7c:	009b      	lsls	r3, r3, #2
20003f7e:	440b      	add	r3, r1
20003f80:	f503 7386 	add.w	r3, r3, #268	@ 0x10c
20003f84:	681b      	ldr	r3, [r3, #0]
20003f86:	4619      	mov	r1, r3
20003f88:	68b8      	ldr	r0, [r7, #8]
20003f8a:	f7fd faa4 	bl	200014d6 <lib_strcmp>
20003f8e:	4603      	mov	r3, r0
20003f90:	2b00      	cmp	r3, #0
20003f92:	d10d      	bne.n	20003fb0 <cmd_sw_value+0x50>
	    *swvalue = cmd->swv[idx].swvalue;
20003f94:	68f9      	ldr	r1, [r7, #12]
20003f96:	697a      	ldr	r2, [r7, #20]
20003f98:	4613      	mov	r3, r2
20003f9a:	005b      	lsls	r3, r3, #1
20003f9c:	4413      	add	r3, r2
20003f9e:	009b      	lsls	r3, r3, #2
20003fa0:	440b      	add	r3, r1
20003fa2:	f503 7388 	add.w	r3, r3, #272	@ 0x110
20003fa6:	681a      	ldr	r2, [r3, #0]
20003fa8:	687b      	ldr	r3, [r7, #4]
20003faa:	601a      	str	r2, [r3, #0]
	    return 1;
20003fac:	2301      	movs	r3, #1
20003fae:	e009      	b.n	20003fc4 <cmd_sw_value+0x64>
    for (idx = 0; idx < cmd->swc; idx++) {
20003fb0:	697b      	ldr	r3, [r7, #20]
20003fb2:	3301      	adds	r3, #1
20003fb4:	617b      	str	r3, [r7, #20]
20003fb6:	68fb      	ldr	r3, [r7, #12]
20003fb8:	f8d3 3104 	ldr.w	r3, [r3, #260]	@ 0x104
20003fbc:	697a      	ldr	r2, [r7, #20]
20003fbe:	429a      	cmp	r2, r3
20003fc0:	dbd7      	blt.n	20003f72 <cmd_sw_value+0x12>
	    }
	}

    return 0;
20003fc2:	2300      	movs	r3, #0
}
20003fc4:	4618      	mov	r0, r3
20003fc6:	3718      	adds	r7, #24
20003fc8:	46bd      	mov	sp, r7
20003fca:	bd80      	pop	{r7, pc}

20003fcc <cmd_sw_name>:

    return -1;
}

char *cmd_sw_name(ui_cmdline_t *cmd,int swidx)
{
20003fcc:	b480      	push	{r7}
20003fce:	b083      	sub	sp, #12
20003fd0:	af00      	add	r7, sp, #0
20003fd2:	6078      	str	r0, [r7, #4]
20003fd4:	6039      	str	r1, [r7, #0]
    if ((swidx < 0) || (swidx >= cmd->swc)) return NULL;
20003fd6:	683b      	ldr	r3, [r7, #0]
20003fd8:	2b00      	cmp	r3, #0
20003fda:	db05      	blt.n	20003fe8 <cmd_sw_name+0x1c>
20003fdc:	687b      	ldr	r3, [r7, #4]
20003fde:	f8d3 3104 	ldr.w	r3, [r3, #260]	@ 0x104
20003fe2:	683a      	ldr	r2, [r7, #0]
20003fe4:	429a      	cmp	r2, r3
20003fe6:	db01      	blt.n	20003fec <cmd_sw_name+0x20>
20003fe8:	2300      	movs	r3, #0
20003fea:	e009      	b.n	20004000 <cmd_sw_name+0x34>

    return cmd->swv[swidx].swname;
20003fec:	6879      	ldr	r1, [r7, #4]
20003fee:	683a      	ldr	r2, [r7, #0]
20003ff0:	4613      	mov	r3, r2
20003ff2:	005b      	lsls	r3, r3, #1
20003ff4:	4413      	add	r3, r2
20003ff6:	009b      	lsls	r3, r3, #2
20003ff8:	440b      	add	r3, r1
20003ffa:	f503 7386 	add.w	r3, r3, #268	@ 0x10c
20003ffe:	681b      	ldr	r3, [r3, #0]
}
20004000:	4618      	mov	r0, r3
20004002:	370c      	adds	r7, #12
20004004:	46bd      	mov	sp, r7
20004006:	f85d 7b04 	ldr.w	r7, [sp], #4
2000400a:	4770      	bx	lr

2000400c <cmd_sw_isset>:


int cmd_sw_isset(ui_cmdline_t *cmd,char *swname)
{
2000400c:	b580      	push	{r7, lr}
2000400e:	b084      	sub	sp, #16
20004010:	af00      	add	r7, sp, #0
20004012:	6078      	str	r0, [r7, #4]
20004014:	6039      	str	r1, [r7, #0]
    int idx;

    for (idx = 0; idx < cmd->swc; idx++) {
20004016:	2300      	movs	r3, #0
20004018:	60fb      	str	r3, [r7, #12]
2000401a:	e015      	b.n	20004048 <cmd_sw_isset+0x3c>
	if (strcmp(swname,cmd->swv[idx].swname) == 0) {
2000401c:	6879      	ldr	r1, [r7, #4]
2000401e:	68fa      	ldr	r2, [r7, #12]
20004020:	4613      	mov	r3, r2
20004022:	005b      	lsls	r3, r3, #1
20004024:	4413      	add	r3, r2
20004026:	009b      	lsls	r3, r3, #2
20004028:	440b      	add	r3, r1
2000402a:	f503 7386 	add.w	r3, r3, #268	@ 0x10c
2000402e:	681b      	ldr	r3, [r3, #0]
20004030:	4619      	mov	r1, r3
20004032:	6838      	ldr	r0, [r7, #0]
20004034:	f7fd fa4f 	bl	200014d6 <lib_strcmp>
20004038:	4603      	mov	r3, r0
2000403a:	2b00      	cmp	r3, #0
2000403c:	d101      	bne.n	20004042 <cmd_sw_isset+0x36>
	    return 1;
2000403e:	2301      	movs	r3, #1
20004040:	e009      	b.n	20004056 <cmd_sw_isset+0x4a>
    for (idx = 0; idx < cmd->swc; idx++) {
20004042:	68fb      	ldr	r3, [r7, #12]
20004044:	3301      	adds	r3, #1
20004046:	60fb      	str	r3, [r7, #12]
20004048:	687b      	ldr	r3, [r7, #4]
2000404a:	f8d3 3104 	ldr.w	r3, [r3, #260]	@ 0x104
2000404e:	68fa      	ldr	r2, [r7, #12]
20004050:	429a      	cmp	r2, r3
20004052:	dbe3      	blt.n	2000401c <cmd_sw_isset+0x10>
	    }
	}

    return 0;
20004054:	2300      	movs	r3, #0
}
20004056:	4618      	mov	r0, r3
20004058:	3710      	adds	r7, #16
2000405a:	46bd      	mov	sp, r7
2000405c:	bd80      	pop	{r7, pc}

2000405e <cmd_getarg>:

char *cmd_getarg(ui_cmdline_t *cmd,int argnum)
{
2000405e:	b480      	push	{r7}
20004060:	b083      	sub	sp, #12
20004062:	af00      	add	r7, sp, #0
20004064:	6078      	str	r0, [r7, #4]
20004066:	6039      	str	r1, [r7, #0]
    argnum += cmd->argidx;
20004068:	687b      	ldr	r3, [r7, #4]
2000406a:	f8d3 31cc 	ldr.w	r3, [r3, #460]	@ 0x1cc
2000406e:	683a      	ldr	r2, [r7, #0]
20004070:	4413      	add	r3, r2
20004072:	603b      	str	r3, [r7, #0]
    if ((argnum < 0) || (argnum >= cmd->argc)) return NULL;
20004074:	683b      	ldr	r3, [r7, #0]
20004076:	2b00      	cmp	r3, #0
20004078:	db04      	blt.n	20004084 <cmd_getarg+0x26>
2000407a:	687b      	ldr	r3, [r7, #4]
2000407c:	681b      	ldr	r3, [r3, #0]
2000407e:	683a      	ldr	r2, [r7, #0]
20004080:	429a      	cmp	r2, r3
20004082:	db01      	blt.n	20004088 <cmd_getarg+0x2a>
20004084:	2300      	movs	r3, #0
20004086:	e004      	b.n	20004092 <cmd_getarg+0x34>
    return cmd->argv[argnum];
20004088:	687a      	ldr	r2, [r7, #4]
2000408a:	683b      	ldr	r3, [r7, #0]
2000408c:	009b      	lsls	r3, r3, #2
2000408e:	4413      	add	r3, r2
20004090:	685b      	ldr	r3, [r3, #4]
}
20004092:	4618      	mov	r0, r3
20004094:	370c      	adds	r7, #12
20004096:	46bd      	mov	sp, r7
20004098:	f85d 7b04 	ldr.w	r7, [sp], #4
2000409c:	4770      	bx	lr
	...

200040a0 <cmd_free>:

void cmd_free(ui_cmdline_t *cmd)
{
200040a0:	b580      	push	{r7, lr}
200040a2:	b084      	sub	sp, #16
200040a4:	af00      	add	r7, sp, #0
200040a6:	6078      	str	r0, [r7, #4]
    int idx;

    for (idx = 0; idx < cmd->argc; idx++) {
200040a8:	2300      	movs	r3, #0
200040aa:	60fb      	str	r3, [r7, #12]
200040ac:	e00b      	b.n	200040c6 <cmd_free+0x26>
	KFREE(cmd->argv[idx]);
200040ae:	687a      	ldr	r2, [r7, #4]
200040b0:	68fb      	ldr	r3, [r7, #12]
200040b2:	009b      	lsls	r3, r3, #2
200040b4:	4413      	add	r3, r2
200040b6:	685b      	ldr	r3, [r3, #4]
200040b8:	4619      	mov	r1, r3
200040ba:	4818      	ldr	r0, [pc, #96]	@ (2000411c <cmd_free+0x7c>)
200040bc:	f7fc ffd8 	bl	20001070 <kfree>
    for (idx = 0; idx < cmd->argc; idx++) {
200040c0:	68fb      	ldr	r3, [r7, #12]
200040c2:	3301      	adds	r3, #1
200040c4:	60fb      	str	r3, [r7, #12]
200040c6:	687b      	ldr	r3, [r7, #4]
200040c8:	681b      	ldr	r3, [r3, #0]
200040ca:	68fa      	ldr	r2, [r7, #12]
200040cc:	429a      	cmp	r2, r3
200040ce:	dbee      	blt.n	200040ae <cmd_free+0xe>
	}

    for (idx = 0; idx < cmd->swc; idx++) {
200040d0:	2300      	movs	r3, #0
200040d2:	60fb      	str	r3, [r7, #12]
200040d4:	e010      	b.n	200040f8 <cmd_free+0x58>
	KFREE(cmd->swv[idx].swname);
200040d6:	6879      	ldr	r1, [r7, #4]
200040d8:	68fa      	ldr	r2, [r7, #12]
200040da:	4613      	mov	r3, r2
200040dc:	005b      	lsls	r3, r3, #1
200040de:	4413      	add	r3, r2
200040e0:	009b      	lsls	r3, r3, #2
200040e2:	440b      	add	r3, r1
200040e4:	f503 7386 	add.w	r3, r3, #268	@ 0x10c
200040e8:	681b      	ldr	r3, [r3, #0]
200040ea:	4619      	mov	r1, r3
200040ec:	480b      	ldr	r0, [pc, #44]	@ (2000411c <cmd_free+0x7c>)
200040ee:	f7fc ffbf 	bl	20001070 <kfree>
    for (idx = 0; idx < cmd->swc; idx++) {
200040f2:	68fb      	ldr	r3, [r7, #12]
200040f4:	3301      	adds	r3, #1
200040f6:	60fb      	str	r3, [r7, #12]
200040f8:	687b      	ldr	r3, [r7, #4]
200040fa:	f8d3 3104 	ldr.w	r3, [r3, #260]	@ 0x104
200040fe:	68fa      	ldr	r2, [r7, #12]
20004100:	429a      	cmp	r2, r3
20004102:	dbe8      	blt.n	200040d6 <cmd_free+0x36>
	}

    cmd->argc = 0;
20004104:	687b      	ldr	r3, [r7, #4]
20004106:	2200      	movs	r2, #0
20004108:	601a      	str	r2, [r3, #0]
    cmd->swc = 0;
2000410a:	687b      	ldr	r3, [r7, #4]
2000410c:	2200      	movs	r2, #0
2000410e:	f8c3 2104 	str.w	r2, [r3, #260]	@ 0x104
}
20004112:	bf00      	nop
20004114:	3710      	adds	r7, #16
20004116:	46bd      	mov	sp, r7
20004118:	bd80      	pop	{r7, pc}
2000411a:	bf00      	nop
2000411c:	200091fc 	.word	0x200091fc

20004120 <cmd_sw_validate>:

int cmd_sw_validate(ui_cmdline_t *cmd,char *validstr)
{
20004120:	b580      	push	{r7, lr}
20004122:	b08a      	sub	sp, #40	@ 0x28
20004124:	af00      	add	r7, sp, #0
20004126:	6078      	str	r0, [r7, #4]
20004128:	6039      	str	r1, [r7, #0]
    char atype;
    char *x;
    int idx;
    int valid;

    if (cmd->swc == 0) return -1;
2000412a:	687b      	ldr	r3, [r7, #4]
2000412c:	f8d3 3104 	ldr.w	r3, [r3, #260]	@ 0x104
20004130:	2b00      	cmp	r3, #0
20004132:	d102      	bne.n	2000413a <cmd_sw_validate+0x1a>
20004134:	f04f 33ff 	mov.w	r3, #4294967295	@ 0xffffffff
20004138:	e094      	b.n	20004264 <cmd_sw_validate+0x144>

    vdup = strdup(validstr);
2000413a:	6838      	ldr	r0, [r7, #0]
2000413c:	f7fd fc06 	bl	2000194c <lib_strdup>
20004140:	6138      	str	r0, [r7, #16]

    for (idx = 0; idx < cmd->swc; idx++) {
20004142:	2300      	movs	r3, #0
20004144:	61bb      	str	r3, [r7, #24]
20004146:	e080      	b.n	2000424a <cmd_sw_validate+0x12a>
	vptr = vdup;
20004148:	693b      	ldr	r3, [r7, #16]
2000414a:	627b      	str	r3, [r7, #36]	@ 0x24

	vnext = vptr;
2000414c:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
2000414e:	623b      	str	r3, [r7, #32]
	valid = 0;
20004150:	2300      	movs	r3, #0
20004152:	617b      	str	r3, [r7, #20]

	while (vnext) {
20004154:	e06a      	b.n	2000422c <cmd_sw_validate+0x10c>

	    /*
	     * Eat the next switch description from the valid string
	     */
	    x = strchr(vptr,'|');
20004156:	217c      	movs	r1, #124	@ 0x7c
20004158:	6a78      	ldr	r0, [r7, #36]	@ 0x24
2000415a:	f7fd f9fd 	bl	20001558 <lib_strchr>
2000415e:	60f8      	str	r0, [r7, #12]
	    if (x) {
20004160:	68fb      	ldr	r3, [r7, #12]
20004162:	2b00      	cmp	r3, #0
20004164:	d006      	beq.n	20004174 <cmd_sw_validate+0x54>
		*x = '\0';
20004166:	68fb      	ldr	r3, [r7, #12]
20004168:	2200      	movs	r2, #0
2000416a:	701a      	strb	r2, [r3, #0]
		vnext = x+1;
2000416c:	68fb      	ldr	r3, [r7, #12]
2000416e:	3301      	adds	r3, #1
20004170:	623b      	str	r3, [r7, #32]
20004172:	e001      	b.n	20004178 <cmd_sw_validate+0x58>
		}
	    else {
		vnext = NULL;
20004174:	2300      	movs	r3, #0
20004176:	623b      	str	r3, [r7, #32]
		}

	    /*
	     * Get the expected arg type, if any 
	     */
	    x = strchr(vptr,'=');
20004178:	213d      	movs	r1, #61	@ 0x3d
2000417a:	6a78      	ldr	r0, [r7, #36]	@ 0x24
2000417c:	f7fd f9ec 	bl	20001558 <lib_strchr>
20004180:	60f8      	str	r0, [r7, #12]
	    if (x) {
20004182:	68fb      	ldr	r3, [r7, #12]
20004184:	2b00      	cmp	r3, #0
20004186:	d006      	beq.n	20004196 <cmd_sw_validate+0x76>
		atype = *(x+1);
20004188:	68fb      	ldr	r3, [r7, #12]
2000418a:	785b      	ldrb	r3, [r3, #1]
2000418c:	77fb      	strb	r3, [r7, #31]
		*x = 0;
2000418e:	68fb      	ldr	r3, [r7, #12]
20004190:	2200      	movs	r2, #0
20004192:	701a      	strb	r2, [r3, #0]
20004194:	e00c      	b.n	200041b0 <cmd_sw_validate+0x90>
		}
	    else {
		if ((x = strchr(vptr,';'))) *x = 0;
20004196:	213b      	movs	r1, #59	@ 0x3b
20004198:	6a78      	ldr	r0, [r7, #36]	@ 0x24
2000419a:	f7fd f9dd 	bl	20001558 <lib_strchr>
2000419e:	60f8      	str	r0, [r7, #12]
200041a0:	68fb      	ldr	r3, [r7, #12]
200041a2:	2b00      	cmp	r3, #0
200041a4:	d002      	beq.n	200041ac <cmd_sw_validate+0x8c>
200041a6:	68fb      	ldr	r3, [r7, #12]
200041a8:	2200      	movs	r2, #0
200041aa:	701a      	strb	r2, [r3, #0]
		atype = 0;
200041ac:	2300      	movs	r3, #0
200041ae:	77fb      	strb	r3, [r7, #31]
	     * See if this matches what the user typed
	     * XXX for now, ignore the arg type processing but
	     * complain if an arg is missing.
	     */

	    if (strcmp(vptr,cmd->swv[idx].swname) == 0) {
200041b0:	6879      	ldr	r1, [r7, #4]
200041b2:	69ba      	ldr	r2, [r7, #24]
200041b4:	4613      	mov	r3, r2
200041b6:	005b      	lsls	r3, r3, #1
200041b8:	4413      	add	r3, r2
200041ba:	009b      	lsls	r3, r3, #2
200041bc:	440b      	add	r3, r1
200041be:	f503 7386 	add.w	r3, r3, #268	@ 0x10c
200041c2:	681b      	ldr	r3, [r3, #0]
200041c4:	4619      	mov	r1, r3
200041c6:	6a78      	ldr	r0, [r7, #36]	@ 0x24
200041c8:	f7fd f985 	bl	200014d6 <lib_strcmp>
200041cc:	4603      	mov	r3, r0
200041ce:	2b00      	cmp	r3, #0
200041d0:	d126      	bne.n	20004220 <cmd_sw_validate+0x100>
		/* Value not needed and not supplied */
		if ((atype == 0) && (cmd->swv[idx].swvalue == NULL)) {
200041d2:	7ffb      	ldrb	r3, [r7, #31]
200041d4:	2b00      	cmp	r3, #0
200041d6:	d10d      	bne.n	200041f4 <cmd_sw_validate+0xd4>
200041d8:	6879      	ldr	r1, [r7, #4]
200041da:	69ba      	ldr	r2, [r7, #24]
200041dc:	4613      	mov	r3, r2
200041de:	005b      	lsls	r3, r3, #1
200041e0:	4413      	add	r3, r2
200041e2:	009b      	lsls	r3, r3, #2
200041e4:	440b      	add	r3, r1
200041e6:	f503 7388 	add.w	r3, r3, #272	@ 0x110
200041ea:	681b      	ldr	r3, [r3, #0]
200041ec:	2b00      	cmp	r3, #0
200041ee:	d101      	bne.n	200041f4 <cmd_sw_validate+0xd4>
		    valid = 1;
200041f0:	2301      	movs	r3, #1
200041f2:	617b      	str	r3, [r7, #20]
		    }
		/* value needed and supplied */
		if ((atype != 0) && (cmd->swv[idx].swvalue != NULL)) {
200041f4:	7ffb      	ldrb	r3, [r7, #31]
200041f6:	2b00      	cmp	r3, #0
200041f8:	d00d      	beq.n	20004216 <cmd_sw_validate+0xf6>
200041fa:	6879      	ldr	r1, [r7, #4]
200041fc:	69ba      	ldr	r2, [r7, #24]
200041fe:	4613      	mov	r3, r2
20004200:	005b      	lsls	r3, r3, #1
20004202:	4413      	add	r3, r2
20004204:	009b      	lsls	r3, r3, #2
20004206:	440b      	add	r3, r1
20004208:	f503 7388 	add.w	r3, r3, #272	@ 0x110
2000420c:	681b      	ldr	r3, [r3, #0]
2000420e:	2b00      	cmp	r3, #0
20004210:	d001      	beq.n	20004216 <cmd_sw_validate+0xf6>
		    valid = 1;
20004212:	2301      	movs	r3, #1
20004214:	617b      	str	r3, [r7, #20]
		    }
		strcpy(vdup,validstr);
20004216:	6839      	ldr	r1, [r7, #0]
20004218:	6938      	ldr	r0, [r7, #16]
2000421a:	f7fd f8fc 	bl	20001416 <lib_strcpy>
		break;
2000421e:	e008      	b.n	20004232 <cmd_sw_validate+0x112>

	    /*
	     * Otherwise, next!
	     */

	    strcpy(vdup,validstr);
20004220:	6839      	ldr	r1, [r7, #0]
20004222:	6938      	ldr	r0, [r7, #16]
20004224:	f7fd f8f7 	bl	20001416 <lib_strcpy>
	    vptr = vnext;
20004228:	6a3b      	ldr	r3, [r7, #32]
2000422a:	627b      	str	r3, [r7, #36]	@ 0x24
	while (vnext) {
2000422c:	6a3b      	ldr	r3, [r7, #32]
2000422e:	2b00      	cmp	r3, #0
20004230:	d191      	bne.n	20004156 <cmd_sw_validate+0x36>

	/*
	 * If not valid, return index of bad switch
	 */

	if (valid == 0) {
20004232:	697b      	ldr	r3, [r7, #20]
20004234:	2b00      	cmp	r3, #0
20004236:	d105      	bne.n	20004244 <cmd_sw_validate+0x124>
	    KFREE(vdup);
20004238:	6939      	ldr	r1, [r7, #16]
2000423a:	480c      	ldr	r0, [pc, #48]	@ (2000426c <cmd_sw_validate+0x14c>)
2000423c:	f7fc ff18 	bl	20001070 <kfree>
	    return idx;
20004240:	69bb      	ldr	r3, [r7, #24]
20004242:	e00f      	b.n	20004264 <cmd_sw_validate+0x144>
    for (idx = 0; idx < cmd->swc; idx++) {
20004244:	69bb      	ldr	r3, [r7, #24]
20004246:	3301      	adds	r3, #1
20004248:	61bb      	str	r3, [r7, #24]
2000424a:	687b      	ldr	r3, [r7, #4]
2000424c:	f8d3 3104 	ldr.w	r3, [r3, #260]	@ 0x104
20004250:	69ba      	ldr	r2, [r7, #24]
20004252:	429a      	cmp	r2, r3
20004254:	f6ff af78 	blt.w	20004148 <cmd_sw_validate+0x28>
    /*
     * Return -1 if everything went well.  A little strange,
     * but it's easier this way.
     */

    KFREE(vdup);
20004258:	6939      	ldr	r1, [r7, #16]
2000425a:	4804      	ldr	r0, [pc, #16]	@ (2000426c <cmd_sw_validate+0x14c>)
2000425c:	f7fc ff08 	bl	20001070 <kfree>
    return -1;
20004260:	f04f 33ff 	mov.w	r3, #4294967295	@ 0xffffffff
}
20004264:	4618      	mov	r0, r3
20004266:	3728      	adds	r7, #40	@ 0x28
20004268:	46bd      	mov	sp, r7
2000426a:	bd80      	pop	{r7, pc}
2000426c:	200091fc 	.word	0x200091fc

20004270 <cmd_findword>:

static cmdtab_t *cmd_findword(cmdtab_t *list,char *cmdword)
{
20004270:	b580      	push	{r7, lr}
20004272:	b082      	sub	sp, #8
20004274:	af00      	add	r7, sp, #0
20004276:	6078      	str	r0, [r7, #4]
20004278:	6039      	str	r1, [r7, #0]
    while (list) {
2000427a:	e00d      	b.n	20004298 <cmd_findword+0x28>
	if (strcmp(cmdword,list->cmdword) == 0) return list;
2000427c:	687b      	ldr	r3, [r7, #4]
2000427e:	689b      	ldr	r3, [r3, #8]
20004280:	4619      	mov	r1, r3
20004282:	6838      	ldr	r0, [r7, #0]
20004284:	f7fd f927 	bl	200014d6 <lib_strcmp>
20004288:	4603      	mov	r3, r0
2000428a:	2b00      	cmp	r3, #0
2000428c:	d101      	bne.n	20004292 <cmd_findword+0x22>
2000428e:	687b      	ldr	r3, [r7, #4]
20004290:	e006      	b.n	200042a0 <cmd_findword+0x30>
	list = list->sibling;
20004292:	687b      	ldr	r3, [r7, #4]
20004294:	681b      	ldr	r3, [r3, #0]
20004296:	607b      	str	r3, [r7, #4]
    while (list) {
20004298:	687b      	ldr	r3, [r7, #4]
2000429a:	2b00      	cmp	r3, #0
2000429c:	d1ee      	bne.n	2000427c <cmd_findword+0xc>
	}

    return NULL;
2000429e:	2300      	movs	r3, #0
}
200042a0:	4618      	mov	r0, r3
200042a2:	3708      	adds	r7, #8
200042a4:	46bd      	mov	sp, r7
200042a6:	bd80      	pop	{r7, pc}

200042a8 <cmd_build_cmdline>:


void cmd_build_cmdline(queue_t *head, ui_cmdline_t *cmd)
{
200042a8:	b590      	push	{r4, r7, lr}
200042aa:	b085      	sub	sp, #20
200042ac:	af00      	add	r7, sp, #0
200042ae:	6078      	str	r0, [r7, #4]
200042b0:	6039      	str	r1, [r7, #0]
    ui_token_t *t;
    ui_token_t *next;

    memset(cmd, 0, sizeof(ui_cmdline_t));
200042b2:	f44f 72ee 	mov.w	r2, #476	@ 0x1dc
200042b6:	2100      	movs	r1, #0
200042b8:	6838      	ldr	r0, [r7, #0]
200042ba:	f7fd f9b8 	bl	2000162e <lib_memset>

    t = (ui_token_t *) q_deqnext(head);
200042be:	6878      	ldr	r0, [r7, #4]
200042c0:	f7fd f86f 	bl	200013a2 <q_deqnext>
200042c4:	60f8      	str	r0, [r7, #12]

    while (t != NULL) {
200042c6:	e092      	b.n	200043ee <cmd_build_cmdline+0x146>
	if (is_white_space(t)) {
200042c8:	68f8      	ldr	r0, [r7, #12]
200042ca:	f7ff fe31 	bl	20003f30 <is_white_space>
200042ce:	4603      	mov	r3, r0
200042d0:	2b00      	cmp	r3, #0
200042d2:	f040 8084 	bne.w	200043de <cmd_build_cmdline+0x136>
	    /* do nothing */
	    } 
	else if (t->token != '-') {
200042d6:	68fb      	ldr	r3, [r7, #12]
200042d8:	7a1b      	ldrb	r3, [r3, #8]
200042da:	2b2d      	cmp	r3, #45	@ 0x2d
200042dc:	d014      	beq.n	20004308 <cmd_build_cmdline+0x60>
	    if(cmd->argc < MAX_TOKENS){
200042de:	683b      	ldr	r3, [r7, #0]
200042e0:	681b      	ldr	r3, [r3, #0]
200042e2:	2b3f      	cmp	r3, #63	@ 0x3f
200042e4:	dc7b      	bgt.n	200043de <cmd_build_cmdline+0x136>
		cmd->argv[cmd->argc] = cmd_eat_quoted_arg(head,t);
200042e6:	683b      	ldr	r3, [r7, #0]
200042e8:	681c      	ldr	r4, [r3, #0]
200042ea:	68f9      	ldr	r1, [r7, #12]
200042ec:	6878      	ldr	r0, [r7, #4]
200042ee:	f000 fdd3 	bl	20004e98 <cmd_eat_quoted_arg>
200042f2:	4601      	mov	r1, r0
200042f4:	683a      	ldr	r2, [r7, #0]
200042f6:	00a3      	lsls	r3, r4, #2
200042f8:	4413      	add	r3, r2
200042fa:	6059      	str	r1, [r3, #4]
		cmd->argc++;
200042fc:	683b      	ldr	r3, [r7, #0]
200042fe:	681b      	ldr	r3, [r3, #0]
20004300:	1c5a      	adds	r2, r3, #1
20004302:	683b      	ldr	r3, [r7, #0]
20004304:	601a      	str	r2, [r3, #0]
20004306:	e06a      	b.n	200043de <cmd_build_cmdline+0x136>
		}
	    /* Token is a switch */
	    }
	else {
	    if (cmd->swc < MAX_SWITCHES) {
20004308:	683b      	ldr	r3, [r7, #0]
2000430a:	f8d3 3104 	ldr.w	r3, [r3, #260]	@ 0x104
2000430e:	2b0f      	cmp	r3, #15
20004310:	dc65      	bgt.n	200043de <cmd_build_cmdline+0x136>
		cmd->swv[cmd->swc].swname = lib_strdup(&(t->token));
20004312:	68fb      	ldr	r3, [r7, #12]
20004314:	f103 0208 	add.w	r2, r3, #8
20004318:	683b      	ldr	r3, [r7, #0]
2000431a:	f8d3 4104 	ldr.w	r4, [r3, #260]	@ 0x104
2000431e:	4610      	mov	r0, r2
20004320:	f7fd fb14 	bl	2000194c <lib_strdup>
20004324:	4601      	mov	r1, r0
20004326:	683a      	ldr	r2, [r7, #0]
20004328:	4623      	mov	r3, r4
2000432a:	005b      	lsls	r3, r3, #1
2000432c:	4423      	add	r3, r4
2000432e:	009b      	lsls	r3, r3, #2
20004330:	4413      	add	r3, r2
20004332:	f503 7386 	add.w	r3, r3, #268	@ 0x10c
20004336:	6019      	str	r1, [r3, #0]

		if (t->qb.q_next != head) {			/* more tokens */
20004338:	68fb      	ldr	r3, [r7, #12]
2000433a:	681b      	ldr	r3, [r3, #0]
2000433c:	687a      	ldr	r2, [r7, #4]
2000433e:	429a      	cmp	r2, r3
20004340:	d038      	beq.n	200043b4 <cmd_build_cmdline+0x10c>
		    next = (ui_token_t *) t->qb.q_next;
20004342:	68fb      	ldr	r3, [r7, #12]
20004344:	681b      	ldr	r3, [r3, #0]
20004346:	60bb      	str	r3, [r7, #8]
		    if (next->token == '=') {			/* switch has value */
20004348:	68bb      	ldr	r3, [r7, #8]
2000434a:	7a1b      	ldrb	r3, [r3, #8]
2000434c:	2b3d      	cmp	r3, #61	@ 0x3d
2000434e:	d124      	bne.n	2000439a <cmd_build_cmdline+0xf2>
			KFREE(t);				/* Free switch name */
20004350:	68f9      	ldr	r1, [r7, #12]
20004352:	482b      	ldr	r0, [pc, #172]	@ (20004400 <cmd_build_cmdline+0x158>)
20004354:	f7fc fe8c 	bl	20001070 <kfree>
			t = (ui_token_t *) q_deqnext(head);	/* eat equal sign */
20004358:	6878      	ldr	r0, [r7, #4]
2000435a:	f7fd f822 	bl	200013a2 <q_deqnext>
2000435e:	60f8      	str	r0, [r7, #12]
			KFREE(t);				/* and free it */
20004360:	68f9      	ldr	r1, [r7, #12]
20004362:	4827      	ldr	r0, [pc, #156]	@ (20004400 <cmd_build_cmdline+0x158>)
20004364:	f7fc fe84 	bl	20001070 <kfree>
			t = (ui_token_t *) q_deqnext(head);	/* now have value */
20004368:	6878      	ldr	r0, [r7, #4]
2000436a:	f7fd f81a 	bl	200013a2 <q_deqnext>
2000436e:	60f8      	str	r0, [r7, #12]
			if (t != NULL) {
20004370:	68fb      	ldr	r3, [r7, #12]
20004372:	2b00      	cmp	r3, #0
20004374:	d01e      	beq.n	200043b4 <cmd_build_cmdline+0x10c>
			    cmd->swv[cmd->swc].swvalue = cmd_eat_quoted_arg(head,t);
20004376:	683b      	ldr	r3, [r7, #0]
20004378:	f8d3 4104 	ldr.w	r4, [r3, #260]	@ 0x104
2000437c:	68f9      	ldr	r1, [r7, #12]
2000437e:	6878      	ldr	r0, [r7, #4]
20004380:	f000 fd8a 	bl	20004e98 <cmd_eat_quoted_arg>
20004384:	4601      	mov	r1, r0
20004386:	683a      	ldr	r2, [r7, #0]
20004388:	4623      	mov	r3, r4
2000438a:	005b      	lsls	r3, r3, #1
2000438c:	4423      	add	r3, r4
2000438e:	009b      	lsls	r3, r3, #2
20004390:	4413      	add	r3, r2
20004392:	f503 7388 	add.w	r3, r3, #272	@ 0x110
20004396:	6019      	str	r1, [r3, #0]
20004398:	e00c      	b.n	200043b4 <cmd_build_cmdline+0x10c>
			    }
			}
		    else {					/* no value */
			cmd->swv[cmd->swc].swvalue = NULL;
2000439a:	683b      	ldr	r3, [r7, #0]
2000439c:	f8d3 2104 	ldr.w	r2, [r3, #260]	@ 0x104
200043a0:	6839      	ldr	r1, [r7, #0]
200043a2:	4613      	mov	r3, r2
200043a4:	005b      	lsls	r3, r3, #1
200043a6:	4413      	add	r3, r2
200043a8:	009b      	lsls	r3, r3, #2
200043aa:	440b      	add	r3, r1
200043ac:	f503 7388 	add.w	r3, r3, #272	@ 0x110
200043b0:	2200      	movs	r2, #0
200043b2:	601a      	str	r2, [r3, #0]
		/* 
		 * swidx is the index of the argument that this
		 * switch precedes.  So, if you have "foo -d bar",
		 * swidx for "-d" would be 1.
		 */
		cmd->swv[cmd->swc].swidx = cmd->argc;
200043b4:	683b      	ldr	r3, [r7, #0]
200043b6:	f8d3 2104 	ldr.w	r2, [r3, #260]	@ 0x104
200043ba:	683b      	ldr	r3, [r7, #0]
200043bc:	6819      	ldr	r1, [r3, #0]
200043be:	6838      	ldr	r0, [r7, #0]
200043c0:	4613      	mov	r3, r2
200043c2:	005b      	lsls	r3, r3, #1
200043c4:	4413      	add	r3, r2
200043c6:	009b      	lsls	r3, r3, #2
200043c8:	4403      	add	r3, r0
200043ca:	f503 7384 	add.w	r3, r3, #264	@ 0x108
200043ce:	6019      	str	r1, [r3, #0]
		cmd->swc++;	
200043d0:	683b      	ldr	r3, [r7, #0]
200043d2:	f8d3 3104 	ldr.w	r3, [r3, #260]	@ 0x104
200043d6:	1c5a      	adds	r2, r3, #1
200043d8:	683b      	ldr	r3, [r7, #0]
200043da:	f8c3 2104 	str.w	r2, [r3, #260]	@ 0x104
		}
	    }
	KFREE(t);
200043de:	68f9      	ldr	r1, [r7, #12]
200043e0:	4807      	ldr	r0, [pc, #28]	@ (20004400 <cmd_build_cmdline+0x158>)
200043e2:	f7fc fe45 	bl	20001070 <kfree>
	t = (ui_token_t *) q_deqnext(head);
200043e6:	6878      	ldr	r0, [r7, #4]
200043e8:	f7fc ffdb 	bl	200013a2 <q_deqnext>
200043ec:	60f8      	str	r0, [r7, #12]
    while (t != NULL) {
200043ee:	68fb      	ldr	r3, [r7, #12]
200043f0:	2b00      	cmp	r3, #0
200043f2:	f47f af69 	bne.w	200042c8 <cmd_build_cmdline+0x20>
	for (idx = 0; idx < cmd->swc; idx++) printf("switch[%s] = [%s]\n",cmd->swv[idx].swname,
						    cmd->swv[idx].swvalue);
	}
#endif

}
200043f6:	bf00      	nop
200043f8:	bf00      	nop
200043fa:	3714      	adds	r7, #20
200043fc:	46bd      	mov	sp, r7
200043fe:	bd90      	pop	{r4, r7, pc}
20004400:	200091fc 	.word	0x200091fc

20004404 <cmd_addcmd>:
	       int (*func)(ui_cmdline_t *,int argc,char *argv[]),
	       void *ref,
	       char *help,
	       char *usage,
	       char *switches)
{
20004404:	b580      	push	{r7, lr}
20004406:	b08a      	sub	sp, #40	@ 0x28
20004408:	af00      	add	r7, sp, #0
2000440a:	60f8      	str	r0, [r7, #12]
2000440c:	60b9      	str	r1, [r7, #8]
2000440e:	607a      	str	r2, [r7, #4]
20004410:	603b      	str	r3, [r7, #0]
    cmdtab_t **list = &cmd_root;
20004412:	4b38      	ldr	r3, [pc, #224]	@ (200044f4 <cmd_addcmd+0xf0>)
20004414:	627b      	str	r3, [r7, #36]	@ 0x24
    cmdtab_t *cmd = NULL;
20004416:	2300      	movs	r3, #0
20004418:	623b      	str	r3, [r7, #32]
    queue_t tokens;
    queue_t *cur;
    ui_token_t *t;

    cmd_build_list(&tokens,command);
2000441a:	f107 0310 	add.w	r3, r7, #16
2000441e:	68f9      	ldr	r1, [r7, #12]
20004420:	4618      	mov	r0, r3
20004422:	f000 fc6b 	bl	20004cfc <cmd_build_list>
    cur = tokens.q_next;
20004426:	693b      	ldr	r3, [r7, #16]
20004428:	61fb      	str	r3, [r7, #28]

    while (cur != &tokens) {
2000442a:	e03f      	b.n	200044ac <cmd_addcmd+0xa8>
	t = (ui_token_t *) cur;
2000442c:	69fb      	ldr	r3, [r7, #28]
2000442e:	61bb      	str	r3, [r7, #24]
	if (!is_white_space(t)) {
20004430:	69b8      	ldr	r0, [r7, #24]
20004432:	f7ff fd7d 	bl	20003f30 <is_white_space>
20004436:	4603      	mov	r3, r0
20004438:	2b00      	cmp	r3, #0
2000443a:	d134      	bne.n	200044a6 <cmd_addcmd+0xa2>
	    cmd = cmd_findword(*list,&(t->token));
2000443c:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
2000443e:	681a      	ldr	r2, [r3, #0]
20004440:	69bb      	ldr	r3, [r7, #24]
20004442:	3308      	adds	r3, #8
20004444:	4619      	mov	r1, r3
20004446:	4610      	mov	r0, r2
20004448:	f7ff ff12 	bl	20004270 <cmd_findword>
2000444c:	6238      	str	r0, [r7, #32]
	    if (!cmd) {
2000444e:	6a3b      	ldr	r3, [r7, #32]
20004450:	2b00      	cmp	r3, #0
20004452:	d125      	bne.n	200044a0 <cmd_addcmd+0x9c>
		cmd = KMALLOC(sizeof(cmdtab_t)+strlen(&(t->token))+1,0);
20004454:	69bb      	ldr	r3, [r7, #24]
20004456:	3308      	adds	r3, #8
20004458:	4618      	mov	r0, r3
2000445a:	f7fd f824 	bl	200014a6 <lib_strlen>
2000445e:	4603      	mov	r3, r0
20004460:	3321      	adds	r3, #33	@ 0x21
20004462:	2200      	movs	r2, #0
20004464:	4619      	mov	r1, r3
20004466:	4824      	ldr	r0, [pc, #144]	@ (200044f8 <cmd_addcmd+0xf4>)
20004468:	f7fc fe36 	bl	200010d8 <kmalloc>
2000446c:	6238      	str	r0, [r7, #32]
		memset(cmd,0,sizeof(cmdtab_t));
2000446e:	2220      	movs	r2, #32
20004470:	2100      	movs	r1, #0
20004472:	6a38      	ldr	r0, [r7, #32]
20004474:	f7fd f8db 	bl	2000162e <lib_memset>
		cmd->cmdword = (char *) (cmd+1);
20004478:	6a3b      	ldr	r3, [r7, #32]
2000447a:	f103 0220 	add.w	r2, r3, #32
2000447e:	6a3b      	ldr	r3, [r7, #32]
20004480:	609a      	str	r2, [r3, #8]
		strcpy(cmd->cmdword,&(t->token));
20004482:	6a3b      	ldr	r3, [r7, #32]
20004484:	689a      	ldr	r2, [r3, #8]
20004486:	69bb      	ldr	r3, [r7, #24]
20004488:	3308      	adds	r3, #8
2000448a:	4619      	mov	r1, r3
2000448c:	4610      	mov	r0, r2
2000448e:	f7fc ffc2 	bl	20001416 <lib_strcpy>
		cmd->sibling = *list;
20004492:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
20004494:	681a      	ldr	r2, [r3, #0]
20004496:	6a3b      	ldr	r3, [r7, #32]
20004498:	601a      	str	r2, [r3, #0]
		*list = cmd;
2000449a:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
2000449c:	6a3a      	ldr	r2, [r7, #32]
2000449e:	601a      	str	r2, [r3, #0]
		}
	    list = &(cmd->child);
200044a0:	6a3b      	ldr	r3, [r7, #32]
200044a2:	3304      	adds	r3, #4
200044a4:	627b      	str	r3, [r7, #36]	@ 0x24
	    }
	cur = cur->q_next;
200044a6:	69fb      	ldr	r3, [r7, #28]
200044a8:	681b      	ldr	r3, [r3, #0]
200044aa:	61fb      	str	r3, [r7, #28]
    while (cur != &tokens) {
200044ac:	f107 0310 	add.w	r3, r7, #16
200044b0:	69fa      	ldr	r2, [r7, #28]
200044b2:	429a      	cmp	r2, r3
200044b4:	d1ba      	bne.n	2000442c <cmd_addcmd+0x28>
	}

    cmd_free_tokens(&tokens);
200044b6:	f107 0310 	add.w	r3, r7, #16
200044ba:	4618      	mov	r0, r3
200044bc:	f000 fe2a 	bl	20005114 <cmd_free_tokens>

    if (!cmd) return -1;
200044c0:	6a3b      	ldr	r3, [r7, #32]
200044c2:	2b00      	cmp	r3, #0
200044c4:	d102      	bne.n	200044cc <cmd_addcmd+0xc8>
200044c6:	f04f 33ff 	mov.w	r3, #4294967295	@ 0xffffffff
200044ca:	e00f      	b.n	200044ec <cmd_addcmd+0xe8>

    cmd->func = func;
200044cc:	6a3b      	ldr	r3, [r7, #32]
200044ce:	68ba      	ldr	r2, [r7, #8]
200044d0:	60da      	str	r2, [r3, #12]
    cmd->usage = usage;
200044d2:	6a3b      	ldr	r3, [r7, #32]
200044d4:	6b3a      	ldr	r2, [r7, #48]	@ 0x30
200044d6:	619a      	str	r2, [r3, #24]
    cmd->ref = ref;
200044d8:	6a3b      	ldr	r3, [r7, #32]
200044da:	687a      	ldr	r2, [r7, #4]
200044dc:	611a      	str	r2, [r3, #16]
    cmd->help = help;
200044de:	6a3b      	ldr	r3, [r7, #32]
200044e0:	683a      	ldr	r2, [r7, #0]
200044e2:	615a      	str	r2, [r3, #20]
    cmd->switches = switches;
200044e4:	6a3b      	ldr	r3, [r7, #32]
200044e6:	6b7a      	ldr	r2, [r7, #52]	@ 0x34
200044e8:	61da      	str	r2, [r3, #28]

    return 0;
200044ea:	2300      	movs	r3, #0
}
200044ec:	4618      	mov	r0, r3
200044ee:	3728      	adds	r7, #40	@ 0x28
200044f0:	46bd      	mov	sp, r7
200044f2:	bd80      	pop	{r7, pc}
200044f4:	20009474 	.word	0x20009474
200044f8:	200091fc 	.word	0x200091fc

200044fc <_dumpindented>:



static void _dumpindented(char *str,int amt)
{
200044fc:	b580      	push	{r7, lr}
200044fe:	b086      	sub	sp, #24
20004500:	af00      	add	r7, sp, #0
20004502:	6078      	str	r0, [r7, #4]
20004504:	6039      	str	r1, [r7, #0]
    int idx;
    char *dupstr;
    char *end;
    char *ptr;

    dupstr = strdup(str);
20004506:	6878      	ldr	r0, [r7, #4]
20004508:	f7fd fa20 	bl	2000194c <lib_strdup>
2000450c:	60b8      	str	r0, [r7, #8]

    ptr = dupstr;
2000450e:	68bb      	ldr	r3, [r7, #8]
20004510:	60fb      	str	r3, [r7, #12]

    while (*ptr) {
20004512:	e028      	b.n	20004566 <_dumpindented+0x6a>
	for (idx = 0; idx < amt; idx++) printf(" ");
20004514:	2300      	movs	r3, #0
20004516:	617b      	str	r3, [r7, #20]
20004518:	e005      	b.n	20004526 <_dumpindented+0x2a>
2000451a:	4819      	ldr	r0, [pc, #100]	@ (20004580 <_dumpindented+0x84>)
2000451c:	f7fc fc22 	bl	20000d64 <printf>
20004520:	697b      	ldr	r3, [r7, #20]
20004522:	3301      	adds	r3, #1
20004524:	617b      	str	r3, [r7, #20]
20004526:	697a      	ldr	r2, [r7, #20]
20004528:	683b      	ldr	r3, [r7, #0]
2000452a:	429a      	cmp	r2, r3
2000452c:	dbf5      	blt.n	2000451a <_dumpindented+0x1e>

	end = strchr(ptr,'\n');
2000452e:	210a      	movs	r1, #10
20004530:	68f8      	ldr	r0, [r7, #12]
20004532:	f7fd f811 	bl	20001558 <lib_strchr>
20004536:	6138      	str	r0, [r7, #16]

	if (end) *end++ = '\0';
20004538:	693b      	ldr	r3, [r7, #16]
2000453a:	2b00      	cmp	r3, #0
2000453c:	d005      	beq.n	2000454a <_dumpindented+0x4e>
2000453e:	693b      	ldr	r3, [r7, #16]
20004540:	1c5a      	adds	r2, r3, #1
20004542:	613a      	str	r2, [r7, #16]
20004544:	2200      	movs	r2, #0
20004546:	701a      	strb	r2, [r3, #0]
20004548:	e007      	b.n	2000455a <_dumpindented+0x5e>
	else end = ptr + strlen(ptr);
2000454a:	68f8      	ldr	r0, [r7, #12]
2000454c:	f7fc ffab 	bl	200014a6 <lib_strlen>
20004550:	4603      	mov	r3, r0
20004552:	461a      	mov	r2, r3
20004554:	68fb      	ldr	r3, [r7, #12]
20004556:	4413      	add	r3, r2
20004558:	613b      	str	r3, [r7, #16]

	printf("%s\n",ptr);
2000455a:	68f9      	ldr	r1, [r7, #12]
2000455c:	4809      	ldr	r0, [pc, #36]	@ (20004584 <_dumpindented+0x88>)
2000455e:	f7fc fc01 	bl	20000d64 <printf>
	ptr = end;
20004562:	693b      	ldr	r3, [r7, #16]
20004564:	60fb      	str	r3, [r7, #12]
    while (*ptr) {
20004566:	68fb      	ldr	r3, [r7, #12]
20004568:	781b      	ldrb	r3, [r3, #0]
2000456a:	2b00      	cmp	r3, #0
2000456c:	d1d2      	bne.n	20004514 <_dumpindented+0x18>
	}

    KFREE(dupstr);
2000456e:	68b9      	ldr	r1, [r7, #8]
20004570:	4805      	ldr	r0, [pc, #20]	@ (20004588 <_dumpindented+0x8c>)
20004572:	f7fc fd7d 	bl	20001070 <kfree>
}
20004576:	bf00      	nop
20004578:	3718      	adds	r7, #24
2000457a:	46bd      	mov	sp, r7
2000457c:	bd80      	pop	{r7, pc}
2000457e:	bf00      	nop
20004580:	20007c48 	.word	0x20007c48
20004584:	20007c4c 	.word	0x20007c4c
20004588:	200091fc 	.word	0x200091fc

2000458c <_dumpswitches>:

static void _dumpswitches(char *str)
{
2000458c:	b580      	push	{r7, lr}
2000458e:	b088      	sub	sp, #32
20004590:	af00      	add	r7, sp, #0
20004592:	6078      	str	r0, [r7, #4]
    char *end;
    char *ptr;
    char *semi;
    char *newline;

    switches = strdup(str);
20004594:	6878      	ldr	r0, [r7, #4]
20004596:	f7fd f9d9 	bl	2000194c <lib_strdup>
2000459a:	6138      	str	r0, [r7, #16]

    ptr = switches;
2000459c:	693b      	ldr	r3, [r7, #16]
2000459e:	61bb      	str	r3, [r7, #24]

    while (*ptr) {
200045a0:	e045      	b.n	2000462e <_dumpswitches+0xa2>
	end = strchr(ptr,'|');
200045a2:	217c      	movs	r1, #124	@ 0x7c
200045a4:	69b8      	ldr	r0, [r7, #24]
200045a6:	f7fc ffd7 	bl	20001558 <lib_strchr>
200045aa:	61f8      	str	r0, [r7, #28]
	if (end) *end++ = '\0';
200045ac:	69fb      	ldr	r3, [r7, #28]
200045ae:	2b00      	cmp	r3, #0
200045b0:	d005      	beq.n	200045be <_dumpswitches+0x32>
200045b2:	69fb      	ldr	r3, [r7, #28]
200045b4:	1c5a      	adds	r2, r3, #1
200045b6:	61fa      	str	r2, [r7, #28]
200045b8:	2200      	movs	r2, #0
200045ba:	701a      	strb	r2, [r3, #0]
200045bc:	e007      	b.n	200045ce <_dumpswitches+0x42>
	else end = ptr + strlen(ptr);
200045be:	69b8      	ldr	r0, [r7, #24]
200045c0:	f7fc ff71 	bl	200014a6 <lib_strlen>
200045c4:	4603      	mov	r3, r0
200045c6:	461a      	mov	r2, r3
200045c8:	69bb      	ldr	r3, [r7, #24]
200045ca:	4413      	add	r3, r2
200045cc:	61fb      	str	r3, [r7, #28]

	printf("     ");
200045ce:	481e      	ldr	r0, [pc, #120]	@ (20004648 <_dumpswitches+0xbc>)
200045d0:	f7fc fbc8 	bl	20000d64 <printf>
	if ((semi = strchr(ptr,';'))) {
200045d4:	213b      	movs	r1, #59	@ 0x3b
200045d6:	69b8      	ldr	r0, [r7, #24]
200045d8:	f7fc ffbe 	bl	20001558 <lib_strchr>
200045dc:	60f8      	str	r0, [r7, #12]
200045de:	68fb      	ldr	r3, [r7, #12]
200045e0:	2b00      	cmp	r3, #0
200045e2:	d01e      	beq.n	20004622 <_dumpswitches+0x96>
	    *semi++ = '\0';
200045e4:	68fb      	ldr	r3, [r7, #12]
200045e6:	1c5a      	adds	r2, r3, #1
200045e8:	60fa      	str	r2, [r7, #12]
200045ea:	2200      	movs	r2, #0
200045ec:	701a      	strb	r2, [r3, #0]
	    newline = strchr(semi,'\n');
200045ee:	210a      	movs	r1, #10
200045f0:	68f8      	ldr	r0, [r7, #12]
200045f2:	f7fc ffb1 	bl	20001558 <lib_strchr>
200045f6:	6178      	str	r0, [r7, #20]
	    if (newline) *newline++ = '\0';
200045f8:	697b      	ldr	r3, [r7, #20]
200045fa:	2b00      	cmp	r3, #0
200045fc:	d004      	beq.n	20004608 <_dumpswitches+0x7c>
200045fe:	697b      	ldr	r3, [r7, #20]
20004600:	1c5a      	adds	r2, r3, #1
20004602:	617a      	str	r2, [r7, #20]
20004604:	2200      	movs	r2, #0
20004606:	701a      	strb	r2, [r3, #0]
	    printf("%-12s %s\n",ptr,semi);
20004608:	68fa      	ldr	r2, [r7, #12]
2000460a:	69b9      	ldr	r1, [r7, #24]
2000460c:	480f      	ldr	r0, [pc, #60]	@ (2000464c <_dumpswitches+0xc0>)
2000460e:	f7fc fba9 	bl	20000d64 <printf>
	    if (newline) _dumpindented(newline,5+12+1);
20004612:	697b      	ldr	r3, [r7, #20]
20004614:	2b00      	cmp	r3, #0
20004616:	d008      	beq.n	2000462a <_dumpswitches+0x9e>
20004618:	2112      	movs	r1, #18
2000461a:	6978      	ldr	r0, [r7, #20]
2000461c:	f7ff ff6e 	bl	200044fc <_dumpindented>
20004620:	e003      	b.n	2000462a <_dumpswitches+0x9e>
	    }
	else {
	    printf("%-12s (no information)\n",ptr);
20004622:	69b9      	ldr	r1, [r7, #24]
20004624:	480a      	ldr	r0, [pc, #40]	@ (20004650 <_dumpswitches+0xc4>)
20004626:	f7fc fb9d 	bl	20000d64 <printf>
	    }
	ptr = end;
2000462a:	69fb      	ldr	r3, [r7, #28]
2000462c:	61bb      	str	r3, [r7, #24]
    while (*ptr) {
2000462e:	69bb      	ldr	r3, [r7, #24]
20004630:	781b      	ldrb	r3, [r3, #0]
20004632:	2b00      	cmp	r3, #0
20004634:	d1b5      	bne.n	200045a2 <_dumpswitches+0x16>
	}

    KFREE(switches);
20004636:	6939      	ldr	r1, [r7, #16]
20004638:	4806      	ldr	r0, [pc, #24]	@ (20004654 <_dumpswitches+0xc8>)
2000463a:	f7fc fd19 	bl	20001070 <kfree>
}
2000463e:	bf00      	nop
20004640:	3720      	adds	r7, #32
20004642:	46bd      	mov	sp, r7
20004644:	bd80      	pop	{r7, pc}
20004646:	bf00      	nop
20004648:	20007c50 	.word	0x20007c50
2000464c:	20007c58 	.word	0x20007c58
20004650:	20007c64 	.word	0x20007c64
20004654:	200091fc 	.word	0x200091fc

20004658 <_dumpcmds>:

static void _dumpcmds(cmdtab_t *cmd,int level,char **words,int verbose)
{
20004658:	b580      	push	{r7, lr}
2000465a:	b086      	sub	sp, #24
2000465c:	af00      	add	r7, sp, #0
2000465e:	60f8      	str	r0, [r7, #12]
20004660:	60b9      	str	r1, [r7, #8]
20004662:	607a      	str	r2, [r7, #4]
20004664:	603b      	str	r3, [r7, #0]
    int idx;
    int len;

    while (cmd) {
20004666:	e06f      	b.n	20004748 <_dumpcmds+0xf0>
	len = 0;
20004668:	2300      	movs	r3, #0
2000466a:	613b      	str	r3, [r7, #16]
	words[level] = cmd->cmdword;
2000466c:	68bb      	ldr	r3, [r7, #8]
2000466e:	009b      	lsls	r3, r3, #2
20004670:	687a      	ldr	r2, [r7, #4]
20004672:	4413      	add	r3, r2
20004674:	68fa      	ldr	r2, [r7, #12]
20004676:	6892      	ldr	r2, [r2, #8]
20004678:	601a      	str	r2, [r3, #0]
	if (cmd->func) {
2000467a:	68fb      	ldr	r3, [r7, #12]
2000467c:	68db      	ldr	r3, [r3, #12]
2000467e:	2b00      	cmp	r3, #0
20004680:	d057      	beq.n	20004732 <_dumpcmds+0xda>
	    for (idx = 0; idx < level; idx++) {
20004682:	2300      	movs	r3, #0
20004684:	617b      	str	r3, [r7, #20]
20004686:	e018      	b.n	200046ba <_dumpcmds+0x62>
		printf("%s ",words[idx]);
20004688:	697b      	ldr	r3, [r7, #20]
2000468a:	009b      	lsls	r3, r3, #2
2000468c:	687a      	ldr	r2, [r7, #4]
2000468e:	4413      	add	r3, r2
20004690:	681b      	ldr	r3, [r3, #0]
20004692:	4619      	mov	r1, r3
20004694:	4830      	ldr	r0, [pc, #192]	@ (20004758 <_dumpcmds+0x100>)
20004696:	f7fc fb65 	bl	20000d64 <printf>
		len += strlen(words[idx])+1;
2000469a:	697b      	ldr	r3, [r7, #20]
2000469c:	009b      	lsls	r3, r3, #2
2000469e:	687a      	ldr	r2, [r7, #4]
200046a0:	4413      	add	r3, r2
200046a2:	681b      	ldr	r3, [r3, #0]
200046a4:	4618      	mov	r0, r3
200046a6:	f7fc fefe 	bl	200014a6 <lib_strlen>
200046aa:	4603      	mov	r3, r0
200046ac:	3301      	adds	r3, #1
200046ae:	693a      	ldr	r2, [r7, #16]
200046b0:	4413      	add	r3, r2
200046b2:	613b      	str	r3, [r7, #16]
	    for (idx = 0; idx < level; idx++) {
200046b4:	697b      	ldr	r3, [r7, #20]
200046b6:	3301      	adds	r3, #1
200046b8:	617b      	str	r3, [r7, #20]
200046ba:	697a      	ldr	r2, [r7, #20]
200046bc:	68bb      	ldr	r3, [r7, #8]
200046be:	429a      	cmp	r2, r3
200046c0:	dbe2      	blt.n	20004688 <_dumpcmds+0x30>
		}
	    printf("%s",cmd->cmdword);
200046c2:	68fb      	ldr	r3, [r7, #12]
200046c4:	689b      	ldr	r3, [r3, #8]
200046c6:	4619      	mov	r1, r3
200046c8:	4824      	ldr	r0, [pc, #144]	@ (2000475c <_dumpcmds+0x104>)
200046ca:	f7fc fb4b 	bl	20000d64 <printf>
	    len += strlen(cmd->cmdword);
200046ce:	68fb      	ldr	r3, [r7, #12]
200046d0:	689b      	ldr	r3, [r3, #8]
200046d2:	4618      	mov	r0, r3
200046d4:	f7fc fee7 	bl	200014a6 <lib_strlen>
200046d8:	4602      	mov	r2, r0
200046da:	693b      	ldr	r3, [r7, #16]
200046dc:	4413      	add	r3, r2
200046de:	613b      	str	r3, [r7, #16]
	    for (idx = len; idx < 20; idx++) printf(" ");
200046e0:	693b      	ldr	r3, [r7, #16]
200046e2:	617b      	str	r3, [r7, #20]
200046e4:	e005      	b.n	200046f2 <_dumpcmds+0x9a>
200046e6:	481e      	ldr	r0, [pc, #120]	@ (20004760 <_dumpcmds+0x108>)
200046e8:	f7fc fb3c 	bl	20000d64 <printf>
200046ec:	697b      	ldr	r3, [r7, #20]
200046ee:	3301      	adds	r3, #1
200046f0:	617b      	str	r3, [r7, #20]
200046f2:	697b      	ldr	r3, [r7, #20]
200046f4:	2b13      	cmp	r3, #19
200046f6:	ddf6      	ble.n	200046e6 <_dumpcmds+0x8e>
	    printf("%s\n",cmd->help);
200046f8:	68fb      	ldr	r3, [r7, #12]
200046fa:	695b      	ldr	r3, [r3, #20]
200046fc:	4619      	mov	r1, r3
200046fe:	4819      	ldr	r0, [pc, #100]	@ (20004764 <_dumpcmds+0x10c>)
20004700:	f7fc fb30 	bl	20000d64 <printf>
	    if (verbose) {
20004704:	683b      	ldr	r3, [r7, #0]
20004706:	2b00      	cmp	r3, #0
20004708:	d013      	beq.n	20004732 <_dumpcmds+0xda>
		printf("\n");
2000470a:	4817      	ldr	r0, [pc, #92]	@ (20004768 <_dumpcmds+0x110>)
2000470c:	f7fc fb2a 	bl	20000d64 <printf>
		_dumpindented(cmd->usage,5);
20004710:	68fb      	ldr	r3, [r7, #12]
20004712:	699b      	ldr	r3, [r3, #24]
20004714:	2105      	movs	r1, #5
20004716:	4618      	mov	r0, r3
20004718:	f7ff fef0 	bl	200044fc <_dumpindented>
		printf("\n");
2000471c:	4812      	ldr	r0, [pc, #72]	@ (20004768 <_dumpcmds+0x110>)
2000471e:	f7fc fb21 	bl	20000d64 <printf>
		_dumpswitches(cmd->switches);
20004722:	68fb      	ldr	r3, [r7, #12]
20004724:	69db      	ldr	r3, [r3, #28]
20004726:	4618      	mov	r0, r3
20004728:	f7ff ff30 	bl	2000458c <_dumpswitches>
		printf("\n");
2000472c:	480e      	ldr	r0, [pc, #56]	@ (20004768 <_dumpcmds+0x110>)
2000472e:	f7fc fb19 	bl	20000d64 <printf>
		}
	    }
	_dumpcmds(cmd->child,level+1,words,verbose);
20004732:	68fb      	ldr	r3, [r7, #12]
20004734:	6858      	ldr	r0, [r3, #4]
20004736:	68bb      	ldr	r3, [r7, #8]
20004738:	1c59      	adds	r1, r3, #1
2000473a:	683b      	ldr	r3, [r7, #0]
2000473c:	687a      	ldr	r2, [r7, #4]
2000473e:	f7ff ff8b 	bl	20004658 <_dumpcmds>
	cmd = cmd->sibling;
20004742:	68fb      	ldr	r3, [r7, #12]
20004744:	681b      	ldr	r3, [r3, #0]
20004746:	60fb      	str	r3, [r7, #12]
    while (cmd) {
20004748:	68fb      	ldr	r3, [r7, #12]
2000474a:	2b00      	cmp	r3, #0
2000474c:	d18c      	bne.n	20004668 <_dumpcmds+0x10>
	}
}
2000474e:	bf00      	nop
20004750:	bf00      	nop
20004752:	3718      	adds	r7, #24
20004754:	46bd      	mov	sp, r7
20004756:	bd80      	pop	{r7, pc}
20004758:	20007c7c 	.word	0x20007c7c
2000475c:	20007c80 	.word	0x20007c80
20004760:	20007c48 	.word	0x20007c48
20004764:	20007c4c 	.word	0x20007c4c
20004768:	20007c84 	.word	0x20007c84

2000476c <dumpcmds>:

static void dumpcmds(int verbose)
{
2000476c:	b580      	push	{r7, lr}
2000476e:	b096      	sub	sp, #88	@ 0x58
20004770:	af00      	add	r7, sp, #0
20004772:	6078      	str	r0, [r7, #4]
    char *words[20];

    _dumpcmds(cmd_root,0,words,verbose);
20004774:	4b05      	ldr	r3, [pc, #20]	@ (2000478c <dumpcmds+0x20>)
20004776:	6818      	ldr	r0, [r3, #0]
20004778:	f107 0208 	add.w	r2, r7, #8
2000477c:	687b      	ldr	r3, [r7, #4]
2000477e:	2100      	movs	r1, #0
20004780:	f7ff ff6a 	bl	20004658 <_dumpcmds>
}
20004784:	bf00      	nop
20004786:	3758      	adds	r7, #88	@ 0x58
20004788:	46bd      	mov	sp, r7
2000478a:	bd80      	pop	{r7, pc}
2000478c:	20009474 	.word	0x20009474

20004790 <_showpossible>:


static void _showpossible(ui_cmdline_t *cline,cmdtab_t *cmd)
{
20004790:	b580      	push	{r7, lr}
20004792:	b084      	sub	sp, #16
20004794:	af00      	add	r7, sp, #0
20004796:	6078      	str	r0, [r7, #4]
20004798:	6039      	str	r1, [r7, #0]
    int i;

    if (cline->argidx == 0) {
2000479a:	687b      	ldr	r3, [r7, #4]
2000479c:	f8d3 31cc 	ldr.w	r3, [r3, #460]	@ 0x1cc
200047a0:	2b00      	cmp	r3, #0
200047a2:	d103      	bne.n	200047ac <_showpossible+0x1c>
	printf("Available commands: ");
200047a4:	481f      	ldr	r0, [pc, #124]	@ (20004824 <_showpossible+0x94>)
200047a6:	f7fc fadd 	bl	20000d64 <printf>
200047aa:	e031      	b.n	20004810 <_showpossible+0x80>
	}
    else {
	printf("Available \"");
200047ac:	481e      	ldr	r0, [pc, #120]	@ (20004828 <_showpossible+0x98>)
200047ae:	f7fc fad9 	bl	20000d64 <printf>
	for (i = 0; i < cline->argidx; i++) {
200047b2:	2300      	movs	r3, #0
200047b4:	60fb      	str	r3, [r7, #12]
200047b6:	e011      	b.n	200047dc <_showpossible+0x4c>
	    printf("%s%s",(i == 0) ? "" : " ",cline->argv[i]);
200047b8:	68fb      	ldr	r3, [r7, #12]
200047ba:	2b00      	cmp	r3, #0
200047bc:	d101      	bne.n	200047c2 <_showpossible+0x32>
200047be:	491b      	ldr	r1, [pc, #108]	@ (2000482c <_showpossible+0x9c>)
200047c0:	e000      	b.n	200047c4 <_showpossible+0x34>
200047c2:	491b      	ldr	r1, [pc, #108]	@ (20004830 <_showpossible+0xa0>)
200047c4:	687a      	ldr	r2, [r7, #4]
200047c6:	68fb      	ldr	r3, [r7, #12]
200047c8:	009b      	lsls	r3, r3, #2
200047ca:	4413      	add	r3, r2
200047cc:	685b      	ldr	r3, [r3, #4]
200047ce:	461a      	mov	r2, r3
200047d0:	4818      	ldr	r0, [pc, #96]	@ (20004834 <_showpossible+0xa4>)
200047d2:	f7fc fac7 	bl	20000d64 <printf>
	for (i = 0; i < cline->argidx; i++) {
200047d6:	68fb      	ldr	r3, [r7, #12]
200047d8:	3301      	adds	r3, #1
200047da:	60fb      	str	r3, [r7, #12]
200047dc:	687b      	ldr	r3, [r7, #4]
200047de:	f8d3 31cc 	ldr.w	r3, [r3, #460]	@ 0x1cc
200047e2:	68fa      	ldr	r2, [r7, #12]
200047e4:	429a      	cmp	r2, r3
200047e6:	dbe7      	blt.n	200047b8 <_showpossible+0x28>
	    }
	printf("\" commands: ");
200047e8:	4813      	ldr	r0, [pc, #76]	@ (20004838 <_showpossible+0xa8>)
200047ea:	f7fc fabb 	bl	20000d64 <printf>
	}

    while (cmd) {
200047ee:	e00f      	b.n	20004810 <_showpossible+0x80>
	printf("%s",cmd->cmdword);
200047f0:	683b      	ldr	r3, [r7, #0]
200047f2:	689b      	ldr	r3, [r3, #8]
200047f4:	4619      	mov	r1, r3
200047f6:	4811      	ldr	r0, [pc, #68]	@ (2000483c <_showpossible+0xac>)
200047f8:	f7fc fab4 	bl	20000d64 <printf>
	if (cmd->sibling) printf(", ");
200047fc:	683b      	ldr	r3, [r7, #0]
200047fe:	681b      	ldr	r3, [r3, #0]
20004800:	2b00      	cmp	r3, #0
20004802:	d002      	beq.n	2000480a <_showpossible+0x7a>
20004804:	480e      	ldr	r0, [pc, #56]	@ (20004840 <_showpossible+0xb0>)
20004806:	f7fc faad 	bl	20000d64 <printf>
	cmd = cmd->sibling;
2000480a:	683b      	ldr	r3, [r7, #0]
2000480c:	681b      	ldr	r3, [r3, #0]
2000480e:	603b      	str	r3, [r7, #0]
    while (cmd) {
20004810:	683b      	ldr	r3, [r7, #0]
20004812:	2b00      	cmp	r3, #0
20004814:	d1ec      	bne.n	200047f0 <_showpossible+0x60>
	}

    printf("\n");
20004816:	480b      	ldr	r0, [pc, #44]	@ (20004844 <_showpossible+0xb4>)
20004818:	f7fc faa4 	bl	20000d64 <printf>
}
2000481c:	bf00      	nop
2000481e:	3710      	adds	r7, #16
20004820:	46bd      	mov	sp, r7
20004822:	bd80      	pop	{r7, pc}
20004824:	20007c88 	.word	0x20007c88
20004828:	20007ca0 	.word	0x20007ca0
2000482c:	20007cac 	.word	0x20007cac
20004830:	20007c48 	.word	0x20007c48
20004834:	20007cb0 	.word	0x20007cb0
20004838:	20007cb8 	.word	0x20007cb8
2000483c:	20007c80 	.word	0x20007c80
20004840:	20007cc8 	.word	0x20007cc8
20004844:	20007c84 	.word	0x20007c84

20004848 <cmd_help>:

static int cmd_help(ui_cmdline_t *cmd,int argc,char *argv[])
{
20004848:	b580      	push	{r7, lr}
2000484a:	b088      	sub	sp, #32
2000484c:	af00      	add	r7, sp, #0
2000484e:	60f8      	str	r0, [r7, #12]
20004850:	60b9      	str	r1, [r7, #8]
20004852:	607a      	str	r2, [r7, #4]
    cmdtab_t **tab;
    cmdtab_t *cword;
    int idx;

    if (argc == 0) {
20004854:	68bb      	ldr	r3, [r7, #8]
20004856:	2b00      	cmp	r3, #0
20004858:	d10c      	bne.n	20004874 <cmd_help+0x2c>
	printf("Available commands:\n\n");
2000485a:	4843      	ldr	r0, [pc, #268]	@ (20004968 <cmd_help+0x120>)
2000485c:	f7fc fa82 	bl	20000d64 <printf>
	dumpcmds(0);
20004860:	2000      	movs	r0, #0
20004862:	f7ff ff83 	bl	2000476c <dumpcmds>
	printf("\n");
20004866:	4841      	ldr	r0, [pc, #260]	@ (2000496c <cmd_help+0x124>)
20004868:	f7fc fa7c 	bl	20000d64 <printf>
	printf("For more information about a command, enter 'help command-name'\n");
2000486c:	4840      	ldr	r0, [pc, #256]	@ (20004970 <cmd_help+0x128>)
2000486e:	f7fc fa79 	bl	20000d64 <printf>
20004872:	e073      	b.n	2000495c <cmd_help+0x114>
	}
    else {
	idx = 0;
20004874:	2300      	movs	r3, #0
20004876:	61bb      	str	r3, [r7, #24]
	tab = &cmd_root;
20004878:	4b3e      	ldr	r3, [pc, #248]	@ (20004974 <cmd_help+0x12c>)
2000487a:	61fb      	str	r3, [r7, #28]
	cword = NULL;
2000487c:	2300      	movs	r3, #0
2000487e:	617b      	str	r3, [r7, #20]

	for (;;) {
	    cword = cmd_findword(*tab,argv[idx]);
20004880:	69fb      	ldr	r3, [r7, #28]
20004882:	6818      	ldr	r0, [r3, #0]
20004884:	69bb      	ldr	r3, [r7, #24]
20004886:	009b      	lsls	r3, r3, #2
20004888:	687a      	ldr	r2, [r7, #4]
2000488a:	4413      	add	r3, r2
2000488c:	681b      	ldr	r3, [r3, #0]
2000488e:	4619      	mov	r1, r3
20004890:	f7ff fcee 	bl	20004270 <cmd_findword>
20004894:	6178      	str	r0, [r7, #20]
	    if (!cword) break;
20004896:	697b      	ldr	r3, [r7, #20]
20004898:	2b00      	cmp	r3, #0
2000489a:	d00e      	beq.n	200048ba <cmd_help+0x72>
	    if (cword->func != NULL) break;
2000489c:	697b      	ldr	r3, [r7, #20]
2000489e:	68db      	ldr	r3, [r3, #12]
200048a0:	2b00      	cmp	r3, #0
200048a2:	d10c      	bne.n	200048be <cmd_help+0x76>
	    idx++;
200048a4:	69bb      	ldr	r3, [r7, #24]
200048a6:	3301      	adds	r3, #1
200048a8:	61bb      	str	r3, [r7, #24]
	    tab = &(cword->child);
200048aa:	697b      	ldr	r3, [r7, #20]
200048ac:	3304      	adds	r3, #4
200048ae:	61fb      	str	r3, [r7, #28]
	    if (idx >= argc) break;
200048b0:	69ba      	ldr	r2, [r7, #24]
200048b2:	68bb      	ldr	r3, [r7, #8]
200048b4:	429a      	cmp	r2, r3
200048b6:	da04      	bge.n	200048c2 <cmd_help+0x7a>
	    cword = cmd_findword(*tab,argv[idx]);
200048b8:	e7e2      	b.n	20004880 <cmd_help+0x38>
	    if (!cword) break;
200048ba:	bf00      	nop
200048bc:	e002      	b.n	200048c4 <cmd_help+0x7c>
	    if (cword->func != NULL) break;
200048be:	bf00      	nop
200048c0:	e000      	b.n	200048c4 <cmd_help+0x7c>
	    if (idx >= argc) break;
200048c2:	bf00      	nop
	    }

	if (cword == NULL) {
200048c4:	697b      	ldr	r3, [r7, #20]
200048c6:	2b00      	cmp	r3, #0
200048c8:	d10e      	bne.n	200048e8 <cmd_help+0xa0>
	    printf("No help available for '%s'.\n\n",argv[idx]);
200048ca:	69bb      	ldr	r3, [r7, #24]
200048cc:	009b      	lsls	r3, r3, #2
200048ce:	687a      	ldr	r2, [r7, #4]
200048d0:	4413      	add	r3, r2
200048d2:	681b      	ldr	r3, [r3, #0]
200048d4:	4619      	mov	r1, r3
200048d6:	4828      	ldr	r0, [pc, #160]	@ (20004978 <cmd_help+0x130>)
200048d8:	f7fc fa44 	bl	20000d64 <printf>
	    printf("Type 'help' for a list of commands.\n");
200048dc:	4827      	ldr	r0, [pc, #156]	@ (2000497c <cmd_help+0x134>)
200048de:	f7fc fa41 	bl	20000d64 <printf>
	    return -1;
200048e2:	f04f 33ff 	mov.w	r3, #4294967295	@ 0xffffffff
200048e6:	e03a      	b.n	2000495e <cmd_help+0x116>
	    }

	if (!cword->func && (idx >= argc)) {
200048e8:	697b      	ldr	r3, [r7, #20]
200048ea:	68db      	ldr	r3, [r3, #12]
200048ec:	2b00      	cmp	r3, #0
200048ee:	d10f      	bne.n	20004910 <cmd_help+0xc8>
200048f0:	69ba      	ldr	r2, [r7, #24]
200048f2:	68bb      	ldr	r3, [r7, #8]
200048f4:	429a      	cmp	r2, r3
200048f6:	db0b      	blt.n	20004910 <cmd_help+0xc8>
	    printf("No help available for '%s'.\n\n",cword->cmdword);
200048f8:	697b      	ldr	r3, [r7, #20]
200048fa:	689b      	ldr	r3, [r3, #8]
200048fc:	4619      	mov	r1, r3
200048fe:	481e      	ldr	r0, [pc, #120]	@ (20004978 <cmd_help+0x130>)
20004900:	f7fc fa30 	bl	20000d64 <printf>
	    printf("Type 'help' for a list of commands.\n");
20004904:	481d      	ldr	r0, [pc, #116]	@ (2000497c <cmd_help+0x134>)
20004906:	f7fc fa2d 	bl	20000d64 <printf>
	    return -1;
2000490a:	f04f 33ff 	mov.w	r3, #4294967295	@ 0xffffffff
2000490e:	e026      	b.n	2000495e <cmd_help+0x116>
	    }

	printf("\n  SUMMARY\n\n");
20004910:	481b      	ldr	r0, [pc, #108]	@ (20004980 <cmd_help+0x138>)
20004912:	f7fc fa27 	bl	20000d64 <printf>
	_dumpindented(cword->help,5);
20004916:	697b      	ldr	r3, [r7, #20]
20004918:	695b      	ldr	r3, [r3, #20]
2000491a:	2105      	movs	r1, #5
2000491c:	4618      	mov	r0, r3
2000491e:	f7ff fded 	bl	200044fc <_dumpindented>
	printf("\n  USAGE\n\n");
20004922:	4818      	ldr	r0, [pc, #96]	@ (20004984 <cmd_help+0x13c>)
20004924:	f7fc fa1e 	bl	20000d64 <printf>
	_dumpindented(cword->usage,5);
20004928:	697b      	ldr	r3, [r7, #20]
2000492a:	699b      	ldr	r3, [r3, #24]
2000492c:	2105      	movs	r1, #5
2000492e:	4618      	mov	r0, r3
20004930:	f7ff fde4 	bl	200044fc <_dumpindented>
	if (cword->switches && cword->switches[0]) {
20004934:	697b      	ldr	r3, [r7, #20]
20004936:	69db      	ldr	r3, [r3, #28]
20004938:	2b00      	cmp	r3, #0
2000493a:	d00c      	beq.n	20004956 <cmd_help+0x10e>
2000493c:	697b      	ldr	r3, [r7, #20]
2000493e:	69db      	ldr	r3, [r3, #28]
20004940:	781b      	ldrb	r3, [r3, #0]
20004942:	2b00      	cmp	r3, #0
20004944:	d007      	beq.n	20004956 <cmd_help+0x10e>
	    printf("\n  OPTIONS\n\n");
20004946:	4810      	ldr	r0, [pc, #64]	@ (20004988 <cmd_help+0x140>)
20004948:	f7fc fa0c 	bl	20000d64 <printf>
	    _dumpswitches(cword->switches);
2000494c:	697b      	ldr	r3, [r7, #20]
2000494e:	69db      	ldr	r3, [r3, #28]
20004950:	4618      	mov	r0, r3
20004952:	f7ff fe1b 	bl	2000458c <_dumpswitches>
	    }
	printf("\n");
20004956:	4805      	ldr	r0, [pc, #20]	@ (2000496c <cmd_help+0x124>)
20004958:	f7fc fa04 	bl	20000d64 <printf>
	}

    return 0;
2000495c:	2300      	movs	r3, #0
}
2000495e:	4618      	mov	r0, r3
20004960:	3720      	adds	r7, #32
20004962:	46bd      	mov	sp, r7
20004964:	bd80      	pop	{r7, pc}
20004966:	bf00      	nop
20004968:	20007ccc 	.word	0x20007ccc
2000496c:	20007c84 	.word	0x20007c84
20004970:	20007ce4 	.word	0x20007ce4
20004974:	20009474 	.word	0x20009474
20004978:	20007d28 	.word	0x20007d28
2000497c:	20007d48 	.word	0x20007d48
20004980:	20007d70 	.word	0x20007d70
20004984:	20007d80 	.word	0x20007d80
20004988:	20007d8c 	.word	0x20007d8c

2000498c <cmd_init>:

void cmd_init(void)
{
2000498c:	b580      	push	{r7, lr}
2000498e:	b082      	sub	sp, #8
20004990:	af02      	add	r7, sp, #8
    cmd_root = NULL;
20004992:	4b08      	ldr	r3, [pc, #32]	@ (200049b4 <cmd_init+0x28>)
20004994:	2200      	movs	r2, #0
20004996:	601a      	str	r2, [r3, #0]

    cmd_addcmd("help",
20004998:	4b07      	ldr	r3, [pc, #28]	@ (200049b8 <cmd_init+0x2c>)
2000499a:	9301      	str	r3, [sp, #4]
2000499c:	4b07      	ldr	r3, [pc, #28]	@ (200049bc <cmd_init+0x30>)
2000499e:	9300      	str	r3, [sp, #0]
200049a0:	4b07      	ldr	r3, [pc, #28]	@ (200049c0 <cmd_init+0x34>)
200049a2:	2200      	movs	r2, #0
200049a4:	4907      	ldr	r1, [pc, #28]	@ (200049c4 <cmd_init+0x38>)
200049a6:	4808      	ldr	r0, [pc, #32]	@ (200049c8 <cmd_init+0x3c>)
200049a8:	f7ff fd2c 	bl	20004404 <cmd_addcmd>
	       "help [command]\n\n"
	       "Without any parameters, the 'help' command will display a summary\n"
	       "of available commands.  For more details on a command, type 'help'\n"
	       "and the command name.",
	       "");
}
200049ac:	bf00      	nop
200049ae:	46bd      	mov	sp, r7
200049b0:	bd80      	pop	{r7, pc}
200049b2:	bf00      	nop
200049b4:	20009474 	.word	0x20009474
200049b8:	20007cac 	.word	0x20007cac
200049bc:	20007dc4 	.word	0x20007dc4
200049c0:	20007d9c 	.word	0x20007d9c
200049c4:	20004849 	.word	0x20004849
200049c8:	20007dbc 	.word	0x20007dbc

200049cc <cmd_lookup>:


int cmd_lookup(queue_t *head,ui_cmdline_t *cmd)
{
200049cc:	b580      	push	{r7, lr}
200049ce:	b086      	sub	sp, #24
200049d0:	af00      	add	r7, sp, #0
200049d2:	6078      	str	r0, [r7, #4]
200049d4:	6039      	str	r1, [r7, #0]

    /*
     * Reset the command line
     */

    memset(cmd,0,sizeof(ui_cmdline_t));
200049d6:	f44f 72ee 	mov.w	r2, #476	@ 0x1dc
200049da:	2100      	movs	r1, #0
200049dc:	6838      	ldr	r0, [r7, #0]
200049de:	f7fc fe26 	bl	2000162e <lib_memset>

    /*
     * Break it up into tokens
     */
    
    cmd_build_cmdline(head, cmd);
200049e2:	6839      	ldr	r1, [r7, #0]
200049e4:	6878      	ldr	r0, [r7, #4]
200049e6:	f7ff fc5f 	bl	200042a8 <cmd_build_cmdline>

    if (cmd->argc == 0) return CMD_ERR_BLANK;
200049ea:	683b      	ldr	r3, [r7, #0]
200049ec:	681b      	ldr	r3, [r3, #0]
200049ee:	2b00      	cmp	r3, #0
200049f0:	d102      	bne.n	200049f8 <cmd_lookup+0x2c>
200049f2:	f06f 0302 	mvn.w	r3, #2
200049f6:	e07f      	b.n	20004af8 <cmd_lookup+0x12c>
    /*
     * Start walking the tree looking for a function	
     * to execute.
     */
  
    idx = 0;
200049f8:	2300      	movs	r3, #0
200049fa:	613b      	str	r3, [r7, #16]
    tab = &cmd_root;
200049fc:	4b40      	ldr	r3, [pc, #256]	@ (20004b00 <cmd_lookup+0x134>)
200049fe:	617b      	str	r3, [r7, #20]
    cword = NULL;
20004a00:	2300      	movs	r3, #0
20004a02:	60fb      	str	r3, [r7, #12]

    for (;;) {
	cword = cmd_findword(*tab,cmd->argv[idx]);
20004a04:	697b      	ldr	r3, [r7, #20]
20004a06:	6818      	ldr	r0, [r3, #0]
20004a08:	683a      	ldr	r2, [r7, #0]
20004a0a:	693b      	ldr	r3, [r7, #16]
20004a0c:	009b      	lsls	r3, r3, #2
20004a0e:	4413      	add	r3, r2
20004a10:	685b      	ldr	r3, [r3, #4]
20004a12:	4619      	mov	r1, r3
20004a14:	f7ff fc2c 	bl	20004270 <cmd_findword>
20004a18:	60f8      	str	r0, [r7, #12]
	if (!cword) break;
20004a1a:	68fb      	ldr	r3, [r7, #12]
20004a1c:	2b00      	cmp	r3, #0
20004a1e:	d00f      	beq.n	20004a40 <cmd_lookup+0x74>
	if (cword->func != NULL) break;
20004a20:	68fb      	ldr	r3, [r7, #12]
20004a22:	68db      	ldr	r3, [r3, #12]
20004a24:	2b00      	cmp	r3, #0
20004a26:	d10d      	bne.n	20004a44 <cmd_lookup+0x78>
	idx++;
20004a28:	693b      	ldr	r3, [r7, #16]
20004a2a:	3301      	adds	r3, #1
20004a2c:	613b      	str	r3, [r7, #16]
	tab = &(cword->child);
20004a2e:	68fb      	ldr	r3, [r7, #12]
20004a30:	3304      	adds	r3, #4
20004a32:	617b      	str	r3, [r7, #20]
	if (idx >= cmd->argc) break;
20004a34:	683b      	ldr	r3, [r7, #0]
20004a36:	681b      	ldr	r3, [r3, #0]
20004a38:	693a      	ldr	r2, [r7, #16]
20004a3a:	429a      	cmp	r2, r3
20004a3c:	da04      	bge.n	20004a48 <cmd_lookup+0x7c>
	cword = cmd_findword(*tab,cmd->argv[idx]);
20004a3e:	e7e1      	b.n	20004a04 <cmd_lookup+0x38>
	if (!cword) break;
20004a40:	bf00      	nop
20004a42:	e002      	b.n	20004a4a <cmd_lookup+0x7e>
	if (cword->func != NULL) break;
20004a44:	bf00      	nop
20004a46:	e000      	b.n	20004a4a <cmd_lookup+0x7e>
	if (idx >= cmd->argc) break;
20004a48:	bf00      	nop
	}

    cmd->argidx = idx;
20004a4a:	683b      	ldr	r3, [r7, #0]
20004a4c:	693a      	ldr	r2, [r7, #16]
20004a4e:	f8c3 21cc 	str.w	r2, [r3, #460]	@ 0x1cc

/* XXX - Must fix this... the error needs to walk the tree! */

    if (cword == NULL) {
20004a52:	68fb      	ldr	r3, [r7, #12]
20004a54:	2b00      	cmp	r3, #0
20004a56:	d114      	bne.n	20004a82 <cmd_lookup+0xb6>
	printf("Invalid command: \"%s\"\n", cmd->argv[idx]);
20004a58:	683a      	ldr	r2, [r7, #0]
20004a5a:	693b      	ldr	r3, [r7, #16]
20004a5c:	009b      	lsls	r3, r3, #2
20004a5e:	4413      	add	r3, r2
20004a60:	685b      	ldr	r3, [r3, #4]
20004a62:	4619      	mov	r1, r3
20004a64:	4827      	ldr	r0, [pc, #156]	@ (20004b04 <cmd_lookup+0x138>)
20004a66:	f7fc f97d 	bl	20000d64 <printf>
	_showpossible(cmd,*tab);
20004a6a:	697b      	ldr	r3, [r7, #20]
20004a6c:	681b      	ldr	r3, [r3, #0]
20004a6e:	4619      	mov	r1, r3
20004a70:	6838      	ldr	r0, [r7, #0]
20004a72:	f7ff fe8d 	bl	20004790 <_showpossible>
	printf("\n");
20004a76:	4824      	ldr	r0, [pc, #144]	@ (20004b08 <cmd_lookup+0x13c>)
20004a78:	f7fc f974 	bl	20000d64 <printf>
	return CMD_ERR_INVALID;
20004a7c:	f04f 33ff 	mov.w	r3, #4294967295	@ 0xffffffff
20004a80:	e03a      	b.n	20004af8 <cmd_lookup+0x12c>
	}

    if (!cword->func && (idx >= cmd->argc)) {
20004a82:	68fb      	ldr	r3, [r7, #12]
20004a84:	68db      	ldr	r3, [r3, #12]
20004a86:	2b00      	cmp	r3, #0
20004a88:	d11a      	bne.n	20004ac0 <cmd_lookup+0xf4>
20004a8a:	683b      	ldr	r3, [r7, #0]
20004a8c:	681b      	ldr	r3, [r3, #0]
20004a8e:	693a      	ldr	r2, [r7, #16]
20004a90:	429a      	cmp	r2, r3
20004a92:	db15      	blt.n	20004ac0 <cmd_lookup+0xf4>
	printf("Incomplete command: \"%s\"\n",cmd->argv[idx-1]);
20004a94:	693b      	ldr	r3, [r7, #16]
20004a96:	3b01      	subs	r3, #1
20004a98:	683a      	ldr	r2, [r7, #0]
20004a9a:	009b      	lsls	r3, r3, #2
20004a9c:	4413      	add	r3, r2
20004a9e:	685b      	ldr	r3, [r3, #4]
20004aa0:	4619      	mov	r1, r3
20004aa2:	481a      	ldr	r0, [pc, #104]	@ (20004b0c <cmd_lookup+0x140>)
20004aa4:	f7fc f95e 	bl	20000d64 <printf>
	_showpossible(cmd,*tab);
20004aa8:	697b      	ldr	r3, [r7, #20]
20004aaa:	681b      	ldr	r3, [r3, #0]
20004aac:	4619      	mov	r1, r3
20004aae:	6838      	ldr	r0, [r7, #0]
20004ab0:	f7ff fe6e 	bl	20004790 <_showpossible>
	printf("\n");
20004ab4:	4814      	ldr	r0, [pc, #80]	@ (20004b08 <cmd_lookup+0x13c>)
20004ab6:	f7fc f955 	bl	20000d64 <printf>
	return CMD_ERR_AMBIGUOUS;
20004aba:	f06f 0301 	mvn.w	r3, #1
20004abe:	e01b      	b.n	20004af8 <cmd_lookup+0x12c>
	}

    cmd->argidx++;
20004ac0:	683b      	ldr	r3, [r7, #0]
20004ac2:	f8d3 31cc 	ldr.w	r3, [r3, #460]	@ 0x1cc
20004ac6:	1c5a      	adds	r2, r3, #1
20004ac8:	683b      	ldr	r3, [r7, #0]
20004aca:	f8c3 21cc 	str.w	r2, [r3, #460]	@ 0x1cc
    cmd->ref = cword->ref;
20004ace:	68fb      	ldr	r3, [r7, #12]
20004ad0:	691a      	ldr	r2, [r3, #16]
20004ad2:	683b      	ldr	r3, [r7, #0]
20004ad4:	f8c3 21d0 	str.w	r2, [r3, #464]	@ 0x1d0
    cmd->usage = cword->usage;
20004ad8:	68fb      	ldr	r3, [r7, #12]
20004ada:	699a      	ldr	r2, [r3, #24]
20004adc:	683b      	ldr	r3, [r7, #0]
20004ade:	f8c3 21d4 	str.w	r2, [r3, #468]	@ 0x1d4
    cmd->switches = cword->switches;
20004ae2:	68fb      	ldr	r3, [r7, #12]
20004ae4:	69da      	ldr	r2, [r3, #28]
20004ae6:	683b      	ldr	r3, [r7, #0]
20004ae8:	f8c3 21d8 	str.w	r2, [r3, #472]	@ 0x1d8
    cmd->func = cword->func;
20004aec:	68fb      	ldr	r3, [r7, #12]
20004aee:	68da      	ldr	r2, [r3, #12]
20004af0:	683b      	ldr	r3, [r7, #0]
20004af2:	f8c3 21c8 	str.w	r2, [r3, #456]	@ 0x1c8

    return 0;
20004af6:	2300      	movs	r3, #0
}
20004af8:	4618      	mov	r0, r3
20004afa:	3718      	adds	r7, #24
20004afc:	46bd      	mov	sp, r7
20004afe:	bd80      	pop	{r7, pc}
20004b00:	20009474 	.word	0x20009474
20004b04:	20007e70 	.word	0x20007e70
20004b08:	20007c84 	.word	0x20007c84
20004b0c:	20007e88 	.word	0x20007e88

20004b10 <cmd_showusage>:


void cmd_showusage(ui_cmdline_t *cmd)
{
20004b10:	b580      	push	{r7, lr}
20004b12:	b082      	sub	sp, #8
20004b14:	af00      	add	r7, sp, #0
20004b16:	6078      	str	r0, [r7, #4]
    printf("\n");
20004b18:	480f      	ldr	r0, [pc, #60]	@ (20004b58 <cmd_showusage+0x48>)
20004b1a:	f7fc f923 	bl	20000d64 <printf>
    _dumpindented(cmd->usage,5);
20004b1e:	687b      	ldr	r3, [r7, #4]
20004b20:	f8d3 31d4 	ldr.w	r3, [r3, #468]	@ 0x1d4
20004b24:	2105      	movs	r1, #5
20004b26:	4618      	mov	r0, r3
20004b28:	f7ff fce8 	bl	200044fc <_dumpindented>
    printf("\n");
20004b2c:	480a      	ldr	r0, [pc, #40]	@ (20004b58 <cmd_showusage+0x48>)
20004b2e:	f7fc f919 	bl	20000d64 <printf>
    if (cmd->switches[0]) {
20004b32:	687b      	ldr	r3, [r7, #4]
20004b34:	f8d3 31d8 	ldr.w	r3, [r3, #472]	@ 0x1d8
20004b38:	781b      	ldrb	r3, [r3, #0]
20004b3a:	2b00      	cmp	r3, #0
20004b3c:	d008      	beq.n	20004b50 <cmd_showusage+0x40>
	_dumpswitches(cmd->switches);
20004b3e:	687b      	ldr	r3, [r7, #4]
20004b40:	f8d3 31d8 	ldr.w	r3, [r3, #472]	@ 0x1d8
20004b44:	4618      	mov	r0, r3
20004b46:	f7ff fd21 	bl	2000458c <_dumpswitches>
	printf("\n");
20004b4a:	4803      	ldr	r0, [pc, #12]	@ (20004b58 <cmd_showusage+0x48>)
20004b4c:	f7fc f90a 	bl	20000d64 <printf>
	}
}
20004b50:	bf00      	nop
20004b52:	3708      	adds	r7, #8
20004b54:	46bd      	mov	sp, r7
20004b56:	bd80      	pop	{r7, pc}
20004b58:	20007c84 	.word	0x20007c84

20004b5c <cmd_eat_leading_white>:


static void cmd_eat_leading_white(queue_t *head)
{
20004b5c:	b580      	push	{r7, lr}
20004b5e:	b084      	sub	sp, #16
20004b60:	af00      	add	r7, sp, #0
20004b62:	6078      	str	r0, [r7, #4]
    ui_token_t *t;

    while (!q_isempty(head)) {
20004b64:	e010      	b.n	20004b88 <cmd_eat_leading_white+0x2c>
	t = (ui_token_t *) q_getfirst(head);
20004b66:	687b      	ldr	r3, [r7, #4]
20004b68:	681b      	ldr	r3, [r3, #0]
20004b6a:	60fb      	str	r3, [r7, #12]
	if (is_white_space(t)) {
20004b6c:	68f8      	ldr	r0, [r7, #12]
20004b6e:	f7ff f9df 	bl	20003f30 <is_white_space>
20004b72:	4603      	mov	r3, r0
20004b74:	2b00      	cmp	r3, #0
20004b76:	d00d      	beq.n	20004b94 <cmd_eat_leading_white+0x38>
	    q_dequeue(&(t->qb));
20004b78:	68fb      	ldr	r3, [r7, #12]
20004b7a:	4618      	mov	r0, r3
20004b7c:	f7fc fbfd 	bl	2000137a <q_dequeue>
	    KFREE(t);
20004b80:	68f9      	ldr	r1, [r7, #12]
20004b82:	4807      	ldr	r0, [pc, #28]	@ (20004ba0 <cmd_eat_leading_white+0x44>)
20004b84:	f7fc fa74 	bl	20001070 <kfree>
    while (!q_isempty(head)) {
20004b88:	687b      	ldr	r3, [r7, #4]
20004b8a:	681b      	ldr	r3, [r3, #0]
20004b8c:	687a      	ldr	r2, [r7, #4]
20004b8e:	429a      	cmp	r2, r3
20004b90:	d1e9      	bne.n	20004b66 <cmd_eat_leading_white+0xa>
	    }
	else break;
	}
}
20004b92:	e000      	b.n	20004b96 <cmd_eat_leading_white+0x3a>
	else break;
20004b94:	bf00      	nop
}
20004b96:	bf00      	nop
20004b98:	3710      	adds	r7, #16
20004b9a:	46bd      	mov	sp, r7
20004b9c:	bd80      	pop	{r7, pc}
20004b9e:	bf00      	nop
20004ba0:	200091fc 	.word	0x200091fc

20004ba4 <cmd_readcommand>:

ui_command_t *cmd_readcommand(queue_t *head)
{
20004ba4:	b580      	push	{r7, lr}
20004ba6:	b088      	sub	sp, #32
20004ba8:	af00      	add	r7, sp, #0
20004baa:	6078      	str	r0, [r7, #4]
    char *ptr;
    int insquote = FALSE;
20004bac:	2300      	movs	r3, #0
20004bae:	61fb      	str	r3, [r7, #28]
    int indquote = FALSE;
20004bb0:	2300      	movs	r3, #0
20004bb2:	61bb      	str	r3, [r7, #24]
    ui_command_t *cmd;
    int term = CMD_TERM_EOL;
20004bb4:	2300      	movs	r3, #0
20004bb6:	617b      	str	r3, [r7, #20]
    ui_token_t *t;

    cmd_eat_leading_white(head);
20004bb8:	6878      	ldr	r0, [r7, #4]
20004bba:	f7ff ffcf 	bl	20004b5c <cmd_eat_leading_white>

    if (q_isempty(head)) return NULL;
20004bbe:	687b      	ldr	r3, [r7, #4]
20004bc0:	681b      	ldr	r3, [r3, #0]
20004bc2:	687a      	ldr	r2, [r7, #4]
20004bc4:	429a      	cmp	r2, r3
20004bc6:	d101      	bne.n	20004bcc <cmd_readcommand+0x28>
20004bc8:	2300      	movs	r3, #0
20004bca:	e06e      	b.n	20004caa <cmd_readcommand+0x106>

    cmd = (ui_command_t *) KMALLOC(sizeof(ui_command_t),0);
20004bcc:	2200      	movs	r2, #0
20004bce:	2118      	movs	r1, #24
20004bd0:	4838      	ldr	r0, [pc, #224]	@ (20004cb4 <cmd_readcommand+0x110>)
20004bd2:	f7fc fa81 	bl	200010d8 <kmalloc>
20004bd6:	6138      	str	r0, [r7, #16]
    q_init(&(cmd->head));
20004bd8:	693b      	ldr	r3, [r7, #16]
20004bda:	f103 0210 	add.w	r2, r3, #16
20004bde:	693b      	ldr	r3, [r7, #16]
20004be0:	615a      	str	r2, [r3, #20]
20004be2:	693b      	ldr	r3, [r7, #16]
20004be4:	f103 0210 	add.w	r2, r3, #16
20004be8:	693b      	ldr	r3, [r7, #16]
20004bea:	611a      	str	r2, [r3, #16]

    while ((t = (ui_token_t *) q_deqnext(head))) {
20004bec:	e04b      	b.n	20004c86 <cmd_readcommand+0xe2>

	ptr = &(t->token);
20004bee:	68fb      	ldr	r3, [r7, #12]
20004bf0:	3308      	adds	r3, #8
20004bf2:	60bb      	str	r3, [r7, #8]

	if (!insquote && !indquote) {
20004bf4:	69fb      	ldr	r3, [r7, #28]
20004bf6:	2b00      	cmp	r3, #0
20004bf8:	d125      	bne.n	20004c46 <cmd_readcommand+0xa2>
20004bfa:	69bb      	ldr	r3, [r7, #24]
20004bfc:	2b00      	cmp	r3, #0
20004bfe:	d122      	bne.n	20004c46 <cmd_readcommand+0xa2>
	    if ((*ptr == ';') || (*ptr == '\n')) {
20004c00:	68bb      	ldr	r3, [r7, #8]
20004c02:	781b      	ldrb	r3, [r3, #0]
20004c04:	2b3b      	cmp	r3, #59	@ 0x3b
20004c06:	d003      	beq.n	20004c10 <cmd_readcommand+0x6c>
20004c08:	68bb      	ldr	r3, [r7, #8]
20004c0a:	781b      	ldrb	r3, [r3, #0]
20004c0c:	2b0a      	cmp	r3, #10
20004c0e:	d102      	bne.n	20004c16 <cmd_readcommand+0x72>
		term = CMD_TERM_SEMI;
20004c10:	2301      	movs	r3, #1
20004c12:	617b      	str	r3, [r7, #20]
		break;
20004c14:	e03e      	b.n	20004c94 <cmd_readcommand+0xf0>
		}	
	    if ((*ptr == '&') && (*(ptr+1) == '&')) {
20004c16:	68bb      	ldr	r3, [r7, #8]
20004c18:	781b      	ldrb	r3, [r3, #0]
20004c1a:	2b26      	cmp	r3, #38	@ 0x26
20004c1c:	d107      	bne.n	20004c2e <cmd_readcommand+0x8a>
20004c1e:	68bb      	ldr	r3, [r7, #8]
20004c20:	3301      	adds	r3, #1
20004c22:	781b      	ldrb	r3, [r3, #0]
20004c24:	2b26      	cmp	r3, #38	@ 0x26
20004c26:	d102      	bne.n	20004c2e <cmd_readcommand+0x8a>
		term = CMD_TERM_AND;
20004c28:	2302      	movs	r3, #2
20004c2a:	617b      	str	r3, [r7, #20]
		break;
20004c2c:	e032      	b.n	20004c94 <cmd_readcommand+0xf0>
		}
	    if ((*ptr == '|') && (*(ptr+1) == '|')) {
20004c2e:	68bb      	ldr	r3, [r7, #8]
20004c30:	781b      	ldrb	r3, [r3, #0]
20004c32:	2b7c      	cmp	r3, #124	@ 0x7c
20004c34:	d107      	bne.n	20004c46 <cmd_readcommand+0xa2>
20004c36:	68bb      	ldr	r3, [r7, #8]
20004c38:	3301      	adds	r3, #1
20004c3a:	781b      	ldrb	r3, [r3, #0]
20004c3c:	2b7c      	cmp	r3, #124	@ 0x7c
20004c3e:	d102      	bne.n	20004c46 <cmd_readcommand+0xa2>
		term = CMD_TERM_OR;
20004c40:	2303      	movs	r3, #3
20004c42:	617b      	str	r3, [r7, #20]
		break;
20004c44:	e026      	b.n	20004c94 <cmd_readcommand+0xf0>
		}
	    }

	if (*ptr == '\'') {
20004c46:	68bb      	ldr	r3, [r7, #8]
20004c48:	781b      	ldrb	r3, [r3, #0]
20004c4a:	2b27      	cmp	r3, #39	@ 0x27
20004c4c:	d106      	bne.n	20004c5c <cmd_readcommand+0xb8>
	    insquote = !insquote;
20004c4e:	69fb      	ldr	r3, [r7, #28]
20004c50:	2b00      	cmp	r3, #0
20004c52:	bf0c      	ite	eq
20004c54:	2301      	moveq	r3, #1
20004c56:	2300      	movne	r3, #0
20004c58:	b2db      	uxtb	r3, r3
20004c5a:	61fb      	str	r3, [r7, #28]
	    }

	if (!insquote) {
20004c5c:	69fb      	ldr	r3, [r7, #28]
20004c5e:	2b00      	cmp	r3, #0
20004c60:	d10a      	bne.n	20004c78 <cmd_readcommand+0xd4>
	    if (*ptr == '"') {
20004c62:	68bb      	ldr	r3, [r7, #8]
20004c64:	781b      	ldrb	r3, [r3, #0]
20004c66:	2b22      	cmp	r3, #34	@ 0x22
20004c68:	d106      	bne.n	20004c78 <cmd_readcommand+0xd4>
		indquote = !indquote;
20004c6a:	69bb      	ldr	r3, [r7, #24]
20004c6c:	2b00      	cmp	r3, #0
20004c6e:	bf0c      	ite	eq
20004c70:	2301      	moveq	r3, #1
20004c72:	2300      	movne	r3, #0
20004c74:	b2db      	uxtb	r3, r3
20004c76:	61bb      	str	r3, [r7, #24]
		}
	    }

	q_enqueue(&(cmd->head),&(t->qb));
20004c78:	693b      	ldr	r3, [r7, #16]
20004c7a:	3310      	adds	r3, #16
20004c7c:	68fa      	ldr	r2, [r7, #12]
20004c7e:	4611      	mov	r1, r2
20004c80:	4618      	mov	r0, r3
20004c82:	f7fc fb61 	bl	20001348 <q_enqueue>
    while ((t = (ui_token_t *) q_deqnext(head))) {
20004c86:	6878      	ldr	r0, [r7, #4]
20004c88:	f7fc fb8b 	bl	200013a2 <q_deqnext>
20004c8c:	60f8      	str	r0, [r7, #12]
20004c8e:	68fb      	ldr	r3, [r7, #12]
20004c90:	2b00      	cmp	r3, #0
20004c92:	d1ac      	bne.n	20004bee <cmd_readcommand+0x4a>
		
	}

    cmd->term = term;
20004c94:	693b      	ldr	r3, [r7, #16]
20004c96:	697a      	ldr	r2, [r7, #20]
20004c98:	609a      	str	r2, [r3, #8]

    /* If we got out by finding a command separator, eat the separator */
    if (term != CMD_TERM_EOL) {
20004c9a:	697b      	ldr	r3, [r7, #20]
20004c9c:	2b00      	cmp	r3, #0
20004c9e:	d003      	beq.n	20004ca8 <cmd_readcommand+0x104>
	KFREE(t);
20004ca0:	68f9      	ldr	r1, [r7, #12]
20004ca2:	4804      	ldr	r0, [pc, #16]	@ (20004cb4 <cmd_readcommand+0x110>)
20004ca4:	f7fc f9e4 	bl	20001070 <kfree>
	}

    return cmd;
20004ca8:	693b      	ldr	r3, [r7, #16]
}
20004caa:	4618      	mov	r0, r3
20004cac:	3720      	adds	r7, #32
20004cae:	46bd      	mov	sp, r7
20004cb0:	bd80      	pop	{r7, pc}
20004cb2:	bf00      	nop
20004cb4:	200091fc 	.word	0x200091fc

20004cb8 <make_token>:



static ui_token_t *make_token(char *str,int len)
{
20004cb8:	b580      	push	{r7, lr}
20004cba:	b084      	sub	sp, #16
20004cbc:	af00      	add	r7, sp, #0
20004cbe:	6078      	str	r0, [r7, #4]
20004cc0:	6039      	str	r1, [r7, #0]
    ui_token_t *t = (ui_token_t *) KMALLOC(sizeof(ui_token_t) + len,0);
20004cc2:	683b      	ldr	r3, [r7, #0]
20004cc4:	330c      	adds	r3, #12
20004cc6:	2200      	movs	r2, #0
20004cc8:	4619      	mov	r1, r3
20004cca:	480b      	ldr	r0, [pc, #44]	@ (20004cf8 <make_token+0x40>)
20004ccc:	f7fc fa04 	bl	200010d8 <kmalloc>
20004cd0:	60f8      	str	r0, [r7, #12]

    memcpy(&(t->token),str,len);
20004cd2:	68fb      	ldr	r3, [r7, #12]
20004cd4:	3308      	adds	r3, #8
20004cd6:	683a      	ldr	r2, [r7, #0]
20004cd8:	6879      	ldr	r1, [r7, #4]
20004cda:	4618      	mov	r0, r3
20004cdc:	f7fc fc87 	bl	200015ee <lib_memcpy>
    (&(t->token))[len] = 0;
20004ce0:	68fb      	ldr	r3, [r7, #12]
20004ce2:	f103 0208 	add.w	r2, r3, #8
20004ce6:	683b      	ldr	r3, [r7, #0]
20004ce8:	4413      	add	r3, r2
20004cea:	2200      	movs	r2, #0
20004cec:	701a      	strb	r2, [r3, #0]

    return t;
20004cee:	68fb      	ldr	r3, [r7, #12]
}
20004cf0:	4618      	mov	r0, r3
20004cf2:	3710      	adds	r7, #16
20004cf4:	46bd      	mov	sp, r7
20004cf6:	bd80      	pop	{r7, pc}
20004cf8:	200091fc 	.word	0x200091fc

20004cfc <cmd_build_list>:

void cmd_build_list(queue_t *qb,char *buf)
{
20004cfc:	b580      	push	{r7, lr}
20004cfe:	b086      	sub	sp, #24
20004d00:	af00      	add	r7, sp, #0
20004d02:	6078      	str	r0, [r7, #4]
20004d04:	6039      	str	r1, [r7, #0]
    char *cur = buf, *start = NULL, *fin = NULL;
20004d06:	683b      	ldr	r3, [r7, #0]
20004d08:	617b      	str	r3, [r7, #20]
20004d0a:	2300      	movs	r3, #0
20004d0c:	613b      	str	r3, [r7, #16]
20004d0e:	2300      	movs	r3, #0
20004d10:	60fb      	str	r3, [r7, #12]
    ui_token_t *t;

    q_init(qb);
20004d12:	687b      	ldr	r3, [r7, #4]
20004d14:	687a      	ldr	r2, [r7, #4]
20004d16:	605a      	str	r2, [r3, #4]
20004d18:	687b      	ldr	r3, [r7, #4]
20004d1a:	687a      	ldr	r2, [r7, #4]
20004d1c:	601a      	str	r2, [r3, #0]

    start = cur;
20004d1e:	697b      	ldr	r3, [r7, #20]
20004d20:	613b      	str	r3, [r7, #16]
    while(*cur != '\0'){
20004d22:	e06a      	b.n	20004dfa <cmd_build_list+0xfe>
	if (*cur == '&' && *(cur + 1) != '&') {
20004d24:	697b      	ldr	r3, [r7, #20]
20004d26:	781b      	ldrb	r3, [r3, #0]
20004d28:	2b26      	cmp	r3, #38	@ 0x26
20004d2a:	d104      	bne.n	20004d36 <cmd_build_list+0x3a>
20004d2c:	697b      	ldr	r3, [r7, #20]
20004d2e:	3301      	adds	r3, #1
20004d30:	781b      	ldrb	r3, [r3, #0]
20004d32:	2b26      	cmp	r3, #38	@ 0x26
20004d34:	d15e      	bne.n	20004df4 <cmd_build_list+0xf8>
	    /* Do nothing if we have only one & */
	    }
	else if (*cur == '|' && *(cur + 1) != '|') {
20004d36:	697b      	ldr	r3, [r7, #20]
20004d38:	781b      	ldrb	r3, [r3, #0]
20004d3a:	2b7c      	cmp	r3, #124	@ 0x7c
20004d3c:	d104      	bne.n	20004d48 <cmd_build_list+0x4c>
20004d3e:	697b      	ldr	r3, [r7, #20]
20004d40:	3301      	adds	r3, #1
20004d42:	781b      	ldrb	r3, [r3, #0]
20004d44:	2b7c      	cmp	r3, #124	@ 0x7c
20004d46:	d155      	bne.n	20004df4 <cmd_build_list+0xf8>
	    /* Do nothing if we have only one | */
	    }
	else if (((*cur == ' ')||(*cur == '\t')) &&
20004d48:	697b      	ldr	r3, [r7, #20]
20004d4a:	781b      	ldrb	r3, [r3, #0]
20004d4c:	2b20      	cmp	r3, #32
20004d4e:	d003      	beq.n	20004d58 <cmd_build_list+0x5c>
20004d50:	697b      	ldr	r3, [r7, #20]
20004d52:	781b      	ldrb	r3, [r3, #0]
20004d54:	2b09      	cmp	r3, #9
20004d56:	d109      	bne.n	20004d6c <cmd_build_list+0x70>
		 ((*(cur - 1) == ' ')||(*(cur - 1) == '\t'))) {
20004d58:	697b      	ldr	r3, [r7, #20]
20004d5a:	3b01      	subs	r3, #1
20004d5c:	781b      	ldrb	r3, [r3, #0]
	else if (((*cur == ' ')||(*cur == '\t')) &&
20004d5e:	2b20      	cmp	r3, #32
20004d60:	d047      	beq.n	20004df2 <cmd_build_list+0xf6>
		 ((*(cur - 1) == ' ')||(*(cur - 1) == '\t'))) {
20004d62:	697b      	ldr	r3, [r7, #20]
20004d64:	3b01      	subs	r3, #1
20004d66:	781b      	ldrb	r3, [r3, #0]
20004d68:	2b09      	cmp	r3, #9
20004d6a:	d042      	beq.n	20004df2 <cmd_build_list+0xf6>
	    /* Make one big token for white space */
	    }
	else {

	    if (strchr(tokenbreaks,*cur)) {
20004d6c:	4b31      	ldr	r3, [pc, #196]	@ (20004e34 <cmd_build_list+0x138>)
20004d6e:	681a      	ldr	r2, [r3, #0]
20004d70:	697b      	ldr	r3, [r7, #20]
20004d72:	781b      	ldrb	r3, [r3, #0]
20004d74:	4619      	mov	r1, r3
20004d76:	4610      	mov	r0, r2
20004d78:	f7fc fbee 	bl	20001558 <lib_strchr>
20004d7c:	4603      	mov	r3, r0
20004d7e:	2b00      	cmp	r3, #0
20004d80:	d015      	beq.n	20004dae <cmd_build_list+0xb2>
		if (cur != buf) {
20004d82:	697a      	ldr	r2, [r7, #20]
20004d84:	683b      	ldr	r3, [r7, #0]
20004d86:	429a      	cmp	r2, r3
20004d88:	d034      	beq.n	20004df4 <cmd_build_list+0xf8>
		    fin = cur;
20004d8a:	697b      	ldr	r3, [r7, #20]
20004d8c:	60fb      	str	r3, [r7, #12]
		    t = make_token(start,fin-start);
20004d8e:	68fa      	ldr	r2, [r7, #12]
20004d90:	693b      	ldr	r3, [r7, #16]
20004d92:	1ad3      	subs	r3, r2, r3
20004d94:	4619      	mov	r1, r3
20004d96:	6938      	ldr	r0, [r7, #16]
20004d98:	f7ff ff8e 	bl	20004cb8 <make_token>
20004d9c:	60b8      	str	r0, [r7, #8]
		    q_enqueue(qb,&(t->qb));
20004d9e:	68bb      	ldr	r3, [r7, #8]
20004da0:	4619      	mov	r1, r3
20004da2:	6878      	ldr	r0, [r7, #4]
20004da4:	f7fc fad0 	bl	20001348 <q_enqueue>
		    start = cur; /* Start new token */
20004da8:	697b      	ldr	r3, [r7, #20]
20004daa:	613b      	str	r3, [r7, #16]
20004dac:	e022      	b.n	20004df4 <cmd_build_list+0xf8>
		}
	    else {
		/* If we are on a normal character but the last character was */
		/* a special char we need to start a new token */

		if ((cur > buf) && strchr(tokenbreaks,*(cur-1))) {
20004dae:	697a      	ldr	r2, [r7, #20]
20004db0:	683b      	ldr	r3, [r7, #0]
20004db2:	429a      	cmp	r2, r3
20004db4:	d91e      	bls.n	20004df4 <cmd_build_list+0xf8>
20004db6:	4b1f      	ldr	r3, [pc, #124]	@ (20004e34 <cmd_build_list+0x138>)
20004db8:	681a      	ldr	r2, [r3, #0]
20004dba:	697b      	ldr	r3, [r7, #20]
20004dbc:	3b01      	subs	r3, #1
20004dbe:	781b      	ldrb	r3, [r3, #0]
20004dc0:	4619      	mov	r1, r3
20004dc2:	4610      	mov	r0, r2
20004dc4:	f7fc fbc8 	bl	20001558 <lib_strchr>
20004dc8:	4603      	mov	r3, r0
20004dca:	2b00      	cmp	r3, #0
20004dcc:	d012      	beq.n	20004df4 <cmd_build_list+0xf8>
		    fin = cur;
20004dce:	697b      	ldr	r3, [r7, #20]
20004dd0:	60fb      	str	r3, [r7, #12]
		    t = make_token(start,fin-start);
20004dd2:	68fa      	ldr	r2, [r7, #12]
20004dd4:	693b      	ldr	r3, [r7, #16]
20004dd6:	1ad3      	subs	r3, r2, r3
20004dd8:	4619      	mov	r1, r3
20004dda:	6938      	ldr	r0, [r7, #16]
20004ddc:	f7ff ff6c 	bl	20004cb8 <make_token>
20004de0:	60b8      	str	r0, [r7, #8]
		    q_enqueue(qb,&(t->qb));
20004de2:	68bb      	ldr	r3, [r7, #8]
20004de4:	4619      	mov	r1, r3
20004de6:	6878      	ldr	r0, [r7, #4]
20004de8:	f7fc faae 	bl	20001348 <q_enqueue>
		    start = cur; /* Start new token */
20004dec:	697b      	ldr	r3, [r7, #20]
20004dee:	613b      	str	r3, [r7, #16]
20004df0:	e000      	b.n	20004df4 <cmd_build_list+0xf8>
	else if (((*cur == ' ')||(*cur == '\t')) &&
20004df2:	bf00      	nop


		}

	    }
	cur++;
20004df4:	697b      	ldr	r3, [r7, #20]
20004df6:	3301      	adds	r3, #1
20004df8:	617b      	str	r3, [r7, #20]
    while(*cur != '\0'){
20004dfa:	697b      	ldr	r3, [r7, #20]
20004dfc:	781b      	ldrb	r3, [r3, #0]
20004dfe:	2b00      	cmp	r3, #0
20004e00:	d190      	bne.n	20004d24 <cmd_build_list+0x28>
	}

    fin = cur;
20004e02:	697b      	ldr	r3, [r7, #20]
20004e04:	60fb      	str	r3, [r7, #12]

    if (fin-start > 0) {
20004e06:	68fa      	ldr	r2, [r7, #12]
20004e08:	693b      	ldr	r3, [r7, #16]
20004e0a:	1ad3      	subs	r3, r2, r3
20004e0c:	2b00      	cmp	r3, #0
20004e0e:	dd0d      	ble.n	20004e2c <cmd_build_list+0x130>
	t = make_token(start,fin-start);
20004e10:	68fa      	ldr	r2, [r7, #12]
20004e12:	693b      	ldr	r3, [r7, #16]
20004e14:	1ad3      	subs	r3, r2, r3
20004e16:	4619      	mov	r1, r3
20004e18:	6938      	ldr	r0, [r7, #16]
20004e1a:	f7ff ff4d 	bl	20004cb8 <make_token>
20004e1e:	60b8      	str	r0, [r7, #8]
	q_enqueue(qb,&(t->qb));
20004e20:	68bb      	ldr	r3, [r7, #8]
20004e22:	4619      	mov	r1, r3
20004e24:	6878      	ldr	r0, [r7, #4]
20004e26:	f7fc fa8f 	bl	20001348 <q_enqueue>
	}

    return;
20004e2a:	bf00      	nop
20004e2c:	bf00      	nop
}
20004e2e:	3718      	adds	r7, #24
20004e30:	46bd      	mov	sp, r7
20004e32:	bd80      	pop	{r7, pc}
20004e34:	200091e0 	.word	0x200091e0

20004e38 <is_command_separator>:

static int is_command_separator(ui_token_t *t)
{
20004e38:	b480      	push	{r7}
20004e3a:	b085      	sub	sp, #20
20004e3c:	af00      	add	r7, sp, #0
20004e3e:	6078      	str	r0, [r7, #4]
    char *string = &(t->token);
20004e40:	687b      	ldr	r3, [r7, #4]
20004e42:	3308      	adds	r3, #8
20004e44:	60bb      	str	r3, [r7, #8]
    int sep = 0;
20004e46:	2300      	movs	r3, #0
20004e48:	60fb      	str	r3, [r7, #12]

    switch(*string){
20004e4a:	68bb      	ldr	r3, [r7, #8]
20004e4c:	781b      	ldrb	r3, [r3, #0]
20004e4e:	2b7c      	cmp	r3, #124	@ 0x7c
20004e50:	d010      	beq.n	20004e74 <is_command_separator+0x3c>
20004e52:	2b7c      	cmp	r3, #124	@ 0x7c
20004e54:	dc15      	bgt.n	20004e82 <is_command_separator+0x4a>
20004e56:	2b26      	cmp	r3, #38	@ 0x26
20004e58:	d004      	beq.n	20004e64 <is_command_separator+0x2c>
20004e5a:	2b3b      	cmp	r3, #59	@ 0x3b
20004e5c:	d111      	bne.n	20004e82 <is_command_separator+0x4a>
	case ';':
	    sep = 1;
20004e5e:	2301      	movs	r3, #1
20004e60:	60fb      	str	r3, [r7, #12]
	    break;
20004e62:	e011      	b.n	20004e88 <is_command_separator+0x50>
	case '&':
	    if(*(string + 1) == '&')
20004e64:	68bb      	ldr	r3, [r7, #8]
20004e66:	3301      	adds	r3, #1
20004e68:	781b      	ldrb	r3, [r3, #0]
20004e6a:	2b26      	cmp	r3, #38	@ 0x26
20004e6c:	d10b      	bne.n	20004e86 <is_command_separator+0x4e>
		sep = 1;
20004e6e:	2301      	movs	r3, #1
20004e70:	60fb      	str	r3, [r7, #12]
	    break;
20004e72:	e008      	b.n	20004e86 <is_command_separator+0x4e>
	case '|':
	    if(*(string + 1) == '|')
20004e74:	68bb      	ldr	r3, [r7, #8]
20004e76:	3301      	adds	r3, #1
20004e78:	781b      	ldrb	r3, [r3, #0]
20004e7a:	2b7c      	cmp	r3, #124	@ 0x7c
20004e7c:	d101      	bne.n	20004e82 <is_command_separator+0x4a>
		sep = 1;
20004e7e:	2301      	movs	r3, #1
20004e80:	60fb      	str	r3, [r7, #12]
	default:
	    break;
20004e82:	bf00      	nop
20004e84:	e000      	b.n	20004e88 <is_command_separator+0x50>
	    break;
20004e86:	bf00      	nop
	}

    return(sep);
20004e88:	68fb      	ldr	r3, [r7, #12]
}
20004e8a:	4618      	mov	r0, r3
20004e8c:	3714      	adds	r7, #20
20004e8e:	46bd      	mov	sp, r7
20004e90:	f85d 7b04 	ldr.w	r7, [sp], #4
20004e94:	4770      	bx	lr
	...

20004e98 <cmd_eat_quoted_arg>:

static char *cmd_eat_quoted_arg(queue_t *head,ui_token_t *t)
{
20004e98:	b580      	push	{r7, lr}
20004e9a:	b08a      	sub	sp, #40	@ 0x28
20004e9c:	af00      	add	r7, sp, #0
20004e9e:	6078      	str	r0, [r7, #4]
20004ea0:	6039      	str	r1, [r7, #0]
    int dquote = 0;
20004ea2:	2300      	movs	r3, #0
20004ea4:	627b      	str	r3, [r7, #36]	@ 0x24
    int squote = 0;
20004ea6:	2300      	movs	r3, #0
20004ea8:	623b      	str	r3, [r7, #32]
    queue_t qlist;
    queue_t *q;
    char *dest;
    int maxlen = 0;
20004eaa:	2300      	movs	r3, #0
20004eac:	61bb      	str	r3, [r7, #24]

    /*
     * If it's not a quoted string, just return this token.
     */

    if (!myisquote(t->token)) {
20004eae:	683b      	ldr	r3, [r7, #0]
20004eb0:	7a1b      	ldrb	r3, [r3, #8]
20004eb2:	2b27      	cmp	r3, #39	@ 0x27
20004eb4:	d00b      	beq.n	20004ece <cmd_eat_quoted_arg+0x36>
20004eb6:	683b      	ldr	r3, [r7, #0]
20004eb8:	7a1b      	ldrb	r3, [r3, #8]
20004eba:	2b22      	cmp	r3, #34	@ 0x22
20004ebc:	d007      	beq.n	20004ece <cmd_eat_quoted_arg+0x36>
	dest = lib_strdup(&(t->token));
20004ebe:	683b      	ldr	r3, [r7, #0]
20004ec0:	3308      	adds	r3, #8
20004ec2:	4618      	mov	r0, r3
20004ec4:	f7fc fd42 	bl	2000194c <lib_strdup>
20004ec8:	6178      	str	r0, [r7, #20]
	/* Note: caller deletes original token */
	return dest;
20004eca:	697b      	ldr	r3, [r7, #20]
20004ecc:	e074      	b.n	20004fb8 <cmd_eat_quoted_arg+0x120>

    /*
     * Otherwise, eat tokens in the quotes.
     */

    q_init(&qlist);
20004ece:	f107 030c 	add.w	r3, r7, #12
20004ed2:	613b      	str	r3, [r7, #16]
20004ed4:	f107 030c 	add.w	r3, r7, #12
20004ed8:	60fb      	str	r3, [r7, #12]

    if (t->token == '"') dquote = 1;
20004eda:	683b      	ldr	r3, [r7, #0]
20004edc:	7a1b      	ldrb	r3, [r3, #8]
20004ede:	2b22      	cmp	r3, #34	@ 0x22
20004ee0:	d102      	bne.n	20004ee8 <cmd_eat_quoted_arg+0x50>
20004ee2:	2301      	movs	r3, #1
20004ee4:	627b      	str	r3, [r7, #36]	@ 0x24
20004ee6:	e001      	b.n	20004eec <cmd_eat_quoted_arg+0x54>
    else squote = 1;			/* must be one or the other */
20004ee8:	2301      	movs	r3, #1
20004eea:	623b      	str	r3, [r7, #32]

    t = (ui_token_t *) q_deqnext(head);
20004eec:	6878      	ldr	r0, [r7, #4]
20004eee:	f7fc fa58 	bl	200013a2 <q_deqnext>
20004ef2:	6038      	str	r0, [r7, #0]
    while (t != NULL) {
20004ef4:	e024      	b.n	20004f40 <cmd_eat_quoted_arg+0xa8>
	/* A single quote can only be terminated by another single quote */
	if (squote && (t->token == '\'')) {
20004ef6:	6a3b      	ldr	r3, [r7, #32]
20004ef8:	2b00      	cmp	r3, #0
20004efa:	d008      	beq.n	20004f0e <cmd_eat_quoted_arg+0x76>
20004efc:	683b      	ldr	r3, [r7, #0]
20004efe:	7a1b      	ldrb	r3, [r3, #8]
20004f00:	2b27      	cmp	r3, #39	@ 0x27
20004f02:	d104      	bne.n	20004f0e <cmd_eat_quoted_arg+0x76>
	    KFREE(t);
20004f04:	6839      	ldr	r1, [r7, #0]
20004f06:	482e      	ldr	r0, [pc, #184]	@ (20004fc0 <cmd_eat_quoted_arg+0x128>)
20004f08:	f7fc f8b2 	bl	20001070 <kfree>
	    break;
20004f0c:	e01b      	b.n	20004f46 <cmd_eat_quoted_arg+0xae>
	    }
	/* A double quote is only honored if not in a single quote */
	if (dquote && !squote && (t->token == '\"')) {
20004f0e:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
20004f10:	2b00      	cmp	r3, #0
20004f12:	d00b      	beq.n	20004f2c <cmd_eat_quoted_arg+0x94>
20004f14:	6a3b      	ldr	r3, [r7, #32]
20004f16:	2b00      	cmp	r3, #0
20004f18:	d108      	bne.n	20004f2c <cmd_eat_quoted_arg+0x94>
20004f1a:	683b      	ldr	r3, [r7, #0]
20004f1c:	7a1b      	ldrb	r3, [r3, #8]
20004f1e:	2b22      	cmp	r3, #34	@ 0x22
20004f20:	d104      	bne.n	20004f2c <cmd_eat_quoted_arg+0x94>
	    KFREE(t);
20004f22:	6839      	ldr	r1, [r7, #0]
20004f24:	4826      	ldr	r0, [pc, #152]	@ (20004fc0 <cmd_eat_quoted_arg+0x128>)
20004f26:	f7fc f8a3 	bl	20001070 <kfree>
	    break;
20004f2a:	e00c      	b.n	20004f46 <cmd_eat_quoted_arg+0xae>
	    }
	/* Otherwise, keep this token. */
	q_enqueue(&qlist,(queue_t *) t);
20004f2c:	f107 030c 	add.w	r3, r7, #12
20004f30:	6839      	ldr	r1, [r7, #0]
20004f32:	4618      	mov	r0, r3
20004f34:	f7fc fa08 	bl	20001348 <q_enqueue>
	t = (ui_token_t *) q_deqnext(head);
20004f38:	6878      	ldr	r0, [r7, #4]
20004f3a:	f7fc fa32 	bl	200013a2 <q_deqnext>
20004f3e:	6038      	str	r0, [r7, #0]
    while (t != NULL) {
20004f40:	683b      	ldr	r3, [r7, #0]
20004f42:	2b00      	cmp	r3, #0
20004f44:	d1d7      	bne.n	20004ef6 <cmd_eat_quoted_arg+0x5e>

    /*
     * Go back through what we collected and figure out the string length.
     */

    for (q = qlist.q_next; q != &qlist; q = q->q_next) {
20004f46:	68fb      	ldr	r3, [r7, #12]
20004f48:	61fb      	str	r3, [r7, #28]
20004f4a:	e00b      	b.n	20004f64 <cmd_eat_quoted_arg+0xcc>
	maxlen += strlen(&(((ui_token_t *) q)->token));
20004f4c:	69fb      	ldr	r3, [r7, #28]
20004f4e:	3308      	adds	r3, #8
20004f50:	4618      	mov	r0, r3
20004f52:	f7fc faa8 	bl	200014a6 <lib_strlen>
20004f56:	4602      	mov	r2, r0
20004f58:	69bb      	ldr	r3, [r7, #24]
20004f5a:	4413      	add	r3, r2
20004f5c:	61bb      	str	r3, [r7, #24]
    for (q = qlist.q_next; q != &qlist; q = q->q_next) {
20004f5e:	69fb      	ldr	r3, [r7, #28]
20004f60:	681b      	ldr	r3, [r3, #0]
20004f62:	61fb      	str	r3, [r7, #28]
20004f64:	f107 030c 	add.w	r3, r7, #12
20004f68:	69fa      	ldr	r2, [r7, #28]
20004f6a:	429a      	cmp	r2, r3
20004f6c:	d1ee      	bne.n	20004f4c <cmd_eat_quoted_arg+0xb4>
	}

    dest = KMALLOC(maxlen+1,0);
20004f6e:	69bb      	ldr	r3, [r7, #24]
20004f70:	3301      	adds	r3, #1
20004f72:	2200      	movs	r2, #0
20004f74:	4619      	mov	r1, r3
20004f76:	4812      	ldr	r0, [pc, #72]	@ (20004fc0 <cmd_eat_quoted_arg+0x128>)
20004f78:	f7fc f8ae 	bl	200010d8 <kmalloc>
20004f7c:	6178      	str	r0, [r7, #20]
    if (!dest) return NULL;
20004f7e:	697b      	ldr	r3, [r7, #20]
20004f80:	2b00      	cmp	r3, #0
20004f82:	d101      	bne.n	20004f88 <cmd_eat_quoted_arg+0xf0>
20004f84:	2300      	movs	r3, #0
20004f86:	e017      	b.n	20004fb8 <cmd_eat_quoted_arg+0x120>

    *dest = '\0';
20004f88:	697b      	ldr	r3, [r7, #20]
20004f8a:	2200      	movs	r2, #0
20004f8c:	701a      	strb	r2, [r3, #0]

    while ((t = (ui_token_t *) q_deqnext(&qlist))) {
20004f8e:	e009      	b.n	20004fa4 <cmd_eat_quoted_arg+0x10c>
	strcat(dest,&(t->token));
20004f90:	683b      	ldr	r3, [r7, #0]
20004f92:	3308      	adds	r3, #8
20004f94:	4619      	mov	r1, r3
20004f96:	6978      	ldr	r0, [r7, #20]
20004f98:	f7fc fb65 	bl	20001666 <lib_strcat>
	KFREE(t);
20004f9c:	6839      	ldr	r1, [r7, #0]
20004f9e:	4808      	ldr	r0, [pc, #32]	@ (20004fc0 <cmd_eat_quoted_arg+0x128>)
20004fa0:	f7fc f866 	bl	20001070 <kfree>
    while ((t = (ui_token_t *) q_deqnext(&qlist))) {
20004fa4:	f107 030c 	add.w	r3, r7, #12
20004fa8:	4618      	mov	r0, r3
20004faa:	f7fc f9fa 	bl	200013a2 <q_deqnext>
20004fae:	6038      	str	r0, [r7, #0]
20004fb0:	683b      	ldr	r3, [r7, #0]
20004fb2:	2b00      	cmp	r3, #0
20004fb4:	d1ec      	bne.n	20004f90 <cmd_eat_quoted_arg+0xf8>
	}

    return dest;
20004fb6:	697b      	ldr	r3, [r7, #20]
}
20004fb8:	4618      	mov	r0, r3
20004fba:	3728      	adds	r7, #40	@ 0x28
20004fbc:	46bd      	mov	sp, r7
20004fbe:	bd80      	pop	{r7, pc}
20004fc0:	200091fc 	.word	0x200091fc

20004fc4 <cmd_append_tokens>:

static void cmd_append_tokens(queue_t *qb,char *str)
{
20004fc4:	b580      	push	{r7, lr}
20004fc6:	b086      	sub	sp, #24
20004fc8:	af00      	add	r7, sp, #0
20004fca:	6078      	str	r0, [r7, #4]
20004fcc:	6039      	str	r1, [r7, #0]
    queue_t *qq;
    queue_t explist;

    cmd_build_list(&explist,str);
20004fce:	f107 030c 	add.w	r3, r7, #12
20004fd2:	6839      	ldr	r1, [r7, #0]
20004fd4:	4618      	mov	r0, r3
20004fd6:	f7ff fe91 	bl	20004cfc <cmd_build_list>

    while ((qq = q_deqnext(&explist))) {
20004fda:	e003      	b.n	20004fe4 <cmd_append_tokens+0x20>
	q_enqueue(qb,qq);
20004fdc:	6979      	ldr	r1, [r7, #20]
20004fde:	6878      	ldr	r0, [r7, #4]
20004fe0:	f7fc f9b2 	bl	20001348 <q_enqueue>
    while ((qq = q_deqnext(&explist))) {
20004fe4:	f107 030c 	add.w	r3, r7, #12
20004fe8:	4618      	mov	r0, r3
20004fea:	f7fc f9da 	bl	200013a2 <q_deqnext>
20004fee:	6178      	str	r0, [r7, #20]
20004ff0:	697b      	ldr	r3, [r7, #20]
20004ff2:	2b00      	cmp	r3, #0
20004ff4:	d1f2      	bne.n	20004fdc <cmd_append_tokens+0x18>
	}
}
20004ff6:	bf00      	nop
20004ff8:	bf00      	nop
20004ffa:	3718      	adds	r7, #24
20004ffc:	46bd      	mov	sp, r7
20004ffe:	bd80      	pop	{r7, pc}

20005000 <cmd_walk_and_expand>:
    printf("\n");
}
#endif

void cmd_walk_and_expand (queue_t *qb)
{
20005000:	b580      	push	{r7, lr}
20005002:	b08a      	sub	sp, #40	@ 0x28
20005004:	af00      	add	r7, sp, #0
20005006:	6078      	str	r0, [r7, #4]
    queue_t *q;
    queue_t newq;
    ui_token_t *t;
    int alias_check = TRUE;
20005008:	2301      	movs	r3, #1
2000500a:	623b      	str	r3, [r7, #32]
    int insquote = FALSE;
2000500c:	2300      	movs	r3, #0
2000500e:	61fb      	str	r3, [r7, #28]
    char *envstr;

    q_init(&newq);
20005010:	f107 030c 	add.w	r3, r7, #12
20005014:	613b      	str	r3, [r7, #16]
20005016:	f107 030c 	add.w	r3, r7, #12
2000501a:	60fb      	str	r3, [r7, #12]

    while ((t = (ui_token_t *) q_deqnext(qb))) {
2000501c:	e05c      	b.n	200050d8 <cmd_walk_and_expand+0xd8>
	if (t->token == '\'') {
2000501e:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
20005020:	7a1b      	ldrb	r3, [r3, #8]
20005022:	2b27      	cmp	r3, #39	@ 0x27
20005024:	d109      	bne.n	2000503a <cmd_walk_and_expand+0x3a>
	    alias_check = FALSE;
20005026:	2300      	movs	r3, #0
20005028:	623b      	str	r3, [r7, #32]
	    insquote = !insquote;
2000502a:	69fb      	ldr	r3, [r7, #28]
2000502c:	2b00      	cmp	r3, #0
2000502e:	bf0c      	ite	eq
20005030:	2301      	moveq	r3, #1
20005032:	2300      	movne	r3, #0
20005034:	b2db      	uxtb	r3, r3
20005036:	61fb      	str	r3, [r7, #28]
20005038:	e040      	b.n	200050bc <cmd_walk_and_expand+0xbc>
	    /* Check to see if we should try to expand this token */
	    }
	else if (!insquote) {
2000503a:	69fb      	ldr	r3, [r7, #28]
2000503c:	2b00      	cmp	r3, #0
2000503e:	d13d      	bne.n	200050bc <cmd_walk_and_expand+0xbc>
	    if (alias_check && !strchr(tokenbreaks,t->token) && 
20005040:	6a3b      	ldr	r3, [r7, #32]
20005042:	2b00      	cmp	r3, #0
20005044:	d020      	beq.n	20005088 <cmd_walk_and_expand+0x88>
20005046:	4b31      	ldr	r3, [pc, #196]	@ (2000510c <cmd_walk_and_expand+0x10c>)
20005048:	681a      	ldr	r2, [r3, #0]
2000504a:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
2000504c:	7a1b      	ldrb	r3, [r3, #8]
2000504e:	4619      	mov	r1, r3
20005050:	4610      	mov	r0, r2
20005052:	f7fc fa81 	bl	20001558 <lib_strchr>
20005056:	4603      	mov	r3, r0
20005058:	2b00      	cmp	r3, #0
2000505a:	d115      	bne.n	20005088 <cmd_walk_and_expand+0x88>
		(envstr = env_getenv(&(t->token)))) {
2000505c:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
2000505e:	3308      	adds	r3, #8
20005060:	4618      	mov	r0, r3
20005062:	f7fe fdb3 	bl	20003bcc <env_getenv>
20005066:	6178      	str	r0, [r7, #20]
	    if (alias_check && !strchr(tokenbreaks,t->token) && 
20005068:	697b      	ldr	r3, [r7, #20]
2000506a:	2b00      	cmp	r3, #0
2000506c:	d00c      	beq.n	20005088 <cmd_walk_and_expand+0x88>
		/* Aliases: stick into token stream if no environment found */
		cmd_append_tokens(&newq,envstr);
2000506e:	f107 030c 	add.w	r3, r7, #12
20005072:	6979      	ldr	r1, [r7, #20]
20005074:	4618      	mov	r0, r3
20005076:	f7ff ffa5 	bl	20004fc4 <cmd_append_tokens>
		KFREE(t);
2000507a:	6a79      	ldr	r1, [r7, #36]	@ 0x24
2000507c:	4824      	ldr	r0, [pc, #144]	@ (20005110 <cmd_walk_and_expand+0x110>)
2000507e:	f7fb fff7 	bl	20001070 <kfree>
		t = NULL;
20005082:	2300      	movs	r3, #0
20005084:	627b      	str	r3, [r7, #36]	@ 0x24
20005086:	e019      	b.n	200050bc <cmd_walk_and_expand+0xbc>
		}
	    else if (t->token == '$') {
20005088:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
2000508a:	7a1b      	ldrb	r3, [r3, #8]
2000508c:	2b24      	cmp	r3, #36	@ 0x24
2000508e:	d115      	bne.n	200050bc <cmd_walk_and_expand+0xbc>
		/* non-aliases: remove from token stream if no env found */
		envstr = env_getenv(&(t->token)+1);
20005090:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
20005092:	3308      	adds	r3, #8
20005094:	3301      	adds	r3, #1
20005096:	4618      	mov	r0, r3
20005098:	f7fe fd98 	bl	20003bcc <env_getenv>
2000509c:	6178      	str	r0, [r7, #20]
		if (envstr) cmd_append_tokens(&newq,envstr);
2000509e:	697b      	ldr	r3, [r7, #20]
200050a0:	2b00      	cmp	r3, #0
200050a2:	d005      	beq.n	200050b0 <cmd_walk_and_expand+0xb0>
200050a4:	f107 030c 	add.w	r3, r7, #12
200050a8:	6979      	ldr	r1, [r7, #20]
200050aa:	4618      	mov	r0, r3
200050ac:	f7ff ff8a 	bl	20004fc4 <cmd_append_tokens>
		KFREE(t);
200050b0:	6a79      	ldr	r1, [r7, #36]	@ 0x24
200050b2:	4817      	ldr	r0, [pc, #92]	@ (20005110 <cmd_walk_and_expand+0x110>)
200050b4:	f7fb ffdc 	bl	20001070 <kfree>
		t = NULL;
200050b8:	2300      	movs	r3, #0
200050ba:	627b      	str	r3, [r7, #36]	@ 0x24

	/*
	 * If token was not removed, add it to the new queue
	 */

	if (t) {
200050bc:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
200050be:	2b00      	cmp	r3, #0
200050c0:	d00a      	beq.n	200050d8 <cmd_walk_and_expand+0xd8>
	    q_enqueue(&newq,&(t->qb));
200050c2:	6a7a      	ldr	r2, [r7, #36]	@ 0x24
200050c4:	f107 030c 	add.w	r3, r7, #12
200050c8:	4611      	mov	r1, r2
200050ca:	4618      	mov	r0, r3
200050cc:	f7fc f93c 	bl	20001348 <q_enqueue>
	    alias_check = is_command_separator(t);
200050d0:	6a78      	ldr	r0, [r7, #36]	@ 0x24
200050d2:	f7ff feb1 	bl	20004e38 <is_command_separator>
200050d6:	6238      	str	r0, [r7, #32]
    while ((t = (ui_token_t *) q_deqnext(qb))) {
200050d8:	6878      	ldr	r0, [r7, #4]
200050da:	f7fc f962 	bl	200013a2 <q_deqnext>
200050de:	6278      	str	r0, [r7, #36]	@ 0x24
200050e0:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
200050e2:	2b00      	cmp	r3, #0
200050e4:	d19b      	bne.n	2000501e <cmd_walk_and_expand+0x1e>

    /*
     * Put everything back on the original list. 
     */

    while ((q = q_deqnext(&newq))) {
200050e6:	e003      	b.n	200050f0 <cmd_walk_and_expand+0xf0>
	q_enqueue(qb,q);
200050e8:	69b9      	ldr	r1, [r7, #24]
200050ea:	6878      	ldr	r0, [r7, #4]
200050ec:	f7fc f92c 	bl	20001348 <q_enqueue>
    while ((q = q_deqnext(&newq))) {
200050f0:	f107 030c 	add.w	r3, r7, #12
200050f4:	4618      	mov	r0, r3
200050f6:	f7fc f954 	bl	200013a2 <q_deqnext>
200050fa:	61b8      	str	r0, [r7, #24]
200050fc:	69bb      	ldr	r3, [r7, #24]
200050fe:	2b00      	cmp	r3, #0
20005100:	d1f2      	bne.n	200050e8 <cmd_walk_and_expand+0xe8>
	}

}
20005102:	bf00      	nop
20005104:	bf00      	nop
20005106:	3728      	adds	r7, #40	@ 0x28
20005108:	46bd      	mov	sp, r7
2000510a:	bd80      	pop	{r7, pc}
2000510c:	200091e0 	.word	0x200091e0
20005110:	200091fc 	.word	0x200091fc

20005114 <cmd_free_tokens>:

void cmd_free_tokens(queue_t *list)
{
20005114:	b580      	push	{r7, lr}
20005116:	b084      	sub	sp, #16
20005118:	af00      	add	r7, sp, #0
2000511a:	6078      	str	r0, [r7, #4]
    queue_t *q;

    while ((q = q_deqnext(list))) {
2000511c:	e003      	b.n	20005126 <cmd_free_tokens+0x12>
	KFREE(q);
2000511e:	68f9      	ldr	r1, [r7, #12]
20005120:	4807      	ldr	r0, [pc, #28]	@ (20005140 <cmd_free_tokens+0x2c>)
20005122:	f7fb ffa5 	bl	20001070 <kfree>
    while ((q = q_deqnext(list))) {
20005126:	6878      	ldr	r0, [r7, #4]
20005128:	f7fc f93b 	bl	200013a2 <q_deqnext>
2000512c:	60f8      	str	r0, [r7, #12]
2000512e:	68fb      	ldr	r3, [r7, #12]
20005130:	2b00      	cmp	r3, #0
20005132:	d1f4      	bne.n	2000511e <cmd_free_tokens+0xa>
	}
}
20005134:	bf00      	nop
20005136:	bf00      	nop
20005138:	3710      	adds	r7, #16
2000513a:	46bd      	mov	sp, r7
2000513c:	bd80      	pop	{r7, pc}
2000513e:	bf00      	nop
20005140:	200091fc 	.word	0x200091fc

20005144 <getaddrargs>:
static int prev_length = 256;
static int prev_dlength = 16;
static int prev_wtype = ATYPE_SIZE_WORD | ATYPE_TYPE_KERN;

static int getaddrargs(ui_cmdline_t *cmd,int *curtype,hsaddr_t *addr,int *length)
{
20005144:	b580      	push	{r7, lr}
20005146:	b08a      	sub	sp, #40	@ 0x28
20005148:	af00      	add	r7, sp, #0
2000514a:	60f8      	str	r0, [r7, #12]
2000514c:	60b9      	str	r1, [r7, #8]
2000514e:	607a      	str	r2, [r7, #4]
20005150:	603b      	str	r3, [r7, #0]
    int atype = *curtype;
20005152:	68bb      	ldr	r3, [r7, #8]
20005154:	681b      	ldr	r3, [r3, #0]
20005156:	627b      	str	r3, [r7, #36]	@ 0x24
    hsaddr_t newaddr;
    int newlen;
    char *x;
    hsaddr_t wlen;

    if (cmd_sw_isset(cmd,"-b")) {
20005158:	4961      	ldr	r1, [pc, #388]	@ (200052e0 <getaddrargs+0x19c>)
2000515a:	68f8      	ldr	r0, [r7, #12]
2000515c:	f7fe ff56 	bl	2000400c <cmd_sw_isset>
20005160:	4603      	mov	r3, r0
20005162:	2b00      	cmp	r3, #0
20005164:	d008      	beq.n	20005178 <getaddrargs+0x34>
	atype &= ~ATYPE_SIZE_MASK;
20005166:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
20005168:	f023 030f 	bic.w	r3, r3, #15
2000516c:	627b      	str	r3, [r7, #36]	@ 0x24
	atype |= ATYPE_SIZE_BYTE;
2000516e:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
20005170:	f043 0301 	orr.w	r3, r3, #1
20005174:	627b      	str	r3, [r7, #36]	@ 0x24
20005176:	e02e      	b.n	200051d6 <getaddrargs+0x92>
	}
    else if (cmd_sw_isset(cmd,"-h")) {
20005178:	495a      	ldr	r1, [pc, #360]	@ (200052e4 <getaddrargs+0x1a0>)
2000517a:	68f8      	ldr	r0, [r7, #12]
2000517c:	f7fe ff46 	bl	2000400c <cmd_sw_isset>
20005180:	4603      	mov	r3, r0
20005182:	2b00      	cmp	r3, #0
20005184:	d008      	beq.n	20005198 <getaddrargs+0x54>
	atype &= ~ATYPE_SIZE_MASK;
20005186:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
20005188:	f023 030f 	bic.w	r3, r3, #15
2000518c:	627b      	str	r3, [r7, #36]	@ 0x24
	atype |= ATYPE_SIZE_HALF;
2000518e:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
20005190:	f043 0302 	orr.w	r3, r3, #2
20005194:	627b      	str	r3, [r7, #36]	@ 0x24
20005196:	e01e      	b.n	200051d6 <getaddrargs+0x92>
	}
    else if (cmd_sw_isset(cmd,"-w")) {
20005198:	4953      	ldr	r1, [pc, #332]	@ (200052e8 <getaddrargs+0x1a4>)
2000519a:	68f8      	ldr	r0, [r7, #12]
2000519c:	f7fe ff36 	bl	2000400c <cmd_sw_isset>
200051a0:	4603      	mov	r3, r0
200051a2:	2b00      	cmp	r3, #0
200051a4:	d008      	beq.n	200051b8 <getaddrargs+0x74>
	atype &= ~ATYPE_SIZE_MASK;
200051a6:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
200051a8:	f023 030f 	bic.w	r3, r3, #15
200051ac:	627b      	str	r3, [r7, #36]	@ 0x24
	atype |= ATYPE_SIZE_WORD;
200051ae:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
200051b0:	f043 0304 	orr.w	r3, r3, #4
200051b4:	627b      	str	r3, [r7, #36]	@ 0x24
200051b6:	e00e      	b.n	200051d6 <getaddrargs+0x92>
	}
    else if (cmd_sw_isset(cmd,"-q")) {
200051b8:	494c      	ldr	r1, [pc, #304]	@ (200052ec <getaddrargs+0x1a8>)
200051ba:	68f8      	ldr	r0, [r7, #12]
200051bc:	f7fe ff26 	bl	2000400c <cmd_sw_isset>
200051c0:	4603      	mov	r3, r0
200051c2:	2b00      	cmp	r3, #0
200051c4:	d007      	beq.n	200051d6 <getaddrargs+0x92>
	atype &= ~ATYPE_SIZE_MASK;
200051c6:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
200051c8:	f023 030f 	bic.w	r3, r3, #15
200051cc:	627b      	str	r3, [r7, #36]	@ 0x24
	atype |= ATYPE_SIZE_QUAD;
200051ce:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
200051d0:	f043 0308 	orr.w	r3, r3, #8
200051d4:	627b      	str	r3, [r7, #36]	@ 0x24
	}

    wlen = atype & ATYPE_SIZE_MASK;
200051d6:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
200051d8:	f003 030f 	and.w	r3, r3, #15
200051dc:	61fb      	str	r3, [r7, #28]
    if (wlen == 0) wlen = 1;		/* bytes are the default */
200051de:	69fb      	ldr	r3, [r7, #28]
200051e0:	2b00      	cmp	r3, #0
200051e2:	d101      	bne.n	200051e8 <getaddrargs+0xa4>
200051e4:	2301      	movs	r3, #1
200051e6:	61fb      	str	r3, [r7, #28]

    if (cmd_sw_isset(cmd,"-p")) {
200051e8:	4941      	ldr	r1, [pc, #260]	@ (200052f0 <getaddrargs+0x1ac>)
200051ea:	68f8      	ldr	r0, [r7, #12]
200051ec:	f7fe ff0e 	bl	2000400c <cmd_sw_isset>
200051f0:	4603      	mov	r3, r0
200051f2:	2b00      	cmp	r3, #0
200051f4:	d008      	beq.n	20005208 <getaddrargs+0xc4>
	atype &= ~ATYPE_TYPE_MASK;
200051f6:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
200051f8:	f023 03f0 	bic.w	r3, r3, #240	@ 0xf0
200051fc:	627b      	str	r3, [r7, #36]	@ 0x24
	atype |= ATYPE_TYPE_PHYS;
200051fe:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
20005200:	f043 0310 	orr.w	r3, r3, #16
20005204:	627b      	str	r3, [r7, #36]	@ 0x24
20005206:	e00e      	b.n	20005226 <getaddrargs+0xe2>
	}
    else if (cmd_sw_isset(cmd,"-v")) {
20005208:	493a      	ldr	r1, [pc, #232]	@ (200052f4 <getaddrargs+0x1b0>)
2000520a:	68f8      	ldr	r0, [r7, #12]
2000520c:	f7fe fefe 	bl	2000400c <cmd_sw_isset>
20005210:	4603      	mov	r3, r0
20005212:	2b00      	cmp	r3, #0
20005214:	d007      	beq.n	20005226 <getaddrargs+0xe2>
	atype &= ~ATYPE_TYPE_MASK;
20005216:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
20005218:	f023 03f0 	bic.w	r3, r3, #240	@ 0xf0
2000521c:	627b      	str	r3, [r7, #36]	@ 0x24
	atype |= ATYPE_TYPE_KERN;
2000521e:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
20005220:	f043 0320 	orr.w	r3, r3, #32
20005224:	627b      	str	r3, [r7, #36]	@ 0x24
	}

    *curtype = atype;
20005226:	68bb      	ldr	r3, [r7, #8]
20005228:	6a7a      	ldr	r2, [r7, #36]	@ 0x24
2000522a:	601a      	str	r2, [r3, #0]

    if (addr) {
2000522c:	687b      	ldr	r3, [r7, #4]
2000522e:	2b00      	cmp	r3, #0
20005230:	d03f      	beq.n	200052b2 <getaddrargs+0x16e>
	x = cmd_getarg(cmd,0);
20005232:	2100      	movs	r1, #0
20005234:	68f8      	ldr	r0, [r7, #12]
20005236:	f7fe ff12 	bl	2000405e <cmd_getarg>
2000523a:	6178      	str	r0, [r7, #20]
	if (x) {
2000523c:	697b      	ldr	r3, [r7, #20]
2000523e:	2b00      	cmp	r3, #0
20005240:	d037      	beq.n	200052b2 <getaddrargs+0x16e>
	    if (strcmp(x,".") == 0) newaddr = *addr;
20005242:	492d      	ldr	r1, [pc, #180]	@ (200052f8 <getaddrargs+0x1b4>)
20005244:	6978      	ldr	r0, [r7, #20]
20005246:	f7fc f946 	bl	200014d6 <lib_strcmp>
2000524a:	4603      	mov	r3, r0
2000524c:	2b00      	cmp	r3, #0
2000524e:	d103      	bne.n	20005258 <getaddrargs+0x114>
20005250:	687b      	ldr	r3, [r7, #4]
20005252:	681b      	ldr	r3, [r3, #0]
20005254:	623b      	str	r3, [r7, #32]
20005256:	e026      	b.n	200052a6 <getaddrargs+0x162>
		 * hold on to your lunch, this is really, really bad! 
		 * Make 64-bit addresses expressed as 8-digit numbers
		 * sign extend automagically.  Saves typing, but is very
		 * gross.
		 */
		int longaddr = 0;
20005258:	2300      	movs	r3, #0
2000525a:	61bb      	str	r3, [r7, #24]
		longaddr = strlen(x);
2000525c:	6978      	ldr	r0, [r7, #20]
2000525e:	f7fc f922 	bl	200014a6 <lib_strlen>
20005262:	61b8      	str	r0, [r7, #24]
		if (memcmp(x,"0x",2) == 0) longaddr -= 2;
20005264:	2202      	movs	r2, #2
20005266:	4925      	ldr	r1, [pc, #148]	@ (200052fc <getaddrargs+0x1b8>)
20005268:	6978      	ldr	r0, [r7, #20]
2000526a:	f7fc f991 	bl	20001590 <lib_memcmp>
2000526e:	4603      	mov	r3, r0
20005270:	2b00      	cmp	r3, #0
20005272:	d102      	bne.n	2000527a <getaddrargs+0x136>
20005274:	69bb      	ldr	r3, [r7, #24]
20005276:	3b02      	subs	r3, #2
20005278:	61bb      	str	r3, [r7, #24]
		longaddr = (longaddr > 8) ? 1 : 0;
2000527a:	69bb      	ldr	r3, [r7, #24]
2000527c:	2b08      	cmp	r3, #8
2000527e:	bfcc      	ite	gt
20005280:	2301      	movgt	r3, #1
20005282:	2300      	movle	r3, #0
20005284:	b2db      	uxtb	r3, r3
20005286:	61bb      	str	r3, [r7, #24]

		if (longaddr) newaddr = (hsaddr_t) xtoq(x);
20005288:	69bb      	ldr	r3, [r7, #24]
2000528a:	2b00      	cmp	r3, #0
2000528c:	d007      	beq.n	2000529e <getaddrargs+0x15a>
2000528e:	6978      	ldr	r0, [r7, #20]
20005290:	f7fc faa7 	bl	200017e2 <lib_xtoq>
20005294:	4602      	mov	r2, r0
20005296:	460b      	mov	r3, r1
20005298:	4613      	mov	r3, r2
2000529a:	623b      	str	r3, [r7, #32]
2000529c:	e003      	b.n	200052a6 <getaddrargs+0x162>
		else newaddr = (hsaddr_t) xtoi(x);
2000529e:	6978      	ldr	r0, [r7, #20]
200052a0:	f7fc fb05 	bl	200018ae <lib_xtoi>
200052a4:	6238      	str	r0, [r7, #32]
		}
	    *addr = newaddr & ~(wlen - 1);	/* align to natural boundary */
200052a6:	69fb      	ldr	r3, [r7, #28]
200052a8:	425a      	negs	r2, r3
200052aa:	6a3b      	ldr	r3, [r7, #32]
200052ac:	401a      	ands	r2, r3
200052ae:	687b      	ldr	r3, [r7, #4]
200052b0:	601a      	str	r2, [r3, #0]
	    }
	}

    if (length) {
200052b2:	683b      	ldr	r3, [r7, #0]
200052b4:	2b00      	cmp	r3, #0
200052b6:	d00e      	beq.n	200052d6 <getaddrargs+0x192>
	x = cmd_getarg(cmd,1);
200052b8:	2101      	movs	r1, #1
200052ba:	68f8      	ldr	r0, [r7, #12]
200052bc:	f7fe fecf 	bl	2000405e <cmd_getarg>
200052c0:	6178      	str	r0, [r7, #20]
	if (x) {
200052c2:	697b      	ldr	r3, [r7, #20]
200052c4:	2b00      	cmp	r3, #0
200052c6:	d006      	beq.n	200052d6 <getaddrargs+0x192>
	    newlen = (long) xtoi(x);
200052c8:	6978      	ldr	r0, [r7, #20]
200052ca:	f7fc faf0 	bl	200018ae <lib_xtoi>
200052ce:	6138      	str	r0, [r7, #16]
	    *length = newlen;
200052d0:	683b      	ldr	r3, [r7, #0]
200052d2:	693a      	ldr	r2, [r7, #16]
200052d4:	601a      	str	r2, [r3, #0]
	    }
	}

    return 0;
200052d6:	2300      	movs	r3, #0

}
200052d8:	4618      	mov	r0, r3
200052da:	3728      	adds	r7, #40	@ 0x28
200052dc:	46bd      	mov	sp, r7
200052de:	bd80      	pop	{r7, pc}
200052e0:	20007ea4 	.word	0x20007ea4
200052e4:	20007ea8 	.word	0x20007ea8
200052e8:	20007eac 	.word	0x20007eac
200052ec:	20007eb0 	.word	0x20007eb0
200052f0:	20007eb4 	.word	0x20007eb4
200052f4:	20007eb8 	.word	0x20007eb8
200052f8:	20007ebc 	.word	0x20007ebc
200052fc:	20007ec0 	.word	0x20007ec0

20005300 <stuffmem>:

static int stuffmem(hsaddr_t addr, int wlen, char *tail)
{
20005300:	e92d 4fb0 	stmdb	sp!, {r4, r5, r7, r8, r9, sl, fp, lr}
20005304:	b08e      	sub	sp, #56	@ 0x38
20005306:	af02      	add	r7, sp, #8
20005308:	60f8      	str	r0, [r7, #12]
2000530a:	60b9      	str	r1, [r7, #8]
2000530c:	607a      	str	r2, [r7, #4]
    char *tok;
    int count = 0;
2000530e:	2300      	movs	r3, #0
20005310:	62fb      	str	r3, [r7, #44]	@ 0x2c
    uint8_t b;
    uint16_t h;
    uint32_t w;
    uint64_t q;
    int res = 0;
20005312:	2300      	movs	r3, #0
20005314:	62bb      	str	r3, [r7, #40]	@ 0x28

    addr &= ~(wlen - 1);
20005316:	68bb      	ldr	r3, [r7, #8]
20005318:	425b      	negs	r3, r3
2000531a:	68fa      	ldr	r2, [r7, #12]
2000531c:	4013      	ands	r3, r2
2000531e:	60fb      	str	r3, [r7, #12]

    while ((tok = gettoken(&tail))) {
20005320:	e073      	b.n	2000540a <stuffmem+0x10a>
        switch (wlen) {
20005322:	68bb      	ldr	r3, [r7, #8]
20005324:	2b08      	cmp	r3, #8
20005326:	d050      	beq.n	200053ca <stuffmem+0xca>
20005328:	68bb      	ldr	r3, [r7, #8]
2000532a:	2b08      	cmp	r3, #8
2000532c:	dc05      	bgt.n	2000533a <stuffmem+0x3a>
2000532e:	68bb      	ldr	r3, [r7, #8]
20005330:	2b02      	cmp	r3, #2
20005332:	d01a      	beq.n	2000536a <stuffmem+0x6a>
20005334:	68bb      	ldr	r3, [r7, #8]
20005336:	2b04      	cmp	r3, #4
20005338:	d02f      	beq.n	2000539a <stuffmem+0x9a>
            default:
            case 1:
                b = (uint8_t) xtoq(tok);
2000533a:	6a78      	ldr	r0, [r7, #36]	@ 0x24
2000533c:	f7fc fa51 	bl	200017e2 <lib_xtoq>
20005340:	4602      	mov	r2, r0
20005342:	460b      	mov	r3, r1
20005344:	4613      	mov	r3, r2
20005346:	747b      	strb	r3, [r7, #17]
                if ((res = mem_poke(addr, b, MEM_BYTE))) {
20005348:	7c7b      	ldrb	r3, [r7, #17]
2000534a:	2200      	movs	r2, #0
2000534c:	461c      	mov	r4, r3
2000534e:	4615      	mov	r5, r2
20005350:	2301      	movs	r3, #1
20005352:	9300      	str	r3, [sp, #0]
20005354:	4622      	mov	r2, r4
20005356:	462b      	mov	r3, r5
20005358:	68f8      	ldr	r0, [r7, #12]
2000535a:	f7fb ffbb 	bl	200012d4 <mem_poke>
2000535e:	62b8      	str	r0, [r7, #40]	@ 0x28
20005360:	6abb      	ldr	r3, [r7, #40]	@ 0x28
20005362:	2b00      	cmp	r3, #0
20005364:	d043      	beq.n	200053ee <stuffmem+0xee>
                    return res;
20005366:	6abb      	ldr	r3, [r7, #40]	@ 0x28
20005368:	e058      	b.n	2000541c <stuffmem+0x11c>
                }
                break;
            case 2:
                h = (uint16_t) xtoq(tok);
2000536a:	6a78      	ldr	r0, [r7, #36]	@ 0x24
2000536c:	f7fc fa39 	bl	200017e2 <lib_xtoq>
20005370:	4602      	mov	r2, r0
20005372:	460b      	mov	r3, r1
20005374:	4613      	mov	r3, r2
20005376:	827b      	strh	r3, [r7, #18]
                if ((res = mem_poke(addr, h, MEM_HALFWORD))) {
20005378:	8a7b      	ldrh	r3, [r7, #18]
2000537a:	2200      	movs	r2, #0
2000537c:	4698      	mov	r8, r3
2000537e:	4691      	mov	r9, r2
20005380:	2302      	movs	r3, #2
20005382:	9300      	str	r3, [sp, #0]
20005384:	4642      	mov	r2, r8
20005386:	464b      	mov	r3, r9
20005388:	68f8      	ldr	r0, [r7, #12]
2000538a:	f7fb ffa3 	bl	200012d4 <mem_poke>
2000538e:	62b8      	str	r0, [r7, #40]	@ 0x28
20005390:	6abb      	ldr	r3, [r7, #40]	@ 0x28
20005392:	2b00      	cmp	r3, #0
20005394:	d02d      	beq.n	200053f2 <stuffmem+0xf2>
                    return res;
20005396:	6abb      	ldr	r3, [r7, #40]	@ 0x28
20005398:	e040      	b.n	2000541c <stuffmem+0x11c>
                }
                break;
            case 4:
                w = (uint32_t) xtoq(tok);
2000539a:	6a78      	ldr	r0, [r7, #36]	@ 0x24
2000539c:	f7fc fa21 	bl	200017e2 <lib_xtoq>
200053a0:	4602      	mov	r2, r0
200053a2:	460b      	mov	r3, r1
200053a4:	4613      	mov	r3, r2
200053a6:	617b      	str	r3, [r7, #20]
                if ((res = mem_poke(addr, w, MEM_WORD))) {
200053a8:	697b      	ldr	r3, [r7, #20]
200053aa:	2200      	movs	r2, #0
200053ac:	469a      	mov	sl, r3
200053ae:	4693      	mov	fp, r2
200053b0:	2303      	movs	r3, #3
200053b2:	9300      	str	r3, [sp, #0]
200053b4:	4652      	mov	r2, sl
200053b6:	465b      	mov	r3, fp
200053b8:	68f8      	ldr	r0, [r7, #12]
200053ba:	f7fb ff8b 	bl	200012d4 <mem_poke>
200053be:	62b8      	str	r0, [r7, #40]	@ 0x28
200053c0:	6abb      	ldr	r3, [r7, #40]	@ 0x28
200053c2:	2b00      	cmp	r3, #0
200053c4:	d017      	beq.n	200053f6 <stuffmem+0xf6>
                    return res;
200053c6:	6abb      	ldr	r3, [r7, #40]	@ 0x28
200053c8:	e028      	b.n	2000541c <stuffmem+0x11c>
                }
                break;
            case 8:
                q = (uint64_t) xtoq(tok);
200053ca:	6a78      	ldr	r0, [r7, #36]	@ 0x24
200053cc:	f7fc fa09 	bl	200017e2 <lib_xtoq>
200053d0:	e9c7 0106 	strd	r0, r1, [r7, #24]
                if ((res = mem_poke(addr, q, MEM_QUADWORD))) {
200053d4:	2304      	movs	r3, #4
200053d6:	9300      	str	r3, [sp, #0]
200053d8:	e9d7 2306 	ldrd	r2, r3, [r7, #24]
200053dc:	68f8      	ldr	r0, [r7, #12]
200053de:	f7fb ff79 	bl	200012d4 <mem_poke>
200053e2:	62b8      	str	r0, [r7, #40]	@ 0x28
200053e4:	6abb      	ldr	r3, [r7, #40]	@ 0x28
200053e6:	2b00      	cmp	r3, #0
200053e8:	d007      	beq.n	200053fa <stuffmem+0xfa>
                    return res;
200053ea:	6abb      	ldr	r3, [r7, #40]	@ 0x28
200053ec:	e016      	b.n	2000541c <stuffmem+0x11c>
                break;
200053ee:	bf00      	nop
200053f0:	e004      	b.n	200053fc <stuffmem+0xfc>
                break;
200053f2:	bf00      	nop
200053f4:	e002      	b.n	200053fc <stuffmem+0xfc>
                break;
200053f6:	bf00      	nop
200053f8:	e000      	b.n	200053fc <stuffmem+0xfc>
                }
                break;
200053fa:	bf00      	nop
        }

        addr += wlen;
200053fc:	68fa      	ldr	r2, [r7, #12]
200053fe:	68bb      	ldr	r3, [r7, #8]
20005400:	4413      	add	r3, r2
20005402:	60fb      	str	r3, [r7, #12]
        count++;
20005404:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
20005406:	3301      	adds	r3, #1
20005408:	62fb      	str	r3, [r7, #44]	@ 0x2c
    while ((tok = gettoken(&tail))) {
2000540a:	1d3b      	adds	r3, r7, #4
2000540c:	4618      	mov	r0, r3
2000540e:	f7fc f950 	bl	200016b2 <lib_gettoken>
20005412:	6278      	str	r0, [r7, #36]	@ 0x24
20005414:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
20005416:	2b00      	cmp	r3, #0
20005418:	d183      	bne.n	20005322 <stuffmem+0x22>
    }
    return count;
2000541a:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
}
2000541c:	4618      	mov	r0, r3
2000541e:	3730      	adds	r7, #48	@ 0x30
20005420:	46bd      	mov	sp, r7
20005422:	e8bd 8fb0 	ldmia.w	sp!, {r4, r5, r7, r8, r9, sl, fp, pc}
	...

20005428 <dumpmem>:

int dumpmem(hsaddr_t addr,hsaddr_t dispaddr,int length,int wlen)
{
20005428:	b580      	push	{r7, lr}
2000542a:	b090      	sub	sp, #64	@ 0x40
2000542c:	af00      	add	r7, sp, #0
2000542e:	60f8      	str	r0, [r7, #12]
20005430:	60b9      	str	r1, [r7, #8]
20005432:	607a      	str	r2, [r7, #4]
20005434:	603b      	str	r3, [r7, #0]
    int idx,x;
    uint8_t b;
    uint16_t h;
    uint32_t w;
    uint64_t q;
    int res = 0;
20005436:	2300      	movs	r3, #0
20005438:	637b      	str	r3, [r7, #52]	@ 0x34
	uint16_t halves[8];
	uint32_t words[4];
	uint64_t quads[2];
    } line;
       
    addr &= ~(wlen-1);
2000543a:	683b      	ldr	r3, [r7, #0]
2000543c:	425b      	negs	r3, r3
2000543e:	68fa      	ldr	r2, [r7, #12]
20005440:	4013      	ands	r3, r2
20005442:	60fb      	str	r3, [r7, #12]

    for (idx = 0; idx < length; idx += 16) {
20005444:	2300      	movs	r3, #0
20005446:	63fb      	str	r3, [r7, #60]	@ 0x3c
20005448:	e124      	b.n	20005694 <dumpmem+0x26c>
	printf(PTRFMT "%c ",dispaddr+idx,(dispaddr != addr) ? '%' : ':');
2000544a:	68ba      	ldr	r2, [r7, #8]
2000544c:	6bfb      	ldr	r3, [r7, #60]	@ 0x3c
2000544e:	18d1      	adds	r1, r2, r3
20005450:	68ba      	ldr	r2, [r7, #8]
20005452:	68fb      	ldr	r3, [r7, #12]
20005454:	429a      	cmp	r2, r3
20005456:	d001      	beq.n	2000545c <dumpmem+0x34>
20005458:	2325      	movs	r3, #37	@ 0x25
2000545a:	e000      	b.n	2000545e <dumpmem+0x36>
2000545c:	233a      	movs	r3, #58	@ 0x3a
2000545e:	461a      	mov	r2, r3
20005460:	4891      	ldr	r0, [pc, #580]	@ (200056a8 <dumpmem+0x280>)
20005462:	f7fb fc7f 	bl	20000d64 <printf>
	switch (wlen) {
20005466:	683b      	ldr	r3, [r7, #0]
20005468:	2b08      	cmp	r3, #8
2000546a:	f000 80a5 	beq.w	200055b8 <dumpmem+0x190>
2000546e:	683b      	ldr	r3, [r7, #0]
20005470:	2b08      	cmp	r3, #8
20005472:	dc05      	bgt.n	20005480 <dumpmem+0x58>
20005474:	683b      	ldr	r3, [r7, #0]
20005476:	2b02      	cmp	r3, #2
20005478:	d035      	beq.n	200054e6 <dumpmem+0xbe>
2000547a:	683b      	ldr	r3, [r7, #0]
2000547c:	2b04      	cmp	r3, #4
2000547e:	d066      	beq.n	2000554e <dumpmem+0x126>
	    default:
	    case 1:
		for (x = 0; x < 16; x++) {
20005480:	2300      	movs	r3, #0
20005482:	63bb      	str	r3, [r7, #56]	@ 0x38
20005484:	e02b      	b.n	200054de <dumpmem+0xb6>
		    if (idx+x < length) {
20005486:	6bfa      	ldr	r2, [r7, #60]	@ 0x3c
20005488:	6bbb      	ldr	r3, [r7, #56]	@ 0x38
2000548a:	4413      	add	r3, r2
2000548c:	687a      	ldr	r2, [r7, #4]
2000548e:	429a      	cmp	r2, r3
20005490:	dd1f      	ble.n	200054d2 <dumpmem+0xaa>
			if ((res = mem_peek(&b, (addr+idx+x), MEM_BYTE))) {
20005492:	68fa      	ldr	r2, [r7, #12]
20005494:	6bfb      	ldr	r3, [r7, #60]	@ 0x3c
20005496:	441a      	add	r2, r3
20005498:	6bbb      	ldr	r3, [r7, #56]	@ 0x38
2000549a:	18d1      	adds	r1, r2, r3
2000549c:	f107 0333 	add.w	r3, r7, #51	@ 0x33
200054a0:	2201      	movs	r2, #1
200054a2:	4618      	mov	r0, r3
200054a4:	f7fb fed8 	bl	20001258 <mem_peek>
200054a8:	6378      	str	r0, [r7, #52]	@ 0x34
200054aa:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
200054ac:	2b00      	cmp	r3, #0
200054ae:	d001      	beq.n	200054b4 <dumpmem+0x8c>
			    return res;
200054b0:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
200054b2:	e0f5      	b.n	200056a0 <dumpmem+0x278>
			    }
			line.bytes[x] = b;
200054b4:	f897 1033 	ldrb.w	r1, [r7, #51]	@ 0x33
200054b8:	f107 0210 	add.w	r2, r7, #16
200054bc:	6bbb      	ldr	r3, [r7, #56]	@ 0x38
200054be:	4413      	add	r3, r2
200054c0:	460a      	mov	r2, r1
200054c2:	701a      	strb	r2, [r3, #0]
			printf("%02X ",b);
200054c4:	f897 3033 	ldrb.w	r3, [r7, #51]	@ 0x33
200054c8:	4619      	mov	r1, r3
200054ca:	4878      	ldr	r0, [pc, #480]	@ (200056ac <dumpmem+0x284>)
200054cc:	f7fb fc4a 	bl	20000d64 <printf>
200054d0:	e002      	b.n	200054d8 <dumpmem+0xb0>
			}
		    else {
			printf("   ");
200054d2:	4877      	ldr	r0, [pc, #476]	@ (200056b0 <dumpmem+0x288>)
200054d4:	f7fb fc46 	bl	20000d64 <printf>
		for (x = 0; x < 16; x++) {
200054d8:	6bbb      	ldr	r3, [r7, #56]	@ 0x38
200054da:	3301      	adds	r3, #1
200054dc:	63bb      	str	r3, [r7, #56]	@ 0x38
200054de:	6bbb      	ldr	r3, [r7, #56]	@ 0x38
200054e0:	2b0f      	cmp	r3, #15
200054e2:	ddd0      	ble.n	20005486 <dumpmem+0x5e>
			}
		    }
		break;
200054e4:	e0a0      	b.n	20005628 <dumpmem+0x200>
	    case 2:
		for (x = 0; x < 16; x+=2) {
200054e6:	2300      	movs	r3, #0
200054e8:	63bb      	str	r3, [r7, #56]	@ 0x38
200054ea:	e02c      	b.n	20005546 <dumpmem+0x11e>
		    if (idx+x < length) { 
200054ec:	6bfa      	ldr	r2, [r7, #60]	@ 0x3c
200054ee:	6bbb      	ldr	r3, [r7, #56]	@ 0x38
200054f0:	4413      	add	r3, r2
200054f2:	687a      	ldr	r2, [r7, #4]
200054f4:	429a      	cmp	r2, r3
200054f6:	dd20      	ble.n	2000553a <dumpmem+0x112>
			if ((res = mem_peek(&h, (addr+idx+x), MEM_HALFWORD))) {
200054f8:	68fa      	ldr	r2, [r7, #12]
200054fa:	6bfb      	ldr	r3, [r7, #60]	@ 0x3c
200054fc:	441a      	add	r2, r3
200054fe:	6bbb      	ldr	r3, [r7, #56]	@ 0x38
20005500:	18d1      	adds	r1, r2, r3
20005502:	f107 0330 	add.w	r3, r7, #48	@ 0x30
20005506:	2202      	movs	r2, #2
20005508:	4618      	mov	r0, r3
2000550a:	f7fb fea5 	bl	20001258 <mem_peek>
2000550e:	6378      	str	r0, [r7, #52]	@ 0x34
20005510:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
20005512:	2b00      	cmp	r3, #0
20005514:	d001      	beq.n	2000551a <dumpmem+0xf2>
			    return res;
20005516:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
20005518:	e0c2      	b.n	200056a0 <dumpmem+0x278>
			    }
			line.halves[x/2] = h;
2000551a:	6bbb      	ldr	r3, [r7, #56]	@ 0x38
2000551c:	0fda      	lsrs	r2, r3, #31
2000551e:	4413      	add	r3, r2
20005520:	105b      	asrs	r3, r3, #1
20005522:	8e3a      	ldrh	r2, [r7, #48]	@ 0x30
20005524:	005b      	lsls	r3, r3, #1
20005526:	3340      	adds	r3, #64	@ 0x40
20005528:	443b      	add	r3, r7
2000552a:	f823 2c30 	strh.w	r2, [r3, #-48]
			printf("%04X ",h);
2000552e:	8e3b      	ldrh	r3, [r7, #48]	@ 0x30
20005530:	4619      	mov	r1, r3
20005532:	4860      	ldr	r0, [pc, #384]	@ (200056b4 <dumpmem+0x28c>)
20005534:	f7fb fc16 	bl	20000d64 <printf>
20005538:	e002      	b.n	20005540 <dumpmem+0x118>
			}
		    else {
			printf("     ");
2000553a:	485f      	ldr	r0, [pc, #380]	@ (200056b8 <dumpmem+0x290>)
2000553c:	f7fb fc12 	bl	20000d64 <printf>
		for (x = 0; x < 16; x+=2) {
20005540:	6bbb      	ldr	r3, [r7, #56]	@ 0x38
20005542:	3302      	adds	r3, #2
20005544:	63bb      	str	r3, [r7, #56]	@ 0x38
20005546:	6bbb      	ldr	r3, [r7, #56]	@ 0x38
20005548:	2b0f      	cmp	r3, #15
2000554a:	ddcf      	ble.n	200054ec <dumpmem+0xc4>
			}
		    }
		break;
2000554c:	e06c      	b.n	20005628 <dumpmem+0x200>
	    case 4:
		for (x = 0; x < 16; x+=4) {
2000554e:	2300      	movs	r3, #0
20005550:	63bb      	str	r3, [r7, #56]	@ 0x38
20005552:	e02d      	b.n	200055b0 <dumpmem+0x188>
		    if (idx+x < length) { 
20005554:	6bfa      	ldr	r2, [r7, #60]	@ 0x3c
20005556:	6bbb      	ldr	r3, [r7, #56]	@ 0x38
20005558:	4413      	add	r3, r2
2000555a:	687a      	ldr	r2, [r7, #4]
2000555c:	429a      	cmp	r2, r3
2000555e:	dd21      	ble.n	200055a4 <dumpmem+0x17c>
		      
			if ((res = mem_peek(&w , (addr+idx+x), MEM_WORD))) {
20005560:	68fa      	ldr	r2, [r7, #12]
20005562:	6bfb      	ldr	r3, [r7, #60]	@ 0x3c
20005564:	441a      	add	r2, r3
20005566:	6bbb      	ldr	r3, [r7, #56]	@ 0x38
20005568:	18d1      	adds	r1, r2, r3
2000556a:	f107 032c 	add.w	r3, r7, #44	@ 0x2c
2000556e:	2203      	movs	r2, #3
20005570:	4618      	mov	r0, r3
20005572:	f7fb fe71 	bl	20001258 <mem_peek>
20005576:	6378      	str	r0, [r7, #52]	@ 0x34
20005578:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
2000557a:	2b00      	cmp	r3, #0
2000557c:	d001      	beq.n	20005582 <dumpmem+0x15a>
			    return res;
2000557e:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
20005580:	e08e      	b.n	200056a0 <dumpmem+0x278>
			    }
			line.words[x/4] = w;
20005582:	6bbb      	ldr	r3, [r7, #56]	@ 0x38
20005584:	2b00      	cmp	r3, #0
20005586:	da00      	bge.n	2000558a <dumpmem+0x162>
20005588:	3303      	adds	r3, #3
2000558a:	109b      	asrs	r3, r3, #2
2000558c:	6afa      	ldr	r2, [r7, #44]	@ 0x2c
2000558e:	009b      	lsls	r3, r3, #2
20005590:	3340      	adds	r3, #64	@ 0x40
20005592:	443b      	add	r3, r7
20005594:	f843 2c30 	str.w	r2, [r3, #-48]
			printf("%08X ",w);
20005598:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
2000559a:	4619      	mov	r1, r3
2000559c:	4847      	ldr	r0, [pc, #284]	@ (200056bc <dumpmem+0x294>)
2000559e:	f7fb fbe1 	bl	20000d64 <printf>
200055a2:	e002      	b.n	200055aa <dumpmem+0x182>
			}
		    else {
			printf("         ");
200055a4:	4846      	ldr	r0, [pc, #280]	@ (200056c0 <dumpmem+0x298>)
200055a6:	f7fb fbdd 	bl	20000d64 <printf>
		for (x = 0; x < 16; x+=4) {
200055aa:	6bbb      	ldr	r3, [r7, #56]	@ 0x38
200055ac:	3304      	adds	r3, #4
200055ae:	63bb      	str	r3, [r7, #56]	@ 0x38
200055b0:	6bbb      	ldr	r3, [r7, #56]	@ 0x38
200055b2:	2b0f      	cmp	r3, #15
200055b4:	ddce      	ble.n	20005554 <dumpmem+0x12c>
			}
		    }
		break;
200055b6:	e037      	b.n	20005628 <dumpmem+0x200>
	    case 8:
		for (x = 0; x < 16; x+=8) { 
200055b8:	2300      	movs	r3, #0
200055ba:	63bb      	str	r3, [r7, #56]	@ 0x38
200055bc:	e030      	b.n	20005620 <dumpmem+0x1f8>
		    if (idx+x < length) {
200055be:	6bfa      	ldr	r2, [r7, #60]	@ 0x3c
200055c0:	6bbb      	ldr	r3, [r7, #56]	@ 0x38
200055c2:	4413      	add	r3, r2
200055c4:	687a      	ldr	r2, [r7, #4]
200055c6:	429a      	cmp	r2, r3
200055c8:	dd24      	ble.n	20005614 <dumpmem+0x1ec>
			if ((res = mem_peek(&q, (addr+idx+x), MEM_QUADWORD))) {
200055ca:	68fa      	ldr	r2, [r7, #12]
200055cc:	6bfb      	ldr	r3, [r7, #60]	@ 0x3c
200055ce:	441a      	add	r2, r3
200055d0:	6bbb      	ldr	r3, [r7, #56]	@ 0x38
200055d2:	18d1      	adds	r1, r2, r3
200055d4:	f107 0320 	add.w	r3, r7, #32
200055d8:	2204      	movs	r2, #4
200055da:	4618      	mov	r0, r3
200055dc:	f7fb fe3c 	bl	20001258 <mem_peek>
200055e0:	6378      	str	r0, [r7, #52]	@ 0x34
200055e2:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
200055e4:	2b00      	cmp	r3, #0
200055e6:	d001      	beq.n	200055ec <dumpmem+0x1c4>
			    return res;
200055e8:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
200055ea:	e059      	b.n	200056a0 <dumpmem+0x278>
			    }
			line.quads[x/8] = q;
200055ec:	6bbb      	ldr	r3, [r7, #56]	@ 0x38
200055ee:	2b00      	cmp	r3, #0
200055f0:	da00      	bge.n	200055f4 <dumpmem+0x1cc>
200055f2:	3307      	adds	r3, #7
200055f4:	10db      	asrs	r3, r3, #3
200055f6:	4619      	mov	r1, r3
200055f8:	e9d7 2308 	ldrd	r2, r3, [r7, #32]
200055fc:	00c9      	lsls	r1, r1, #3
200055fe:	3140      	adds	r1, #64	@ 0x40
20005600:	4439      	add	r1, r7
20005602:	3930      	subs	r1, #48	@ 0x30
20005604:	e9c1 2300 	strd	r2, r3, [r1]
			printf("%016llX ",q);
20005608:	e9d7 2308 	ldrd	r2, r3, [r7, #32]
2000560c:	482d      	ldr	r0, [pc, #180]	@ (200056c4 <dumpmem+0x29c>)
2000560e:	f7fb fba9 	bl	20000d64 <printf>
20005612:	e002      	b.n	2000561a <dumpmem+0x1f2>
			}
		    else { 
			printf("                 ");
20005614:	482c      	ldr	r0, [pc, #176]	@ (200056c8 <dumpmem+0x2a0>)
20005616:	f7fb fba5 	bl	20000d64 <printf>
		for (x = 0; x < 16; x+=8) { 
2000561a:	6bbb      	ldr	r3, [r7, #56]	@ 0x38
2000561c:	3308      	adds	r3, #8
2000561e:	63bb      	str	r3, [r7, #56]	@ 0x38
20005620:	6bbb      	ldr	r3, [r7, #56]	@ 0x38
20005622:	2b0f      	cmp	r3, #15
20005624:	ddcb      	ble.n	200055be <dumpmem+0x196>
			}
		    }
		break;
20005626:	bf00      	nop
	    }

	printf(" ");
20005628:	4828      	ldr	r0, [pc, #160]	@ (200056cc <dumpmem+0x2a4>)
2000562a:	f7fb fb9b 	bl	20000d64 <printf>
	for (x = 0; x < 16; x++) {
2000562e:	2300      	movs	r3, #0
20005630:	63bb      	str	r3, [r7, #56]	@ 0x38
20005632:	e026      	b.n	20005682 <dumpmem+0x25a>
	    if (idx+x < length) {
20005634:	6bfa      	ldr	r2, [r7, #60]	@ 0x3c
20005636:	6bbb      	ldr	r3, [r7, #56]	@ 0x38
20005638:	4413      	add	r3, r2
2000563a:	687a      	ldr	r2, [r7, #4]
2000563c:	429a      	cmp	r2, r3
2000563e:	dd1a      	ble.n	20005676 <dumpmem+0x24e>
		b = line.bytes[x];
20005640:	f107 0210 	add.w	r2, r7, #16
20005644:	6bbb      	ldr	r3, [r7, #56]	@ 0x38
20005646:	4413      	add	r3, r2
20005648:	781b      	ldrb	r3, [r3, #0]
2000564a:	f887 3033 	strb.w	r3, [r7, #51]	@ 0x33
		if ((b < 32) || (b > 127)) printf(".");
2000564e:	f897 3033 	ldrb.w	r3, [r7, #51]	@ 0x33
20005652:	2b1f      	cmp	r3, #31
20005654:	d904      	bls.n	20005660 <dumpmem+0x238>
20005656:	f897 3033 	ldrb.w	r3, [r7, #51]	@ 0x33
2000565a:	b25b      	sxtb	r3, r3
2000565c:	2b00      	cmp	r3, #0
2000565e:	da03      	bge.n	20005668 <dumpmem+0x240>
20005660:	481b      	ldr	r0, [pc, #108]	@ (200056d0 <dumpmem+0x2a8>)
20005662:	f7fb fb7f 	bl	20000d64 <printf>
20005666:	e009      	b.n	2000567c <dumpmem+0x254>
		else printf("%c",b);
20005668:	f897 3033 	ldrb.w	r3, [r7, #51]	@ 0x33
2000566c:	4619      	mov	r1, r3
2000566e:	4819      	ldr	r0, [pc, #100]	@ (200056d4 <dumpmem+0x2ac>)
20005670:	f7fb fb78 	bl	20000d64 <printf>
20005674:	e002      	b.n	2000567c <dumpmem+0x254>
		}
	    else {
		printf(" ");
20005676:	4815      	ldr	r0, [pc, #84]	@ (200056cc <dumpmem+0x2a4>)
20005678:	f7fb fb74 	bl	20000d64 <printf>
	for (x = 0; x < 16; x++) {
2000567c:	6bbb      	ldr	r3, [r7, #56]	@ 0x38
2000567e:	3301      	adds	r3, #1
20005680:	63bb      	str	r3, [r7, #56]	@ 0x38
20005682:	6bbb      	ldr	r3, [r7, #56]	@ 0x38
20005684:	2b0f      	cmp	r3, #15
20005686:	ddd5      	ble.n	20005634 <dumpmem+0x20c>
		}
	    }
	printf("\r\n");
20005688:	4813      	ldr	r0, [pc, #76]	@ (200056d8 <dumpmem+0x2b0>)
2000568a:	f7fb fb6b 	bl	20000d64 <printf>
    for (idx = 0; idx < length; idx += 16) {
2000568e:	6bfb      	ldr	r3, [r7, #60]	@ 0x3c
20005690:	3310      	adds	r3, #16
20005692:	63fb      	str	r3, [r7, #60]	@ 0x3c
20005694:	6bfa      	ldr	r2, [r7, #60]	@ 0x3c
20005696:	687b      	ldr	r3, [r7, #4]
20005698:	429a      	cmp	r2, r3
2000569a:	f6ff aed6 	blt.w	2000544a <dumpmem+0x22>
	}

    return 0;
2000569e:	2300      	movs	r3, #0
}
200056a0:	4618      	mov	r0, r3
200056a2:	3740      	adds	r7, #64	@ 0x40
200056a4:	46bd      	mov	sp, r7
200056a6:	bd80      	pop	{r7, pc}
200056a8:	20007ec4 	.word	0x20007ec4
200056ac:	20007ed0 	.word	0x20007ed0
200056b0:	20007ed8 	.word	0x20007ed8
200056b4:	20007edc 	.word	0x20007edc
200056b8:	20007ee4 	.word	0x20007ee4
200056bc:	20007eec 	.word	0x20007eec
200056c0:	20007ef4 	.word	0x20007ef4
200056c4:	20007f00 	.word	0x20007f00
200056c8:	20007f0c 	.word	0x20007f0c
200056cc:	20007f20 	.word	0x20007f20
200056d0:	20007ebc 	.word	0x20007ebc
200056d4:	20007f24 	.word	0x20007f24
200056d8:	20007f28 	.word	0x20007f28

200056dc <ui_cmd_memedit>:

static int ui_cmd_memedit(ui_cmdline_t *cmd,int argc,char *argv[])
{
200056dc:	b580      	push	{r7, lr}
200056de:	b0d8      	sub	sp, #352	@ 0x160
200056e0:	af00      	add	r7, sp, #0
200056e2:	f507 73b0 	add.w	r3, r7, #352	@ 0x160
200056e6:	f5a3 73aa 	sub.w	r3, r3, #340	@ 0x154
200056ea:	6018      	str	r0, [r3, #0]
200056ec:	f507 73b0 	add.w	r3, r7, #352	@ 0x160
200056f0:	f5a3 73ac 	sub.w	r3, r3, #344	@ 0x158
200056f4:	6019      	str	r1, [r3, #0]
200056f6:	f507 73b0 	add.w	r3, r7, #352	@ 0x160
200056fa:	f5a3 73ae 	sub.w	r3, r3, #348	@ 0x15c
200056fe:	601a      	str	r2, [r3, #0]

    hsaddr_t addr;
    char *vtext;
    int wlen;
    int count;
    int idx = 1;
20005700:	2301      	movs	r3, #1
20005702:	f8c7 3154 	str.w	r3, [r7, #340]	@ 0x154
    int stuffed = 0;
20005706:	2300      	movs	r3, #0
20005708:	f8c7 3150 	str.w	r3, [r7, #336]	@ 0x150
    int res = 0;
2000570c:	2300      	movs	r3, #0
2000570e:	f8c7 314c 	str.w	r3, [r7, #332]	@ 0x14c

    getaddrargs(cmd,&prev_wtype,&prev_addr,NULL);
20005712:	f507 73b0 	add.w	r3, r7, #352	@ 0x160
20005716:	f5a3 70aa 	sub.w	r0, r3, #340	@ 0x154
2000571a:	2300      	movs	r3, #0
2000571c:	4ab3      	ldr	r2, [pc, #716]	@ (200059ec <ui_cmd_memedit+0x310>)
2000571e:	49b4      	ldr	r1, [pc, #720]	@ (200059f0 <ui_cmd_memedit+0x314>)
20005720:	6800      	ldr	r0, [r0, #0]
20005722:	f7ff fd0f 	bl	20005144 <getaddrargs>

    wlen = prev_wtype & ATYPE_SIZE_MASK;
20005726:	4bb2      	ldr	r3, [pc, #712]	@ (200059f0 <ui_cmd_memedit+0x314>)
20005728:	681b      	ldr	r3, [r3, #0]
2000572a:	f003 030f 	and.w	r3, r3, #15
2000572e:	f8c7 3148 	str.w	r3, [r7, #328]	@ 0x148

    vtext = cmd_getarg(cmd,idx++);
20005732:	f8d7 3154 	ldr.w	r3, [r7, #340]	@ 0x154
20005736:	1c5a      	adds	r2, r3, #1
20005738:	f8c7 2154 	str.w	r2, [r7, #340]	@ 0x154
2000573c:	f507 72b0 	add.w	r2, r7, #352	@ 0x160
20005740:	f5a2 72aa 	sub.w	r2, r2, #340	@ 0x154
20005744:	4619      	mov	r1, r3
20005746:	6810      	ldr	r0, [r2, #0]
20005748:	f7fe fc89 	bl	2000405e <cmd_getarg>
2000574c:	f8c7 0158 	str.w	r0, [r7, #344]	@ 0x158

    addr = prev_addr;
20005750:	4ba6      	ldr	r3, [pc, #664]	@ (200059ec <ui_cmd_memedit+0x310>)
20005752:	681b      	ldr	r3, [r3, #0]
20005754:	f8c7 315c 	str.w	r3, [r7, #348]	@ 0x15c

    while (vtext) {
20005758:	e041      	b.n	200057de <ui_cmd_memedit+0x102>
	count = stuffmem(addr,wlen,vtext);
2000575a:	f8d7 2158 	ldr.w	r2, [r7, #344]	@ 0x158
2000575e:	f8d7 1148 	ldr.w	r1, [r7, #328]	@ 0x148
20005762:	f8d7 015c 	ldr.w	r0, [r7, #348]	@ 0x15c
20005766:	f7ff fdcb 	bl	20005300 <stuffmem>
2000576a:	f8c7 0144 	str.w	r0, [r7, #324]	@ 0x144
	if (count < 0) {
2000576e:	f8d7 3144 	ldr.w	r3, [r7, #324]	@ 0x144
20005772:	2b00      	cmp	r3, #0
20005774:	da07      	bge.n	20005786 <ui_cmd_memedit+0xaa>
	    ui_showerror(count,"Could not modify memory");
20005776:	499f      	ldr	r1, [pc, #636]	@ (200059f4 <ui_cmd_memedit+0x318>)
20005778:	f8d7 0144 	ldr.w	r0, [r7, #324]	@ 0x144
2000577c:	f7fe fab2 	bl	20003ce4 <ui_showerror>
	    return count;			/* error */
20005780:	f8d7 3144 	ldr.w	r3, [r7, #324]	@ 0x144
20005784:	e12d      	b.n	200059e2 <ui_cmd_memedit+0x306>
	    }
	addr += count*wlen;
20005786:	f8d7 3144 	ldr.w	r3, [r7, #324]	@ 0x144
2000578a:	f8d7 2148 	ldr.w	r2, [r7, #328]	@ 0x148
2000578e:	fb02 f303 	mul.w	r3, r2, r3
20005792:	f8d7 215c 	ldr.w	r2, [r7, #348]	@ 0x15c
20005796:	4413      	add	r3, r2
20005798:	f8c7 315c 	str.w	r3, [r7, #348]	@ 0x15c
	prev_addr += count*wlen;
2000579c:	f8d7 3144 	ldr.w	r3, [r7, #324]	@ 0x144
200057a0:	f8d7 2148 	ldr.w	r2, [r7, #328]	@ 0x148
200057a4:	fb03 f202 	mul.w	r2, r3, r2
200057a8:	4b90      	ldr	r3, [pc, #576]	@ (200059ec <ui_cmd_memedit+0x310>)
200057aa:	681b      	ldr	r3, [r3, #0]
200057ac:	4413      	add	r3, r2
200057ae:	4a8f      	ldr	r2, [pc, #572]	@ (200059ec <ui_cmd_memedit+0x310>)
200057b0:	6013      	str	r3, [r2, #0]
	stuffed += count;
200057b2:	f8d7 2150 	ldr.w	r2, [r7, #336]	@ 0x150
200057b6:	f8d7 3144 	ldr.w	r3, [r7, #324]	@ 0x144
200057ba:	4413      	add	r3, r2
200057bc:	f8c7 3150 	str.w	r3, [r7, #336]	@ 0x150
	vtext = cmd_getarg(cmd,idx++);
200057c0:	f8d7 3154 	ldr.w	r3, [r7, #340]	@ 0x154
200057c4:	1c5a      	adds	r2, r3, #1
200057c6:	f8c7 2154 	str.w	r2, [r7, #340]	@ 0x154
200057ca:	f507 72b0 	add.w	r2, r7, #352	@ 0x160
200057ce:	f5a2 72aa 	sub.w	r2, r2, #340	@ 0x154
200057d2:	4619      	mov	r1, r3
200057d4:	6810      	ldr	r0, [r2, #0]
200057d6:	f7fe fc42 	bl	2000405e <cmd_getarg>
200057da:	f8c7 0158 	str.w	r0, [r7, #344]	@ 0x158
    while (vtext) {
200057de:	f8d7 3158 	ldr.w	r3, [r7, #344]	@ 0x158
200057e2:	2b00      	cmp	r3, #0
200057e4:	d1b9      	bne.n	2000575a <ui_cmd_memedit+0x7e>
	}

    if (stuffed == 0) {
200057e6:	f8d7 3150 	ldr.w	r3, [r7, #336]	@ 0x150
200057ea:	2b00      	cmp	r3, #0
200057ec:	f040 80f8 	bne.w	200059e0 <ui_cmd_memedit+0x304>
	char line[256];
	char prompt[32];

	printf("Type '.' to exit, '-' to back up, '=' to dump memory.\n");
200057f0:	4881      	ldr	r0, [pc, #516]	@ (200059f8 <ui_cmd_memedit+0x31c>)
200057f2:	f7fb fab7 	bl	20000d64 <printf>
	for (;;) {

	    addr = prev_addr;
200057f6:	4b7d      	ldr	r3, [pc, #500]	@ (200059ec <ui_cmd_memedit+0x310>)
200057f8:	681b      	ldr	r3, [r3, #0]
200057fa:	f8c7 315c 	str.w	r3, [r7, #348]	@ 0x15c
	    if ((prev_wtype & ATYPE_TYPE_MASK) == ATYPE_TYPE_PHYS) {
200057fe:	4b7c      	ldr	r3, [pc, #496]	@ (200059f0 <ui_cmd_memedit+0x314>)
20005800:	681b      	ldr	r3, [r3, #0]
20005802:	f003 03f0 	and.w	r3, r3, #240	@ 0xf0
20005806:	2b10      	cmp	r3, #16
		addr = UNCADDR(addr);
		}

	    printf(PTRFMT "%c ",prev_addr,(addr != prev_addr) ? '%' : ':');
20005808:	4b78      	ldr	r3, [pc, #480]	@ (200059ec <ui_cmd_memedit+0x310>)
2000580a:	6819      	ldr	r1, [r3, #0]
2000580c:	4b77      	ldr	r3, [pc, #476]	@ (200059ec <ui_cmd_memedit+0x310>)
2000580e:	681b      	ldr	r3, [r3, #0]
20005810:	f8d7 215c 	ldr.w	r2, [r7, #348]	@ 0x15c
20005814:	429a      	cmp	r2, r3
20005816:	d001      	beq.n	2000581c <ui_cmd_memedit+0x140>
20005818:	2325      	movs	r3, #37	@ 0x25
2000581a:	e000      	b.n	2000581e <ui_cmd_memedit+0x142>
2000581c:	233a      	movs	r3, #58	@ 0x3a
2000581e:	461a      	mov	r2, r3
20005820:	4876      	ldr	r0, [pc, #472]	@ (200059fc <ui_cmd_memedit+0x320>)
20005822:	f7fb fa9f 	bl	20000d64 <printf>

	    switch (wlen) {
20005826:	f8d7 3148 	ldr.w	r3, [r7, #328]	@ 0x148
2000582a:	2b08      	cmp	r3, #8
2000582c:	d05b      	beq.n	200058e6 <ui_cmd_memedit+0x20a>
2000582e:	f8d7 3148 	ldr.w	r3, [r7, #328]	@ 0x148
20005832:	2b08      	cmp	r3, #8
20005834:	dc07      	bgt.n	20005846 <ui_cmd_memedit+0x16a>
20005836:	f8d7 3148 	ldr.w	r3, [r7, #328]	@ 0x148
2000583a:	2b02      	cmp	r3, #2
2000583c:	d01e      	beq.n	2000587c <ui_cmd_memedit+0x1a0>
2000583e:	f8d7 3148 	ldr.w	r3, [r7, #328]	@ 0x148
20005842:	2b04      	cmp	r3, #4
20005844:	d035      	beq.n	200058b2 <ui_cmd_memedit+0x1d6>
		default:
		case 1:
		    if ((res = mem_peek(&b, addr, MEM_BYTE))) {
20005846:	f207 1343 	addw	r3, r7, #323	@ 0x143
2000584a:	2201      	movs	r2, #1
2000584c:	f8d7 115c 	ldr.w	r1, [r7, #348]	@ 0x15c
20005850:	4618      	mov	r0, r3
20005852:	f7fb fd01 	bl	20001258 <mem_peek>
20005856:	f8c7 014c 	str.w	r0, [r7, #332]	@ 0x14c
2000585a:	f8d7 314c 	ldr.w	r3, [r7, #332]	@ 0x14c
2000585e:	2b00      	cmp	r3, #0
20005860:	d002      	beq.n	20005868 <ui_cmd_memedit+0x18c>
			return res;
20005862:	f8d7 314c 	ldr.w	r3, [r7, #332]	@ 0x14c
20005866:	e0bc      	b.n	200059e2 <ui_cmd_memedit+0x306>
			}
		    xsprintf(prompt,"[%02X]: ", b);
20005868:	f897 3143 	ldrb.w	r3, [r7, #323]	@ 0x143
2000586c:	461a      	mov	r2, r3
2000586e:	f107 0310 	add.w	r3, r7, #16
20005872:	4963      	ldr	r1, [pc, #396]	@ (20005a00 <ui_cmd_memedit+0x324>)
20005874:	4618      	mov	r0, r3
20005876:	f7fb fa5f 	bl	20000d38 <xsprintf>
		    break;
2000587a:	e04d      	b.n	20005918 <ui_cmd_memedit+0x23c>
		case 2:
		    if ((res = mem_peek(&h, addr, MEM_HALFWORD))) {
2000587c:	f507 73a0 	add.w	r3, r7, #320	@ 0x140
20005880:	2202      	movs	r2, #2
20005882:	f8d7 115c 	ldr.w	r1, [r7, #348]	@ 0x15c
20005886:	4618      	mov	r0, r3
20005888:	f7fb fce6 	bl	20001258 <mem_peek>
2000588c:	f8c7 014c 	str.w	r0, [r7, #332]	@ 0x14c
20005890:	f8d7 314c 	ldr.w	r3, [r7, #332]	@ 0x14c
20005894:	2b00      	cmp	r3, #0
20005896:	d002      	beq.n	2000589e <ui_cmd_memedit+0x1c2>
			return res;
20005898:	f8d7 314c 	ldr.w	r3, [r7, #332]	@ 0x14c
2000589c:	e0a1      	b.n	200059e2 <ui_cmd_memedit+0x306>
			}
		    xsprintf(prompt,"[%04X]: ",h);
2000589e:	f8b7 3140 	ldrh.w	r3, [r7, #320]	@ 0x140
200058a2:	461a      	mov	r2, r3
200058a4:	f107 0310 	add.w	r3, r7, #16
200058a8:	4956      	ldr	r1, [pc, #344]	@ (20005a04 <ui_cmd_memedit+0x328>)
200058aa:	4618      	mov	r0, r3
200058ac:	f7fb fa44 	bl	20000d38 <xsprintf>
		    break;
200058b0:	e032      	b.n	20005918 <ui_cmd_memedit+0x23c>
		case 4:
		    if ((res = mem_peek(&w, addr, MEM_WORD))) {
200058b2:	f507 739e 	add.w	r3, r7, #316	@ 0x13c
200058b6:	2203      	movs	r2, #3
200058b8:	f8d7 115c 	ldr.w	r1, [r7, #348]	@ 0x15c
200058bc:	4618      	mov	r0, r3
200058be:	f7fb fccb 	bl	20001258 <mem_peek>
200058c2:	f8c7 014c 	str.w	r0, [r7, #332]	@ 0x14c
200058c6:	f8d7 314c 	ldr.w	r3, [r7, #332]	@ 0x14c
200058ca:	2b00      	cmp	r3, #0
200058cc:	d002      	beq.n	200058d4 <ui_cmd_memedit+0x1f8>
			return res;
200058ce:	f8d7 314c 	ldr.w	r3, [r7, #332]	@ 0x14c
200058d2:	e086      	b.n	200059e2 <ui_cmd_memedit+0x306>
			}
		    xsprintf(prompt,"[%08X]: ",w);
200058d4:	f8d7 213c 	ldr.w	r2, [r7, #316]	@ 0x13c
200058d8:	f107 0310 	add.w	r3, r7, #16
200058dc:	494a      	ldr	r1, [pc, #296]	@ (20005a08 <ui_cmd_memedit+0x32c>)
200058de:	4618      	mov	r0, r3
200058e0:	f7fb fa2a 	bl	20000d38 <xsprintf>
		    break;
200058e4:	e018      	b.n	20005918 <ui_cmd_memedit+0x23c>
		case 8:
		    if ((res = mem_peek(&q, addr, MEM_QUADWORD))) {
200058e6:	f507 7398 	add.w	r3, r7, #304	@ 0x130
200058ea:	2204      	movs	r2, #4
200058ec:	f8d7 115c 	ldr.w	r1, [r7, #348]	@ 0x15c
200058f0:	4618      	mov	r0, r3
200058f2:	f7fb fcb1 	bl	20001258 <mem_peek>
200058f6:	f8c7 014c 	str.w	r0, [r7, #332]	@ 0x14c
200058fa:	f8d7 314c 	ldr.w	r3, [r7, #332]	@ 0x14c
200058fe:	2b00      	cmp	r3, #0
20005900:	d002      	beq.n	20005908 <ui_cmd_memedit+0x22c>
			return res;
20005902:	f8d7 314c 	ldr.w	r3, [r7, #332]	@ 0x14c
20005906:	e06c      	b.n	200059e2 <ui_cmd_memedit+0x306>
			}
		    xsprintf(prompt,"[%016llX]: ",q);
20005908:	e9d7 234c 	ldrd	r2, r3, [r7, #304]	@ 0x130
2000590c:	f107 0010 	add.w	r0, r7, #16
20005910:	493e      	ldr	r1, [pc, #248]	@ (20005a0c <ui_cmd_memedit+0x330>)
20005912:	f7fb fa11 	bl	20000d38 <xsprintf>
		    break;
20005916:	bf00      	nop
		}

	    console_readline(prompt,line,sizeof(line));
20005918:	f107 0130 	add.w	r1, r7, #48	@ 0x30
2000591c:	f107 0310 	add.w	r3, r7, #16
20005920:	f44f 7280 	mov.w	r2, #256	@ 0x100
20005924:	4618      	mov	r0, r3
20005926:	f7fd f9cf 	bl	20002cc8 <console_readline>
	    if (line[0] == '-') {
2000592a:	f507 73b0 	add.w	r3, r7, #352	@ 0x160
2000592e:	f5a3 7398 	sub.w	r3, r3, #304	@ 0x130
20005932:	781b      	ldrb	r3, [r3, #0]
20005934:	2b2d      	cmp	r3, #45	@ 0x2d
20005936:	d107      	bne.n	20005948 <ui_cmd_memedit+0x26c>
		prev_addr -= wlen;
20005938:	4b2c      	ldr	r3, [pc, #176]	@ (200059ec <ui_cmd_memedit+0x310>)
2000593a:	681a      	ldr	r2, [r3, #0]
2000593c:	f8d7 3148 	ldr.w	r3, [r7, #328]	@ 0x148
20005940:	1ad3      	subs	r3, r2, r3
20005942:	4a2a      	ldr	r2, [pc, #168]	@ (200059ec <ui_cmd_memedit+0x310>)
20005944:	6013      	str	r3, [r2, #0]
		continue;
20005946:	e047      	b.n	200059d8 <ui_cmd_memedit+0x2fc>
		}
	    if (line[0] == '=') {
20005948:	f507 73b0 	add.w	r3, r7, #352	@ 0x160
2000594c:	f5a3 7398 	sub.w	r3, r3, #304	@ 0x130
20005950:	781b      	ldrb	r3, [r3, #0]
20005952:	2b3d      	cmp	r3, #61	@ 0x3d
20005954:	d109      	bne.n	2000596a <ui_cmd_memedit+0x28e>
		dumpmem(prev_addr,prev_addr,16,wlen);
20005956:	4b25      	ldr	r3, [pc, #148]	@ (200059ec <ui_cmd_memedit+0x310>)
20005958:	6818      	ldr	r0, [r3, #0]
2000595a:	4b24      	ldr	r3, [pc, #144]	@ (200059ec <ui_cmd_memedit+0x310>)
2000595c:	6819      	ldr	r1, [r3, #0]
2000595e:	f8d7 3148 	ldr.w	r3, [r7, #328]	@ 0x148
20005962:	2210      	movs	r2, #16
20005964:	f7ff fd60 	bl	20005428 <dumpmem>
		continue;
20005968:	e036      	b.n	200059d8 <ui_cmd_memedit+0x2fc>
		}
	    if (line[0] == '.') {
2000596a:	f507 73b0 	add.w	r3, r7, #352	@ 0x160
2000596e:	f5a3 7398 	sub.w	r3, r3, #304	@ 0x130
20005972:	781b      	ldrb	r3, [r3, #0]
20005974:	2b2e      	cmp	r3, #46	@ 0x2e
20005976:	d030      	beq.n	200059da <ui_cmd_memedit+0x2fe>
		break;
		}
	    if (line[0] == '\0') {
20005978:	f507 73b0 	add.w	r3, r7, #352	@ 0x160
2000597c:	f5a3 7398 	sub.w	r3, r3, #304	@ 0x130
20005980:	781b      	ldrb	r3, [r3, #0]
20005982:	2b00      	cmp	r3, #0
20005984:	d107      	bne.n	20005996 <ui_cmd_memedit+0x2ba>
		prev_addr += wlen;
20005986:	4b19      	ldr	r3, [pc, #100]	@ (200059ec <ui_cmd_memedit+0x310>)
20005988:	681a      	ldr	r2, [r3, #0]
2000598a:	f8d7 3148 	ldr.w	r3, [r7, #328]	@ 0x148
2000598e:	4413      	add	r3, r2
20005990:	4a16      	ldr	r2, [pc, #88]	@ (200059ec <ui_cmd_memedit+0x310>)
20005992:	6013      	str	r3, [r2, #0]
		continue;
20005994:	e020      	b.n	200059d8 <ui_cmd_memedit+0x2fc>
		}
	    count = stuffmem(addr,wlen,line);
20005996:	f107 0330 	add.w	r3, r7, #48	@ 0x30
2000599a:	461a      	mov	r2, r3
2000599c:	f8d7 1148 	ldr.w	r1, [r7, #328]	@ 0x148
200059a0:	f8d7 015c 	ldr.w	r0, [r7, #348]	@ 0x15c
200059a4:	f7ff fcac 	bl	20005300 <stuffmem>
200059a8:	f8c7 0144 	str.w	r0, [r7, #324]	@ 0x144
	    if (count < 0) return count;
200059ac:	f8d7 3144 	ldr.w	r3, [r7, #324]	@ 0x144
200059b0:	2b00      	cmp	r3, #0
200059b2:	da02      	bge.n	200059ba <ui_cmd_memedit+0x2de>
200059b4:	f8d7 3144 	ldr.w	r3, [r7, #324]	@ 0x144
200059b8:	e013      	b.n	200059e2 <ui_cmd_memedit+0x306>
	    if (count == 0) break;
200059ba:	f8d7 3144 	ldr.w	r3, [r7, #324]	@ 0x144
200059be:	2b00      	cmp	r3, #0
200059c0:	d00d      	beq.n	200059de <ui_cmd_memedit+0x302>
	    prev_addr += count*wlen;
200059c2:	f8d7 3144 	ldr.w	r3, [r7, #324]	@ 0x144
200059c6:	f8d7 2148 	ldr.w	r2, [r7, #328]	@ 0x148
200059ca:	fb03 f202 	mul.w	r2, r3, r2
200059ce:	4b07      	ldr	r3, [pc, #28]	@ (200059ec <ui_cmd_memedit+0x310>)
200059d0:	681b      	ldr	r3, [r3, #0]
200059d2:	4413      	add	r3, r2
200059d4:	4a05      	ldr	r2, [pc, #20]	@ (200059ec <ui_cmd_memedit+0x310>)
200059d6:	6013      	str	r3, [r2, #0]
	    addr = prev_addr;
200059d8:	e70d      	b.n	200057f6 <ui_cmd_memedit+0x11a>
		break;
200059da:	bf00      	nop
200059dc:	e000      	b.n	200059e0 <ui_cmd_memedit+0x304>
	    if (count == 0) break;
200059de:	bf00      	nop
	    }
	}

    return 0;
200059e0:	2300      	movs	r3, #0
}
200059e2:	4618      	mov	r0, r3
200059e4:	f507 77b0 	add.w	r7, r7, #352	@ 0x160
200059e8:	46bd      	mov	sp, r7
200059ea:	bd80      	pop	{r7, pc}
200059ec:	20009478 	.word	0x20009478
200059f0:	200091f0 	.word	0x200091f0
200059f4:	20007f2c 	.word	0x20007f2c
200059f8:	20007f44 	.word	0x20007f44
200059fc:	20007ec4 	.word	0x20007ec4
20005a00:	20007f7c 	.word	0x20007f7c
20005a04:	20007f88 	.word	0x20007f88
20005a08:	20007f94 	.word	0x20007f94
20005a0c:	20007fa0 	.word	0x20007fa0

20005a10 <ui_cmd_memfill>:

static int ui_cmd_memfill(ui_cmdline_t *cmd,int argc,char *argv[])
{
20005a10:	b580      	push	{r7, lr}
20005a12:	b090      	sub	sp, #64	@ 0x40
20005a14:	af02      	add	r7, sp, #8
20005a16:	60f8      	str	r0, [r7, #12]
20005a18:	60b9      	str	r1, [r7, #8]
20005a1a:	607a      	str	r2, [r7, #4]
    hsaddr_t addr;
    char *atext;
    int wlen;
    int idx = 2;
20005a1c:	2302      	movs	r3, #2
20005a1e:	633b      	str	r3, [r7, #48]	@ 0x30
    int len;
    uint64_t pattern;
    int res;

    getaddrargs(cmd,&prev_wtype,&prev_addr,&len);
20005a20:	f107 0314 	add.w	r3, r7, #20
20005a24:	4a4f      	ldr	r2, [pc, #316]	@ (20005b64 <ui_cmd_memfill+0x154>)
20005a26:	4950      	ldr	r1, [pc, #320]	@ (20005b68 <ui_cmd_memfill+0x158>)
20005a28:	68f8      	ldr	r0, [r7, #12]
20005a2a:	f7ff fb8b 	bl	20005144 <getaddrargs>

    atext = cmd_getarg(cmd,idx++);
20005a2e:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
20005a30:	1c5a      	adds	r2, r3, #1
20005a32:	633a      	str	r2, [r7, #48]	@ 0x30
20005a34:	4619      	mov	r1, r3
20005a36:	68f8      	ldr	r0, [r7, #12]
20005a38:	f7fe fb11 	bl	2000405e <cmd_getarg>
20005a3c:	62f8      	str	r0, [r7, #44]	@ 0x2c
    if (!atext) return ui_showusage(cmd);
20005a3e:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
20005a40:	2b00      	cmp	r3, #0
20005a42:	d104      	bne.n	20005a4e <ui_cmd_memfill+0x3e>
20005a44:	68f8      	ldr	r0, [r7, #12]
20005a46:	f7fe f9de 	bl	20003e06 <ui_showusage>
20005a4a:	4603      	mov	r3, r0
20005a4c:	e086      	b.n	20005b5c <ui_cmd_memfill+0x14c>
    pattern = xtoq(atext);   
20005a4e:	6af8      	ldr	r0, [r7, #44]	@ 0x2c
20005a50:	f7fb fec7 	bl	200017e2 <lib_xtoq>
20005a54:	e9c7 0108 	strd	r0, r1, [r7, #32]

    addr = prev_addr;
20005a58:	4b42      	ldr	r3, [pc, #264]	@ (20005b64 <ui_cmd_memfill+0x154>)
20005a5a:	681b      	ldr	r3, [r3, #0]
20005a5c:	637b      	str	r3, [r7, #52]	@ 0x34

    if ((prev_wtype & ATYPE_TYPE_MASK) == ATYPE_TYPE_PHYS) {
20005a5e:	4b42      	ldr	r3, [pc, #264]	@ (20005b68 <ui_cmd_memfill+0x158>)
20005a60:	681b      	ldr	r3, [r3, #0]
20005a62:	f003 03f0 	and.w	r3, r3, #240	@ 0xf0
20005a66:	2b10      	cmp	r3, #16
	addr = UNCADDR(addr);
	}

    wlen = prev_wtype & ATYPE_SIZE_MASK;
20005a68:	4b3f      	ldr	r3, [pc, #252]	@ (20005b68 <ui_cmd_memfill+0x158>)
20005a6a:	681b      	ldr	r3, [r3, #0]
20005a6c:	f003 030f 	and.w	r3, r3, #15
20005a70:	61fb      	str	r3, [r7, #28]

    switch (wlen) {
20005a72:	69fb      	ldr	r3, [r7, #28]
20005a74:	3b01      	subs	r3, #1
20005a76:	2b07      	cmp	r3, #7
20005a78:	d86f      	bhi.n	20005b5a <ui_cmd_memfill+0x14a>
20005a7a:	a201      	add	r2, pc, #4	@ (adr r2, 20005a80 <ui_cmd_memfill+0x70>)
20005a7c:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
20005a80:	20005ac7 	.word	0x20005ac7
20005a84:	20005af5 	.word	0x20005af5
20005a88:	20005b5b 	.word	0x20005b5b
20005a8c:	20005b25 	.word	0x20005b25
20005a90:	20005b5b 	.word	0x20005b5b
20005a94:	20005b5b 	.word	0x20005b5b
20005a98:	20005b5b 	.word	0x20005b5b
20005a9c:	20005b53 	.word	0x20005b53
	case 1:
	    while (len > 0) {
	        if ((res = mem_poke(addr,  pattern, MEM_BYTE))) {
20005aa0:	2301      	movs	r3, #1
20005aa2:	9300      	str	r3, [sp, #0]
20005aa4:	e9d7 2308 	ldrd	r2, r3, [r7, #32]
20005aa8:	6b78      	ldr	r0, [r7, #52]	@ 0x34
20005aaa:	f7fb fc13 	bl	200012d4 <mem_poke>
20005aae:	61b8      	str	r0, [r7, #24]
20005ab0:	69bb      	ldr	r3, [r7, #24]
20005ab2:	2b00      	cmp	r3, #0
20005ab4:	d001      	beq.n	20005aba <ui_cmd_memfill+0xaa>
		    /*Did not edit*/
		    return 0;
20005ab6:	2300      	movs	r3, #0
20005ab8:	e050      	b.n	20005b5c <ui_cmd_memfill+0x14c>
		    }
		addr++;
20005aba:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
20005abc:	3301      	adds	r3, #1
20005abe:	637b      	str	r3, [r7, #52]	@ 0x34
		len--;
20005ac0:	697b      	ldr	r3, [r7, #20]
20005ac2:	3b01      	subs	r3, #1
20005ac4:	617b      	str	r3, [r7, #20]
	    while (len > 0) {
20005ac6:	697b      	ldr	r3, [r7, #20]
20005ac8:	2b00      	cmp	r3, #0
20005aca:	dce9      	bgt.n	20005aa0 <ui_cmd_memfill+0x90>
		}
	    break;
20005acc:	e045      	b.n	20005b5a <ui_cmd_memfill+0x14a>
	case 2:
	    while (len > 0) {
		if ((res = mem_poke(addr,  pattern, MEM_HALFWORD))) {
20005ace:	2302      	movs	r3, #2
20005ad0:	9300      	str	r3, [sp, #0]
20005ad2:	e9d7 2308 	ldrd	r2, r3, [r7, #32]
20005ad6:	6b78      	ldr	r0, [r7, #52]	@ 0x34
20005ad8:	f7fb fbfc 	bl	200012d4 <mem_poke>
20005adc:	61b8      	str	r0, [r7, #24]
20005ade:	69bb      	ldr	r3, [r7, #24]
20005ae0:	2b00      	cmp	r3, #0
20005ae2:	d001      	beq.n	20005ae8 <ui_cmd_memfill+0xd8>
		    return 0;
20005ae4:	2300      	movs	r3, #0
20005ae6:	e039      	b.n	20005b5c <ui_cmd_memfill+0x14c>
		    }
		addr += 2;
20005ae8:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
20005aea:	3302      	adds	r3, #2
20005aec:	637b      	str	r3, [r7, #52]	@ 0x34
		len--;
20005aee:	697b      	ldr	r3, [r7, #20]
20005af0:	3b01      	subs	r3, #1
20005af2:	617b      	str	r3, [r7, #20]
	    while (len > 0) {
20005af4:	697b      	ldr	r3, [r7, #20]
20005af6:	2b00      	cmp	r3, #0
20005af8:	dce9      	bgt.n	20005ace <ui_cmd_memfill+0xbe>
		}
	    break;
20005afa:	e02e      	b.n	20005b5a <ui_cmd_memfill+0x14a>
	case 4:
	    while (len > 0) {
	        if ((res = mem_poke(addr,  pattern, MEM_WORD))) {
20005afc:	2303      	movs	r3, #3
20005afe:	9300      	str	r3, [sp, #0]
20005b00:	e9d7 2308 	ldrd	r2, r3, [r7, #32]
20005b04:	6b78      	ldr	r0, [r7, #52]	@ 0x34
20005b06:	f7fb fbe5 	bl	200012d4 <mem_poke>
20005b0a:	61b8      	str	r0, [r7, #24]
20005b0c:	69bb      	ldr	r3, [r7, #24]
20005b0e:	2b00      	cmp	r3, #0
20005b10:	d002      	beq.n	20005b18 <ui_cmd_memfill+0x108>
		    return -1;
20005b12:	f04f 33ff 	mov.w	r3, #4294967295	@ 0xffffffff
20005b16:	e021      	b.n	20005b5c <ui_cmd_memfill+0x14c>
		    }
		addr += 4;
20005b18:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
20005b1a:	3304      	adds	r3, #4
20005b1c:	637b      	str	r3, [r7, #52]	@ 0x34
		len--;
20005b1e:	697b      	ldr	r3, [r7, #20]
20005b20:	3b01      	subs	r3, #1
20005b22:	617b      	str	r3, [r7, #20]
	    while (len > 0) {
20005b24:	697b      	ldr	r3, [r7, #20]
20005b26:	2b00      	cmp	r3, #0
20005b28:	dce8      	bgt.n	20005afc <ui_cmd_memfill+0xec>
		}
	    break;
20005b2a:	e016      	b.n	20005b5a <ui_cmd_memfill+0x14a>
	case 8:
	    while (len > 0) {
		if ((res = mem_poke(addr,  pattern, MEM_QUADWORD))) {
20005b2c:	2304      	movs	r3, #4
20005b2e:	9300      	str	r3, [sp, #0]
20005b30:	e9d7 2308 	ldrd	r2, r3, [r7, #32]
20005b34:	6b78      	ldr	r0, [r7, #52]	@ 0x34
20005b36:	f7fb fbcd 	bl	200012d4 <mem_poke>
20005b3a:	61b8      	str	r0, [r7, #24]
20005b3c:	69bb      	ldr	r3, [r7, #24]
20005b3e:	2b00      	cmp	r3, #0
20005b40:	d001      	beq.n	20005b46 <ui_cmd_memfill+0x136>
		    return 0;
20005b42:	2300      	movs	r3, #0
20005b44:	e00a      	b.n	20005b5c <ui_cmd_memfill+0x14c>
		    }
		addr += 8;
20005b46:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
20005b48:	3308      	adds	r3, #8
20005b4a:	637b      	str	r3, [r7, #52]	@ 0x34
		len--;
20005b4c:	697b      	ldr	r3, [r7, #20]
20005b4e:	3b01      	subs	r3, #1
20005b50:	617b      	str	r3, [r7, #20]
	    while (len > 0) {
20005b52:	697b      	ldr	r3, [r7, #20]
20005b54:	2b00      	cmp	r3, #0
20005b56:	dce9      	bgt.n	20005b2c <ui_cmd_memfill+0x11c>
		}
	    break;
20005b58:	bf00      	nop
	}

    return 0;
20005b5a:	2300      	movs	r3, #0
}
20005b5c:	4618      	mov	r0, r3
20005b5e:	3738      	adds	r7, #56	@ 0x38
20005b60:	46bd      	mov	sp, r7
20005b62:	bd80      	pop	{r7, pc}
20005b64:	20009478 	.word	0x20009478
20005b68:	200091f0 	.word	0x200091f0

20005b6c <ui_cmd_memtest>:
             }

#define MEMTEST(ptr,len,pattern) if (!error) { FILL(ptr,len,pattern) ; CHECK(ptr,len,pattern); }

static int ui_cmd_memtest(ui_cmdline_t *cmd,int argc,char *argv[])
{
20005b6c:	e92d 43b0 	stmdb	sp!, {r4, r5, r7, r8, r9, lr}
20005b70:	b090      	sub	sp, #64	@ 0x40
20005b72:	af02      	add	r7, sp, #8
20005b74:	60f8      	str	r0, [r7, #12]
20005b76:	60b9      	str	r1, [r7, #8]
20005b78:	607a      	str	r2, [r7, #4]
    hsaddr_t addr = 0;
20005b7a:	2300      	movs	r3, #0
20005b7c:	61fb      	str	r3, [r7, #28]
    int len = 0;
20005b7e:	2300      	movs	r3, #0
20005b80:	61bb      	str	r3, [r7, #24]
    int wtype = 0;
20005b82:	2300      	movs	r3, #0
20005b84:	617b      	str	r3, [r7, #20]
    hsaddr_t wlen;
    int idx = 0;
20005b86:	2300      	movs	r3, #0
20005b88:	637b      	str	r3, [r7, #52]	@ 0x34
    int error = 0;
20005b8a:	2300      	movs	r3, #0
20005b8c:	633b      	str	r3, [r7, #48]	@ 0x30
    int loopmode = 0;
20005b8e:	2300      	movs	r3, #0
20005b90:	62fb      	str	r3, [r7, #44]	@ 0x2c
    int pass =0;
20005b92:	2300      	movs	r3, #0
20005b94:	62bb      	str	r3, [r7, #40]	@ 0x28
    int nostop;

    nostop = cmd_sw_isset(cmd,"-nostop");
20005b96:	499f      	ldr	r1, [pc, #636]	@ (20005e14 <ui_cmd_memtest+0x2a8>)
20005b98:	68f8      	ldr	r0, [r7, #12]
20005b9a:	f7fe fa37 	bl	2000400c <cmd_sw_isset>
20005b9e:	6278      	str	r0, [r7, #36]	@ 0x24

    getaddrargs(cmd,&wtype,&addr,&len);
20005ba0:	f107 0318 	add.w	r3, r7, #24
20005ba4:	f107 021c 	add.w	r2, r7, #28
20005ba8:	f107 0114 	add.w	r1, r7, #20
20005bac:	68f8      	ldr	r0, [r7, #12]
20005bae:	f7ff fac9 	bl	20005144 <getaddrargs>

    wlen = 8;
20005bb2:	2308      	movs	r3, #8
20005bb4:	623b      	str	r3, [r7, #32]
    addr &= ~(wlen-1);
20005bb6:	6a3b      	ldr	r3, [r7, #32]
20005bb8:	425a      	negs	r2, r3
20005bba:	69fb      	ldr	r3, [r7, #28]
20005bbc:	4013      	ands	r3, r2
20005bbe:	61fb      	str	r3, [r7, #28]

    if ((prev_wtype & ATYPE_TYPE_MASK) == ATYPE_TYPE_PHYS) {
20005bc0:	4b95      	ldr	r3, [pc, #596]	@ (20005e18 <ui_cmd_memtest+0x2ac>)
20005bc2:	681b      	ldr	r3, [r3, #0]
20005bc4:	f003 03f0 	and.w	r3, r3, #240	@ 0xf0
20005bc8:	2b10      	cmp	r3, #16
20005bca:	d101      	bne.n	20005bd0 <ui_cmd_memtest+0x64>
	addr = UNCADDR(addr);
20005bcc:	69fb      	ldr	r3, [r7, #28]
20005bce:	61fb      	str	r3, [r7, #28]
	}

    if (cmd_sw_isset(cmd,"-loop")) {
20005bd0:	4992      	ldr	r1, [pc, #584]	@ (20005e1c <ui_cmd_memtest+0x2b0>)
20005bd2:	68f8      	ldr	r0, [r7, #12]
20005bd4:	f7fe fa1a 	bl	2000400c <cmd_sw_isset>
20005bd8:	4603      	mov	r3, r0
20005bda:	2b00      	cmp	r3, #0
20005bdc:	d001      	beq.n	20005be2 <ui_cmd_memtest+0x76>
	loopmode = 1;
20005bde:	2301      	movs	r3, #1
20005be0:	62fb      	str	r3, [r7, #44]	@ 0x2c
	}

    pass = 0;
20005be2:	2300      	movs	r3, #0
20005be4:	62bb      	str	r3, [r7, #40]	@ 0x28
    for (;;) {
	if (loopmode) {
20005be6:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
20005be8:	2b00      	cmp	r3, #0
20005bea:	d009      	beq.n	20005c00 <ui_cmd_memtest+0x94>
	    printf("Pass %d\n",pass);
20005bec:	6ab9      	ldr	r1, [r7, #40]	@ 0x28
20005bee:	488c      	ldr	r0, [pc, #560]	@ (20005e20 <ui_cmd_memtest+0x2b4>)
20005bf0:	f7fb f8b8 	bl	20000d64 <printf>
	    if (console_status()) break;
20005bf4:	f7fc f8e0 	bl	20001db8 <console_status>
20005bf8:	4603      	mov	r3, r0
20005bfa:	2b00      	cmp	r3, #0
20005bfc:	f040 823b 	bne.w	20006076 <ui_cmd_memtest+0x50a>
	    }
	MEMTEST(addr,len,(idx*8));
20005c00:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
20005c02:	2b00      	cmp	r3, #0
20005c04:	d14d      	bne.n	20005ca2 <ui_cmd_memtest+0x136>
20005c06:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
20005c08:	00db      	lsls	r3, r3, #3
20005c0a:	4619      	mov	r1, r3
20005c0c:	4885      	ldr	r0, [pc, #532]	@ (20005e24 <ui_cmd_memtest+0x2b8>)
20005c0e:	f7fb f8a9 	bl	20000d64 <printf>
20005c12:	2300      	movs	r3, #0
20005c14:	637b      	str	r3, [r7, #52]	@ 0x34
20005c16:	e00d      	b.n	20005c34 <ui_cmd_memtest+0xc8>
20005c18:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
20005c1a:	00db      	lsls	r3, r3, #3
20005c1c:	69f9      	ldr	r1, [r7, #28]
20005c1e:	6b7a      	ldr	r2, [r7, #52]	@ 0x34
20005c20:	440a      	add	r2, r1
20005c22:	17d9      	asrs	r1, r3, #31
20005c24:	4698      	mov	r8, r3
20005c26:	4689      	mov	r9, r1
20005c28:	e9c2 8900 	strd	r8, r9, [r2]
20005c2c:	6b7a      	ldr	r2, [r7, #52]	@ 0x34
20005c2e:	6a3b      	ldr	r3, [r7, #32]
20005c30:	4413      	add	r3, r2
20005c32:	637b      	str	r3, [r7, #52]	@ 0x34
20005c34:	69bb      	ldr	r3, [r7, #24]
20005c36:	6b7a      	ldr	r2, [r7, #52]	@ 0x34
20005c38:	429a      	cmp	r2, r3
20005c3a:	dbed      	blt.n	20005c18 <ui_cmd_memtest+0xac>
20005c3c:	2300      	movs	r3, #0
20005c3e:	637b      	str	r3, [r7, #52]	@ 0x34
20005c40:	e02b      	b.n	20005c9a <ui_cmd_memtest+0x12e>
20005c42:	69fa      	ldr	r2, [r7, #28]
20005c44:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
20005c46:	4413      	add	r3, r2
20005c48:	e9d3 2300 	ldrd	r2, r3, [r3]
20005c4c:	6b79      	ldr	r1, [r7, #52]	@ 0x34
20005c4e:	00c9      	lsls	r1, r1, #3
20005c50:	17c8      	asrs	r0, r1, #31
20005c52:	460c      	mov	r4, r1
20005c54:	4605      	mov	r5, r0
20005c56:	42ab      	cmp	r3, r5
20005c58:	bf08      	it	eq
20005c5a:	42a2      	cmpeq	r2, r4
20005c5c:	d019      	beq.n	20005c92 <ui_cmd_memtest+0x126>
20005c5e:	69fa      	ldr	r2, [r7, #28]
20005c60:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
20005c62:	18d1      	adds	r1, r2, r3
20005c64:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
20005c66:	00d8      	lsls	r0, r3, #3
20005c68:	69fa      	ldr	r2, [r7, #28]
20005c6a:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
20005c6c:	4413      	add	r3, r2
20005c6e:	e9d3 2300 	ldrd	r2, r3, [r3]
20005c72:	e9cd 2300 	strd	r2, r3, [sp]
20005c76:	4602      	mov	r2, r0
20005c78:	486b      	ldr	r0, [pc, #428]	@ (20005e28 <ui_cmd_memtest+0x2bc>)
20005c7a:	f7fb f873 	bl	20000d64 <printf>
20005c7e:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
20005c80:	2b00      	cmp	r3, #0
20005c82:	bf0c      	ite	eq
20005c84:	2301      	moveq	r3, #1
20005c86:	2300      	movne	r3, #0
20005c88:	b2db      	uxtb	r3, r3
20005c8a:	633b      	str	r3, [r7, #48]	@ 0x30
20005c8c:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
20005c8e:	62fb      	str	r3, [r7, #44]	@ 0x2c
20005c90:	e007      	b.n	20005ca2 <ui_cmd_memtest+0x136>
20005c92:	6b7a      	ldr	r2, [r7, #52]	@ 0x34
20005c94:	6a3b      	ldr	r3, [r7, #32]
20005c96:	4413      	add	r3, r2
20005c98:	637b      	str	r3, [r7, #52]	@ 0x34
20005c9a:	69bb      	ldr	r3, [r7, #24]
20005c9c:	6b7a      	ldr	r2, [r7, #52]	@ 0x34
20005c9e:	429a      	cmp	r2, r3
20005ca0:	dbcf      	blt.n	20005c42 <ui_cmd_memtest+0xd6>
	MEMTEST(addr,len,	0);
20005ca2:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
20005ca4:	2b00      	cmp	r3, #0
20005ca6:	d142      	bne.n	20005d2e <ui_cmd_memtest+0x1c2>
20005ca8:	2100      	movs	r1, #0
20005caa:	485e      	ldr	r0, [pc, #376]	@ (20005e24 <ui_cmd_memtest+0x2b8>)
20005cac:	f7fb f85a 	bl	20000d64 <printf>
20005cb0:	2300      	movs	r3, #0
20005cb2:	637b      	str	r3, [r7, #52]	@ 0x34
20005cb4:	e00d      	b.n	20005cd2 <ui_cmd_memtest+0x166>
20005cb6:	69fa      	ldr	r2, [r7, #28]
20005cb8:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
20005cba:	4413      	add	r3, r2
20005cbc:	4619      	mov	r1, r3
20005cbe:	f04f 0200 	mov.w	r2, #0
20005cc2:	f04f 0300 	mov.w	r3, #0
20005cc6:	e9c1 2300 	strd	r2, r3, [r1]
20005cca:	6b7a      	ldr	r2, [r7, #52]	@ 0x34
20005ccc:	6a3b      	ldr	r3, [r7, #32]
20005cce:	4413      	add	r3, r2
20005cd0:	637b      	str	r3, [r7, #52]	@ 0x34
20005cd2:	69bb      	ldr	r3, [r7, #24]
20005cd4:	6b7a      	ldr	r2, [r7, #52]	@ 0x34
20005cd6:	429a      	cmp	r2, r3
20005cd8:	dbed      	blt.n	20005cb6 <ui_cmd_memtest+0x14a>
20005cda:	2300      	movs	r3, #0
20005cdc:	637b      	str	r3, [r7, #52]	@ 0x34
20005cde:	e022      	b.n	20005d26 <ui_cmd_memtest+0x1ba>
20005ce0:	69fa      	ldr	r2, [r7, #28]
20005ce2:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
20005ce4:	4413      	add	r3, r2
20005ce6:	e9d3 2300 	ldrd	r2, r3, [r3]
20005cea:	4313      	orrs	r3, r2
20005cec:	d017      	beq.n	20005d1e <ui_cmd_memtest+0x1b2>
20005cee:	69fa      	ldr	r2, [r7, #28]
20005cf0:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
20005cf2:	18d1      	adds	r1, r2, r3
20005cf4:	69fa      	ldr	r2, [r7, #28]
20005cf6:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
20005cf8:	4413      	add	r3, r2
20005cfa:	e9d3 2300 	ldrd	r2, r3, [r3]
20005cfe:	e9cd 2300 	strd	r2, r3, [sp]
20005d02:	2200      	movs	r2, #0
20005d04:	4848      	ldr	r0, [pc, #288]	@ (20005e28 <ui_cmd_memtest+0x2bc>)
20005d06:	f7fb f82d 	bl	20000d64 <printf>
20005d0a:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
20005d0c:	2b00      	cmp	r3, #0
20005d0e:	bf0c      	ite	eq
20005d10:	2301      	moveq	r3, #1
20005d12:	2300      	movne	r3, #0
20005d14:	b2db      	uxtb	r3, r3
20005d16:	633b      	str	r3, [r7, #48]	@ 0x30
20005d18:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
20005d1a:	62fb      	str	r3, [r7, #44]	@ 0x2c
20005d1c:	e007      	b.n	20005d2e <ui_cmd_memtest+0x1c2>
20005d1e:	6b7a      	ldr	r2, [r7, #52]	@ 0x34
20005d20:	6a3b      	ldr	r3, [r7, #32]
20005d22:	4413      	add	r3, r2
20005d24:	637b      	str	r3, [r7, #52]	@ 0x34
20005d26:	69bb      	ldr	r3, [r7, #24]
20005d28:	6b7a      	ldr	r2, [r7, #52]	@ 0x34
20005d2a:	429a      	cmp	r2, r3
20005d2c:	dbd8      	blt.n	20005ce0 <ui_cmd_memtest+0x174>
	MEMTEST(addr,len,0xFFFFFFFFFFFFFFFFULL);
20005d2e:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
20005d30:	2b00      	cmp	r3, #0
20005d32:	d14c      	bne.n	20005dce <ui_cmd_memtest+0x262>
20005d34:	f04f 32ff 	mov.w	r2, #4294967295	@ 0xffffffff
20005d38:	f04f 33ff 	mov.w	r3, #4294967295	@ 0xffffffff
20005d3c:	4839      	ldr	r0, [pc, #228]	@ (20005e24 <ui_cmd_memtest+0x2b8>)
20005d3e:	f7fb f811 	bl	20000d64 <printf>
20005d42:	2300      	movs	r3, #0
20005d44:	637b      	str	r3, [r7, #52]	@ 0x34
20005d46:	e00d      	b.n	20005d64 <ui_cmd_memtest+0x1f8>
20005d48:	69fa      	ldr	r2, [r7, #28]
20005d4a:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
20005d4c:	4413      	add	r3, r2
20005d4e:	4619      	mov	r1, r3
20005d50:	f04f 32ff 	mov.w	r2, #4294967295	@ 0xffffffff
20005d54:	f04f 33ff 	mov.w	r3, #4294967295	@ 0xffffffff
20005d58:	e9c1 2300 	strd	r2, r3, [r1]
20005d5c:	6b7a      	ldr	r2, [r7, #52]	@ 0x34
20005d5e:	6a3b      	ldr	r3, [r7, #32]
20005d60:	4413      	add	r3, r2
20005d62:	637b      	str	r3, [r7, #52]	@ 0x34
20005d64:	69bb      	ldr	r3, [r7, #24]
20005d66:	6b7a      	ldr	r2, [r7, #52]	@ 0x34
20005d68:	429a      	cmp	r2, r3
20005d6a:	dbed      	blt.n	20005d48 <ui_cmd_memtest+0x1dc>
20005d6c:	2300      	movs	r3, #0
20005d6e:	637b      	str	r3, [r7, #52]	@ 0x34
20005d70:	e029      	b.n	20005dc6 <ui_cmd_memtest+0x25a>
20005d72:	69fa      	ldr	r2, [r7, #28]
20005d74:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
20005d76:	4413      	add	r3, r2
20005d78:	e9d3 2300 	ldrd	r2, r3, [r3]
20005d7c:	f1b3 3fff 	cmp.w	r3, #4294967295	@ 0xffffffff
20005d80:	bf08      	it	eq
20005d82:	f1b2 3fff 	cmpeq.w	r2, #4294967295	@ 0xffffffff
20005d86:	d01a      	beq.n	20005dbe <ui_cmd_memtest+0x252>
20005d88:	69fa      	ldr	r2, [r7, #28]
20005d8a:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
20005d8c:	18d1      	adds	r1, r2, r3
20005d8e:	69fa      	ldr	r2, [r7, #28]
20005d90:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
20005d92:	4413      	add	r3, r2
20005d94:	e9d3 2300 	ldrd	r2, r3, [r3]
20005d98:	e9cd 2300 	strd	r2, r3, [sp]
20005d9c:	f04f 32ff 	mov.w	r2, #4294967295	@ 0xffffffff
20005da0:	f04f 33ff 	mov.w	r3, #4294967295	@ 0xffffffff
20005da4:	4820      	ldr	r0, [pc, #128]	@ (20005e28 <ui_cmd_memtest+0x2bc>)
20005da6:	f7fa ffdd 	bl	20000d64 <printf>
20005daa:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
20005dac:	2b00      	cmp	r3, #0
20005dae:	bf0c      	ite	eq
20005db0:	2301      	moveq	r3, #1
20005db2:	2300      	movne	r3, #0
20005db4:	b2db      	uxtb	r3, r3
20005db6:	633b      	str	r3, [r7, #48]	@ 0x30
20005db8:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
20005dba:	62fb      	str	r3, [r7, #44]	@ 0x2c
20005dbc:	e007      	b.n	20005dce <ui_cmd_memtest+0x262>
20005dbe:	6b7a      	ldr	r2, [r7, #52]	@ 0x34
20005dc0:	6a3b      	ldr	r3, [r7, #32]
20005dc2:	4413      	add	r3, r2
20005dc4:	637b      	str	r3, [r7, #52]	@ 0x34
20005dc6:	69bb      	ldr	r3, [r7, #24]
20005dc8:	6b7a      	ldr	r2, [r7, #52]	@ 0x34
20005dca:	429a      	cmp	r2, r3
20005dcc:	dbd1      	blt.n	20005d72 <ui_cmd_memtest+0x206>
	MEMTEST(addr,len,0x5555555555555555ULL); 
20005dce:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
20005dd0:	2b00      	cmp	r3, #0
20005dd2:	d159      	bne.n	20005e88 <ui_cmd_memtest+0x31c>
20005dd4:	f04f 3255 	mov.w	r2, #1431655765	@ 0x55555555
20005dd8:	f04f 3355 	mov.w	r3, #1431655765	@ 0x55555555
20005ddc:	4811      	ldr	r0, [pc, #68]	@ (20005e24 <ui_cmd_memtest+0x2b8>)
20005dde:	f7fa ffc1 	bl	20000d64 <printf>
20005de2:	2300      	movs	r3, #0
20005de4:	637b      	str	r3, [r7, #52]	@ 0x34
20005de6:	e00d      	b.n	20005e04 <ui_cmd_memtest+0x298>
20005de8:	69fa      	ldr	r2, [r7, #28]
20005dea:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
20005dec:	4413      	add	r3, r2
20005dee:	4619      	mov	r1, r3
20005df0:	f04f 3255 	mov.w	r2, #1431655765	@ 0x55555555
20005df4:	f04f 3355 	mov.w	r3, #1431655765	@ 0x55555555
20005df8:	e9c1 2300 	strd	r2, r3, [r1]
20005dfc:	6b7a      	ldr	r2, [r7, #52]	@ 0x34
20005dfe:	6a3b      	ldr	r3, [r7, #32]
20005e00:	4413      	add	r3, r2
20005e02:	637b      	str	r3, [r7, #52]	@ 0x34
20005e04:	69bb      	ldr	r3, [r7, #24]
20005e06:	6b7a      	ldr	r2, [r7, #52]	@ 0x34
20005e08:	429a      	cmp	r2, r3
20005e0a:	dbed      	blt.n	20005de8 <ui_cmd_memtest+0x27c>
20005e0c:	2300      	movs	r3, #0
20005e0e:	637b      	str	r3, [r7, #52]	@ 0x34
20005e10:	e036      	b.n	20005e80 <ui_cmd_memtest+0x314>
20005e12:	bf00      	nop
20005e14:	20007fac 	.word	0x20007fac
20005e18:	200091f0 	.word	0x200091f0
20005e1c:	20007fb4 	.word	0x20007fb4
20005e20:	20007fbc 	.word	0x20007fbc
20005e24:	20007fc8 	.word	0x20007fc8
20005e28:	20007fdc 	.word	0x20007fdc
20005e2c:	69fa      	ldr	r2, [r7, #28]
20005e2e:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
20005e30:	4413      	add	r3, r2
20005e32:	e9d3 2300 	ldrd	r2, r3, [r3]
20005e36:	f1b3 3f55 	cmp.w	r3, #1431655765	@ 0x55555555
20005e3a:	bf08      	it	eq
20005e3c:	f1b2 3f55 	cmpeq.w	r2, #1431655765	@ 0x55555555
20005e40:	d01a      	beq.n	20005e78 <ui_cmd_memtest+0x30c>
20005e42:	69fa      	ldr	r2, [r7, #28]
20005e44:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
20005e46:	18d1      	adds	r1, r2, r3
20005e48:	69fa      	ldr	r2, [r7, #28]
20005e4a:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
20005e4c:	4413      	add	r3, r2
20005e4e:	e9d3 2300 	ldrd	r2, r3, [r3]
20005e52:	e9cd 2300 	strd	r2, r3, [sp]
20005e56:	f04f 3255 	mov.w	r2, #1431655765	@ 0x55555555
20005e5a:	f04f 3355 	mov.w	r3, #1431655765	@ 0x55555555
20005e5e:	488a      	ldr	r0, [pc, #552]	@ (20006088 <ui_cmd_memtest+0x51c>)
20005e60:	f7fa ff80 	bl	20000d64 <printf>
20005e64:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
20005e66:	2b00      	cmp	r3, #0
20005e68:	bf0c      	ite	eq
20005e6a:	2301      	moveq	r3, #1
20005e6c:	2300      	movne	r3, #0
20005e6e:	b2db      	uxtb	r3, r3
20005e70:	633b      	str	r3, [r7, #48]	@ 0x30
20005e72:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
20005e74:	62fb      	str	r3, [r7, #44]	@ 0x2c
20005e76:	e007      	b.n	20005e88 <ui_cmd_memtest+0x31c>
20005e78:	6b7a      	ldr	r2, [r7, #52]	@ 0x34
20005e7a:	6a3b      	ldr	r3, [r7, #32]
20005e7c:	4413      	add	r3, r2
20005e7e:	637b      	str	r3, [r7, #52]	@ 0x34
20005e80:	69bb      	ldr	r3, [r7, #24]
20005e82:	6b7a      	ldr	r2, [r7, #52]	@ 0x34
20005e84:	429a      	cmp	r2, r3
20005e86:	dbd1      	blt.n	20005e2c <ui_cmd_memtest+0x2c0>
	MEMTEST(addr,len,0xAAAAAAAAAAAAAAAAULL); 
20005e88:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
20005e8a:	2b00      	cmp	r3, #0
20005e8c:	d14c      	bne.n	20005f28 <ui_cmd_memtest+0x3bc>
20005e8e:	f04f 32aa 	mov.w	r2, #2863311530	@ 0xaaaaaaaa
20005e92:	f04f 33aa 	mov.w	r3, #2863311530	@ 0xaaaaaaaa
20005e96:	487d      	ldr	r0, [pc, #500]	@ (2000608c <ui_cmd_memtest+0x520>)
20005e98:	f7fa ff64 	bl	20000d64 <printf>
20005e9c:	2300      	movs	r3, #0
20005e9e:	637b      	str	r3, [r7, #52]	@ 0x34
20005ea0:	e00d      	b.n	20005ebe <ui_cmd_memtest+0x352>
20005ea2:	69fa      	ldr	r2, [r7, #28]
20005ea4:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
20005ea6:	4413      	add	r3, r2
20005ea8:	4619      	mov	r1, r3
20005eaa:	f04f 32aa 	mov.w	r2, #2863311530	@ 0xaaaaaaaa
20005eae:	f04f 33aa 	mov.w	r3, #2863311530	@ 0xaaaaaaaa
20005eb2:	e9c1 2300 	strd	r2, r3, [r1]
20005eb6:	6b7a      	ldr	r2, [r7, #52]	@ 0x34
20005eb8:	6a3b      	ldr	r3, [r7, #32]
20005eba:	4413      	add	r3, r2
20005ebc:	637b      	str	r3, [r7, #52]	@ 0x34
20005ebe:	69bb      	ldr	r3, [r7, #24]
20005ec0:	6b7a      	ldr	r2, [r7, #52]	@ 0x34
20005ec2:	429a      	cmp	r2, r3
20005ec4:	dbed      	blt.n	20005ea2 <ui_cmd_memtest+0x336>
20005ec6:	2300      	movs	r3, #0
20005ec8:	637b      	str	r3, [r7, #52]	@ 0x34
20005eca:	e029      	b.n	20005f20 <ui_cmd_memtest+0x3b4>
20005ecc:	69fa      	ldr	r2, [r7, #28]
20005ece:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
20005ed0:	4413      	add	r3, r2
20005ed2:	e9d3 2300 	ldrd	r2, r3, [r3]
20005ed6:	f1b3 3faa 	cmp.w	r3, #2863311530	@ 0xaaaaaaaa
20005eda:	bf08      	it	eq
20005edc:	f1b2 3faa 	cmpeq.w	r2, #2863311530	@ 0xaaaaaaaa
20005ee0:	d01a      	beq.n	20005f18 <ui_cmd_memtest+0x3ac>
20005ee2:	69fa      	ldr	r2, [r7, #28]
20005ee4:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
20005ee6:	18d1      	adds	r1, r2, r3
20005ee8:	69fa      	ldr	r2, [r7, #28]
20005eea:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
20005eec:	4413      	add	r3, r2
20005eee:	e9d3 2300 	ldrd	r2, r3, [r3]
20005ef2:	e9cd 2300 	strd	r2, r3, [sp]
20005ef6:	f04f 32aa 	mov.w	r2, #2863311530	@ 0xaaaaaaaa
20005efa:	f04f 33aa 	mov.w	r3, #2863311530	@ 0xaaaaaaaa
20005efe:	4862      	ldr	r0, [pc, #392]	@ (20006088 <ui_cmd_memtest+0x51c>)
20005f00:	f7fa ff30 	bl	20000d64 <printf>
20005f04:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
20005f06:	2b00      	cmp	r3, #0
20005f08:	bf0c      	ite	eq
20005f0a:	2301      	moveq	r3, #1
20005f0c:	2300      	movne	r3, #0
20005f0e:	b2db      	uxtb	r3, r3
20005f10:	633b      	str	r3, [r7, #48]	@ 0x30
20005f12:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
20005f14:	62fb      	str	r3, [r7, #44]	@ 0x2c
20005f16:	e007      	b.n	20005f28 <ui_cmd_memtest+0x3bc>
20005f18:	6b7a      	ldr	r2, [r7, #52]	@ 0x34
20005f1a:	6a3b      	ldr	r3, [r7, #32]
20005f1c:	4413      	add	r3, r2
20005f1e:	637b      	str	r3, [r7, #52]	@ 0x34
20005f20:	69bb      	ldr	r3, [r7, #24]
20005f22:	6b7a      	ldr	r2, [r7, #52]	@ 0x34
20005f24:	429a      	cmp	r2, r3
20005f26:	dbd1      	blt.n	20005ecc <ui_cmd_memtest+0x360>
	MEMTEST(addr,len,0xFF00FF00FF00FF00ULL);
20005f28:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
20005f2a:	2b00      	cmp	r3, #0
20005f2c:	d14c      	bne.n	20005fc8 <ui_cmd_memtest+0x45c>
20005f2e:	f04f 22ff 	mov.w	r2, #4278255360	@ 0xff00ff00
20005f32:	f04f 23ff 	mov.w	r3, #4278255360	@ 0xff00ff00
20005f36:	4855      	ldr	r0, [pc, #340]	@ (2000608c <ui_cmd_memtest+0x520>)
20005f38:	f7fa ff14 	bl	20000d64 <printf>
20005f3c:	2300      	movs	r3, #0
20005f3e:	637b      	str	r3, [r7, #52]	@ 0x34
20005f40:	e00d      	b.n	20005f5e <ui_cmd_memtest+0x3f2>
20005f42:	69fa      	ldr	r2, [r7, #28]
20005f44:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
20005f46:	4413      	add	r3, r2
20005f48:	4619      	mov	r1, r3
20005f4a:	f04f 22ff 	mov.w	r2, #4278255360	@ 0xff00ff00
20005f4e:	f04f 23ff 	mov.w	r3, #4278255360	@ 0xff00ff00
20005f52:	e9c1 2300 	strd	r2, r3, [r1]
20005f56:	6b7a      	ldr	r2, [r7, #52]	@ 0x34
20005f58:	6a3b      	ldr	r3, [r7, #32]
20005f5a:	4413      	add	r3, r2
20005f5c:	637b      	str	r3, [r7, #52]	@ 0x34
20005f5e:	69bb      	ldr	r3, [r7, #24]
20005f60:	6b7a      	ldr	r2, [r7, #52]	@ 0x34
20005f62:	429a      	cmp	r2, r3
20005f64:	dbed      	blt.n	20005f42 <ui_cmd_memtest+0x3d6>
20005f66:	2300      	movs	r3, #0
20005f68:	637b      	str	r3, [r7, #52]	@ 0x34
20005f6a:	e029      	b.n	20005fc0 <ui_cmd_memtest+0x454>
20005f6c:	69fa      	ldr	r2, [r7, #28]
20005f6e:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
20005f70:	4413      	add	r3, r2
20005f72:	e9d3 2300 	ldrd	r2, r3, [r3]
20005f76:	f1b3 2fff 	cmp.w	r3, #4278255360	@ 0xff00ff00
20005f7a:	bf08      	it	eq
20005f7c:	f1b2 2fff 	cmpeq.w	r2, #4278255360	@ 0xff00ff00
20005f80:	d01a      	beq.n	20005fb8 <ui_cmd_memtest+0x44c>
20005f82:	69fa      	ldr	r2, [r7, #28]
20005f84:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
20005f86:	18d1      	adds	r1, r2, r3
20005f88:	69fa      	ldr	r2, [r7, #28]
20005f8a:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
20005f8c:	4413      	add	r3, r2
20005f8e:	e9d3 2300 	ldrd	r2, r3, [r3]
20005f92:	e9cd 2300 	strd	r2, r3, [sp]
20005f96:	f04f 22ff 	mov.w	r2, #4278255360	@ 0xff00ff00
20005f9a:	f04f 23ff 	mov.w	r3, #4278255360	@ 0xff00ff00
20005f9e:	483a      	ldr	r0, [pc, #232]	@ (20006088 <ui_cmd_memtest+0x51c>)
20005fa0:	f7fa fee0 	bl	20000d64 <printf>
20005fa4:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
20005fa6:	2b00      	cmp	r3, #0
20005fa8:	bf0c      	ite	eq
20005faa:	2301      	moveq	r3, #1
20005fac:	2300      	movne	r3, #0
20005fae:	b2db      	uxtb	r3, r3
20005fb0:	633b      	str	r3, [r7, #48]	@ 0x30
20005fb2:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
20005fb4:	62fb      	str	r3, [r7, #44]	@ 0x2c
20005fb6:	e007      	b.n	20005fc8 <ui_cmd_memtest+0x45c>
20005fb8:	6b7a      	ldr	r2, [r7, #52]	@ 0x34
20005fba:	6a3b      	ldr	r3, [r7, #32]
20005fbc:	4413      	add	r3, r2
20005fbe:	637b      	str	r3, [r7, #52]	@ 0x34
20005fc0:	69bb      	ldr	r3, [r7, #24]
20005fc2:	6b7a      	ldr	r2, [r7, #52]	@ 0x34
20005fc4:	429a      	cmp	r2, r3
20005fc6:	dbd1      	blt.n	20005f6c <ui_cmd_memtest+0x400>
	MEMTEST(addr,len,0x00FF00FF00FF00FFULL);
20005fc8:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
20005fca:	2b00      	cmp	r3, #0
20005fcc:	d14c      	bne.n	20006068 <ui_cmd_memtest+0x4fc>
20005fce:	f04f 12ff 	mov.w	r2, #16711935	@ 0xff00ff
20005fd2:	f04f 13ff 	mov.w	r3, #16711935	@ 0xff00ff
20005fd6:	482d      	ldr	r0, [pc, #180]	@ (2000608c <ui_cmd_memtest+0x520>)
20005fd8:	f7fa fec4 	bl	20000d64 <printf>
20005fdc:	2300      	movs	r3, #0
20005fde:	637b      	str	r3, [r7, #52]	@ 0x34
20005fe0:	e00d      	b.n	20005ffe <ui_cmd_memtest+0x492>
20005fe2:	69fa      	ldr	r2, [r7, #28]
20005fe4:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
20005fe6:	4413      	add	r3, r2
20005fe8:	4619      	mov	r1, r3
20005fea:	f04f 12ff 	mov.w	r2, #16711935	@ 0xff00ff
20005fee:	f04f 13ff 	mov.w	r3, #16711935	@ 0xff00ff
20005ff2:	e9c1 2300 	strd	r2, r3, [r1]
20005ff6:	6b7a      	ldr	r2, [r7, #52]	@ 0x34
20005ff8:	6a3b      	ldr	r3, [r7, #32]
20005ffa:	4413      	add	r3, r2
20005ffc:	637b      	str	r3, [r7, #52]	@ 0x34
20005ffe:	69bb      	ldr	r3, [r7, #24]
20006000:	6b7a      	ldr	r2, [r7, #52]	@ 0x34
20006002:	429a      	cmp	r2, r3
20006004:	dbed      	blt.n	20005fe2 <ui_cmd_memtest+0x476>
20006006:	2300      	movs	r3, #0
20006008:	637b      	str	r3, [r7, #52]	@ 0x34
2000600a:	e029      	b.n	20006060 <ui_cmd_memtest+0x4f4>
2000600c:	69fa      	ldr	r2, [r7, #28]
2000600e:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
20006010:	4413      	add	r3, r2
20006012:	e9d3 2300 	ldrd	r2, r3, [r3]
20006016:	f1b3 1fff 	cmp.w	r3, #16711935	@ 0xff00ff
2000601a:	bf08      	it	eq
2000601c:	f1b2 1fff 	cmpeq.w	r2, #16711935	@ 0xff00ff
20006020:	d01a      	beq.n	20006058 <ui_cmd_memtest+0x4ec>
20006022:	69fa      	ldr	r2, [r7, #28]
20006024:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
20006026:	18d1      	adds	r1, r2, r3
20006028:	69fa      	ldr	r2, [r7, #28]
2000602a:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
2000602c:	4413      	add	r3, r2
2000602e:	e9d3 2300 	ldrd	r2, r3, [r3]
20006032:	e9cd 2300 	strd	r2, r3, [sp]
20006036:	f04f 12ff 	mov.w	r2, #16711935	@ 0xff00ff
2000603a:	f04f 13ff 	mov.w	r3, #16711935	@ 0xff00ff
2000603e:	4812      	ldr	r0, [pc, #72]	@ (20006088 <ui_cmd_memtest+0x51c>)
20006040:	f7fa fe90 	bl	20000d64 <printf>
20006044:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
20006046:	2b00      	cmp	r3, #0
20006048:	bf0c      	ite	eq
2000604a:	2301      	moveq	r3, #1
2000604c:	2300      	movne	r3, #0
2000604e:	b2db      	uxtb	r3, r3
20006050:	633b      	str	r3, [r7, #48]	@ 0x30
20006052:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
20006054:	62fb      	str	r3, [r7, #44]	@ 0x2c
20006056:	e007      	b.n	20006068 <ui_cmd_memtest+0x4fc>
20006058:	6b7a      	ldr	r2, [r7, #52]	@ 0x34
2000605a:	6a3b      	ldr	r3, [r7, #32]
2000605c:	4413      	add	r3, r2
2000605e:	637b      	str	r3, [r7, #52]	@ 0x34
20006060:	69bb      	ldr	r3, [r7, #24]
20006062:	6b7a      	ldr	r2, [r7, #52]	@ 0x34
20006064:	429a      	cmp	r2, r3
20006066:	dbd1      	blt.n	2000600c <ui_cmd_memtest+0x4a0>
	if (!loopmode) break;
20006068:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
2000606a:	2b00      	cmp	r3, #0
2000606c:	d005      	beq.n	2000607a <ui_cmd_memtest+0x50e>
	pass++;
2000606e:	6abb      	ldr	r3, [r7, #40]	@ 0x28
20006070:	3301      	adds	r3, #1
20006072:	62bb      	str	r3, [r7, #40]	@ 0x28
	if (loopmode) {
20006074:	e5b7      	b.n	20005be6 <ui_cmd_memtest+0x7a>
	    if (console_status()) break;
20006076:	bf00      	nop
20006078:	e000      	b.n	2000607c <ui_cmd_memtest+0x510>
	if (!loopmode) break;
2000607a:	bf00      	nop
	}

    return 0;
2000607c:	2300      	movs	r3, #0
}
2000607e:	4618      	mov	r0, r3
20006080:	3738      	adds	r7, #56	@ 0x38
20006082:	46bd      	mov	sp, r7
20006084:	e8bd 83b0 	ldmia.w	sp!, {r4, r5, r7, r8, r9, pc}
20006088:	20007fdc 	.word	0x20007fdc
2000608c:	20007fc8 	.word	0x20007fc8

20006090 <ui_cmd_memdump>:
#endif

static int ui_cmd_memdump(ui_cmdline_t *cmd,int argc,char *argv[])
{
20006090:	b580      	push	{r7, lr}
20006092:	b086      	sub	sp, #24
20006094:	af00      	add	r7, sp, #0
20006096:	60f8      	str	r0, [r7, #12]
20006098:	60b9      	str	r1, [r7, #8]
2000609a:	607a      	str	r2, [r7, #4]
    hsaddr_t addr;
    int res;

    getaddrargs(cmd,&prev_wtype,&prev_addr,&prev_length);
2000609c:	4b16      	ldr	r3, [pc, #88]	@ (200060f8 <ui_cmd_memdump+0x68>)
2000609e:	4a17      	ldr	r2, [pc, #92]	@ (200060fc <ui_cmd_memdump+0x6c>)
200060a0:	4917      	ldr	r1, [pc, #92]	@ (20006100 <ui_cmd_memdump+0x70>)
200060a2:	68f8      	ldr	r0, [r7, #12]
200060a4:	f7ff f84e 	bl	20005144 <getaddrargs>

    addr = prev_addr;
200060a8:	4b14      	ldr	r3, [pc, #80]	@ (200060fc <ui_cmd_memdump+0x6c>)
200060aa:	681b      	ldr	r3, [r3, #0]
200060ac:	617b      	str	r3, [r7, #20]
    if ((prev_wtype & ATYPE_TYPE_MASK) == ATYPE_TYPE_PHYS) {
200060ae:	4b14      	ldr	r3, [pc, #80]	@ (20006100 <ui_cmd_memdump+0x70>)
200060b0:	681b      	ldr	r3, [r3, #0]
200060b2:	f003 03f0 	and.w	r3, r3, #240	@ 0xf0
200060b6:	2b10      	cmp	r3, #16
	addr = UNCADDR(addr);
	}
    
    res = dumpmem(addr,
200060b8:	4b10      	ldr	r3, [pc, #64]	@ (200060fc <ui_cmd_memdump+0x6c>)
200060ba:	6819      	ldr	r1, [r3, #0]
200060bc:	4b0e      	ldr	r3, [pc, #56]	@ (200060f8 <ui_cmd_memdump+0x68>)
200060be:	681a      	ldr	r2, [r3, #0]
200060c0:	4b0f      	ldr	r3, [pc, #60]	@ (20006100 <ui_cmd_memdump+0x70>)
200060c2:	681b      	ldr	r3, [r3, #0]
200060c4:	f003 030f 	and.w	r3, r3, #15
200060c8:	6978      	ldr	r0, [r7, #20]
200060ca:	f7ff f9ad 	bl	20005428 <dumpmem>
200060ce:	6138      	str	r0, [r7, #16]
	    prev_addr,
	    prev_length,
	    prev_wtype & ATYPE_SIZE_MASK);

    if (res < 0) {
200060d0:	693b      	ldr	r3, [r7, #16]
200060d2:	2b00      	cmp	r3, #0
200060d4:	da04      	bge.n	200060e0 <ui_cmd_memdump+0x50>
	ui_showerror(res,"Could not display memory");
200060d6:	490b      	ldr	r1, [pc, #44]	@ (20006104 <ui_cmd_memdump+0x74>)
200060d8:	6938      	ldr	r0, [r7, #16]
200060da:	f7fd fe03 	bl	20003ce4 <ui_showerror>
200060de:	e006      	b.n	200060ee <ui_cmd_memdump+0x5e>
	}
    else {
	prev_addr += prev_length;
200060e0:	4b06      	ldr	r3, [pc, #24]	@ (200060fc <ui_cmd_memdump+0x6c>)
200060e2:	681a      	ldr	r2, [r3, #0]
200060e4:	4b04      	ldr	r3, [pc, #16]	@ (200060f8 <ui_cmd_memdump+0x68>)
200060e6:	681b      	ldr	r3, [r3, #0]
200060e8:	4413      	add	r3, r2
200060ea:	4a04      	ldr	r2, [pc, #16]	@ (200060fc <ui_cmd_memdump+0x6c>)
200060ec:	6013      	str	r3, [r2, #0]
	}

    return res;
200060ee:	693b      	ldr	r3, [r7, #16]
}
200060f0:	4618      	mov	r0, r3
200060f2:	3718      	adds	r7, #24
200060f4:	46bd      	mov	sp, r7
200060f6:	bd80      	pop	{r7, pc}
200060f8:	200091e8 	.word	0x200091e8
200060fc:	20009478 	.word	0x20009478
20006100:	200091f0 	.word	0x200091f0
20006104:	20008010 	.word	0x20008010

20006108 <ui_cmd_disasm>:

static int ui_cmd_disasm(ui_cmdline_t *cmd,int argc,char *argv[])
{
20006108:	b580      	push	{r7, lr}
2000610a:	f5ad 7d0a 	sub.w	sp, sp, #552	@ 0x228
2000610e:	af02      	add	r7, sp, #8
20006110:	f507 7308 	add.w	r3, r7, #544	@ 0x220
20006114:	f5a3 7305 	sub.w	r3, r3, #532	@ 0x214
20006118:	6018      	str	r0, [r3, #0]
2000611a:	f507 7308 	add.w	r3, r7, #544	@ 0x220
2000611e:	f5a3 7306 	sub.w	r3, r3, #536	@ 0x218
20006122:	6019      	str	r1, [r3, #0]
20006124:	f507 7308 	add.w	r3, r7, #544	@ 0x220
20006128:	f5a3 7307 	sub.w	r3, r3, #540	@ 0x21c
2000612c:	601a      	str	r2, [r3, #0]
    char buf[512];
    int idx;
    uint32_t inst;
    int res;

    getaddrargs(cmd,&prev_wtype,&prev_addr,&prev_dlength);
2000612e:	f507 7308 	add.w	r3, r7, #544	@ 0x220
20006132:	f5a3 7005 	sub.w	r0, r3, #532	@ 0x214
20006136:	4b30      	ldr	r3, [pc, #192]	@ (200061f8 <ui_cmd_disasm+0xf0>)
20006138:	4a30      	ldr	r2, [pc, #192]	@ (200061fc <ui_cmd_disasm+0xf4>)
2000613a:	4931      	ldr	r1, [pc, #196]	@ (20006200 <ui_cmd_disasm+0xf8>)
2000613c:	6800      	ldr	r0, [r0, #0]
2000613e:	f7ff f801 	bl	20005144 <getaddrargs>

    prev_addr &= ~3;
20006142:	4b2e      	ldr	r3, [pc, #184]	@ (200061fc <ui_cmd_disasm+0xf4>)
20006144:	681b      	ldr	r3, [r3, #0]
20006146:	f023 0303 	bic.w	r3, r3, #3
2000614a:	4a2c      	ldr	r2, [pc, #176]	@ (200061fc <ui_cmd_disasm+0xf4>)
2000614c:	6013      	str	r3, [r2, #0]

    addr = prev_addr;
2000614e:	4b2b      	ldr	r3, [pc, #172]	@ (200061fc <ui_cmd_disasm+0xf4>)
20006150:	681b      	ldr	r3, [r3, #0]
20006152:	f8c7 321c 	str.w	r3, [r7, #540]	@ 0x21c
    if ((prev_wtype & ATYPE_TYPE_MASK) == ATYPE_TYPE_PHYS) {
20006156:	4b2a      	ldr	r3, [pc, #168]	@ (20006200 <ui_cmd_disasm+0xf8>)
20006158:	681b      	ldr	r3, [r3, #0]
2000615a:	f003 03f0 	and.w	r3, r3, #240	@ 0xf0
2000615e:	2b10      	cmp	r3, #16
	addr = UNCADDR(addr);
	}

    for (idx = 0; idx < prev_dlength; idx++) {
20006160:	2300      	movs	r3, #0
20006162:	f8c7 3218 	str.w	r3, [r7, #536]	@ 0x218
20006166:	e03b      	b.n	200061e0 <ui_cmd_disasm+0xd8>
	if ((res = mem_peek(&inst, addr, MEM_WORD))) {
20006168:	f107 0310 	add.w	r3, r7, #16
2000616c:	2203      	movs	r2, #3
2000616e:	f8d7 121c 	ldr.w	r1, [r7, #540]	@ 0x21c
20006172:	4618      	mov	r0, r3
20006174:	f7fb f870 	bl	20001258 <mem_peek>
20006178:	f8c7 0214 	str.w	r0, [r7, #532]	@ 0x214
2000617c:	f8d7 3214 	ldr.w	r3, [r7, #532]	@ 0x214
20006180:	2b00      	cmp	r3, #0
20006182:	d007      	beq.n	20006194 <ui_cmd_disasm+0x8c>
	    ui_showerror(res,"Could not disassemble memory");
20006184:	491f      	ldr	r1, [pc, #124]	@ (20006204 <ui_cmd_disasm+0xfc>)
20006186:	f8d7 0214 	ldr.w	r0, [r7, #532]	@ 0x214
2000618a:	f7fd fdab 	bl	20003ce4 <ui_showerror>
	    return res;
2000618e:	f8d7 3214 	ldr.w	r3, [r7, #532]	@ 0x214
20006192:	e02c      	b.n	200061ee <ui_cmd_disasm+0xe6>
	    }	  
	//disasm_inst(buf,sizeof(buf),inst,(uint64_t) prev_addr);
	printf("%P%c %08x    %s\n",prev_addr,(addr != prev_addr) ? '%' : ':',inst,buf);
20006194:	4b19      	ldr	r3, [pc, #100]	@ (200061fc <ui_cmd_disasm+0xf4>)
20006196:	6819      	ldr	r1, [r3, #0]
20006198:	4b18      	ldr	r3, [pc, #96]	@ (200061fc <ui_cmd_disasm+0xf4>)
2000619a:	681b      	ldr	r3, [r3, #0]
2000619c:	f8d7 221c 	ldr.w	r2, [r7, #540]	@ 0x21c
200061a0:	429a      	cmp	r2, r3
200061a2:	d001      	beq.n	200061a8 <ui_cmd_disasm+0xa0>
200061a4:	2225      	movs	r2, #37	@ 0x25
200061a6:	e000      	b.n	200061aa <ui_cmd_disasm+0xa2>
200061a8:	223a      	movs	r2, #58	@ 0x3a
200061aa:	f507 7308 	add.w	r3, r7, #544	@ 0x220
200061ae:	f5a3 7304 	sub.w	r3, r3, #528	@ 0x210
200061b2:	6818      	ldr	r0, [r3, #0]
200061b4:	f107 0314 	add.w	r3, r7, #20
200061b8:	9300      	str	r3, [sp, #0]
200061ba:	4603      	mov	r3, r0
200061bc:	4812      	ldr	r0, [pc, #72]	@ (20006208 <ui_cmd_disasm+0x100>)
200061be:	f7fa fdd1 	bl	20000d64 <printf>
	addr += 4;
200061c2:	f8d7 321c 	ldr.w	r3, [r7, #540]	@ 0x21c
200061c6:	3304      	adds	r3, #4
200061c8:	f8c7 321c 	str.w	r3, [r7, #540]	@ 0x21c
	prev_addr += 4;
200061cc:	4b0b      	ldr	r3, [pc, #44]	@ (200061fc <ui_cmd_disasm+0xf4>)
200061ce:	681b      	ldr	r3, [r3, #0]
200061d0:	3304      	adds	r3, #4
200061d2:	4a0a      	ldr	r2, [pc, #40]	@ (200061fc <ui_cmd_disasm+0xf4>)
200061d4:	6013      	str	r3, [r2, #0]
    for (idx = 0; idx < prev_dlength; idx++) {
200061d6:	f8d7 3218 	ldr.w	r3, [r7, #536]	@ 0x218
200061da:	3301      	adds	r3, #1
200061dc:	f8c7 3218 	str.w	r3, [r7, #536]	@ 0x218
200061e0:	4b05      	ldr	r3, [pc, #20]	@ (200061f8 <ui_cmd_disasm+0xf0>)
200061e2:	681b      	ldr	r3, [r3, #0]
200061e4:	f8d7 2218 	ldr.w	r2, [r7, #536]	@ 0x218
200061e8:	429a      	cmp	r2, r3
200061ea:	dbbd      	blt.n	20006168 <ui_cmd_disasm+0x60>
	}

    return 0;
200061ec:	2300      	movs	r3, #0
}
200061ee:	4618      	mov	r0, r3
200061f0:	f507 7708 	add.w	r7, r7, #544	@ 0x220
200061f4:	46bd      	mov	sp, r7
200061f6:	bd80      	pop	{r7, pc}
200061f8:	200091ec 	.word	0x200091ec
200061fc:	20009478 	.word	0x20009478
20006200:	200091f0 	.word	0x200091f0
20006204:	2000802c 	.word	0x2000802c
20006208:	2000804c 	.word	0x2000804c

2000620c <ui_init_examcmds>:

int ui_init_examcmds(void)
{
2000620c:	b580      	push	{r7, lr}
2000620e:	b082      	sub	sp, #8
20006210:	af02      	add	r7, sp, #8
    cmd_addcmd("u",
20006212:	4b1b      	ldr	r3, [pc, #108]	@ (20006280 <ui_init_examcmds+0x74>)
20006214:	9301      	str	r3, [sp, #4]
20006216:	4b1b      	ldr	r3, [pc, #108]	@ (20006284 <ui_init_examcmds+0x78>)
20006218:	9300      	str	r3, [sp, #0]
2000621a:	4b1b      	ldr	r3, [pc, #108]	@ (20006288 <ui_init_examcmds+0x7c>)
2000621c:	2200      	movs	r2, #0
2000621e:	491b      	ldr	r1, [pc, #108]	@ (2000628c <ui_init_examcmds+0x80>)
20006220:	481b      	ldr	r0, [pc, #108]	@ (20006290 <ui_init_examcmds+0x84>)
20006222:	f7fe f8ef 	bl	20004404 <cmd_addcmd>
	       "to continue a previous request.\n",
               "-p;Address is an uncached physical address|"
	       "-v;Address is a kernel virtual address");


    cmd_addcmd("d",
20006226:	4b1b      	ldr	r3, [pc, #108]	@ (20006294 <ui_init_examcmds+0x88>)
20006228:	9301      	str	r3, [sp, #4]
2000622a:	4b1b      	ldr	r3, [pc, #108]	@ (20006298 <ui_init_examcmds+0x8c>)
2000622c:	9300      	str	r3, [sp, #0]
2000622e:	4b1b      	ldr	r3, [pc, #108]	@ (2000629c <ui_init_examcmds+0x90>)
20006230:	2200      	movs	r2, #0
20006232:	491b      	ldr	r1, [pc, #108]	@ (200062a0 <ui_init_examcmds+0x94>)
20006234:	481b      	ldr	r0, [pc, #108]	@ (200062a4 <ui_init_examcmds+0x98>)
20006236:	f7fe f8e5 	bl	20004404 <cmd_addcmd>
               "-q;Dump memory as quadwords (64-bits)|"
               "-p;Address is an uncached physical address|"
	       "-v;Address is a kernel virtual address");


    cmd_addcmd("e",
2000623a:	4b1b      	ldr	r3, [pc, #108]	@ (200062a8 <ui_init_examcmds+0x9c>)
2000623c:	9301      	str	r3, [sp, #4]
2000623e:	4b1b      	ldr	r3, [pc, #108]	@ (200062ac <ui_init_examcmds+0xa0>)
20006240:	9300      	str	r3, [sp, #0]
20006242:	4b1b      	ldr	r3, [pc, #108]	@ (200062b0 <ui_init_examcmds+0xa4>)
20006244:	2200      	movs	r2, #0
20006246:	491b      	ldr	r1, [pc, #108]	@ (200062b4 <ui_init_examcmds+0xa8>)
20006248:	481b      	ldr	r0, [pc, #108]	@ (200062b8 <ui_init_examcmds+0xac>)
2000624a:	f7fe f8db 	bl	20004404 <cmd_addcmd>
               "-w;Edit memory as words (32-bits)|"
               "-q;Edit memory as quadwords (64-bits)|"
	       "-p;Address is an uncached physical address|"
	       "-v;Address is a kernel virtual address");

    cmd_addcmd("f",
2000624e:	4b16      	ldr	r3, [pc, #88]	@ (200062a8 <ui_init_examcmds+0x9c>)
20006250:	9301      	str	r3, [sp, #4]
20006252:	4b1a      	ldr	r3, [pc, #104]	@ (200062bc <ui_init_examcmds+0xb0>)
20006254:	9300      	str	r3, [sp, #0]
20006256:	4b1a      	ldr	r3, [pc, #104]	@ (200062c0 <ui_init_examcmds+0xb4>)
20006258:	2200      	movs	r2, #0
2000625a:	491a      	ldr	r1, [pc, #104]	@ (200062c4 <ui_init_examcmds+0xb8>)
2000625c:	481a      	ldr	r0, [pc, #104]	@ (200062c8 <ui_init_examcmds+0xbc>)
2000625e:	f7fe f8d1 	bl	20004404 <cmd_addcmd>
               "-q;Edit memory as quadwords (64-bits)|"
	       "-p;Address is an uncached physical address|"
	       "-v;Address is a kernel virtual address");

#if 1
    cmd_addcmd("memtest",
20006262:	4b1a      	ldr	r3, [pc, #104]	@ (200062cc <ui_init_examcmds+0xc0>)
20006264:	9301      	str	r3, [sp, #4]
20006266:	4b1a      	ldr	r3, [pc, #104]	@ (200062d0 <ui_init_examcmds+0xc4>)
20006268:	9300      	str	r3, [sp, #0]
2000626a:	4b1a      	ldr	r3, [pc, #104]	@ (200062d4 <ui_init_examcmds+0xc8>)
2000626c:	2200      	movs	r2, #0
2000626e:	491a      	ldr	r1, [pc, #104]	@ (200062d8 <ui_init_examcmds+0xcc>)
20006270:	481a      	ldr	r0, [pc, #104]	@ (200062dc <ui_init_examcmds+0xd0>)
20006272:	f7fe f8c7 	bl	20004404 <cmd_addcmd>
#endif


    //prev_addr = PTR2HSADDR(KERNADDR(0));

    return 0;
20006276:	2300      	movs	r3, #0
}
20006278:	4618      	mov	r0, r3
2000627a:	46bd      	mov	sp, r7
2000627c:	bd80      	pop	{r7, pc}
2000627e:	bf00      	nop
20006280:	20008080 	.word	0x20008080
20006284:	200080d4 	.word	0x200080d4
20006288:	20008060 	.word	0x20008060
2000628c:	20006109 	.word	0x20006109
20006290:	2000807c 	.word	0x2000807c
20006294:	20008224 	.word	0x20008224
20006298:	200082fc 	.word	0x200082fc
2000629c:	20008210 	.word	0x20008210
200062a0:	20006091 	.word	0x20006091
200062a4:	20008220 	.word	0x20008220
200062a8:	20008470 	.word	0x20008470
200062ac:	20008548 	.word	0x20008548
200062b0:	20008450 	.word	0x20008450
200062b4:	200056dd 	.word	0x200056dd
200062b8:	2000846c 	.word	0x2000846c
200062bc:	20008680 	.word	0x20008680
200062c0:	20008660 	.word	0x20008660
200062c4:	20005a11 	.word	0x20005a11
200062c8:	2000867c 	.word	0x2000867c
200062cc:	20008740 	.word	0x20008740
200062d0:	2000879c 	.word	0x2000879c
200062d4:	20008728 	.word	0x20008728
200062d8:	20005b6d 	.word	0x20005b6d
200062dc:	20008738 	.word	0x20008738

200062e0 <ui_init_misccmds>:
static int uart_handler(ui_cmdline_t *cmd, int argc, char *argv[]);
static int ui_cmd_LED2(ui_cmdline_t *cmd, int argc, char *argv[]);
int ui_init_misccmds(void);

int ui_init_misccmds(void)
{
200062e0:	b580      	push	{r7, lr}
200062e2:	b082      	sub	sp, #8
200062e4:	af02      	add	r7, sp, #8

    cmd_addcmd("loop",
200062e6:	4b61      	ldr	r3, [pc, #388]	@ (2000646c <ui_init_misccmds+0x18c>)
200062e8:	9301      	str	r3, [sp, #4]
200062ea:	4b61      	ldr	r3, [pc, #388]	@ (20006470 <ui_init_misccmds+0x190>)
200062ec:	9300      	str	r3, [sp, #0]
200062ee:	4b61      	ldr	r3, [pc, #388]	@ (20006474 <ui_init_misccmds+0x194>)
200062f0:	2200      	movs	r2, #0
200062f2:	4961      	ldr	r1, [pc, #388]	@ (20006478 <ui_init_misccmds+0x198>)
200062f4:	4861      	ldr	r0, [pc, #388]	@ (2000647c <ui_init_misccmds+0x19c>)
200062f6:	f7fe f885 	bl	20004404 <cmd_addcmd>
	       "The 'loop' command causes the specified command or list of commands\n"
	       "to be repeated 'count' times or forever, or until a character is typed",
	       "-count=*;Specifies number of iterations|"
	       "-forever;Loops forever");

    cmd_addcmd("sleep",
200062fa:	4b61      	ldr	r3, [pc, #388]	@ (20006480 <ui_init_misccmds+0x1a0>)
200062fc:	9301      	str	r3, [sp, #4]
200062fe:	4b61      	ldr	r3, [pc, #388]	@ (20006484 <ui_init_misccmds+0x1a4>)
20006300:	9300      	str	r3, [sp, #0]
20006302:	4b61      	ldr	r3, [pc, #388]	@ (20006488 <ui_init_misccmds+0x1a8>)
20006304:	2200      	movs	r2, #0
20006306:	4961      	ldr	r1, [pc, #388]	@ (2000648c <ui_init_misccmds+0x1ac>)
20006308:	4861      	ldr	r0, [pc, #388]	@ (20006490 <ui_init_misccmds+0x1b0>)
2000630a:	f7fe f87b 	bl	20004404 <cmd_addcmd>
	       "operating system.  If specified, 'n' will be placed in $4 as a\n"
	       "return code.",
	       "");
#endif

    cmd_addcmd("set console",
2000630e:	4b5c      	ldr	r3, [pc, #368]	@ (20006480 <ui_init_misccmds+0x1a0>)
20006310:	9301      	str	r3, [sp, #4]
20006312:	4b60      	ldr	r3, [pc, #384]	@ (20006494 <ui_init_misccmds+0x1b4>)
20006314:	9300      	str	r3, [sp, #0]
20006316:	4b60      	ldr	r3, [pc, #384]	@ (20006498 <ui_init_misccmds+0x1b8>)
20006318:	2200      	movs	r2, #0
2000631a:	4960      	ldr	r1, [pc, #384]	@ (2000649c <ui_init_misccmds+0x1bc>)
2000631c:	4860      	ldr	r0, [pc, #384]	@ (200064a0 <ui_init_misccmds+0x1c0>)
2000631e:	f7fe f871 	bl	20004404 <cmd_addcmd>
	       "must be a serial-style device.  Be careful not to change the console\n"
	       "to a device that is not connected!",
	       "");


    cmd_addcmd("display",
20006322:	4b57      	ldr	r3, [pc, #348]	@ (20006480 <ui_init_misccmds+0x1a0>)
20006324:	9301      	str	r3, [sp, #4]
20006326:	4b56      	ldr	r3, [pc, #344]	@ (20006480 <ui_init_misccmds+0x1a0>)
20006328:	9300      	str	r3, [sp, #0]
2000632a:	4b5e      	ldr	r3, [pc, #376]	@ (200064a4 <ui_init_misccmds+0x1c4>)
2000632c:	2200      	movs	r2, #0
2000632e:	495e      	ldr	r1, [pc, #376]	@ (200064a8 <ui_init_misccmds+0x1c8>)
20006330:	485e      	ldr	r0, [pc, #376]	@ (200064ac <ui_init_misccmds+0x1cc>)
20006332:	f7fe f867 	bl	20004404 <cmd_addcmd>
	       NULL,
	       "enter a address display <addr>",
	       "",
	       "");

    cmd_addcmd("edit",
20006336:	4b52      	ldr	r3, [pc, #328]	@ (20006480 <ui_init_misccmds+0x1a0>)
20006338:	9301      	str	r3, [sp, #4]
2000633a:	4b51      	ldr	r3, [pc, #324]	@ (20006480 <ui_init_misccmds+0x1a0>)
2000633c:	9300      	str	r3, [sp, #0]
2000633e:	4b5c      	ldr	r3, [pc, #368]	@ (200064b0 <ui_init_misccmds+0x1d0>)
20006340:	2200      	movs	r2, #0
20006342:	495c      	ldr	r1, [pc, #368]	@ (200064b4 <ui_init_misccmds+0x1d4>)
20006344:	485c      	ldr	r0, [pc, #368]	@ (200064b8 <ui_init_misccmds+0x1d8>)
20006346:	f7fe f85d 	bl	20004404 <cmd_addcmd>
	       ui_cmd_edit,
	       NULL,
	       "edit a specific addr edit <addr> <newvalue> ",
	       "",
	       "");
    cmd_addcmd("printten",
2000634a:	4b4d      	ldr	r3, [pc, #308]	@ (20006480 <ui_init_misccmds+0x1a0>)
2000634c:	9301      	str	r3, [sp, #4]
2000634e:	4b4c      	ldr	r3, [pc, #304]	@ (20006480 <ui_init_misccmds+0x1a0>)
20006350:	9300      	str	r3, [sp, #0]
20006352:	4b5a      	ldr	r3, [pc, #360]	@ (200064bc <ui_init_misccmds+0x1dc>)
20006354:	2200      	movs	r2, #0
20006356:	495a      	ldr	r1, [pc, #360]	@ (200064c0 <ui_init_misccmds+0x1e0>)
20006358:	4858      	ldr	r0, [pc, #352]	@ (200064bc <ui_init_misccmds+0x1dc>)
2000635a:	f7fe f853 	bl	20004404 <cmd_addcmd>
	       NULL,
	       "printten",
	       "",
	       "");

    cmd_addcmd("led",
2000635e:	4b48      	ldr	r3, [pc, #288]	@ (20006480 <ui_init_misccmds+0x1a0>)
20006360:	9301      	str	r3, [sp, #4]
20006362:	4b58      	ldr	r3, [pc, #352]	@ (200064c4 <ui_init_misccmds+0x1e4>)
20006364:	9300      	str	r3, [sp, #0]
20006366:	4b58      	ldr	r3, [pc, #352]	@ (200064c8 <ui_init_misccmds+0x1e8>)
20006368:	2200      	movs	r2, #0
2000636a:	4958      	ldr	r1, [pc, #352]	@ (200064cc <ui_init_misccmds+0x1ec>)
2000636c:	4858      	ldr	r0, [pc, #352]	@ (200064d0 <ui_init_misccmds+0x1f0>)
2000636e:	f7fe f849 	bl	20004404 <cmd_addcmd>
	       NULL,
	       "1 to turn on light",
	       "0 to turn off light",
	       "");

    cmd_addcmd("led2",
20006372:	4b43      	ldr	r3, [pc, #268]	@ (20006480 <ui_init_misccmds+0x1a0>)
20006374:	9301      	str	r3, [sp, #4]
20006376:	4b53      	ldr	r3, [pc, #332]	@ (200064c4 <ui_init_misccmds+0x1e4>)
20006378:	9300      	str	r3, [sp, #0]
2000637a:	4b53      	ldr	r3, [pc, #332]	@ (200064c8 <ui_init_misccmds+0x1e8>)
2000637c:	2200      	movs	r2, #0
2000637e:	4955      	ldr	r1, [pc, #340]	@ (200064d4 <ui_init_misccmds+0x1f4>)
20006380:	4855      	ldr	r0, [pc, #340]	@ (200064d8 <ui_init_misccmds+0x1f8>)
20006382:	f7fe f83f 	bl	20004404 <cmd_addcmd>
	       NULL,
	       "1 to turn on light",
	       "0 to turn off light",
	       "");

    cmd_addcmd("ledg",
20006386:	4b3e      	ldr	r3, [pc, #248]	@ (20006480 <ui_init_misccmds+0x1a0>)
20006388:	9301      	str	r3, [sp, #4]
2000638a:	4b4e      	ldr	r3, [pc, #312]	@ (200064c4 <ui_init_misccmds+0x1e4>)
2000638c:	9300      	str	r3, [sp, #0]
2000638e:	4b4e      	ldr	r3, [pc, #312]	@ (200064c8 <ui_init_misccmds+0x1e8>)
20006390:	2200      	movs	r2, #0
20006392:	4952      	ldr	r1, [pc, #328]	@ (200064dc <ui_init_misccmds+0x1fc>)
20006394:	4852      	ldr	r0, [pc, #328]	@ (200064e0 <ui_init_misccmds+0x200>)
20006396:	f7fe f835 	bl	20004404 <cmd_addcmd>
	       ui_cmd_LEDG,
	       NULL,
	       "1 to turn on light",
	       "0 to turn off light",
	       "");
    cmd_addcmd("joystick",
2000639a:	4b39      	ldr	r3, [pc, #228]	@ (20006480 <ui_init_misccmds+0x1a0>)
2000639c:	9301      	str	r3, [sp, #4]
2000639e:	4b49      	ldr	r3, [pc, #292]	@ (200064c4 <ui_init_misccmds+0x1e4>)
200063a0:	9300      	str	r3, [sp, #0]
200063a2:	4b49      	ldr	r3, [pc, #292]	@ (200064c8 <ui_init_misccmds+0x1e8>)
200063a4:	2200      	movs	r2, #0
200063a6:	494f      	ldr	r1, [pc, #316]	@ (200064e4 <ui_init_misccmds+0x204>)
200063a8:	484f      	ldr	r0, [pc, #316]	@ (200064e8 <ui_init_misccmds+0x208>)
200063aa:	f7fe f82b 	bl	20004404 <cmd_addcmd>
	       NULL,
	       "1 to turn on light",
	       "0 to turn off light",
	       "");

	cmd_addcmd("ledo",
200063ae:	4b34      	ldr	r3, [pc, #208]	@ (20006480 <ui_init_misccmds+0x1a0>)
200063b0:	9301      	str	r3, [sp, #4]
200063b2:	4b44      	ldr	r3, [pc, #272]	@ (200064c4 <ui_init_misccmds+0x1e4>)
200063b4:	9300      	str	r3, [sp, #0]
200063b6:	4b44      	ldr	r3, [pc, #272]	@ (200064c8 <ui_init_misccmds+0x1e8>)
200063b8:	2200      	movs	r2, #0
200063ba:	494c      	ldr	r1, [pc, #304]	@ (200064ec <ui_init_misccmds+0x20c>)
200063bc:	484c      	ldr	r0, [pc, #304]	@ (200064f0 <ui_init_misccmds+0x210>)
200063be:	f7fe f821 	bl	20004404 <cmd_addcmd>
			   ui_cmd_LEDO,
			   NULL,
			   "1 to turn on light",
			   "0 to turn off light",
			   "");
	cmd_addcmd("ledb",
200063c2:	4b2f      	ldr	r3, [pc, #188]	@ (20006480 <ui_init_misccmds+0x1a0>)
200063c4:	9301      	str	r3, [sp, #4]
200063c6:	4b3f      	ldr	r3, [pc, #252]	@ (200064c4 <ui_init_misccmds+0x1e4>)
200063c8:	9300      	str	r3, [sp, #0]
200063ca:	4b3f      	ldr	r3, [pc, #252]	@ (200064c8 <ui_init_misccmds+0x1e8>)
200063cc:	2200      	movs	r2, #0
200063ce:	4949      	ldr	r1, [pc, #292]	@ (200064f4 <ui_init_misccmds+0x214>)
200063d0:	4849      	ldr	r0, [pc, #292]	@ (200064f8 <ui_init_misccmds+0x218>)
200063d2:	f7fe f817 	bl	20004404 <cmd_addcmd>
			   NULL,
			   "1 to turn on light",
			   "0 to turn off light",
			   "");

	cmd_addcmd("i2c",
200063d6:	4b2a      	ldr	r3, [pc, #168]	@ (20006480 <ui_init_misccmds+0x1a0>)
200063d8:	9301      	str	r3, [sp, #4]
200063da:	4b29      	ldr	r3, [pc, #164]	@ (20006480 <ui_init_misccmds+0x1a0>)
200063dc:	9300      	str	r3, [sp, #0]
200063de:	4b28      	ldr	r3, [pc, #160]	@ (20006480 <ui_init_misccmds+0x1a0>)
200063e0:	2200      	movs	r2, #0
200063e2:	4946      	ldr	r1, [pc, #280]	@ (200064fc <ui_init_misccmds+0x21c>)
200063e4:	4846      	ldr	r0, [pc, #280]	@ (20006500 <ui_init_misccmds+0x220>)
200063e6:	f7fe f80d 	bl	20004404 <cmd_addcmd>
			   NULL,
			   "",
			   "",
			   "");

	cmd_addcmd("writei2c",
200063ea:	4b25      	ldr	r3, [pc, #148]	@ (20006480 <ui_init_misccmds+0x1a0>)
200063ec:	9301      	str	r3, [sp, #4]
200063ee:	4b45      	ldr	r3, [pc, #276]	@ (20006504 <ui_init_misccmds+0x224>)
200063f0:	9300      	str	r3, [sp, #0]
200063f2:	4b45      	ldr	r3, [pc, #276]	@ (20006508 <ui_init_misccmds+0x228>)
200063f4:	2200      	movs	r2, #0
200063f6:	4945      	ldr	r1, [pc, #276]	@ (2000650c <ui_init_misccmds+0x22c>)
200063f8:	4845      	ldr	r0, [pc, #276]	@ (20006510 <ui_init_misccmds+0x230>)
200063fa:	f7fe f803 	bl	20004404 <cmd_addcmd>
	           "write_i2c <reg_address> <value>\n"
	           "  <reg_address>  Register address to write to (hex)\n"
	           "  <value>        Value to write (hex)",
	           "");

	cmd_addcmd("displayi2c",
200063fe:	4b20      	ldr	r3, [pc, #128]	@ (20006480 <ui_init_misccmds+0x1a0>)
20006400:	9301      	str	r3, [sp, #4]
20006402:	4b40      	ldr	r3, [pc, #256]	@ (20006504 <ui_init_misccmds+0x224>)
20006404:	9300      	str	r3, [sp, #0]
20006406:	4b40      	ldr	r3, [pc, #256]	@ (20006508 <ui_init_misccmds+0x228>)
20006408:	2200      	movs	r2, #0
2000640a:	4942      	ldr	r1, [pc, #264]	@ (20006514 <ui_init_misccmds+0x234>)
2000640c:	4842      	ldr	r0, [pc, #264]	@ (20006518 <ui_init_misccmds+0x238>)
2000640e:	f7fd fff9 	bl	20004404 <cmd_addcmd>
	           "write_i2c <reg_address> <value>\n"
	           "  <reg_address>  Register address to write to (hex)\n"
	           "  <value>        Value to write (hex)",
	           "");

	cmd_addcmd("writei2cio2",
20006412:	4b1b      	ldr	r3, [pc, #108]	@ (20006480 <ui_init_misccmds+0x1a0>)
20006414:	9301      	str	r3, [sp, #4]
20006416:	4b3b      	ldr	r3, [pc, #236]	@ (20006504 <ui_init_misccmds+0x224>)
20006418:	9300      	str	r3, [sp, #0]
2000641a:	4b3b      	ldr	r3, [pc, #236]	@ (20006508 <ui_init_misccmds+0x228>)
2000641c:	2200      	movs	r2, #0
2000641e:	493f      	ldr	r1, [pc, #252]	@ (2000651c <ui_init_misccmds+0x23c>)
20006420:	483f      	ldr	r0, [pc, #252]	@ (20006520 <ui_init_misccmds+0x240>)
20006422:	f7fd ffef 	bl	20004404 <cmd_addcmd>
	           "Write to an I2C device",
	           "write_i2c <reg_address> <value>\n"
	           "  <reg_address>  Register address to write to (hex)\n"
	           "  <value>        Value to write (hex)",
	           "");
	cmd_addcmd("systick",
20006426:	4b16      	ldr	r3, [pc, #88]	@ (20006480 <ui_init_misccmds+0x1a0>)
20006428:	9301      	str	r3, [sp, #4]
2000642a:	4b15      	ldr	r3, [pc, #84]	@ (20006480 <ui_init_misccmds+0x1a0>)
2000642c:	9300      	str	r3, [sp, #0]
2000642e:	4b3d      	ldr	r3, [pc, #244]	@ (20006524 <ui_init_misccmds+0x244>)
20006430:	2200      	movs	r2, #0
20006432:	493d      	ldr	r1, [pc, #244]	@ (20006528 <ui_init_misccmds+0x248>)
20006434:	483d      	ldr	r0, [pc, #244]	@ (2000652c <ui_init_misccmds+0x24c>)
20006436:	f7fd ffe5 	bl	20004404 <cmd_addcmd>
	           ""
	           ""
	           "",
	           "");

	cmd_addcmd("addasm",
2000643a:	4b11      	ldr	r3, [pc, #68]	@ (20006480 <ui_init_misccmds+0x1a0>)
2000643c:	9301      	str	r3, [sp, #4]
2000643e:	4b10      	ldr	r3, [pc, #64]	@ (20006480 <ui_init_misccmds+0x1a0>)
20006440:	9300      	str	r3, [sp, #0]
20006442:	4b0f      	ldr	r3, [pc, #60]	@ (20006480 <ui_init_misccmds+0x1a0>)
20006444:	2200      	movs	r2, #0
20006446:	493a      	ldr	r1, [pc, #232]	@ (20006530 <ui_init_misccmds+0x250>)
20006448:	483a      	ldr	r0, [pc, #232]	@ (20006534 <ui_init_misccmds+0x254>)
2000644a:	f7fd ffdb 	bl	20004404 <cmd_addcmd>
	           ""
	           "",
	           "");


	cmd_addcmd("uart",
2000644e:	4b0c      	ldr	r3, [pc, #48]	@ (20006480 <ui_init_misccmds+0x1a0>)
20006450:	9301      	str	r3, [sp, #4]
20006452:	4b0b      	ldr	r3, [pc, #44]	@ (20006480 <ui_init_misccmds+0x1a0>)
20006454:	9300      	str	r3, [sp, #0]
20006456:	4b0a      	ldr	r3, [pc, #40]	@ (20006480 <ui_init_misccmds+0x1a0>)
20006458:	2200      	movs	r2, #0
2000645a:	4937      	ldr	r1, [pc, #220]	@ (20006538 <ui_init_misccmds+0x258>)
2000645c:	4837      	ldr	r0, [pc, #220]	@ (2000653c <ui_init_misccmds+0x25c>)
2000645e:	f7fd ffd1 	bl	20004404 <cmd_addcmd>
	           "",
	           ""
	           ""
	           "",
	           "");
	return 0;
20006462:	2300      	movs	r3, #0

}
20006464:	4618      	mov	r0, r3
20006466:	46bd      	mov	sp, r7
20006468:	bd80      	pop	{r7, pc}
2000646a:	bf00      	nop
2000646c:	20008858 	.word	0x20008858
20006470:	20008898 	.word	0x20008898
20006474:	20008840 	.word	0x20008840
20006478:	200065bd 	.word	0x200065bd
2000647c:	20008850 	.word	0x20008850
20006480:	20008968 	.word	0x20008968
20006484:	2000896c 	.word	0x2000896c
20006488:	20008940 	.word	0x20008940
2000648c:	20006541 	.word	0x20006541
20006490:	20008960 	.word	0x20008960
20006494:	20008a2c 	.word	0x20008a2c
20006498:	200089fc 	.word	0x200089fc
2000649c:	2000665d 	.word	0x2000665d
200064a0:	20008a20 	.word	0x20008a20
200064a4:	20008af4 	.word	0x20008af4
200064a8:	200066cd 	.word	0x200066cd
200064ac:	20008b14 	.word	0x20008b14
200064b0:	20008b1c 	.word	0x20008b1c
200064b4:	20006739 	.word	0x20006739
200064b8:	20008b4c 	.word	0x20008b4c
200064bc:	20008b54 	.word	0x20008b54
200064c0:	200067a5 	.word	0x200067a5
200064c4:	20008b78 	.word	0x20008b78
200064c8:	20008b60 	.word	0x20008b60
200064cc:	2000682d 	.word	0x2000682d
200064d0:	20008b74 	.word	0x20008b74
200064d4:	200075ed 	.word	0x200075ed
200064d8:	20008b8c 	.word	0x20008b8c
200064dc:	200068f5 	.word	0x200068f5
200064e0:	20008b94 	.word	0x20008b94
200064e4:	2000733d 	.word	0x2000733d
200064e8:	20008b9c 	.word	0x20008b9c
200064ec:	20007139 	.word	0x20007139
200064f0:	20008ba8 	.word	0x20008ba8
200064f4:	200071a9 	.word	0x200071a9
200064f8:	20008bb0 	.word	0x20008bb0
200064fc:	20006961 	.word	0x20006961
20006500:	20008bb8 	.word	0x20008bb8
20006504:	20008be0 	.word	0x20008be0
20006508:	20008bbc 	.word	0x20008bbc
2000650c:	20006b5d 	.word	0x20006b5d
20006510:	20008bd4 	.word	0x20008bd4
20006514:	20006f2d 	.word	0x20006f2d
20006518:	20008c5c 	.word	0x20008c5c
2000651c:	2000721d 	.word	0x2000721d
20006520:	20008c68 	.word	0x20008c68
20006524:	20008c74 	.word	0x20008c74
20006528:	20007419 	.word	0x20007419
2000652c:	20008c84 	.word	0x20008c84
20006530:	2000747d 	.word	0x2000747d
20006534:	20008c8c 	.word	0x20008c8c
20006538:	20007565 	.word	0x20007565
2000653c:	20008c94 	.word	0x20008c94

20006540 <ui_cmd_sleep>:

static int ui_cmd_sleep(ui_cmdline_t *cmd,int argc,char *argv[])
{
20006540:	e92d 43b0 	stmdb	sp!, {r4, r5, r7, r8, r9, lr}
20006544:	b088      	sub	sp, #32
20006546:	af00      	add	r7, sp, #0
20006548:	60f8      	str	r0, [r7, #12]
2000654a:	60b9      	str	r1, [r7, #8]
2000654c:	607a      	str	r2, [r7, #4]
    int seconds = 1;
2000654e:	2301      	movs	r3, #1
20006550:	61fb      	str	r3, [r7, #28]
    char *x;
    cfe_timer_t timer;

    if ((x = cmd_getarg(cmd,0))) seconds = atoi(x);
20006552:	2100      	movs	r1, #0
20006554:	68f8      	ldr	r0, [r7, #12]
20006556:	f7fd fd82 	bl	2000405e <cmd_getarg>
2000655a:	61b8      	str	r0, [r7, #24]
2000655c:	69bb      	ldr	r3, [r7, #24]
2000655e:	2b00      	cmp	r3, #0
20006560:	d003      	beq.n	2000656a <ui_cmd_sleep+0x2a>
20006562:	69b8      	ldr	r0, [r7, #24]
20006564:	f7fb f905 	bl	20001772 <lib_atoi>
20006568:	61f8      	str	r0, [r7, #28]

    TIMER_SET(timer,seconds*CFE_HZ);
2000656a:	69fa      	ldr	r2, [r7, #28]
2000656c:	4613      	mov	r3, r2
2000656e:	009b      	lsls	r3, r3, #2
20006570:	4413      	add	r3, r2
20006572:	005b      	lsls	r3, r3, #1
20006574:	17da      	asrs	r2, r3, #31
20006576:	461c      	mov	r4, r3
20006578:	4615      	mov	r5, r2
2000657a:	4b0f      	ldr	r3, [pc, #60]	@ (200065b8 <ui_cmd_sleep+0x78>)
2000657c:	e9d3 2300 	ldrd	r2, r3, [r3]
20006580:	eb14 0802 	adds.w	r8, r4, r2
20006584:	eb45 0903 	adc.w	r9, r5, r3
20006588:	e9c7 8904 	strd	r8, r9, [r7, #16]
    while (!TIMER_EXPIRED(timer)) {
2000658c:	e001      	b.n	20006592 <ui_cmd_sleep+0x52>
	POLL();
2000658e:	f7fb fb47 	bl	20001c20 <background>
    while (!TIMER_EXPIRED(timer)) {
20006592:	e9d7 2304 	ldrd	r2, r3, [r7, #16]
20006596:	4313      	orrs	r3, r2
20006598:	d0f9      	beq.n	2000658e <ui_cmd_sleep+0x4e>
2000659a:	4b07      	ldr	r3, [pc, #28]	@ (200065b8 <ui_cmd_sleep+0x78>)
2000659c:	e9d3 2300 	ldrd	r2, r3, [r3]
200065a0:	e9d7 0104 	ldrd	r0, r1, [r7, #16]
200065a4:	4290      	cmp	r0, r2
200065a6:	eb71 0303 	sbcs.w	r3, r1, r3
200065aa:	daf0      	bge.n	2000658e <ui_cmd_sleep+0x4e>
	}

    return 0;
200065ac:	2300      	movs	r3, #0
}
200065ae:	4618      	mov	r0, r3
200065b0:	3720      	adds	r7, #32
200065b2:	46bd      	mov	sp, r7
200065b4:	e8bd 83b0 	ldmia.w	sp!, {r4, r5, r7, r8, r9, pc}
200065b8:	20009450 	.word	0x20009450

200065bc <ui_cmd_loop>:

static int ui_cmd_loop(ui_cmdline_t *cmd,int argc,char *argv[])
{
200065bc:	b580      	push	{r7, lr}
200065be:	b088      	sub	sp, #32
200065c0:	af00      	add	r7, sp, #0
200065c2:	60f8      	str	r0, [r7, #12]
200065c4:	60b9      	str	r1, [r7, #8]
200065c6:	607a      	str	r2, [r7, #4]
    int count = 10;
200065c8:	230a      	movs	r3, #10
200065ca:	61fb      	str	r3, [r7, #28]
    char *x;
    int res;
    int forever;

    if (cmd_sw_value(cmd,"-count",&x)) count = atoi(x);
200065cc:	f107 0310 	add.w	r3, r7, #16
200065d0:	461a      	mov	r2, r3
200065d2:	4920      	ldr	r1, [pc, #128]	@ (20006654 <ui_cmd_loop+0x98>)
200065d4:	68f8      	ldr	r0, [r7, #12]
200065d6:	f7fd fcc3 	bl	20003f60 <cmd_sw_value>
200065da:	4603      	mov	r3, r0
200065dc:	2b00      	cmp	r3, #0
200065de:	d004      	beq.n	200065ea <ui_cmd_loop+0x2e>
200065e0:	693b      	ldr	r3, [r7, #16]
200065e2:	4618      	mov	r0, r3
200065e4:	f7fb f8c5 	bl	20001772 <lib_atoi>
200065e8:	61f8      	str	r0, [r7, #28]
    
    forever = cmd_sw_isset(cmd,"-forever");
200065ea:	491b      	ldr	r1, [pc, #108]	@ (20006658 <ui_cmd_loop+0x9c>)
200065ec:	68f8      	ldr	r0, [r7, #12]
200065ee:	f7fd fd0d 	bl	2000400c <cmd_sw_isset>
200065f2:	6178      	str	r0, [r7, #20]

    x = cmd_getarg(cmd,0);
200065f4:	2100      	movs	r1, #0
200065f6:	68f8      	ldr	r0, [r7, #12]
200065f8:	f7fd fd31 	bl	2000405e <cmd_getarg>
200065fc:	4603      	mov	r3, r0
200065fe:	613b      	str	r3, [r7, #16]
    if (!x) return ui_showusage(cmd);
20006600:	693b      	ldr	r3, [r7, #16]
20006602:	2b00      	cmp	r3, #0
20006604:	d104      	bne.n	20006610 <ui_cmd_loop+0x54>
20006606:	68f8      	ldr	r0, [r7, #12]
20006608:	f7fd fbfd 	bl	20003e06 <ui_showusage>
2000660c:	4603      	mov	r3, r0
2000660e:	e01d      	b.n	2000664c <ui_cmd_loop+0x90>

    res = 0;
20006610:	2300      	movs	r3, #0
20006612:	61bb      	str	r3, [r7, #24]
    while (count || forever) {
20006614:	e00f      	b.n	20006636 <ui_cmd_loop+0x7a>
	if (console_status()) break;
20006616:	f7fb fbcf 	bl	20001db8 <console_status>
2000661a:	4603      	mov	r3, r0
2000661c:	2b00      	cmp	r3, #0
2000661e:	d111      	bne.n	20006644 <ui_cmd_loop+0x88>
	res = ui_docommands(x);
20006620:	693b      	ldr	r3, [r7, #16]
20006622:	4618      	mov	r0, r3
20006624:	f7fd fc64 	bl	20003ef0 <ui_docommands>
20006628:	61b8      	str	r0, [r7, #24]
	if (res != 0) break;
2000662a:	69bb      	ldr	r3, [r7, #24]
2000662c:	2b00      	cmp	r3, #0
2000662e:	d10b      	bne.n	20006648 <ui_cmd_loop+0x8c>
	count--;
20006630:	69fb      	ldr	r3, [r7, #28]
20006632:	3b01      	subs	r3, #1
20006634:	61fb      	str	r3, [r7, #28]
    while (count || forever) {
20006636:	69fb      	ldr	r3, [r7, #28]
20006638:	2b00      	cmp	r3, #0
2000663a:	d1ec      	bne.n	20006616 <ui_cmd_loop+0x5a>
2000663c:	697b      	ldr	r3, [r7, #20]
2000663e:	2b00      	cmp	r3, #0
20006640:	d1e9      	bne.n	20006616 <ui_cmd_loop+0x5a>
20006642:	e002      	b.n	2000664a <ui_cmd_loop+0x8e>
	if (console_status()) break;
20006644:	bf00      	nop
20006646:	e000      	b.n	2000664a <ui_cmd_loop+0x8e>
	if (res != 0) break;
20006648:	bf00      	nop
	}

    return res;
2000664a:	69bb      	ldr	r3, [r7, #24]
}
2000664c:	4618      	mov	r0, r3
2000664e:	3720      	adds	r7, #32
20006650:	46bd      	mov	sp, r7
20006652:	bd80      	pop	{r7, pc}
20006654:	20008c9c 	.word	0x20008c9c
20006658:	20008ca4 	.word	0x20008ca4

2000665c <ui_cmd_console>:
}
#endif


static int ui_cmd_console(ui_cmdline_t *cmd,int argc,char *argv[])
{
2000665c:	b580      	push	{r7, lr}
2000665e:	b086      	sub	sp, #24
20006660:	af00      	add	r7, sp, #0
20006662:	60f8      	str	r0, [r7, #12]
20006664:	60b9      	str	r1, [r7, #8]
20006666:	607a      	str	r2, [r7, #4]
    int res;
    char *dev;

    dev = cmd_getarg(cmd,0);
20006668:	2100      	movs	r1, #0
2000666a:	68f8      	ldr	r0, [r7, #12]
2000666c:	f7fd fcf7 	bl	2000405e <cmd_getarg>
20006670:	6178      	str	r0, [r7, #20]
    if (!dev) return -1; 	/* XXX usage */
20006672:	697b      	ldr	r3, [r7, #20]
20006674:	2b00      	cmp	r3, #0
20006676:	d102      	bne.n	2000667e <ui_cmd_console+0x22>
20006678:	f04f 33ff 	mov.w	r3, #4294967295	@ 0xffffffff
2000667c:	e01d      	b.n	200066ba <ui_cmd_console+0x5e>

    res = cfe_getdevinfo(dev);
2000667e:	6978      	ldr	r0, [r7, #20]
20006680:	f7fc fc2c 	bl	20002edc <cfe_getdevinfo>
20006684:	6138      	str	r0, [r7, #16]
    if (res < 0) {
20006686:	693b      	ldr	r3, [r7, #16]
20006688:	2b00      	cmp	r3, #0
2000668a:	da06      	bge.n	2000669a <ui_cmd_console+0x3e>
	printf("Device '%s' is not valid\n",dev);
2000668c:	6979      	ldr	r1, [r7, #20]
2000668e:	480d      	ldr	r0, [pc, #52]	@ (200066c4 <ui_cmd_console+0x68>)
20006690:	f7fa fb68 	bl	20000d64 <printf>
	return CFE_ERR_DEVNOTFOUND;
20006694:	f06f 0305 	mvn.w	r3, #5
20006698:	e00f      	b.n	200066ba <ui_cmd_console+0x5e>
	}

    if ((res & CFE_DEV_MASK) != CFE_DEV_SERIAL) {
2000669a:	693b      	ldr	r3, [r7, #16]
2000669c:	f003 030f 	and.w	r3, r3, #15
200066a0:	2b04      	cmp	r3, #4
200066a2:	d006      	beq.n	200066b2 <ui_cmd_console+0x56>
	printf("Device '%s' is not the appropriate type to be a console\n",
200066a4:	6979      	ldr	r1, [r7, #20]
200066a6:	4808      	ldr	r0, [pc, #32]	@ (200066c8 <ui_cmd_console+0x6c>)
200066a8:	f7fa fb5c 	bl	20000d64 <printf>
		dev);
	return CFE_ERR_WRONGDEVTYPE;
200066ac:	f06f 031f 	mvn.w	r3, #31
200066b0:	e003      	b.n	200066ba <ui_cmd_console+0x5e>
	}

    cfe_set_console(dev);
200066b2:	6978      	ldr	r0, [r7, #20]
200066b4:	f7fb fbca 	bl	20001e4c <cfe_set_console>

    return 0;
200066b8:	2300      	movs	r3, #0
}
200066ba:	4618      	mov	r0, r3
200066bc:	3718      	adds	r7, #24
200066be:	46bd      	mov	sp, r7
200066c0:	bd80      	pop	{r7, pc}
200066c2:	bf00      	nop
200066c4:	20008cb0 	.word	0x20008cb0
200066c8:	20008ccc 	.word	0x20008ccc

200066cc <ui_cmd_display>:

static int ui_cmd_display(ui_cmdline_t *cmd,int argc,char *argv[])
{
200066cc:	b580      	push	{r7, lr}
200066ce:	b08a      	sub	sp, #40	@ 0x28
200066d0:	af00      	add	r7, sp, #0
200066d2:	60f8      	str	r0, [r7, #12]
200066d4:	60b9      	str	r1, [r7, #8]
200066d6:	607a      	str	r2, [r7, #4]

    printf("Printing out Memory Contents:\n");
200066d8:	4814      	ldr	r0, [pc, #80]	@ (2000672c <ui_cmd_display+0x60>)
200066da:	f7fa fb43 	bl	20000d64 <printf>
    uint32_t address;
    volatile uint32_t *ptr;
    uint32_t value;


    addr_str = cmd_getarg(cmd, 0);
200066de:	2100      	movs	r1, #0
200066e0:	68f8      	ldr	r0, [r7, #12]
200066e2:	f7fd fcbc 	bl	2000405e <cmd_getarg>
200066e6:	6238      	str	r0, [r7, #32]


    address = atoi(addr_str);
200066e8:	6a38      	ldr	r0, [r7, #32]
200066ea:	f7fb f842 	bl	20001772 <lib_atoi>
200066ee:	4603      	mov	r3, r0
200066f0:	627b      	str	r3, [r7, #36]	@ 0x24

    volatile uint32_t *ADDRESS_END = (uint32_t *)(address + 0x32);
200066f2:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
200066f4:	3332      	adds	r3, #50	@ 0x32
200066f6:	61fb      	str	r3, [r7, #28]

	for (address; address <= ADDRESS_END; address= address + 0x4) {
200066f8:	e00f      	b.n	2000671a <ui_cmd_display+0x4e>
	    ptr = (volatile uint32_t *)address;
200066fa:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
200066fc:	61bb      	str	r3, [r7, #24]
	    value = *ptr;
200066fe:	69bb      	ldr	r3, [r7, #24]
20006700:	681b      	ldr	r3, [r3, #0]
20006702:	617b      	str	r3, [r7, #20]

		printf("0x%08X", address);
20006704:	6a79      	ldr	r1, [r7, #36]	@ 0x24
20006706:	480a      	ldr	r0, [pc, #40]	@ (20006730 <ui_cmd_display+0x64>)
20006708:	f7fa fb2c 	bl	20000d64 <printf>
		printf("0x%08X\n", value);
2000670c:	6979      	ldr	r1, [r7, #20]
2000670e:	4809      	ldr	r0, [pc, #36]	@ (20006734 <ui_cmd_display+0x68>)
20006710:	f7fa fb28 	bl	20000d64 <printf>
	for (address; address <= ADDRESS_END; address= address + 0x4) {
20006714:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
20006716:	3304      	adds	r3, #4
20006718:	627b      	str	r3, [r7, #36]	@ 0x24
2000671a:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
2000671c:	69fa      	ldr	r2, [r7, #28]
2000671e:	429a      	cmp	r2, r3
20006720:	d2eb      	bcs.n	200066fa <ui_cmd_display+0x2e>
	    }

    return 0;
20006722:	2300      	movs	r3, #0
}
20006724:	4618      	mov	r0, r3
20006726:	3728      	adds	r7, #40	@ 0x28
20006728:	46bd      	mov	sp, r7
2000672a:	bd80      	pop	{r7, pc}
2000672c:	20008d08 	.word	0x20008d08
20006730:	20008d28 	.word	0x20008d28
20006734:	20008d30 	.word	0x20008d30

20006738 <ui_cmd_edit>:


static int ui_cmd_edit(ui_cmdline_t *cmd,int argc,char *argv[])
{
20006738:	b580      	push	{r7, lr}
2000673a:	b08a      	sub	sp, #40	@ 0x28
2000673c:	af00      	add	r7, sp, #0
2000673e:	60f8      	str	r0, [r7, #12]
20006740:	60b9      	str	r1, [r7, #8]
20006742:	607a      	str	r2, [r7, #4]
	uint32_t address;
	volatile uint32_t *ptr;
	uint32_t value;


	addr_str = cmd_getarg(cmd, 0);
20006744:	2100      	movs	r1, #0
20006746:	68f8      	ldr	r0, [r7, #12]
20006748:	f7fd fc89 	bl	2000405e <cmd_getarg>
2000674c:	6278      	str	r0, [r7, #36]	@ 0x24
	address = atoi(addr_str);
2000674e:	6a78      	ldr	r0, [r7, #36]	@ 0x24
20006750:	f7fb f80f 	bl	20001772 <lib_atoi>
20006754:	4603      	mov	r3, r0
20006756:	623b      	str	r3, [r7, #32]

	value_str = cmd_getarg(cmd, 1);
20006758:	2101      	movs	r1, #1
2000675a:	68f8      	ldr	r0, [r7, #12]
2000675c:	f7fd fc7f 	bl	2000405e <cmd_getarg>
20006760:	61f8      	str	r0, [r7, #28]
	value = atoi(value_str);
20006762:	69f8      	ldr	r0, [r7, #28]
20006764:	f7fb f805 	bl	20001772 <lib_atoi>
20006768:	4603      	mov	r3, r0
2000676a:	61bb      	str	r3, [r7, #24]

    ptr = (volatile uint32_t *)address;
2000676c:	6a3b      	ldr	r3, [r7, #32]
2000676e:	617b      	str	r3, [r7, #20]
    *ptr = value;
20006770:	697b      	ldr	r3, [r7, #20]
20006772:	69ba      	ldr	r2, [r7, #24]
20006774:	601a      	str	r2, [r3, #0]

    printf("new value:");
20006776:	4808      	ldr	r0, [pc, #32]	@ (20006798 <ui_cmd_edit+0x60>)
20006778:	f7fa faf4 	bl	20000d64 <printf>

    printf("0x%08X", address);
2000677c:	6a39      	ldr	r1, [r7, #32]
2000677e:	4807      	ldr	r0, [pc, #28]	@ (2000679c <ui_cmd_edit+0x64>)
20006780:	f7fa faf0 	bl	20000d64 <printf>

    printf("0x%08X\n", value);
20006784:	69b9      	ldr	r1, [r7, #24]
20006786:	4806      	ldr	r0, [pc, #24]	@ (200067a0 <ui_cmd_edit+0x68>)
20006788:	f7fa faec 	bl	20000d64 <printf>


	return 0;
2000678c:	2300      	movs	r3, #0
}
2000678e:	4618      	mov	r0, r3
20006790:	3728      	adds	r7, #40	@ 0x28
20006792:	46bd      	mov	sp, r7
20006794:	bd80      	pop	{r7, pc}
20006796:	bf00      	nop
20006798:	20008d38 	.word	0x20008d38
2000679c:	20008d28 	.word	0x20008d28
200067a0:	20008d30 	.word	0x20008d30

200067a4 <ui_cmd_printten>:

static int ui_cmd_printten(ui_cmdline_t *cmd,int argc,char *argv[])
{
200067a4:	b580      	push	{r7, lr}
200067a6:	b086      	sub	sp, #24
200067a8:	af00      	add	r7, sp, #0
200067aa:	60f8      	str	r0, [r7, #12]
200067ac:	60b9      	str	r1, [r7, #8]
200067ae:	607a      	str	r2, [r7, #4]
	for(int i = 1; i< 10; i++){
200067b0:	2301      	movs	r3, #1
200067b2:	617b      	str	r3, [r7, #20]
200067b4:	e005      	b.n	200067c2 <ui_cmd_printten+0x1e>
		printf("hello world");
200067b6:	4807      	ldr	r0, [pc, #28]	@ (200067d4 <ui_cmd_printten+0x30>)
200067b8:	f7fa fad4 	bl	20000d64 <printf>
	for(int i = 1; i< 10; i++){
200067bc:	697b      	ldr	r3, [r7, #20]
200067be:	3301      	adds	r3, #1
200067c0:	617b      	str	r3, [r7, #20]
200067c2:	697b      	ldr	r3, [r7, #20]
200067c4:	2b09      	cmp	r3, #9
200067c6:	ddf6      	ble.n	200067b6 <ui_cmd_printten+0x12>
	}
	return 0;
200067c8:	2300      	movs	r3, #0
}
200067ca:	4618      	mov	r0, r3
200067cc:	3718      	adds	r7, #24
200067ce:	46bd      	mov	sp, r7
200067d0:	bd80      	pop	{r7, pc}
200067d2:	bf00      	nop
200067d4:	20008d44 	.word	0x20008d44

200067d8 <LED_Init>:

#define PWR_BASE 0x40007000



void LED_Init(void) {
200067d8:	b480      	push	{r7}
200067da:	b083      	sub	sp, #12
200067dc:	af00      	add	r7, sp, #0

    *(volatile uint32_t *)(0x40007004) = 0x200;
200067de:	4b0e      	ldr	r3, [pc, #56]	@ (20006818 <LED_Init+0x40>)
200067e0:	f44f 7200 	mov.w	r2, #512	@ 0x200
200067e4:	601a      	str	r2, [r3, #0]

    volatile uint32_t *RCC_AHB2ENR = (uint32_t *)(0x40021000 + 0x4C);
200067e6:	4b0d      	ldr	r3, [pc, #52]	@ (2000681c <LED_Init+0x44>)
200067e8:	607b      	str	r3, [r7, #4]
    *RCC_AHB2ENR = 0xf;
200067ea:	687b      	ldr	r3, [r7, #4]
200067ec:	220f      	movs	r2, #15
200067ee:	601a      	str	r2, [r3, #0]


    volatile uint32_t *RCC_APB1ENR1 = (uint32_t *)(0x40021000 + 0x58);
200067f0:	4b0b      	ldr	r3, [pc, #44]	@ (20006820 <LED_Init+0x48>)
200067f2:	603b      	str	r3, [r7, #0]
    *RCC_APB1ENR1 |= (1 << 28);
200067f4:	683b      	ldr	r3, [r7, #0]
200067f6:	681b      	ldr	r3, [r3, #0]
200067f8:	f043 5280 	orr.w	r2, r3, #268435456	@ 0x10000000
200067fc:	683b      	ldr	r3, [r7, #0]
200067fe:	601a      	str	r2, [r3, #0]


    *(volatile uint32_t *)(GPIOC_BASE) = 0x4; // turn on
20006800:	4b08      	ldr	r3, [pc, #32]	@ (20006824 <LED_Init+0x4c>)
20006802:	2204      	movs	r2, #4
20006804:	601a      	str	r2, [r3, #0]


    *(volatile uint32_t *)(GPIOC_BASE + 0x14) = 0x0; // turn off
20006806:	4b08      	ldr	r3, [pc, #32]	@ (20006828 <LED_Init+0x50>)
20006808:	2200      	movs	r2, #0
2000680a:	601a      	str	r2, [r3, #0]
}
2000680c:	bf00      	nop
2000680e:	370c      	adds	r7, #12
20006810:	46bd      	mov	sp, r7
20006812:	f85d 7b04 	ldr.w	r7, [sp], #4
20006816:	4770      	bx	lr
20006818:	40007004 	.word	0x40007004
2000681c:	4002104c 	.word	0x4002104c
20006820:	40021058 	.word	0x40021058
20006824:	48000800 	.word	0x48000800
20006828:	48000814 	.word	0x48000814

2000682c <ui_cmd_LED>:

static int ui_cmd_LED(ui_cmdline_t *cmd, int argc, char *argv[])
{
2000682c:	b580      	push	{r7, lr}
2000682e:	b088      	sub	sp, #32
20006830:	af00      	add	r7, sp, #0
20006832:	60f8      	str	r0, [r7, #12]
20006834:	60b9      	str	r1, [r7, #8]
20006836:	607a      	str	r2, [r7, #4]
    char *state_str;
    int state;

    state_str = cmd_getarg(cmd, 0);
20006838:	2100      	movs	r1, #0
2000683a:	68f8      	ldr	r0, [r7, #12]
2000683c:	f7fd fc0f 	bl	2000405e <cmd_getarg>
20006840:	61f8      	str	r0, [r7, #28]
    state = atoi(state_str);
20006842:	69f8      	ldr	r0, [r7, #28]
20006844:	f7fa ff95 	bl	20001772 <lib_atoi>
20006848:	61b8      	str	r0, [r7, #24]

    LED_Init();
2000684a:	f7ff ffc5 	bl	200067d8 <LED_Init>
    volatile uint32_t *GPIOC_ODR = (uint32_t *)(GPIOC_BASE + 0x14);
2000684e:	4b0f      	ldr	r3, [pc, #60]	@ (2000688c <ui_cmd_LED+0x60>)
20006850:	617b      	str	r3, [r7, #20]

    if (state == 0) {
20006852:	69bb      	ldr	r3, [r7, #24]
20006854:	2b00      	cmp	r3, #0
20006856:	d108      	bne.n	2000686a <ui_cmd_LED+0x3e>

        *GPIOC_ODR |= (1 << 1);
20006858:	697b      	ldr	r3, [r7, #20]
2000685a:	681b      	ldr	r3, [r3, #0]
2000685c:	f043 0202 	orr.w	r2, r3, #2
20006860:	697b      	ldr	r3, [r7, #20]
20006862:	601a      	str	r2, [r3, #0]
        printf("LED is OFF\n");
20006864:	480a      	ldr	r0, [pc, #40]	@ (20006890 <ui_cmd_LED+0x64>)
20006866:	f7fa fa7d 	bl	20000d64 <printf>
    }
    if (state == 1) {
2000686a:	69bb      	ldr	r3, [r7, #24]
2000686c:	2b01      	cmp	r3, #1
2000686e:	d108      	bne.n	20006882 <ui_cmd_LED+0x56>

        *GPIOC_ODR &= ~(1 << 1);
20006870:	697b      	ldr	r3, [r7, #20]
20006872:	681b      	ldr	r3, [r3, #0]
20006874:	f023 0202 	bic.w	r2, r3, #2
20006878:	697b      	ldr	r3, [r7, #20]
2000687a:	601a      	str	r2, [r3, #0]
        printf("LED is ON\n");
2000687c:	4805      	ldr	r0, [pc, #20]	@ (20006894 <ui_cmd_LED+0x68>)
2000687e:	f7fa fa71 	bl	20000d64 <printf>
    }

    return 0;
20006882:	2300      	movs	r3, #0
}
20006884:	4618      	mov	r0, r3
20006886:	3720      	adds	r7, #32
20006888:	46bd      	mov	sp, r7
2000688a:	bd80      	pop	{r7, pc}
2000688c:	48000814 	.word	0x48000814
20006890:	20008d50 	.word	0x20008d50
20006894:	20008d5c 	.word	0x20008d5c

20006898 <LEDG_Init>:

void LEDG_Init(void) {
20006898:	b480      	push	{r7}
2000689a:	b083      	sub	sp, #12
2000689c:	af00      	add	r7, sp, #0

    *(volatile uint32_t *)(0x40007004) = 0x200;
2000689e:	4b10      	ldr	r3, [pc, #64]	@ (200068e0 <LEDG_Init+0x48>)
200068a0:	f44f 7200 	mov.w	r2, #512	@ 0x200
200068a4:	601a      	str	r2, [r3, #0]

    volatile uint32_t *RCC_AHB2ENR = (uint32_t *)(0x40021000 + 0x4C);
200068a6:	4b0f      	ldr	r3, [pc, #60]	@ (200068e4 <LEDG_Init+0x4c>)
200068a8:	607b      	str	r3, [r7, #4]
    *RCC_AHB2ENR = 0xf;
200068aa:	687b      	ldr	r3, [r7, #4]
200068ac:	220f      	movs	r2, #15
200068ae:	601a      	str	r2, [r3, #0]

    volatile uint32_t *RCC_APB1ENR1 = (uint32_t *)(0x40021000 + 0x58);
200068b0:	4b0d      	ldr	r3, [pc, #52]	@ (200068e8 <LEDG_Init+0x50>)
200068b2:	603b      	str	r3, [r7, #0]
    *RCC_APB1ENR1 |= (1 << 28);
200068b4:	683b      	ldr	r3, [r7, #0]
200068b6:	681b      	ldr	r3, [r3, #0]
200068b8:	f043 5280 	orr.w	r2, r3, #268435456	@ 0x10000000
200068bc:	683b      	ldr	r3, [r7, #0]
200068be:	601a      	str	r2, [r3, #0]


    *(volatile uint32_t *)(GPIOB_BASE + 0)  |= 0x10; //
200068c0:	4b0a      	ldr	r3, [pc, #40]	@ (200068ec <LEDG_Init+0x54>)
200068c2:	681b      	ldr	r3, [r3, #0]
200068c4:	4a09      	ldr	r2, [pc, #36]	@ (200068ec <LEDG_Init+0x54>)
200068c6:	f043 0310 	orr.w	r3, r3, #16
200068ca:	6013      	str	r3, [r2, #0]

    *(volatile uint32_t *)(GPIOB_BASE + 0x14) = 0x0;
200068cc:	4b08      	ldr	r3, [pc, #32]	@ (200068f0 <LEDG_Init+0x58>)
200068ce:	2200      	movs	r2, #0
200068d0:	601a      	str	r2, [r3, #0]
}
200068d2:	bf00      	nop
200068d4:	370c      	adds	r7, #12
200068d6:	46bd      	mov	sp, r7
200068d8:	f85d 7b04 	ldr.w	r7, [sp], #4
200068dc:	4770      	bx	lr
200068de:	bf00      	nop
200068e0:	40007004 	.word	0x40007004
200068e4:	4002104c 	.word	0x4002104c
200068e8:	40021058 	.word	0x40021058
200068ec:	48000400 	.word	0x48000400
200068f0:	48000414 	.word	0x48000414

200068f4 <ui_cmd_LEDG>:


static int ui_cmd_LEDG(ui_cmdline_t *cmd, int argc, char *argv[]) {
200068f4:	b580      	push	{r7, lr}
200068f6:	b088      	sub	sp, #32
200068f8:	af00      	add	r7, sp, #0
200068fa:	60f8      	str	r0, [r7, #12]
200068fc:	60b9      	str	r1, [r7, #8]
200068fe:	607a      	str	r2, [r7, #4]
    char *state_str;
    int state;

    state_str = cmd_getarg(cmd, 0);
20006900:	2100      	movs	r1, #0
20006902:	68f8      	ldr	r0, [r7, #12]
20006904:	f7fd fbab 	bl	2000405e <cmd_getarg>
20006908:	61f8      	str	r0, [r7, #28]
    state = atoi(state_str);
2000690a:	69f8      	ldr	r0, [r7, #28]
2000690c:	f7fa ff31 	bl	20001772 <lib_atoi>
20006910:	61b8      	str	r0, [r7, #24]

    LEDG_Init();
20006912:	f7ff ffc1 	bl	20006898 <LEDG_Init>
    volatile uint32_t *GPIOB_ODR = (uint32_t *)(GPIOB_BASE + 0x14);
20006916:	4b0f      	ldr	r3, [pc, #60]	@ (20006954 <ui_cmd_LEDG+0x60>)
20006918:	617b      	str	r3, [r7, #20]

    if (state == 0) {
2000691a:	69bb      	ldr	r3, [r7, #24]
2000691c:	2b00      	cmp	r3, #0
2000691e:	d108      	bne.n	20006932 <ui_cmd_LEDG+0x3e>
        *GPIOB_ODR |= (1 << 2);
20006920:	697b      	ldr	r3, [r7, #20]
20006922:	681b      	ldr	r3, [r3, #0]
20006924:	f043 0204 	orr.w	r2, r3, #4
20006928:	697b      	ldr	r3, [r7, #20]
2000692a:	601a      	str	r2, [r3, #0]
        printf("LED1 is OFF\n");
2000692c:	480a      	ldr	r0, [pc, #40]	@ (20006958 <ui_cmd_LEDG+0x64>)
2000692e:	f7fa fa19 	bl	20000d64 <printf>
    }
    if (state == 1) {
20006932:	69bb      	ldr	r3, [r7, #24]
20006934:	2b01      	cmp	r3, #1
20006936:	d108      	bne.n	2000694a <ui_cmd_LEDG+0x56>
        *GPIOB_ODR &= ~(1 << 2);
20006938:	697b      	ldr	r3, [r7, #20]
2000693a:	681b      	ldr	r3, [r3, #0]
2000693c:	f023 0204 	bic.w	r2, r3, #4
20006940:	697b      	ldr	r3, [r7, #20]
20006942:	601a      	str	r2, [r3, #0]
        printf("LED1 is ON\n");
20006944:	4805      	ldr	r0, [pc, #20]	@ (2000695c <ui_cmd_LEDG+0x68>)
20006946:	f7fa fa0d 	bl	20000d64 <printf>
    }

    return 0;
2000694a:	2300      	movs	r3, #0
}
2000694c:	4618      	mov	r0, r3
2000694e:	3720      	adds	r7, #32
20006950:	46bd      	mov	sp, r7
20006952:	bd80      	pop	{r7, pc}
20006954:	48000414 	.word	0x48000414
20006958:	20008d68 	.word	0x20008d68
2000695c:	20008d78 	.word	0x20008d78

20006960 <ui_cmd_I2C>:


static int ui_cmd_I2C(ui_cmdline_t *cmd, int argc, char *argv[])
{
20006960:	b580      	push	{r7, lr}
20006962:	b088      	sub	sp, #32
20006964:	af00      	add	r7, sp, #0
20006966:	60f8      	str	r0, [r7, #12]
20006968:	60b9      	str	r1, [r7, #8]
2000696a:	607a      	str	r2, [r7, #4]

    *(volatile uint32_t *)(0x40021060) = 0x4001; // __HAL_RCC_SYSCFG_CLK_ENABLE();
2000696c:	4b59      	ldr	r3, [pc, #356]	@ (20006ad4 <ui_cmd_I2C+0x174>)
2000696e:	f244 0201 	movw	r2, #16385	@ 0x4001
20006972:	601a      	str	r2, [r3, #0]

    *(volatile uint32_t *)(0x40021058) = 0x10000000;//__HAL_RCC_PWR_CLK_ENABLE();
20006974:	4b58      	ldr	r3, [pc, #352]	@ (20006ad8 <ui_cmd_I2C+0x178>)
20006976:	f04f 5280 	mov.w	r2, #268435456	@ 0x10000000
2000697a:	601a      	str	r2, [r3, #0]


	*(volatile uint32_t *)(0x40021088) = 0; //RCC i2c clock selection
2000697c:	4b57      	ldr	r3, [pc, #348]	@ (20006adc <ui_cmd_I2C+0x17c>)
2000697e:	2200      	movs	r2, #0
20006980:	601a      	str	r2, [r3, #0]

    *(volatile uint32_t *)(0x40007004) = 0x200;   // PWR_CR2 enable
20006982:	4b57      	ldr	r3, [pc, #348]	@ (20006ae0 <ui_cmd_I2C+0x180>)
20006984:	f44f 7200 	mov.w	r2, #512	@ 0x200
20006988:	601a      	str	r2, [r3, #0]

    *(volatile uint32_t *)(0x4002104C) = 0x20ff;    // GPIOG_CLK_ENABLE
2000698a:	4b56      	ldr	r3, [pc, #344]	@ (20006ae4 <ui_cmd_I2C+0x184>)
2000698c:	f242 02ff 	movw	r2, #8447	@ 0x20ff
20006990:	601a      	str	r2, [r3, #0]

    *(volatile uint32_t *)(0x40021058) = 0x32200000;
20006992:	4b51      	ldr	r3, [pc, #324]	@ (20006ad8 <ui_cmd_I2C+0x178>)
20006994:	4a54      	ldr	r2, [pc, #336]	@ (20006ae8 <ui_cmd_I2C+0x188>)
20006996:	601a      	str	r2, [r3, #0]


    *(volatile uint32_t *)(0x48001808) = 0xc3c0fff; //GPIOx_OSPEEDR
20006998:	4b54      	ldr	r3, [pc, #336]	@ (20006aec <ui_cmd_I2C+0x18c>)
2000699a:	4a55      	ldr	r2, [pc, #340]	@ (20006af0 <ui_cmd_I2C+0x190>)
2000699c:	601a      	str	r2, [r3, #0]
    *(volatile uint32_t *)(0x48001804) = 0x2000; //GPIO port output type register (GPIOx_OTYPER)
2000699e:	4b55      	ldr	r3, [pc, #340]	@ (20006af4 <ui_cmd_I2C+0x194>)
200069a0:	f44f 5200 	mov.w	r2, #8192	@ 0x2000
200069a4:	601a      	str	r2, [r3, #0]
    *(volatile uint32_t *)(0x4800180C) = 0x4000000; //GPIOG_PUPDR
200069a6:	4b54      	ldr	r3, [pc, #336]	@ (20006af8 <ui_cmd_I2C+0x198>)
200069a8:	f04f 6280 	mov.w	r2, #67108864	@ 0x4000000
200069ac:	601a      	str	r2, [r3, #0]

    *(volatile uint32_t *)(0x48001824) = 0x400cc0;// Configure Alternate function mapped with the current IO
200069ae:	4b53      	ldr	r3, [pc, #332]	@ (20006afc <ui_cmd_I2C+0x19c>)
200069b0:	4a53      	ldr	r2, [pc, #332]	@ (20006b00 <ui_cmd_I2C+0x1a0>)
200069b2:	601a      	str	r2, [r3, #0]
    *(volatile uint32_t *)(0x48001800) = 0x3bebcaaa; // Configure IO Direction mode (Input, Output, Alternate or Analog)
200069b4:	4b53      	ldr	r3, [pc, #332]	@ (20006b04 <ui_cmd_I2C+0x1a4>)
200069b6:	4a54      	ldr	r2, [pc, #336]	@ (20006b08 <ui_cmd_I2C+0x1a8>)
200069b8:	601a      	str	r2, [r3, #0]
    *(volatile uint32_t *)(0x48001808) = 0x3c3c0fff;  // Configure the IO Speed */
200069ba:	4b4c      	ldr	r3, [pc, #304]	@ (20006aec <ui_cmd_I2C+0x18c>)
200069bc:	4a53      	ldr	r2, [pc, #332]	@ (20006b0c <ui_cmd_I2C+0x1ac>)
200069be:	601a      	str	r2, [r3, #0]
    *(volatile uint32_t *)(0x48001804) = 0x6000; // GPIO_OTYPER
200069c0:	4b4c      	ldr	r3, [pc, #304]	@ (20006af4 <ui_cmd_I2C+0x194>)
200069c2:	f44f 42c0 	mov.w	r2, #24576	@ 0x6000
200069c6:	601a      	str	r2, [r3, #0]
    *(volatile uint32_t *)(0x4800082C) = 0x4000000; // activate pull up or pull down GPIO_PUPDR
200069c8:	4b51      	ldr	r3, [pc, #324]	@ (20006b10 <ui_cmd_I2C+0x1b0>)
200069ca:	f04f 6280 	mov.w	r2, #67108864	@ 0x4000000
200069ce:	601a      	str	r2, [r3, #0]
    *(volatile uint32_t *)(0x48001824) = 0x4400cc0;// Configure Alternate function mapped with the current IO
200069d0:	4b4a      	ldr	r3, [pc, #296]	@ (20006afc <ui_cmd_I2C+0x19c>)
200069d2:	4a50      	ldr	r2, [pc, #320]	@ (20006b14 <ui_cmd_I2C+0x1b4>)
200069d4:	601a      	str	r2, [r3, #0]
    *(volatile uint32_t *)(0x48001800) = 0x2bebcaaa; // Configure IO Direction mode (Input, Output, Alternate or Analog)
200069d6:	4b4b      	ldr	r3, [pc, #300]	@ (20006b04 <ui_cmd_I2C+0x1a4>)
200069d8:	4a4f      	ldr	r2, [pc, #316]	@ (20006b18 <ui_cmd_I2C+0x1b8>)
200069da:	601a      	str	r2, [r3, #0]

    *(volatile uint32_t *)(0x48001808) = 0x3c3c0fff;  /* Configure the IO Speed */
200069dc:	4b43      	ldr	r3, [pc, #268]	@ (20006aec <ui_cmd_I2C+0x18c>)
200069de:	4a4b      	ldr	r2, [pc, #300]	@ (20006b0c <ui_cmd_I2C+0x1ac>)
200069e0:	601a      	str	r2, [r3, #0]
    *(volatile uint32_t *)(0x48001804) = 0x6000; // GPIO_OTYPER
200069e2:	4b44      	ldr	r3, [pc, #272]	@ (20006af4 <ui_cmd_I2C+0x194>)
200069e4:	f44f 42c0 	mov.w	r2, #24576	@ 0x6000
200069e8:	601a      	str	r2, [r3, #0]
    *(volatile uint32_t *)(0x4800082C) = 0x0; /* activate pull up or pull down GPIO_PUPDR */
200069ea:	4b49      	ldr	r3, [pc, #292]	@ (20006b10 <ui_cmd_I2C+0x1b0>)
200069ec:	2200      	movs	r2, #0
200069ee:	601a      	str	r2, [r3, #0]

    *(volatile uint8_t *)(0x48001841) = 0x24; //hi2c->State = HAL_I2C_STATE_BUSY;
200069f0:	4b4a      	ldr	r3, [pc, #296]	@ (20006b1c <ui_cmd_I2C+0x1bc>)
200069f2:	2224      	movs	r2, #36	@ 0x24
200069f4:	701a      	strb	r2, [r3, #0]



	*(volatile uint32_t *)(0x40005400) = 0; //Disable the selected I2C peripheral
200069f6:	4b4a      	ldr	r3, [pc, #296]	@ (20006b20 <ui_cmd_I2C+0x1c0>)
200069f8:	2200      	movs	r2, #0
200069fa:	601a      	str	r2, [r3, #0]
	*(volatile uint32_t *)(0x40005410) = 0x20303E5D; //Configure I2Cx: Frequency range
200069fc:	4b49      	ldr	r3, [pc, #292]	@ (20006b24 <ui_cmd_I2C+0x1c4>)
200069fe:	4a4a      	ldr	r2, [pc, #296]	@ (20006b28 <ui_cmd_I2C+0x1c8>)
20006a00:	601a      	str	r2, [r3, #0]
	*(volatile uint32_t *)(0x40005408) = 0; //I2Cx OAR1 Configuration
20006a02:	4b4a      	ldr	r3, [pc, #296]	@ (20006b2c <ui_cmd_I2C+0x1cc>)
20006a04:	2200      	movs	r2, #0
20006a06:	601a      	str	r2, [r3, #0]
	*(volatile uint32_t *)(0x40005408) = 0x8000; //ack own address1 mode
20006a08:	4b48      	ldr	r3, [pc, #288]	@ (20006b2c <ui_cmd_I2C+0x1cc>)
20006a0a:	f44f 4200 	mov.w	r2, #32768	@ 0x8000
20006a0e:	601a      	str	r2, [r3, #0]

	*(volatile uint32_t *)(0x40005404) = 0; //Clear the I2C ADD10 bit
20006a10:	4b47      	ldr	r3, [pc, #284]	@ (20006b30 <ui_cmd_I2C+0x1d0>)
20006a12:	2200      	movs	r2, #0
20006a14:	601a      	str	r2, [r3, #0]
	*(volatile uint32_t *)(0x4000540C) = 0; //I2Cx OAR2 Configuration
20006a16:	4b47      	ldr	r3, [pc, #284]	@ (20006b34 <ui_cmd_I2C+0x1d4>)
20006a18:	2200      	movs	r2, #0
20006a1a:	601a      	str	r2, [r3, #0]
	*(volatile uint32_t *)(0x40005400) = 0; //Configure I2Cx: Generalcall and NoStretch mode
20006a1c:	4b40      	ldr	r3, [pc, #256]	@ (20006b20 <ui_cmd_I2C+0x1c0>)
20006a1e:	2200      	movs	r2, #0
20006a20:	601a      	str	r2, [r3, #0]
	*(volatile uint32_t *)(0x40005400) = 1; //Enable the selected I2C peripheral
20006a22:	4b3f      	ldr	r3, [pc, #252]	@ (20006b20 <ui_cmd_I2C+0x1c0>)
20006a24:	2201      	movs	r2, #1
20006a26:	601a      	str	r2, [r3, #0]



// transmit
	*(volatile uint32_t *)(0x40005400) = 0; //I2C_CR1, clear
20006a28:	4b3d      	ldr	r3, [pc, #244]	@ (20006b20 <ui_cmd_I2C+0x1c0>)
20006a2a:	2200      	movs	r2, #0
20006a2c:	601a      	str	r2, [r3, #0]
	*(volatile uint32_t *)(0x40005410) = 0x20303e5d; //595, timing
20006a2e:	4b3d      	ldr	r3, [pc, #244]	@ (20006b24 <ui_cmd_I2C+0x1c4>)
20006a30:	4a3d      	ldr	r2, [pc, #244]	@ (20006b28 <ui_cmd_I2C+0x1c8>)
20006a32:	601a      	str	r2, [r3, #0]
	*(volatile uint32_t *)(0x40005408) = 0; //595, OAR1
20006a34:	4b3d      	ldr	r3, [pc, #244]	@ (20006b2c <ui_cmd_I2C+0x1cc>)
20006a36:	2200      	movs	r2, #0
20006a38:	601a      	str	r2, [r3, #0]
	*(volatile uint32_t *)(0x40005408) = 0x8000;
20006a3a:	4b3c      	ldr	r3, [pc, #240]	@ (20006b2c <ui_cmd_I2C+0x1cc>)
20006a3c:	f44f 4200 	mov.w	r2, #32768	@ 0x8000
20006a40:	601a      	str	r2, [r3, #0]
	*(volatile uint32_t *)(0x40005404) = 0; //616, CR2
20006a42:	4b3b      	ldr	r3, [pc, #236]	@ (20006b30 <ui_cmd_I2C+0x1d0>)
20006a44:	2200      	movs	r2, #0
20006a46:	601a      	str	r2, [r3, #0]
	*(volatile uint32_t *)(0x40004404) = 0x2008000; //618, auto end, bit 15, NACK
20006a48:	4b3b      	ldr	r3, [pc, #236]	@ (20006b38 <ui_cmd_I2C+0x1d8>)
20006a4a:	4a3c      	ldr	r2, [pc, #240]	@ (20006b3c <ui_cmd_I2C+0x1dc>)
20006a4c:	601a      	str	r2, [r3, #0]
	*(volatile uint32_t *)(0x4000540C) = 0;//623,  OAR2
20006a4e:	4b39      	ldr	r3, [pc, #228]	@ (20006b34 <ui_cmd_I2C+0x1d4>)
20006a50:	2200      	movs	r2, #0
20006a52:	601a      	str	r2, [r3, #0]

	*(volatile uint32_t *)(0x40005400) = 1;//634, peripheral enable bit 0
20006a54:	4b32      	ldr	r3, [pc, #200]	@ (20006b20 <ui_cmd_I2C+0x1c0>)
20006a56:	2201      	movs	r2, #1
20006a58:	601a      	str	r2, [r3, #0]
	*(volatile uint32_t *)(0x40005428) = 0x0;//1162, TX reg,
20006a5a:	4b39      	ldr	r3, [pc, #228]	@ (20006b40 <ui_cmd_I2C+0x1e0>)
20006a5c:	2200      	movs	r2, #0
20006a5e:	601a      	str	r2, [r3, #0]
	*(volatile uint32_t *)(0x40005404) = 0x2012082; //7217,      82 device address
20006a60:	4b33      	ldr	r3, [pc, #204]	@ (20006b30 <ui_cmd_I2C+0x1d0>)
20006a62:	4a38      	ldr	r2, [pc, #224]	@ (20006b44 <ui_cmd_I2C+0x1e4>)
20006a64:	601a      	str	r2, [r3, #0]

	//receive

	uint32_t temp = 0; //I2C_ISR STOPF: STOP detection flag
20006a66:	2300      	movs	r3, #0
20006a68:	61fb      	str	r3, [r7, #28]
	while(((temp = *(volatile uint32_t *)(0x40005418)) & 0x20) == 0){
20006a6a:	bf00      	nop
20006a6c:	4b36      	ldr	r3, [pc, #216]	@ (20006b48 <ui_cmd_I2C+0x1e8>)
20006a6e:	681b      	ldr	r3, [r3, #0]
20006a70:	61fb      	str	r3, [r7, #28]
20006a72:	69fb      	ldr	r3, [r7, #28]
20006a74:	f003 0320 	and.w	r3, r3, #32
20006a78:	2b00      	cmp	r3, #0
20006a7a:	d0f7      	beq.n	20006a6c <ui_cmd_I2C+0x10c>
	}

	*(volatile uint32_t *)(0x40005404) = 0x2012482; //7217 update CR2 register */
20006a7c:	4b2c      	ldr	r3, [pc, #176]	@ (20006b30 <ui_cmd_I2C+0x1d0>)
20006a7e:	4a33      	ldr	r2, [pc, #204]	@ (20006b4c <ui_cmd_I2C+0x1ec>)
20006a80:	601a      	str	r2, [r3, #0]

	uint32_t busy = 0; //I2C_ISR BUSY: BUSY detection flag
20006a82:	2300      	movs	r3, #0
20006a84:	61bb      	str	r3, [r7, #24]
	while(((busy = *(volatile uint32_t *)(0x40005400)) & 0x8000) == 1){
20006a86:	bf00      	nop
20006a88:	4b25      	ldr	r3, [pc, #148]	@ (20006b20 <ui_cmd_I2C+0x1c0>)
20006a8a:	681b      	ldr	r3, [r3, #0]
20006a8c:	61bb      	str	r3, [r7, #24]
20006a8e:	69bb      	ldr	r3, [r7, #24]
20006a90:	f403 4300 	and.w	r3, r3, #32768	@ 0x8000
20006a94:	2b01      	cmp	r3, #1
20006a96:	d0f7      	beq.n	20006a88 <ui_cmd_I2C+0x128>
	}

	uint32_t RXNE_BUSY = 0; //RXNE: Receive data register
20006a98:	2300      	movs	r3, #0
20006a9a:	617b      	str	r3, [r7, #20]
	while(((RXNE_BUSY = *(volatile uint32_t *)(0x40005418)) & 0x4) == 0){
20006a9c:	bf00      	nop
20006a9e:	4b2a      	ldr	r3, [pc, #168]	@ (20006b48 <ui_cmd_I2C+0x1e8>)
20006aa0:	681b      	ldr	r3, [r3, #0]
20006aa2:	617b      	str	r3, [r7, #20]
20006aa4:	697b      	ldr	r3, [r7, #20]
20006aa6:	f003 0304 	and.w	r3, r3, #4
20006aaa:	2b00      	cmp	r3, #0
20006aac:	d0f7      	beq.n	20006a9e <ui_cmd_I2C+0x13e>


	/*
	 * corrections for printing function
	 */
	*(volatile uint32_t *)(0x40021088) = 0x2;
20006aae:	4b0b      	ldr	r3, [pc, #44]	@ (20006adc <ui_cmd_I2C+0x17c>)
20006ab0:	2202      	movs	r2, #2
20006ab2:	601a      	str	r2, [r3, #0]


    uint32_t received_data = *(volatile uint32_t *)(0x40005424);
20006ab4:	4b26      	ldr	r3, [pc, #152]	@ (20006b50 <ui_cmd_I2C+0x1f0>)
20006ab6:	681b      	ldr	r3, [r3, #0]
20006ab8:	613b      	str	r3, [r7, #16]
    printf("data");
20006aba:	4826      	ldr	r0, [pc, #152]	@ (20006b54 <ui_cmd_I2C+0x1f4>)
20006abc:	f7fa f952 	bl	20000d64 <printf>
    printf("Received data: 0x%08X\n", received_data);
20006ac0:	6939      	ldr	r1, [r7, #16]
20006ac2:	4825      	ldr	r0, [pc, #148]	@ (20006b58 <ui_cmd_I2C+0x1f8>)
20006ac4:	f7fa f94e 	bl	20000d64 <printf>


    return 0;
20006ac8:	2300      	movs	r3, #0
}
20006aca:	4618      	mov	r0, r3
20006acc:	3720      	adds	r7, #32
20006ace:	46bd      	mov	sp, r7
20006ad0:	bd80      	pop	{r7, pc}
20006ad2:	bf00      	nop
20006ad4:	40021060 	.word	0x40021060
20006ad8:	40021058 	.word	0x40021058
20006adc:	40021088 	.word	0x40021088
20006ae0:	40007004 	.word	0x40007004
20006ae4:	4002104c 	.word	0x4002104c
20006ae8:	32200000 	.word	0x32200000
20006aec:	48001808 	.word	0x48001808
20006af0:	0c3c0fff 	.word	0x0c3c0fff
20006af4:	48001804 	.word	0x48001804
20006af8:	4800180c 	.word	0x4800180c
20006afc:	48001824 	.word	0x48001824
20006b00:	00400cc0 	.word	0x00400cc0
20006b04:	48001800 	.word	0x48001800
20006b08:	3bebcaaa 	.word	0x3bebcaaa
20006b0c:	3c3c0fff 	.word	0x3c3c0fff
20006b10:	4800082c 	.word	0x4800082c
20006b14:	04400cc0 	.word	0x04400cc0
20006b18:	2bebcaaa 	.word	0x2bebcaaa
20006b1c:	48001841 	.word	0x48001841
20006b20:	40005400 	.word	0x40005400
20006b24:	40005410 	.word	0x40005410
20006b28:	20303e5d 	.word	0x20303e5d
20006b2c:	40005408 	.word	0x40005408
20006b30:	40005404 	.word	0x40005404
20006b34:	4000540c 	.word	0x4000540c
20006b38:	40004404 	.word	0x40004404
20006b3c:	02008000 	.word	0x02008000
20006b40:	40005428 	.word	0x40005428
20006b44:	02012082 	.word	0x02012082
20006b48:	40005418 	.word	0x40005418
20006b4c:	02012482 	.word	0x02012482
20006b50:	40005424 	.word	0x40005424
20006b54:	20008d84 	.word	0x20008d84
20006b58:	20008d8c 	.word	0x20008d8c

20006b5c <ui_cmd_write_I2C>:
#define IOEXPANDER_ADDRESS 0x82  // I2C address of the IO expander
#define IOEXPANDER_LED2_PIN 0    // GPIO0 is used for LED2


static int ui_cmd_write_I2C(ui_cmdline_t *cmd, int argc, char *argv[])
{
20006b5c:	b580      	push	{r7, lr}
20006b5e:	b08c      	sub	sp, #48	@ 0x30
20006b60:	af00      	add	r7, sp, #0
20006b62:	60f8      	str	r0, [r7, #12]
20006b64:	60b9      	str	r1, [r7, #8]
20006b66:	607a      	str	r2, [r7, #4]
    char *val_input;

    int reg_address;
    int value_to_send;

    reg_input = cmd_getarg(cmd, 0);
20006b68:	2100      	movs	r1, #0
20006b6a:	68f8      	ldr	r0, [r7, #12]
20006b6c:	f7fd fa77 	bl	2000405e <cmd_getarg>
20006b70:	62f8      	str	r0, [r7, #44]	@ 0x2c
    reg_address = atoi(reg_input);
20006b72:	6af8      	ldr	r0, [r7, #44]	@ 0x2c
20006b74:	f7fa fdfd 	bl	20001772 <lib_atoi>
20006b78:	62b8      	str	r0, [r7, #40]	@ 0x28

    val_input  = cmd_getarg(cmd, 1);
20006b7a:	2101      	movs	r1, #1
20006b7c:	68f8      	ldr	r0, [r7, #12]
20006b7e:	f7fd fa6e 	bl	2000405e <cmd_getarg>
20006b82:	6278      	str	r0, [r7, #36]	@ 0x24
    value_to_send = atoi(val_input);
20006b84:	6a78      	ldr	r0, [r7, #36]	@ 0x24
20006b86:	f7fa fdf4 	bl	20001772 <lib_atoi>
20006b8a:	6238      	str	r0, [r7, #32]


    // Initialization and clock configuration
    I2C_Init_INIT();
20006b8c:	f000 f884 	bl	20006c98 <I2C_Init_INIT>
    I2C_Init();
20006b90:	f000 f914 	bl	20006dbc <I2C_Init>

    //printf("Writing 0x%02X to register 0x%02X\n", value_to_send, reg_address);

    // RECorrections for printing function
    //*(volatile uint32_t *)(0x40021088) = 0; // RCC I2C clock selection
    uint32_t temp = 0;
20006b94:	2300      	movs	r3, #0
20006b96:	61fb      	str	r3, [r7, #28]

    while (((temp = *(volatile uint32_t *)(0x40005418)) & 0x1) == 0) {}
20006b98:	bf00      	nop
20006b9a:	4b35      	ldr	r3, [pc, #212]	@ (20006c70 <ui_cmd_write_I2C+0x114>)
20006b9c:	681b      	ldr	r3, [r3, #0]
20006b9e:	61fb      	str	r3, [r7, #28]
20006ba0:	69fb      	ldr	r3, [r7, #28]
20006ba2:	f003 0301 	and.w	r3, r3, #1
20006ba6:	2b00      	cmp	r3, #0
20006ba8:	d0f7      	beq.n	20006b9a <ui_cmd_write_I2C+0x3e>

    *(volatile uint32_t *)(0x40005428) = reg_address; // Register address
20006baa:	4a32      	ldr	r2, [pc, #200]	@ (20006c74 <ui_cmd_write_I2C+0x118>)
20006bac:	6abb      	ldr	r3, [r7, #40]	@ 0x28
20006bae:	6013      	str	r3, [r2, #0]
   // *(volatile uint32_t *)(0x40005428) = value_to_send; // Data to send

    *(volatile uint32_t *)(0x40005404) = 0x2022082; //7217,      82 device address
20006bb0:	4b31      	ldr	r3, [pc, #196]	@ (20006c78 <ui_cmd_write_I2C+0x11c>)
20006bb2:	4a32      	ldr	r2, [pc, #200]	@ (20006c7c <ui_cmd_write_I2C+0x120>)
20006bb4:	601a      	str	r2, [r3, #0]


    while (((temp = *(volatile uint32_t *)(0x40005418)) & 0x1) == 0) {}
20006bb6:	bf00      	nop
20006bb8:	4b2d      	ldr	r3, [pc, #180]	@ (20006c70 <ui_cmd_write_I2C+0x114>)
20006bba:	681b      	ldr	r3, [r3, #0]
20006bbc:	61fb      	str	r3, [r7, #28]
20006bbe:	69fb      	ldr	r3, [r7, #28]
20006bc0:	f003 0301 	and.w	r3, r3, #1
20006bc4:	2b00      	cmp	r3, #0
20006bc6:	d0f7      	beq.n	20006bb8 <ui_cmd_write_I2C+0x5c>

    *(volatile uint32_t *)(0x40005428) = value_to_send;
20006bc8:	4a2a      	ldr	r2, [pc, #168]	@ (20006c74 <ui_cmd_write_I2C+0x118>)
20006bca:	6a3b      	ldr	r3, [r7, #32]
20006bcc:	6013      	str	r3, [r2, #0]
    // Wait for STOPF
     temp = 0;
20006bce:	2300      	movs	r3, #0
20006bd0:	61fb      	str	r3, [r7, #28]
    while (((temp = *(volatile uint32_t *)(0x40005418)) & 0x20) == 0) {}
20006bd2:	bf00      	nop
20006bd4:	4b26      	ldr	r3, [pc, #152]	@ (20006c70 <ui_cmd_write_I2C+0x114>)
20006bd6:	681b      	ldr	r3, [r3, #0]
20006bd8:	61fb      	str	r3, [r7, #28]
20006bda:	69fb      	ldr	r3, [r7, #28]
20006bdc:	f003 0320 	and.w	r3, r3, #32
20006be0:	2b00      	cmp	r3, #0
20006be2:	d0f7      	beq.n	20006bd4 <ui_cmd_write_I2C+0x78>


    // RECorrections for printing function
    //*(volatile uint32_t *)(0x40021088) = 0; // RCC I2C clock selection

    while (((temp = *(volatile uint32_t *)(0x40005418)) & 0x1) == 0) {}
20006be4:	bf00      	nop
20006be6:	4b22      	ldr	r3, [pc, #136]	@ (20006c70 <ui_cmd_write_I2C+0x114>)
20006be8:	681b      	ldr	r3, [r3, #0]
20006bea:	61fb      	str	r3, [r7, #28]
20006bec:	69fb      	ldr	r3, [r7, #28]
20006bee:	f003 0301 	and.w	r3, r3, #1
20006bf2:	2b00      	cmp	r3, #0
20006bf4:	d0f7      	beq.n	20006be6 <ui_cmd_write_I2C+0x8a>

    *(volatile uint32_t *)(0x40005428) = reg_address; // Register address
20006bf6:	4a1f      	ldr	r2, [pc, #124]	@ (20006c74 <ui_cmd_write_I2C+0x118>)
20006bf8:	6abb      	ldr	r3, [r7, #40]	@ 0x28
20006bfa:	6013      	str	r3, [r2, #0]
      // *(volatile uint32_t *)(0x40005428) = value_to_send; // Data to send

    *(volatile uint32_t *)(0x40005404) = 0x2012082; //7217,      82 device address
20006bfc:	4b1e      	ldr	r3, [pc, #120]	@ (20006c78 <ui_cmd_write_I2C+0x11c>)
20006bfe:	4a20      	ldr	r2, [pc, #128]	@ (20006c80 <ui_cmd_write_I2C+0x124>)
20006c00:	601a      	str	r2, [r3, #0]

    while (((temp = *(volatile uint32_t *)(0x40005418)) & 0x1) == 0) {}
20006c02:	bf00      	nop
20006c04:	4b1a      	ldr	r3, [pc, #104]	@ (20006c70 <ui_cmd_write_I2C+0x114>)
20006c06:	681b      	ldr	r3, [r3, #0]
20006c08:	61fb      	str	r3, [r7, #28]
20006c0a:	69fb      	ldr	r3, [r7, #28]
20006c0c:	f003 0301 	and.w	r3, r3, #1
20006c10:	2b00      	cmp	r3, #0
20006c12:	d0f7      	beq.n	20006c04 <ui_cmd_write_I2C+0xa8>

       // Wait for STOPF
	temp = 0;
20006c14:	2300      	movs	r3, #0
20006c16:	61fb      	str	r3, [r7, #28]
	while (((temp = *(volatile uint32_t *)(0x40005418)) & 0x20) == 0) {}
20006c18:	bf00      	nop
20006c1a:	4b15      	ldr	r3, [pc, #84]	@ (20006c70 <ui_cmd_write_I2C+0x114>)
20006c1c:	681b      	ldr	r3, [r3, #0]
20006c1e:	61fb      	str	r3, [r7, #28]
20006c20:	69fb      	ldr	r3, [r7, #28]
20006c22:	f003 0320 	and.w	r3, r3, #32
20006c26:	2b00      	cmp	r3, #0
20006c28:	d0f7      	beq.n	20006c1a <ui_cmd_write_I2C+0xbe>


    *(volatile uint32_t *)(0x40005404) = 0x2012482; //7217 update CR2 register */
20006c2a:	4b13      	ldr	r3, [pc, #76]	@ (20006c78 <ui_cmd_write_I2C+0x11c>)
20006c2c:	4a15      	ldr	r2, [pc, #84]	@ (20006c84 <ui_cmd_write_I2C+0x128>)
20006c2e:	601a      	str	r2, [r3, #0]

    // Wait for RXNE
    uint32_t RXNE_BUSY = 0;
20006c30:	2300      	movs	r3, #0
20006c32:	61bb      	str	r3, [r7, #24]
    while (((RXNE_BUSY = *(volatile uint32_t *)(0x40005418)) & 0x4) == 0) {}
20006c34:	bf00      	nop
20006c36:	4b0e      	ldr	r3, [pc, #56]	@ (20006c70 <ui_cmd_write_I2C+0x114>)
20006c38:	681b      	ldr	r3, [r3, #0]
20006c3a:	61bb      	str	r3, [r7, #24]
20006c3c:	69bb      	ldr	r3, [r7, #24]
20006c3e:	f003 0304 	and.w	r3, r3, #4
20006c42:	2b00      	cmp	r3, #0
20006c44:	d0f7      	beq.n	20006c36 <ui_cmd_write_I2C+0xda>

    uint32_t received_data = *(volatile uint32_t *)(0x40005424);
20006c46:	4b10      	ldr	r3, [pc, #64]	@ (20006c88 <ui_cmd_write_I2C+0x12c>)
20006c48:	681b      	ldr	r3, [r3, #0]
20006c4a:	617b      	str	r3, [r7, #20]

	// Corrections for printing function
	*(volatile uint32_t *)(0x40021088) = 0x2;
20006c4c:	4b0f      	ldr	r3, [pc, #60]	@ (20006c8c <ui_cmd_write_I2C+0x130>)
20006c4e:	2202      	movs	r2, #2
20006c50:	601a      	str	r2, [r3, #0]
	printf("Writing 0x%02X to register 0x%02X\n", value_to_send, reg_address);
20006c52:	6aba      	ldr	r2, [r7, #40]	@ 0x28
20006c54:	6a39      	ldr	r1, [r7, #32]
20006c56:	480e      	ldr	r0, [pc, #56]	@ (20006c90 <ui_cmd_write_I2C+0x134>)
20006c58:	f7fa f884 	bl	20000d64 <printf>
    printf("Received data: 0x%08X\n", received_data);
20006c5c:	6979      	ldr	r1, [r7, #20]
20006c5e:	480d      	ldr	r0, [pc, #52]	@ (20006c94 <ui_cmd_write_I2C+0x138>)
20006c60:	f7fa f880 	bl	20000d64 <printf>



    return 0;
20006c64:	2300      	movs	r3, #0

}
20006c66:	4618      	mov	r0, r3
20006c68:	3730      	adds	r7, #48	@ 0x30
20006c6a:	46bd      	mov	sp, r7
20006c6c:	bd80      	pop	{r7, pc}
20006c6e:	bf00      	nop
20006c70:	40005418 	.word	0x40005418
20006c74:	40005428 	.word	0x40005428
20006c78:	40005404 	.word	0x40005404
20006c7c:	02022082 	.word	0x02022082
20006c80:	02012082 	.word	0x02012082
20006c84:	02012482 	.word	0x02012482
20006c88:	40005424 	.word	0x40005424
20006c8c:	40021088 	.word	0x40021088
20006c90:	20008da4 	.word	0x20008da4
20006c94:	20008d8c 	.word	0x20008d8c

20006c98 <I2C_Init_INIT>:


void I2C_Init_INIT(void) {
20006c98:	b480      	push	{r7}
20006c9a:	af00      	add	r7, sp, #0
    // Initialization and clock configuration



    *(volatile uint32_t *)(0x40021060) = 0x4001; // __HAL_RCC_SYSCFG_CLK_ENABLE();
20006c9c:	4b2f      	ldr	r3, [pc, #188]	@ (20006d5c <I2C_Init_INIT+0xc4>)
20006c9e:	f244 0201 	movw	r2, #16385	@ 0x4001
20006ca2:	601a      	str	r2, [r3, #0]



    *(volatile uint32_t *)(0x40021058) = 0x10000000; // __HAL_RCC_PWR_CLK_ENABLE();
20006ca4:	4b2e      	ldr	r3, [pc, #184]	@ (20006d60 <I2C_Init_INIT+0xc8>)
20006ca6:	f04f 5280 	mov.w	r2, #268435456	@ 0x10000000
20006caa:	601a      	str	r2, [r3, #0]

  //  *(volatile uint32_t *)(0x40021088) = 0; // RCC I2C clock selection

    *(volatile uint32_t *)(0x40007004) = 0x200; // PWR_CR2 enable
20006cac:	4b2d      	ldr	r3, [pc, #180]	@ (20006d64 <I2C_Init_INIT+0xcc>)
20006cae:	f44f 7200 	mov.w	r2, #512	@ 0x200
20006cb2:	601a      	str	r2, [r3, #0]


    *(volatile uint32_t *)(0x4002104C) = 0x20ff; // GPIOG_CLK_ENABLE
20006cb4:	4b2c      	ldr	r3, [pc, #176]	@ (20006d68 <I2C_Init_INIT+0xd0>)
20006cb6:	f242 02ff 	movw	r2, #8447	@ 0x20ff
20006cba:	601a      	str	r2, [r3, #0]


    *(volatile uint32_t *)(0x40021058) = 0x32200000;
20006cbc:	4b28      	ldr	r3, [pc, #160]	@ (20006d60 <I2C_Init_INIT+0xc8>)
20006cbe:	4a2b      	ldr	r2, [pc, #172]	@ (20006d6c <I2C_Init_INIT+0xd4>)
20006cc0:	601a      	str	r2, [r3, #0]


    // GPIO configuration
    *(volatile uint32_t *)(0x48001808) = 0xc3c0fff; // GPIOx_OSPEEDR
20006cc2:	4b2b      	ldr	r3, [pc, #172]	@ (20006d70 <I2C_Init_INIT+0xd8>)
20006cc4:	4a2b      	ldr	r2, [pc, #172]	@ (20006d74 <I2C_Init_INIT+0xdc>)
20006cc6:	601a      	str	r2, [r3, #0]
    *(volatile uint32_t *)(0x48001804) = 0x2000; // GPIO port output type register (GPIOx_OTYPER)
20006cc8:	4b2b      	ldr	r3, [pc, #172]	@ (20006d78 <I2C_Init_INIT+0xe0>)
20006cca:	f44f 5200 	mov.w	r2, #8192	@ 0x2000
20006cce:	601a      	str	r2, [r3, #0]
    *(volatile uint32_t *)(0x4800180C) = 0x4000000; // GPIOG_PUPDR
20006cd0:	4b2a      	ldr	r3, [pc, #168]	@ (20006d7c <I2C_Init_INIT+0xe4>)
20006cd2:	f04f 6280 	mov.w	r2, #67108864	@ 0x4000000
20006cd6:	601a      	str	r2, [r3, #0]
    *(volatile uint32_t *)(0x48001824) = 0x400cc0; // Configure Alternate function mapped with the current IO
20006cd8:	4b29      	ldr	r3, [pc, #164]	@ (20006d80 <I2C_Init_INIT+0xe8>)
20006cda:	4a2a      	ldr	r2, [pc, #168]	@ (20006d84 <I2C_Init_INIT+0xec>)
20006cdc:	601a      	str	r2, [r3, #0]
    *(volatile uint32_t *)(0x48001800) = 0x3bebcaaa; // Configure IO Direction mode (Input, Output, Alternate or Analog)
20006cde:	4b2a      	ldr	r3, [pc, #168]	@ (20006d88 <I2C_Init_INIT+0xf0>)
20006ce0:	4a2a      	ldr	r2, [pc, #168]	@ (20006d8c <I2C_Init_INIT+0xf4>)
20006ce2:	601a      	str	r2, [r3, #0]
    *(volatile uint32_t *)(0x48001808) = 0x3c3c0fff; // Configure the IO Speed
20006ce4:	4b22      	ldr	r3, [pc, #136]	@ (20006d70 <I2C_Init_INIT+0xd8>)
20006ce6:	4a2a      	ldr	r2, [pc, #168]	@ (20006d90 <I2C_Init_INIT+0xf8>)
20006ce8:	601a      	str	r2, [r3, #0]
    *(volatile uint32_t *)(0x48001804) = 0x6000; // GPIO_OTYPER
20006cea:	4b23      	ldr	r3, [pc, #140]	@ (20006d78 <I2C_Init_INIT+0xe0>)
20006cec:	f44f 42c0 	mov.w	r2, #24576	@ 0x6000
20006cf0:	601a      	str	r2, [r3, #0]
    *(volatile uint32_t *)(0x4800082C) = 0x4000000; // Activate pull up or pull down GPIO_PUPDR
20006cf2:	4b28      	ldr	r3, [pc, #160]	@ (20006d94 <I2C_Init_INIT+0xfc>)
20006cf4:	f04f 6280 	mov.w	r2, #67108864	@ 0x4000000
20006cf8:	601a      	str	r2, [r3, #0]
    *(volatile uint32_t *)(0x48001824) = 0x4400cc0; // Configure Alternate function mapped with the current IO
20006cfa:	4b21      	ldr	r3, [pc, #132]	@ (20006d80 <I2C_Init_INIT+0xe8>)
20006cfc:	4a26      	ldr	r2, [pc, #152]	@ (20006d98 <I2C_Init_INIT+0x100>)
20006cfe:	601a      	str	r2, [r3, #0]
    *(volatile uint32_t *)(0x48001800) = 0x2bebcaaa; // Configure IO Direction mode (Input, Output, Alternate or Analog)
20006d00:	4b21      	ldr	r3, [pc, #132]	@ (20006d88 <I2C_Init_INIT+0xf0>)
20006d02:	4a26      	ldr	r2, [pc, #152]	@ (20006d9c <I2C_Init_INIT+0x104>)
20006d04:	601a      	str	r2, [r3, #0]
    *(volatile uint32_t *)(0x48001808) = 0x3c3c0fff; // Configure the IO Speed
20006d06:	4b1a      	ldr	r3, [pc, #104]	@ (20006d70 <I2C_Init_INIT+0xd8>)
20006d08:	4a21      	ldr	r2, [pc, #132]	@ (20006d90 <I2C_Init_INIT+0xf8>)
20006d0a:	601a      	str	r2, [r3, #0]
    *(volatile uint32_t *)(0x48001804) = 0x6000; // GPIO_OTYPER
20006d0c:	4b1a      	ldr	r3, [pc, #104]	@ (20006d78 <I2C_Init_INIT+0xe0>)
20006d0e:	f44f 42c0 	mov.w	r2, #24576	@ 0x6000
20006d12:	601a      	str	r2, [r3, #0]
    *(volatile uint32_t *)(0x4800082C) = 0x0; // Activate pull up or pull down GPIO_PUPDR
20006d14:	4b1f      	ldr	r3, [pc, #124]	@ (20006d94 <I2C_Init_INIT+0xfc>)
20006d16:	2200      	movs	r2, #0
20006d18:	601a      	str	r2, [r3, #0]
    *(volatile uint8_t *)(0x48001841) = 0x24; // hi2c->State = HAL_I2C_STATE_BUSY
20006d1a:	4b21      	ldr	r3, [pc, #132]	@ (20006da0 <I2C_Init_INIT+0x108>)
20006d1c:	2224      	movs	r2, #36	@ 0x24
20006d1e:	701a      	strb	r2, [r3, #0]


    *(volatile uint32_t *)(0x40005400) = 0; // Disable the selected I2C peripheral
20006d20:	4b20      	ldr	r3, [pc, #128]	@ (20006da4 <I2C_Init_INIT+0x10c>)
20006d22:	2200      	movs	r2, #0
20006d24:	601a      	str	r2, [r3, #0]
    *(volatile uint32_t *)(0x40005410) = 0x20303E5D; // Configure I2Cx: Frequency range
20006d26:	4b20      	ldr	r3, [pc, #128]	@ (20006da8 <I2C_Init_INIT+0x110>)
20006d28:	4a20      	ldr	r2, [pc, #128]	@ (20006dac <I2C_Init_INIT+0x114>)
20006d2a:	601a      	str	r2, [r3, #0]
    *(volatile uint32_t *)(0x40005408) = 0; // I2Cx OAR1 Configuration
20006d2c:	4b20      	ldr	r3, [pc, #128]	@ (20006db0 <I2C_Init_INIT+0x118>)
20006d2e:	2200      	movs	r2, #0
20006d30:	601a      	str	r2, [r3, #0]
    *(volatile uint32_t *)(0x40005408) = 0x8000; // Ack own address1 mode
20006d32:	4b1f      	ldr	r3, [pc, #124]	@ (20006db0 <I2C_Init_INIT+0x118>)
20006d34:	f44f 4200 	mov.w	r2, #32768	@ 0x8000
20006d38:	601a      	str	r2, [r3, #0]
    *(volatile uint32_t *)(0x40005404) = 0; // Clear the I2C ADD10 bit
20006d3a:	4b1e      	ldr	r3, [pc, #120]	@ (20006db4 <I2C_Init_INIT+0x11c>)
20006d3c:	2200      	movs	r2, #0
20006d3e:	601a      	str	r2, [r3, #0]
    *(volatile uint32_t *)(0x4000540C) = 0; // I2Cx OAR2 Configuration
20006d40:	4b1d      	ldr	r3, [pc, #116]	@ (20006db8 <I2C_Init_INIT+0x120>)
20006d42:	2200      	movs	r2, #0
20006d44:	601a      	str	r2, [r3, #0]
    *(volatile uint32_t *)(0x40005400) = 0; // Configure I2Cx: Generalcall and NoStretch mode
20006d46:	4b17      	ldr	r3, [pc, #92]	@ (20006da4 <I2C_Init_INIT+0x10c>)
20006d48:	2200      	movs	r2, #0
20006d4a:	601a      	str	r2, [r3, #0]
    *(volatile uint32_t *)(0x40005400) = 1; // Enable the selected I2C peripheral
20006d4c:	4b15      	ldr	r3, [pc, #84]	@ (20006da4 <I2C_Init_INIT+0x10c>)
20006d4e:	2201      	movs	r2, #1
20006d50:	601a      	str	r2, [r3, #0]

}
20006d52:	bf00      	nop
20006d54:	46bd      	mov	sp, r7
20006d56:	f85d 7b04 	ldr.w	r7, [sp], #4
20006d5a:	4770      	bx	lr
20006d5c:	40021060 	.word	0x40021060
20006d60:	40021058 	.word	0x40021058
20006d64:	40007004 	.word	0x40007004
20006d68:	4002104c 	.word	0x4002104c
20006d6c:	32200000 	.word	0x32200000
20006d70:	48001808 	.word	0x48001808
20006d74:	0c3c0fff 	.word	0x0c3c0fff
20006d78:	48001804 	.word	0x48001804
20006d7c:	4800180c 	.word	0x4800180c
20006d80:	48001824 	.word	0x48001824
20006d84:	00400cc0 	.word	0x00400cc0
20006d88:	48001800 	.word	0x48001800
20006d8c:	3bebcaaa 	.word	0x3bebcaaa
20006d90:	3c3c0fff 	.word	0x3c3c0fff
20006d94:	4800082c 	.word	0x4800082c
20006d98:	04400cc0 	.word	0x04400cc0
20006d9c:	2bebcaaa 	.word	0x2bebcaaa
20006da0:	48001841 	.word	0x48001841
20006da4:	40005400 	.word	0x40005400
20006da8:	40005410 	.word	0x40005410
20006dac:	20303e5d 	.word	0x20303e5d
20006db0:	40005408 	.word	0x40005408
20006db4:	40005404 	.word	0x40005404
20006db8:	4000540c 	.word	0x4000540c

20006dbc <I2C_Init>:


void I2C_Init(void) {
20006dbc:	b480      	push	{r7}
20006dbe:	af00      	add	r7, sp, #0



    // Transmit
    *(volatile uint32_t *)(0x40005400) = 0; // I2C_CR1, clear
20006dc0:	4b0e      	ldr	r3, [pc, #56]	@ (20006dfc <I2C_Init+0x40>)
20006dc2:	2200      	movs	r2, #0
20006dc4:	601a      	str	r2, [r3, #0]
    *(volatile uint32_t *)(0x40005410) = 0x20303e5d; // I2C timing configuration
20006dc6:	4b0e      	ldr	r3, [pc, #56]	@ (20006e00 <I2C_Init+0x44>)
20006dc8:	4a0e      	ldr	r2, [pc, #56]	@ (20006e04 <I2C_Init+0x48>)
20006dca:	601a      	str	r2, [r3, #0]
    *(volatile uint32_t *)(0x40005408) = 0; // I2C OAR1 configuration
20006dcc:	4b0e      	ldr	r3, [pc, #56]	@ (20006e08 <I2C_Init+0x4c>)
20006dce:	2200      	movs	r2, #0
20006dd0:	601a      	str	r2, [r3, #0]
    *(volatile uint32_t *)(0x40005408) = 0x8000; // Ack own address1 mode
20006dd2:	4b0d      	ldr	r3, [pc, #52]	@ (20006e08 <I2C_Init+0x4c>)
20006dd4:	f44f 4200 	mov.w	r2, #32768	@ 0x8000
20006dd8:	601a      	str	r2, [r3, #0]
    *(volatile uint32_t *)(0x40005404) = 0; // I2C CR2 configuration
20006dda:	4b0c      	ldr	r3, [pc, #48]	@ (20006e0c <I2C_Init+0x50>)
20006ddc:	2200      	movs	r2, #0
20006dde:	601a      	str	r2, [r3, #0]
    *(volatile uint32_t *)(0x40004404) = 0x2008000; // Auto end, bit 15, NACK
20006de0:	4b0b      	ldr	r3, [pc, #44]	@ (20006e10 <I2C_Init+0x54>)
20006de2:	4a0c      	ldr	r2, [pc, #48]	@ (20006e14 <I2C_Init+0x58>)
20006de4:	601a      	str	r2, [r3, #0]
    *(volatile uint32_t *)(0x4000540C) = 0; // I2C OAR2 configuration
20006de6:	4b0c      	ldr	r3, [pc, #48]	@ (20006e18 <I2C_Init+0x5c>)
20006de8:	2200      	movs	r2, #0
20006dea:	601a      	str	r2, [r3, #0]

    *(volatile uint32_t *)(0x40005400) = 1; // Enable the selected I2C peripheral
20006dec:	4b03      	ldr	r3, [pc, #12]	@ (20006dfc <I2C_Init+0x40>)
20006dee:	2201      	movs	r2, #1
20006df0:	601a      	str	r2, [r3, #0]
}
20006df2:	bf00      	nop
20006df4:	46bd      	mov	sp, r7
20006df6:	f85d 7b04 	ldr.w	r7, [sp], #4
20006dfa:	4770      	bx	lr
20006dfc:	40005400 	.word	0x40005400
20006e00:	40005410 	.word	0x40005410
20006e04:	20303e5d 	.word	0x20303e5d
20006e08:	40005408 	.word	0x40005408
20006e0c:	40005404 	.word	0x40005404
20006e10:	40004404 	.word	0x40004404
20006e14:	02008000 	.word	0x02008000
20006e18:	4000540c 	.word	0x4000540c

20006e1c <write_I2C>:

static int write_I2C(int reg_address, int value_to_send)
{
20006e1c:	b580      	push	{r7, lr}
20006e1e:	b086      	sub	sp, #24
20006e20:	af00      	add	r7, sp, #0
20006e22:	6078      	str	r0, [r7, #4]
20006e24:	6039      	str	r1, [r7, #0]

    I2C_Init();
20006e26:	f7ff ffc9 	bl	20006dbc <I2C_Init>

    //printf("Writing 0x%02X to register 0x%02X", value_to_send, reg_address);

    // RECorrections for printing function
    //*(volatile uint32_t *)(0x40021088) = 0; // RCC I2C clock selection
    uint32_t temp = 0;
20006e2a:	2300      	movs	r3, #0
20006e2c:	617b      	str	r3, [r7, #20]

    while (((temp = *(volatile uint32_t *)(0x40005418)) & 0x1) == 0) {}
20006e2e:	bf00      	nop
20006e30:	4b34      	ldr	r3, [pc, #208]	@ (20006f04 <write_I2C+0xe8>)
20006e32:	681b      	ldr	r3, [r3, #0]
20006e34:	617b      	str	r3, [r7, #20]
20006e36:	697b      	ldr	r3, [r7, #20]
20006e38:	f003 0301 	and.w	r3, r3, #1
20006e3c:	2b00      	cmp	r3, #0
20006e3e:	d0f7      	beq.n	20006e30 <write_I2C+0x14>

    *(volatile uint32_t *)(0x40005428) = reg_address; // Register address
20006e40:	4a31      	ldr	r2, [pc, #196]	@ (20006f08 <write_I2C+0xec>)
20006e42:	687b      	ldr	r3, [r7, #4]
20006e44:	6013      	str	r3, [r2, #0]
    // *(volatile uint32_t *)(0x40005428) = value_to_send; // Data to send

    *(volatile uint32_t *)(0x40005404) = 0x2022082; // 7217, 82 device address
20006e46:	4b31      	ldr	r3, [pc, #196]	@ (20006f0c <write_I2C+0xf0>)
20006e48:	4a31      	ldr	r2, [pc, #196]	@ (20006f10 <write_I2C+0xf4>)
20006e4a:	601a      	str	r2, [r3, #0]

    while (((temp = *(volatile uint32_t *)(0x40005418)) & 0x1) == 0) {}
20006e4c:	bf00      	nop
20006e4e:	4b2d      	ldr	r3, [pc, #180]	@ (20006f04 <write_I2C+0xe8>)
20006e50:	681b      	ldr	r3, [r3, #0]
20006e52:	617b      	str	r3, [r7, #20]
20006e54:	697b      	ldr	r3, [r7, #20]
20006e56:	f003 0301 	and.w	r3, r3, #1
20006e5a:	2b00      	cmp	r3, #0
20006e5c:	d0f7      	beq.n	20006e4e <write_I2C+0x32>

    *(volatile uint32_t *)(0x40005428) = value_to_send;
20006e5e:	4a2a      	ldr	r2, [pc, #168]	@ (20006f08 <write_I2C+0xec>)
20006e60:	683b      	ldr	r3, [r7, #0]
20006e62:	6013      	str	r3, [r2, #0]
    // Wait for STOPF
    temp = 0;
20006e64:	2300      	movs	r3, #0
20006e66:	617b      	str	r3, [r7, #20]
    while (((temp = *(volatile uint32_t *)(0x40005418)) & 0x20) == 0) {}
20006e68:	bf00      	nop
20006e6a:	4b26      	ldr	r3, [pc, #152]	@ (20006f04 <write_I2C+0xe8>)
20006e6c:	681b      	ldr	r3, [r3, #0]
20006e6e:	617b      	str	r3, [r7, #20]
20006e70:	697b      	ldr	r3, [r7, #20]
20006e72:	f003 0320 	and.w	r3, r3, #32
20006e76:	2b00      	cmp	r3, #0
20006e78:	d0f7      	beq.n	20006e6a <write_I2C+0x4e>
    //printf("Reading back register 0x%02X", reg_address);

    // RECorrections for printing function
    //*(volatile uint32_t *)(0x40021088) = 0; // RCC I2C clock selection

    while (((temp = *(volatile uint32_t *)(0x40005418)) & 0x1) == 0) {}
20006e7a:	bf00      	nop
20006e7c:	4b21      	ldr	r3, [pc, #132]	@ (20006f04 <write_I2C+0xe8>)
20006e7e:	681b      	ldr	r3, [r3, #0]
20006e80:	617b      	str	r3, [r7, #20]
20006e82:	697b      	ldr	r3, [r7, #20]
20006e84:	f003 0301 	and.w	r3, r3, #1
20006e88:	2b00      	cmp	r3, #0
20006e8a:	d0f7      	beq.n	20006e7c <write_I2C+0x60>

    *(volatile uint32_t *)(0x40005428) = reg_address; // Register address
20006e8c:	4a1e      	ldr	r2, [pc, #120]	@ (20006f08 <write_I2C+0xec>)
20006e8e:	687b      	ldr	r3, [r7, #4]
20006e90:	6013      	str	r3, [r2, #0]
    // *(volatile uint32_t *)(0x40005428) = value_to_send; // Data to send

    *(volatile uint32_t *)(0x40005404) = 0x2012082; // 7217, 82 device address
20006e92:	4b1e      	ldr	r3, [pc, #120]	@ (20006f0c <write_I2C+0xf0>)
20006e94:	4a1f      	ldr	r2, [pc, #124]	@ (20006f14 <write_I2C+0xf8>)
20006e96:	601a      	str	r2, [r3, #0]

    while (((temp = *(volatile uint32_t *)(0x40005418)) & 0x1) == 0) {}
20006e98:	bf00      	nop
20006e9a:	4b1a      	ldr	r3, [pc, #104]	@ (20006f04 <write_I2C+0xe8>)
20006e9c:	681b      	ldr	r3, [r3, #0]
20006e9e:	617b      	str	r3, [r7, #20]
20006ea0:	697b      	ldr	r3, [r7, #20]
20006ea2:	f003 0301 	and.w	r3, r3, #1
20006ea6:	2b00      	cmp	r3, #0
20006ea8:	d0f7      	beq.n	20006e9a <write_I2C+0x7e>

    // Wait for STOPF
    temp = 0;
20006eaa:	2300      	movs	r3, #0
20006eac:	617b      	str	r3, [r7, #20]
    while (((temp = *(volatile uint32_t *)(0x40005418)) & 0x20) == 0) {}
20006eae:	bf00      	nop
20006eb0:	4b14      	ldr	r3, [pc, #80]	@ (20006f04 <write_I2C+0xe8>)
20006eb2:	681b      	ldr	r3, [r3, #0]
20006eb4:	617b      	str	r3, [r7, #20]
20006eb6:	697b      	ldr	r3, [r7, #20]
20006eb8:	f003 0320 	and.w	r3, r3, #32
20006ebc:	2b00      	cmp	r3, #0
20006ebe:	d0f7      	beq.n	20006eb0 <write_I2C+0x94>

    *(volatile uint32_t *)(0x40005404) = 0x2012482; // 7217 update CR2 register
20006ec0:	4b12      	ldr	r3, [pc, #72]	@ (20006f0c <write_I2C+0xf0>)
20006ec2:	4a15      	ldr	r2, [pc, #84]	@ (20006f18 <write_I2C+0xfc>)
20006ec4:	601a      	str	r2, [r3, #0]

    // Wait for RXNE
    uint32_t RXNE_BUSY = 0;
20006ec6:	2300      	movs	r3, #0
20006ec8:	613b      	str	r3, [r7, #16]
    while (((RXNE_BUSY = *(volatile uint32_t *)(0x40005418)) & 0x4) == 0) {}
20006eca:	bf00      	nop
20006ecc:	4b0d      	ldr	r3, [pc, #52]	@ (20006f04 <write_I2C+0xe8>)
20006ece:	681b      	ldr	r3, [r3, #0]
20006ed0:	613b      	str	r3, [r7, #16]
20006ed2:	693b      	ldr	r3, [r7, #16]
20006ed4:	f003 0304 	and.w	r3, r3, #4
20006ed8:	2b00      	cmp	r3, #0
20006eda:	d0f7      	beq.n	20006ecc <write_I2C+0xb0>

    uint32_t received_data = *(volatile uint32_t *)(0x40005424);
20006edc:	4b0f      	ldr	r3, [pc, #60]	@ (20006f1c <write_I2C+0x100>)
20006ede:	681b      	ldr	r3, [r3, #0]
20006ee0:	60fb      	str	r3, [r7, #12]

    // Corrections for printing function
	*(volatile uint32_t *)(0x40021088) = 0x2;
20006ee2:	4b0f      	ldr	r3, [pc, #60]	@ (20006f20 <write_I2C+0x104>)
20006ee4:	2202      	movs	r2, #2
20006ee6:	601a      	str	r2, [r3, #0]
	printf("Writing 0x%02X to register 0x%02X\n", value_to_send, reg_address);
20006ee8:	687a      	ldr	r2, [r7, #4]
20006eea:	6839      	ldr	r1, [r7, #0]
20006eec:	480d      	ldr	r0, [pc, #52]	@ (20006f24 <write_I2C+0x108>)
20006eee:	f7f9 ff39 	bl	20000d64 <printf>
    printf("Received data: 0x%08X\n", received_data);
20006ef2:	68f9      	ldr	r1, [r7, #12]
20006ef4:	480c      	ldr	r0, [pc, #48]	@ (20006f28 <write_I2C+0x10c>)
20006ef6:	f7f9 ff35 	bl	20000d64 <printf>



    return 0;
20006efa:	2300      	movs	r3, #0
}
20006efc:	4618      	mov	r0, r3
20006efe:	3718      	adds	r7, #24
20006f00:	46bd      	mov	sp, r7
20006f02:	bd80      	pop	{r7, pc}
20006f04:	40005418 	.word	0x40005418
20006f08:	40005428 	.word	0x40005428
20006f0c:	40005404 	.word	0x40005404
20006f10:	02022082 	.word	0x02022082
20006f14:	02012082 	.word	0x02012082
20006f18:	02012482 	.word	0x02012482
20006f1c:	40005424 	.word	0x40005424
20006f20:	40021088 	.word	0x40021088
20006f24:	20008da4 	.word	0x20008da4
20006f28:	20008d8c 	.word	0x20008d8c

20006f2c <display_I2C>:



    return received_data;
}
static int display_I2C(ui_cmdline_t *cmd, int argc, char *argv[]) {
20006f2c:	b580      	push	{r7, lr}
20006f2e:	b08a      	sub	sp, #40	@ 0x28
20006f30:	af00      	add	r7, sp, #0
20006f32:	60f8      	str	r0, [r7, #12]
20006f34:	60b9      	str	r1, [r7, #8]
20006f36:	607a      	str	r2, [r7, #4]
    char *address;
    int reg_address;

    address = cmd_getarg(cmd, 0);
20006f38:	2100      	movs	r1, #0
20006f3a:	68f8      	ldr	r0, [r7, #12]
20006f3c:	f7fd f88f 	bl	2000405e <cmd_getarg>
20006f40:	6278      	str	r0, [r7, #36]	@ 0x24
    reg_address = atoi(address);
20006f42:	6a78      	ldr	r0, [r7, #36]	@ 0x24
20006f44:	f7fa fc15 	bl	20001772 <lib_atoi>
20006f48:	6238      	str	r0, [r7, #32]
    //I2C_Init_INIT();
    //I2C_Init();


    *(volatile uint32_t *)(0x40021060) = 0x4001; // __HAL_RCC_SYSCFG_CLK_ENABLE();
20006f4a:	4b59      	ldr	r3, [pc, #356]	@ (200070b0 <display_I2C+0x184>)
20006f4c:	f244 0201 	movw	r2, #16385	@ 0x4001
20006f50:	601a      	str	r2, [r3, #0]

    *(volatile uint32_t *)(0x40021058) = 0x10000000;//__HAL_RCC_PWR_CLK_ENABLE();
20006f52:	4b58      	ldr	r3, [pc, #352]	@ (200070b4 <display_I2C+0x188>)
20006f54:	f04f 5280 	mov.w	r2, #268435456	@ 0x10000000
20006f58:	601a      	str	r2, [r3, #0]


	*(volatile uint32_t *)(0x40021088) = 0; //RCC i2c clock selection
20006f5a:	4b57      	ldr	r3, [pc, #348]	@ (200070b8 <display_I2C+0x18c>)
20006f5c:	2200      	movs	r2, #0
20006f5e:	601a      	str	r2, [r3, #0]

    *(volatile uint32_t *)(0x40007004) = 0x200;   // PWR_CR2 enable
20006f60:	4b56      	ldr	r3, [pc, #344]	@ (200070bc <display_I2C+0x190>)
20006f62:	f44f 7200 	mov.w	r2, #512	@ 0x200
20006f66:	601a      	str	r2, [r3, #0]

    *(volatile uint32_t *)(0x4002104C) = 0x20ff;    // GPIOG_CLK_ENABLE
20006f68:	4b55      	ldr	r3, [pc, #340]	@ (200070c0 <display_I2C+0x194>)
20006f6a:	f242 02ff 	movw	r2, #8447	@ 0x20ff
20006f6e:	601a      	str	r2, [r3, #0]

    *(volatile uint32_t *)(0x40021058) = 0x32200000;
20006f70:	4b50      	ldr	r3, [pc, #320]	@ (200070b4 <display_I2C+0x188>)
20006f72:	4a54      	ldr	r2, [pc, #336]	@ (200070c4 <display_I2C+0x198>)
20006f74:	601a      	str	r2, [r3, #0]


    *(volatile uint32_t *)(0x48001808) = 0xc3c0fff; //GPIOx_OSPEEDR
20006f76:	4b54      	ldr	r3, [pc, #336]	@ (200070c8 <display_I2C+0x19c>)
20006f78:	4a54      	ldr	r2, [pc, #336]	@ (200070cc <display_I2C+0x1a0>)
20006f7a:	601a      	str	r2, [r3, #0]
    *(volatile uint32_t *)(0x48001804) = 0x2000; //GPIO port output type register (GPIOx_OTYPER)
20006f7c:	4b54      	ldr	r3, [pc, #336]	@ (200070d0 <display_I2C+0x1a4>)
20006f7e:	f44f 5200 	mov.w	r2, #8192	@ 0x2000
20006f82:	601a      	str	r2, [r3, #0]
    *(volatile uint32_t *)(0x4800180C) = 0x4000000; //GPIOG_PUPDR
20006f84:	4b53      	ldr	r3, [pc, #332]	@ (200070d4 <display_I2C+0x1a8>)
20006f86:	f04f 6280 	mov.w	r2, #67108864	@ 0x4000000
20006f8a:	601a      	str	r2, [r3, #0]

    *(volatile uint32_t *)(0x48001824) = 0x400cc0;// Configure Alternate function mapped with the current IO
20006f8c:	4b52      	ldr	r3, [pc, #328]	@ (200070d8 <display_I2C+0x1ac>)
20006f8e:	4a53      	ldr	r2, [pc, #332]	@ (200070dc <display_I2C+0x1b0>)
20006f90:	601a      	str	r2, [r3, #0]
    *(volatile uint32_t *)(0x48001800) = 0x3bebcaaa; // Configure IO Direction mode (Input, Output, Alternate or Analog)
20006f92:	4b53      	ldr	r3, [pc, #332]	@ (200070e0 <display_I2C+0x1b4>)
20006f94:	4a53      	ldr	r2, [pc, #332]	@ (200070e4 <display_I2C+0x1b8>)
20006f96:	601a      	str	r2, [r3, #0]
    *(volatile uint32_t *)(0x48001808) = 0x3c3c0fff;  // Configure the IO Speed */
20006f98:	4b4b      	ldr	r3, [pc, #300]	@ (200070c8 <display_I2C+0x19c>)
20006f9a:	4a53      	ldr	r2, [pc, #332]	@ (200070e8 <display_I2C+0x1bc>)
20006f9c:	601a      	str	r2, [r3, #0]
    *(volatile uint32_t *)(0x48001804) = 0x6000; // GPIO_OTYPER
20006f9e:	4b4c      	ldr	r3, [pc, #304]	@ (200070d0 <display_I2C+0x1a4>)
20006fa0:	f44f 42c0 	mov.w	r2, #24576	@ 0x6000
20006fa4:	601a      	str	r2, [r3, #0]
    *(volatile uint32_t *)(0x4800082C) = 0x4000000; // activate pull up or pull down GPIO_PUPDR
20006fa6:	4b51      	ldr	r3, [pc, #324]	@ (200070ec <display_I2C+0x1c0>)
20006fa8:	f04f 6280 	mov.w	r2, #67108864	@ 0x4000000
20006fac:	601a      	str	r2, [r3, #0]
    *(volatile uint32_t *)(0x48001824) = 0x4400cc0;// Configure Alternate function mapped with the current IO
20006fae:	4b4a      	ldr	r3, [pc, #296]	@ (200070d8 <display_I2C+0x1ac>)
20006fb0:	4a4f      	ldr	r2, [pc, #316]	@ (200070f0 <display_I2C+0x1c4>)
20006fb2:	601a      	str	r2, [r3, #0]
    *(volatile uint32_t *)(0x48001800) = 0x2bebcaaa; // Configure IO Direction mode (Input, Output, Alternate or Analog)
20006fb4:	4b4a      	ldr	r3, [pc, #296]	@ (200070e0 <display_I2C+0x1b4>)
20006fb6:	4a4f      	ldr	r2, [pc, #316]	@ (200070f4 <display_I2C+0x1c8>)
20006fb8:	601a      	str	r2, [r3, #0]

    *(volatile uint32_t *)(0x48001808) = 0x3c3c0fff;  /* Configure the IO Speed */
20006fba:	4b43      	ldr	r3, [pc, #268]	@ (200070c8 <display_I2C+0x19c>)
20006fbc:	4a4a      	ldr	r2, [pc, #296]	@ (200070e8 <display_I2C+0x1bc>)
20006fbe:	601a      	str	r2, [r3, #0]
    *(volatile uint32_t *)(0x48001804) = 0x6000; // GPIO_OTYPER
20006fc0:	4b43      	ldr	r3, [pc, #268]	@ (200070d0 <display_I2C+0x1a4>)
20006fc2:	f44f 42c0 	mov.w	r2, #24576	@ 0x6000
20006fc6:	601a      	str	r2, [r3, #0]
    *(volatile uint32_t *)(0x4800082C) = 0x0; /* activate pull up or pull down GPIO_PUPDR */
20006fc8:	4b48      	ldr	r3, [pc, #288]	@ (200070ec <display_I2C+0x1c0>)
20006fca:	2200      	movs	r2, #0
20006fcc:	601a      	str	r2, [r3, #0]

    *(volatile uint8_t *)(0x48001841) = 0x24; //hi2c->State = HAL_I2C_STATE_BUSY;
20006fce:	4b4a      	ldr	r3, [pc, #296]	@ (200070f8 <display_I2C+0x1cc>)
20006fd0:	2224      	movs	r2, #36	@ 0x24
20006fd2:	701a      	strb	r2, [r3, #0]



	*(volatile uint32_t *)(0x40005400) = 0; //Disable the selected I2C peripheral
20006fd4:	4b49      	ldr	r3, [pc, #292]	@ (200070fc <display_I2C+0x1d0>)
20006fd6:	2200      	movs	r2, #0
20006fd8:	601a      	str	r2, [r3, #0]
	*(volatile uint32_t *)(0x40005410) = 0x20303E5D; //Configure I2Cx: Frequency range
20006fda:	4b49      	ldr	r3, [pc, #292]	@ (20007100 <display_I2C+0x1d4>)
20006fdc:	4a49      	ldr	r2, [pc, #292]	@ (20007104 <display_I2C+0x1d8>)
20006fde:	601a      	str	r2, [r3, #0]
	*(volatile uint32_t *)(0x40005408) = 0; //I2Cx OAR1 Configuration
20006fe0:	4b49      	ldr	r3, [pc, #292]	@ (20007108 <display_I2C+0x1dc>)
20006fe2:	2200      	movs	r2, #0
20006fe4:	601a      	str	r2, [r3, #0]
	*(volatile uint32_t *)(0x40005408) = 0x8000; //ack own address1 mode
20006fe6:	4b48      	ldr	r3, [pc, #288]	@ (20007108 <display_I2C+0x1dc>)
20006fe8:	f44f 4200 	mov.w	r2, #32768	@ 0x8000
20006fec:	601a      	str	r2, [r3, #0]

	*(volatile uint32_t *)(0x40005404) = 0; //Clear the I2C ADD10 bit
20006fee:	4b47      	ldr	r3, [pc, #284]	@ (2000710c <display_I2C+0x1e0>)
20006ff0:	2200      	movs	r2, #0
20006ff2:	601a      	str	r2, [r3, #0]
	*(volatile uint32_t *)(0x4000540C) = 0; //I2Cx OAR2 Configuration
20006ff4:	4b46      	ldr	r3, [pc, #280]	@ (20007110 <display_I2C+0x1e4>)
20006ff6:	2200      	movs	r2, #0
20006ff8:	601a      	str	r2, [r3, #0]
	*(volatile uint32_t *)(0x40005400) = 0; //Configure I2Cx: Generalcall and NoStretch mode
20006ffa:	4b40      	ldr	r3, [pc, #256]	@ (200070fc <display_I2C+0x1d0>)
20006ffc:	2200      	movs	r2, #0
20006ffe:	601a      	str	r2, [r3, #0]
	*(volatile uint32_t *)(0x40005400) = 1; //Enable the selected I2C peripheral
20007000:	4b3e      	ldr	r3, [pc, #248]	@ (200070fc <display_I2C+0x1d0>)
20007002:	2201      	movs	r2, #1
20007004:	601a      	str	r2, [r3, #0]



// transmit
	*(volatile uint32_t *)(0x40005400) = 0; //I2C_CR1, clear
20007006:	4b3d      	ldr	r3, [pc, #244]	@ (200070fc <display_I2C+0x1d0>)
20007008:	2200      	movs	r2, #0
2000700a:	601a      	str	r2, [r3, #0]
	*(volatile uint32_t *)(0x40005410) = 0x20303e5d; //595, timing
2000700c:	4b3c      	ldr	r3, [pc, #240]	@ (20007100 <display_I2C+0x1d4>)
2000700e:	4a3d      	ldr	r2, [pc, #244]	@ (20007104 <display_I2C+0x1d8>)
20007010:	601a      	str	r2, [r3, #0]
	*(volatile uint32_t *)(0x40005408) = 0; //595, OAR1
20007012:	4b3d      	ldr	r3, [pc, #244]	@ (20007108 <display_I2C+0x1dc>)
20007014:	2200      	movs	r2, #0
20007016:	601a      	str	r2, [r3, #0]
	*(volatile uint32_t *)(0x40005408) = 0x8000;
20007018:	4b3b      	ldr	r3, [pc, #236]	@ (20007108 <display_I2C+0x1dc>)
2000701a:	f44f 4200 	mov.w	r2, #32768	@ 0x8000
2000701e:	601a      	str	r2, [r3, #0]
	*(volatile uint32_t *)(0x40005404) = 0; //616, CR2
20007020:	4b3a      	ldr	r3, [pc, #232]	@ (2000710c <display_I2C+0x1e0>)
20007022:	2200      	movs	r2, #0
20007024:	601a      	str	r2, [r3, #0]
	*(volatile uint32_t *)(0x40004404) = 0x2008000; //618, auto end, bit 15, NACK
20007026:	4b3b      	ldr	r3, [pc, #236]	@ (20007114 <display_I2C+0x1e8>)
20007028:	4a3b      	ldr	r2, [pc, #236]	@ (20007118 <display_I2C+0x1ec>)
2000702a:	601a      	str	r2, [r3, #0]
	*(volatile uint32_t *)(0x4000540C) = 0;//623,  OAR2
2000702c:	4b38      	ldr	r3, [pc, #224]	@ (20007110 <display_I2C+0x1e4>)
2000702e:	2200      	movs	r2, #0
20007030:	601a      	str	r2, [r3, #0]

	*(volatile uint32_t *)(0x40005400) = 1;//634, peripheral enable bit 0
20007032:	4b32      	ldr	r3, [pc, #200]	@ (200070fc <display_I2C+0x1d0>)
20007034:	2201      	movs	r2, #1
20007036:	601a      	str	r2, [r3, #0]
	*(volatile uint32_t *)(0x40005428) = reg_address;//1162, TX reg,
20007038:	4a38      	ldr	r2, [pc, #224]	@ (2000711c <display_I2C+0x1f0>)
2000703a:	6a3b      	ldr	r3, [r7, #32]
2000703c:	6013      	str	r3, [r2, #0]
	*(volatile uint32_t *)(0x40005404) = 0x2012082; //7217,      82 device address
2000703e:	4b33      	ldr	r3, [pc, #204]	@ (2000710c <display_I2C+0x1e0>)
20007040:	4a37      	ldr	r2, [pc, #220]	@ (20007120 <display_I2C+0x1f4>)
20007042:	601a      	str	r2, [r3, #0]

	//receive

	uint32_t temp = 0; //I2C_ISR STOPF: STOP detection flag
20007044:	2300      	movs	r3, #0
20007046:	61fb      	str	r3, [r7, #28]
	while(((temp = *(volatile uint32_t *)(0x40005418)) & 0x20) == 0){
20007048:	bf00      	nop
2000704a:	4b36      	ldr	r3, [pc, #216]	@ (20007124 <display_I2C+0x1f8>)
2000704c:	681b      	ldr	r3, [r3, #0]
2000704e:	61fb      	str	r3, [r7, #28]
20007050:	69fb      	ldr	r3, [r7, #28]
20007052:	f003 0320 	and.w	r3, r3, #32
20007056:	2b00      	cmp	r3, #0
20007058:	d0f7      	beq.n	2000704a <display_I2C+0x11e>
	}

	*(volatile uint32_t *)(0x40005404) = 0x2012482; //7217 update CR2 register */
2000705a:	4b2c      	ldr	r3, [pc, #176]	@ (2000710c <display_I2C+0x1e0>)
2000705c:	4a32      	ldr	r2, [pc, #200]	@ (20007128 <display_I2C+0x1fc>)
2000705e:	601a      	str	r2, [r3, #0]

	uint32_t busy = 0; //I2C_ISR BUSY: BUSY detection flag
20007060:	2300      	movs	r3, #0
20007062:	61bb      	str	r3, [r7, #24]
	while(((busy = *(volatile uint32_t *)(0x40005400)) & 0x8000) == 1){
20007064:	bf00      	nop
20007066:	4b25      	ldr	r3, [pc, #148]	@ (200070fc <display_I2C+0x1d0>)
20007068:	681b      	ldr	r3, [r3, #0]
2000706a:	61bb      	str	r3, [r7, #24]
2000706c:	69bb      	ldr	r3, [r7, #24]
2000706e:	f403 4300 	and.w	r3, r3, #32768	@ 0x8000
20007072:	2b01      	cmp	r3, #1
20007074:	d0f7      	beq.n	20007066 <display_I2C+0x13a>
	}

	uint32_t RXNE_BUSY = 0; //RXNE: Receive data register
20007076:	2300      	movs	r3, #0
20007078:	617b      	str	r3, [r7, #20]
	while(((RXNE_BUSY = *(volatile uint32_t *)(0x40005418)) & 0x4) == 0){
2000707a:	bf00      	nop
2000707c:	4b29      	ldr	r3, [pc, #164]	@ (20007124 <display_I2C+0x1f8>)
2000707e:	681b      	ldr	r3, [r3, #0]
20007080:	617b      	str	r3, [r7, #20]
20007082:	697b      	ldr	r3, [r7, #20]
20007084:	f003 0304 	and.w	r3, r3, #4
20007088:	2b00      	cmp	r3, #0
2000708a:	d0f7      	beq.n	2000707c <display_I2C+0x150>


	/*
	 * corrections for printing function
	 */
	*(volatile uint32_t *)(0x40021088) = 0x2;
2000708c:	4b0a      	ldr	r3, [pc, #40]	@ (200070b8 <display_I2C+0x18c>)
2000708e:	2202      	movs	r2, #2
20007090:	601a      	str	r2, [r3, #0]


    uint32_t received_data = *(volatile uint32_t *)(0x40005424);
20007092:	4b26      	ldr	r3, [pc, #152]	@ (2000712c <display_I2C+0x200>)
20007094:	681b      	ldr	r3, [r3, #0]
20007096:	613b      	str	r3, [r7, #16]
    printf("data");
20007098:	4825      	ldr	r0, [pc, #148]	@ (20007130 <display_I2C+0x204>)
2000709a:	f7f9 fe63 	bl	20000d64 <printf>
    printf("Received data: 0x%08X\n", received_data);
2000709e:	6939      	ldr	r1, [r7, #16]
200070a0:	4824      	ldr	r0, [pc, #144]	@ (20007134 <display_I2C+0x208>)
200070a2:	f7f9 fe5f 	bl	20000d64 <printf>


    return 0;
200070a6:	2300      	movs	r3, #0
}
200070a8:	4618      	mov	r0, r3
200070aa:	3728      	adds	r7, #40	@ 0x28
200070ac:	46bd      	mov	sp, r7
200070ae:	bd80      	pop	{r7, pc}
200070b0:	40021060 	.word	0x40021060
200070b4:	40021058 	.word	0x40021058
200070b8:	40021088 	.word	0x40021088
200070bc:	40007004 	.word	0x40007004
200070c0:	4002104c 	.word	0x4002104c
200070c4:	32200000 	.word	0x32200000
200070c8:	48001808 	.word	0x48001808
200070cc:	0c3c0fff 	.word	0x0c3c0fff
200070d0:	48001804 	.word	0x48001804
200070d4:	4800180c 	.word	0x4800180c
200070d8:	48001824 	.word	0x48001824
200070dc:	00400cc0 	.word	0x00400cc0
200070e0:	48001800 	.word	0x48001800
200070e4:	3bebcaaa 	.word	0x3bebcaaa
200070e8:	3c3c0fff 	.word	0x3c3c0fff
200070ec:	4800082c 	.word	0x4800082c
200070f0:	04400cc0 	.word	0x04400cc0
200070f4:	2bebcaaa 	.word	0x2bebcaaa
200070f8:	48001841 	.word	0x48001841
200070fc:	40005400 	.word	0x40005400
20007100:	40005410 	.word	0x40005410
20007104:	20303e5d 	.word	0x20303e5d
20007108:	40005408 	.word	0x40005408
2000710c:	40005404 	.word	0x40005404
20007110:	4000540c 	.word	0x4000540c
20007114:	40004404 	.word	0x40004404
20007118:	02008000 	.word	0x02008000
2000711c:	40005428 	.word	0x40005428
20007120:	02012082 	.word	0x02012082
20007124:	40005418 	.word	0x40005418
20007128:	02012482 	.word	0x02012482
2000712c:	40005424 	.word	0x40005424
20007130:	20008d84 	.word	0x20008d84
20007134:	20008d8c 	.word	0x20008d8c

20007138 <ui_cmd_LEDO>:


static int ui_cmd_LEDO(ui_cmdline_t *cmd, int argc, char *argv[]) {
20007138:	b580      	push	{r7, lr}
2000713a:	b086      	sub	sp, #24
2000713c:	af00      	add	r7, sp, #0
2000713e:	60f8      	str	r0, [r7, #12]
20007140:	60b9      	str	r1, [r7, #8]
20007142:	607a      	str	r2, [r7, #4]
    char *state_str;
    int state;

    state_str = cmd_getarg(cmd, 0);
20007144:	2100      	movs	r1, #0
20007146:	68f8      	ldr	r0, [r7, #12]
20007148:	f7fc ff89 	bl	2000405e <cmd_getarg>
2000714c:	6178      	str	r0, [r7, #20]
    state = atoi(state_str);
2000714e:	6978      	ldr	r0, [r7, #20]
20007150:	f7fa fb0f 	bl	20001772 <lib_atoi>
20007154:	6138      	str	r0, [r7, #16]
	I2C_Init_INIT();
20007156:	f7ff fd9f 	bl	20006c98 <I2C_Init_INIT>
	//I2C_Init();
    if (state == 1) { // turn on
2000715a:	693b      	ldr	r3, [r7, #16]
2000715c:	2b01      	cmp	r3, #1
2000715e:	d10f      	bne.n	20007180 <ui_cmd_LEDO+0x48>
        write_I2C(0x11, 0x1);
20007160:	2101      	movs	r1, #1
20007162:	2011      	movs	r0, #17
20007164:	f7ff fe5a 	bl	20006e1c <write_I2C>
        write_I2C(0x17, 0x1);
20007168:	2101      	movs	r1, #1
2000716a:	2017      	movs	r0, #23
2000716c:	f7ff fe56 	bl	20006e1c <write_I2C>
        write_I2C(0x13, 0x1);
20007170:	2101      	movs	r1, #1
20007172:	2013      	movs	r0, #19
20007174:	f7ff fe52 	bl	20006e1c <write_I2C>
        printf("LEDs are ON\n");
20007178:	4809      	ldr	r0, [pc, #36]	@ (200071a0 <ui_cmd_LEDO+0x68>)
2000717a:	f7f9 fdf3 	bl	20000d64 <printf>
2000717e:	e009      	b.n	20007194 <ui_cmd_LEDO+0x5c>
    } else if (state == 0) { // turn off
20007180:	693b      	ldr	r3, [r7, #16]
20007182:	2b00      	cmp	r3, #0
20007184:	d106      	bne.n	20007194 <ui_cmd_LEDO+0x5c>
        write_I2C(0x10, 0x1);
20007186:	2101      	movs	r1, #1
20007188:	2010      	movs	r0, #16
2000718a:	f7ff fe47 	bl	20006e1c <write_I2C>
        printf("LEDs are OFF\n");
2000718e:	4805      	ldr	r0, [pc, #20]	@ (200071a4 <ui_cmd_LEDO+0x6c>)
20007190:	f7f9 fde8 	bl	20000d64 <printf>
    }

    return 0;
20007194:	2300      	movs	r3, #0
}
20007196:	4618      	mov	r0, r3
20007198:	3718      	adds	r7, #24
2000719a:	46bd      	mov	sp, r7
2000719c:	bd80      	pop	{r7, pc}
2000719e:	bf00      	nop
200071a0:	20008dc8 	.word	0x20008dc8
200071a4:	20008dd8 	.word	0x20008dd8

200071a8 <ui_cmd_LEDB>:

static int ui_cmd_LEDB(ui_cmdline_t *cmd, int argc, char *argv[]) {
200071a8:	b580      	push	{r7, lr}
200071aa:	b086      	sub	sp, #24
200071ac:	af00      	add	r7, sp, #0
200071ae:	60f8      	str	r0, [r7, #12]
200071b0:	60b9      	str	r1, [r7, #8]
200071b2:	607a      	str	r2, [r7, #4]
    char *state_str;
    int state;

    state_str = cmd_getarg(cmd, 0);
200071b4:	2100      	movs	r1, #0
200071b6:	68f8      	ldr	r0, [r7, #12]
200071b8:	f7fc ff51 	bl	2000405e <cmd_getarg>
200071bc:	6178      	str	r0, [r7, #20]
    state = atoi(state_str);
200071be:	6978      	ldr	r0, [r7, #20]
200071c0:	f7fa fad7 	bl	20001772 <lib_atoi>
200071c4:	6138      	str	r0, [r7, #16]
	I2C_Init_INIT();
200071c6:	f7ff fd67 	bl	20006c98 <I2C_Init_INIT>

    if (state == 1) { // turn on
200071ca:	693b      	ldr	r3, [r7, #16]
200071cc:	2b01      	cmp	r3, #1
200071ce:	d10f      	bne.n	200071f0 <ui_cmd_LEDB+0x48>


    	write_I2C(0x11, 0x4);
200071d0:	2104      	movs	r1, #4
200071d2:	2011      	movs	r0, #17
200071d4:	f7ff fe22 	bl	20006e1c <write_I2C>
        write_I2C(0x17, 0x4);
200071d8:	2104      	movs	r1, #4
200071da:	2017      	movs	r0, #23
200071dc:	f7ff fe1e 	bl	20006e1c <write_I2C>
        write_I2C(0x13, 0x4);
200071e0:	2104      	movs	r1, #4
200071e2:	2013      	movs	r0, #19
200071e4:	f7ff fe1a 	bl	20006e1c <write_I2C>
        printf("Blue LED is ON\n");
200071e8:	480a      	ldr	r0, [pc, #40]	@ (20007214 <ui_cmd_LEDB+0x6c>)
200071ea:	f7f9 fdbb 	bl	20000d64 <printf>
200071ee:	e00b      	b.n	20007208 <ui_cmd_LEDB+0x60>
    } else if (state == 0) { // turn off
200071f0:	693b      	ldr	r3, [r7, #16]
200071f2:	2b00      	cmp	r3, #0
200071f4:	d108      	bne.n	20007208 <ui_cmd_LEDB+0x60>
        I2C_Init();
200071f6:	f7ff fde1 	bl	20006dbc <I2C_Init>

        // Disable Blue LED
        write_I2C(0x10, 0x4);
200071fa:	2104      	movs	r1, #4
200071fc:	2010      	movs	r0, #16
200071fe:	f7ff fe0d 	bl	20006e1c <write_I2C>
        printf("Blue LED is OFF\n");
20007202:	4805      	ldr	r0, [pc, #20]	@ (20007218 <ui_cmd_LEDB+0x70>)
20007204:	f7f9 fdae 	bl	20000d64 <printf>
    }

    return 0;
20007208:	2300      	movs	r3, #0
}
2000720a:	4618      	mov	r0, r3
2000720c:	3718      	adds	r7, #24
2000720e:	46bd      	mov	sp, r7
20007210:	bd80      	pop	{r7, pc}
20007212:	bf00      	nop
20007214:	20008de8 	.word	0x20008de8
20007218:	20008df8 	.word	0x20008df8

2000721c <ui_cmd_write_I2C_IO2>:


#define STMPE1600_I2C_ADDRESS
static int ui_cmd_write_I2C_IO2(ui_cmdline_t *cmd, int argc, char *argv[])
{
2000721c:	b580      	push	{r7, lr}
2000721e:	b08a      	sub	sp, #40	@ 0x28
20007220:	af00      	add	r7, sp, #0
20007222:	60f8      	str	r0, [r7, #12]
20007224:	60b9      	str	r1, [r7, #8]
20007226:	607a      	str	r2, [r7, #4]
    char *address;
    int reg_address;

    address = cmd_getarg(cmd, 0);
20007228:	2100      	movs	r1, #0
2000722a:	68f8      	ldr	r0, [r7, #12]
2000722c:	f7fc ff17 	bl	2000405e <cmd_getarg>
20007230:	6278      	str	r0, [r7, #36]	@ 0x24
    reg_address = atoi(address);
20007232:	6a78      	ldr	r0, [r7, #36]	@ 0x24
20007234:	f7fa fa9d 	bl	20001772 <lib_atoi>
20007238:	6238      	str	r0, [r7, #32]
    I2C_Init_INIT();
2000723a:	f7ff fd2d 	bl	20006c98 <I2C_Init_INIT>
    I2C_Init();
2000723e:	f7ff fdbd 	bl	20006dbc <I2C_Init>
    uint32_t temp = 0;
20007242:	2300      	movs	r3, #0
20007244:	61fb      	str	r3, [r7, #28]

    *(volatile uint32_t *)(0x40005428) = reg_address; // Register address
20007246:	4a17      	ldr	r2, [pc, #92]	@ (200072a4 <ui_cmd_write_I2C_IO2+0x88>)
20007248:	6a3b      	ldr	r3, [r7, #32]
2000724a:	6013      	str	r3, [r2, #0]
    // *(volatile uint32_t *)(0x40005428) = value_to_send; // Data to send

    *(volatile uint32_t *)(0x40005404) = 0x2012084; // 7217, 82 device address
2000724c:	4b16      	ldr	r3, [pc, #88]	@ (200072a8 <ui_cmd_write_I2C_IO2+0x8c>)
2000724e:	4a17      	ldr	r2, [pc, #92]	@ (200072ac <ui_cmd_write_I2C_IO2+0x90>)
20007250:	601a      	str	r2, [r3, #0]

    //while (((temp = *(volatile uint32_t *)(0x40005418)) & 0x1) == 0) {}

    // Wait for STOPF
    temp = 0;
20007252:	2300      	movs	r3, #0
20007254:	61fb      	str	r3, [r7, #28]
    while (((temp = *(volatile uint32_t *)(0x40005418)) & 0x20) == 0) {}
20007256:	bf00      	nop
20007258:	4b15      	ldr	r3, [pc, #84]	@ (200072b0 <ui_cmd_write_I2C_IO2+0x94>)
2000725a:	681b      	ldr	r3, [r3, #0]
2000725c:	61fb      	str	r3, [r7, #28]
2000725e:	69fb      	ldr	r3, [r7, #28]
20007260:	f003 0320 	and.w	r3, r3, #32
20007264:	2b00      	cmp	r3, #0
20007266:	d0f7      	beq.n	20007258 <ui_cmd_write_I2C_IO2+0x3c>

    *(volatile uint32_t *)(0x40005404) = 0x2012484; // 7217 update CR2 register
20007268:	4b0f      	ldr	r3, [pc, #60]	@ (200072a8 <ui_cmd_write_I2C_IO2+0x8c>)
2000726a:	4a12      	ldr	r2, [pc, #72]	@ (200072b4 <ui_cmd_write_I2C_IO2+0x98>)
2000726c:	601a      	str	r2, [r3, #0]

    // Wait for RXNE
    uint32_t RXNE_BUSY = 0;
2000726e:	2300      	movs	r3, #0
20007270:	61bb      	str	r3, [r7, #24]
    while (((RXNE_BUSY = *(volatile uint32_t *)(0x40005418)) & 0x4) == 0) {}
20007272:	bf00      	nop
20007274:	4b0e      	ldr	r3, [pc, #56]	@ (200072b0 <ui_cmd_write_I2C_IO2+0x94>)
20007276:	681b      	ldr	r3, [r3, #0]
20007278:	61bb      	str	r3, [r7, #24]
2000727a:	69bb      	ldr	r3, [r7, #24]
2000727c:	f003 0304 	and.w	r3, r3, #4
20007280:	2b00      	cmp	r3, #0
20007282:	d0f7      	beq.n	20007274 <ui_cmd_write_I2C_IO2+0x58>

    uint32_t received_data = *(volatile uint32_t *)(0x40005424);
20007284:	4b0c      	ldr	r3, [pc, #48]	@ (200072b8 <ui_cmd_write_I2C_IO2+0x9c>)
20007286:	681b      	ldr	r3, [r3, #0]
20007288:	617b      	str	r3, [r7, #20]

    // Corrections for printing function
	*(volatile uint32_t *)(0x40021088) = 0x2;
2000728a:	4b0c      	ldr	r3, [pc, #48]	@ (200072bc <ui_cmd_write_I2C_IO2+0xa0>)
2000728c:	2202      	movs	r2, #2
2000728e:	601a      	str	r2, [r3, #0]
    printf("Received data: 0x%08X\n", received_data);
20007290:	6979      	ldr	r1, [r7, #20]
20007292:	480b      	ldr	r0, [pc, #44]	@ (200072c0 <ui_cmd_write_I2C_IO2+0xa4>)
20007294:	f7f9 fd66 	bl	20000d64 <printf>



    return 0;
20007298:	2300      	movs	r3, #0
}
2000729a:	4618      	mov	r0, r3
2000729c:	3728      	adds	r7, #40	@ 0x28
2000729e:	46bd      	mov	sp, r7
200072a0:	bd80      	pop	{r7, pc}
200072a2:	bf00      	nop
200072a4:	40005428 	.word	0x40005428
200072a8:	40005404 	.word	0x40005404
200072ac:	02012084 	.word	0x02012084
200072b0:	40005418 	.word	0x40005418
200072b4:	02012484 	.word	0x02012484
200072b8:	40005424 	.word	0x40005424
200072bc:	40021088 	.word	0x40021088
200072c0:	20008d8c 	.word	0x20008d8c

200072c4 <READ_I2C_IO2>:

    return 0;
}

static int READ_I2C_IO2(int reg_address)
{
200072c4:	b580      	push	{r7, lr}
200072c6:	b086      	sub	sp, #24
200072c8:	af00      	add	r7, sp, #0
200072ca:	6078      	str	r0, [r7, #4]
    I2C_Init();
200072cc:	f7ff fd76 	bl	20006dbc <I2C_Init>
    uint32_t temp = 0;
200072d0:	2300      	movs	r3, #0
200072d2:	617b      	str	r3, [r7, #20]

    *(volatile uint32_t *)(0x40005428) = reg_address; // Register address
200072d4:	4a13      	ldr	r2, [pc, #76]	@ (20007324 <READ_I2C_IO2+0x60>)
200072d6:	687b      	ldr	r3, [r7, #4]
200072d8:	6013      	str	r3, [r2, #0]
    // *(volatile uint32_t *)(0x40005428) = value_to_send; // Data to send

    *(volatile uint32_t *)(0x40005404) = 0x2012084; // 7217, 82 device address
200072da:	4b13      	ldr	r3, [pc, #76]	@ (20007328 <READ_I2C_IO2+0x64>)
200072dc:	4a13      	ldr	r2, [pc, #76]	@ (2000732c <READ_I2C_IO2+0x68>)
200072de:	601a      	str	r2, [r3, #0]

    //while (((temp = *(volatile uint32_t *)(0x40005418)) & 0x1) == 0) {}

    // Wait for STOPF
    temp = 0;
200072e0:	2300      	movs	r3, #0
200072e2:	617b      	str	r3, [r7, #20]
    while (((temp = *(volatile uint32_t *)(0x40005418)) & 0x20) == 0) {}
200072e4:	bf00      	nop
200072e6:	4b12      	ldr	r3, [pc, #72]	@ (20007330 <READ_I2C_IO2+0x6c>)
200072e8:	681b      	ldr	r3, [r3, #0]
200072ea:	617b      	str	r3, [r7, #20]
200072ec:	697b      	ldr	r3, [r7, #20]
200072ee:	f003 0320 	and.w	r3, r3, #32
200072f2:	2b00      	cmp	r3, #0
200072f4:	d0f7      	beq.n	200072e6 <READ_I2C_IO2+0x22>

    *(volatile uint32_t *)(0x40005404) = 0x2012484; // 7217 update CR2 register
200072f6:	4b0c      	ldr	r3, [pc, #48]	@ (20007328 <READ_I2C_IO2+0x64>)
200072f8:	4a0e      	ldr	r2, [pc, #56]	@ (20007334 <READ_I2C_IO2+0x70>)
200072fa:	601a      	str	r2, [r3, #0]

    // Wait for RXNE
    uint32_t RXNE_BUSY = 0;
200072fc:	2300      	movs	r3, #0
200072fe:	613b      	str	r3, [r7, #16]
    while (((RXNE_BUSY = *(volatile uint32_t *)(0x40005418)) & 0x4) == 0) {}
20007300:	bf00      	nop
20007302:	4b0b      	ldr	r3, [pc, #44]	@ (20007330 <READ_I2C_IO2+0x6c>)
20007304:	681b      	ldr	r3, [r3, #0]
20007306:	613b      	str	r3, [r7, #16]
20007308:	693b      	ldr	r3, [r7, #16]
2000730a:	f003 0304 	and.w	r3, r3, #4
2000730e:	2b00      	cmp	r3, #0
20007310:	d0f7      	beq.n	20007302 <READ_I2C_IO2+0x3e>

    uint32_t received_data = *(volatile uint32_t *)(0x40005424);
20007312:	4b09      	ldr	r3, [pc, #36]	@ (20007338 <READ_I2C_IO2+0x74>)
20007314:	681b      	ldr	r3, [r3, #0]
20007316:	60fb      	str	r3, [r7, #12]

    // Corrections for printing function
//	*(volatile uint32_t *)(0x40021088) = 0x2;
    //printf("Received data: 0x%08X\n", received_data);

    return received_data;
20007318:	68fb      	ldr	r3, [r7, #12]
}
2000731a:	4618      	mov	r0, r3
2000731c:	3718      	adds	r7, #24
2000731e:	46bd      	mov	sp, r7
20007320:	bd80      	pop	{r7, pc}
20007322:	bf00      	nop
20007324:	40005428 	.word	0x40005428
20007328:	40005404 	.word	0x40005404
2000732c:	02012084 	.word	0x02012084
20007330:	40005418 	.word	0x40005418
20007334:	02012484 	.word	0x02012484
20007338:	40005424 	.word	0x40005424

2000733c <ui_cmd_joystick>:


static int ui_cmd_joystick(ui_cmdline_t *cmd, int argc, char *argv[])
{
2000733c:	b580      	push	{r7, lr}
2000733e:	b084      	sub	sp, #16
20007340:	af00      	add	r7, sp, #0
20007342:	60f8      	str	r0, [r7, #12]
20007344:	60b9      	str	r1, [r7, #8]
20007346:	607a      	str	r2, [r7, #4]
*/



    // *(volatile uint32_t *)(0x40005404) = 0x12084;
	I2C_Init_INIT();
20007348:	f7ff fca6 	bl	20006c98 <I2C_Init_INIT>
	//*(volatile uint32_t *)(0x40021088) = 0x2;


    while(1){

    	if((READ_I2C_IO2(0x10) & 1) == 0){
2000734c:	2010      	movs	r0, #16
2000734e:	f7ff ffb9 	bl	200072c4 <READ_I2C_IO2>
20007352:	4603      	mov	r3, r0
20007354:	f003 0301 	and.w	r3, r3, #1
20007358:	2b00      	cmp	r3, #0
2000735a:	d103      	bne.n	20007364 <ui_cmd_joystick+0x28>
    		printf("SEL\r");
2000735c:	481c      	ldr	r0, [pc, #112]	@ (200073d0 <ui_cmd_joystick+0x94>)
2000735e:	f7f9 fd01 	bl	20000d64 <printf>
    		break;
20007362:	e02c      	b.n	200073be <ui_cmd_joystick+0x82>
    	}
    	if((READ_I2C_IO2(0x10) & 2) == 0){
20007364:	2010      	movs	r0, #16
20007366:	f7ff ffad 	bl	200072c4 <READ_I2C_IO2>
2000736a:	4603      	mov	r3, r0
2000736c:	f003 0302 	and.w	r3, r3, #2
20007370:	2b00      	cmp	r3, #0
20007372:	d102      	bne.n	2000737a <ui_cmd_joystick+0x3e>
    		printf("DOWN\r");
20007374:	4817      	ldr	r0, [pc, #92]	@ (200073d4 <ui_cmd_joystick+0x98>)
20007376:	f7f9 fcf5 	bl	20000d64 <printf>
    	}
    	if((READ_I2C_IO2(0x10) & 4) == 0){
2000737a:	2010      	movs	r0, #16
2000737c:	f7ff ffa2 	bl	200072c4 <READ_I2C_IO2>
20007380:	4603      	mov	r3, r0
20007382:	f003 0304 	and.w	r3, r3, #4
20007386:	2b00      	cmp	r3, #0
20007388:	d102      	bne.n	20007390 <ui_cmd_joystick+0x54>
    		printf("LEFT\r");
2000738a:	4813      	ldr	r0, [pc, #76]	@ (200073d8 <ui_cmd_joystick+0x9c>)
2000738c:	f7f9 fcea 	bl	20000d64 <printf>
    	}
    	if((READ_I2C_IO2(0x10) & 8) == 0){
20007390:	2010      	movs	r0, #16
20007392:	f7ff ff97 	bl	200072c4 <READ_I2C_IO2>
20007396:	4603      	mov	r3, r0
20007398:	f003 0308 	and.w	r3, r3, #8
2000739c:	2b00      	cmp	r3, #0
2000739e:	d102      	bne.n	200073a6 <ui_cmd_joystick+0x6a>
    		printf("RIGHT\r");
200073a0:	480e      	ldr	r0, [pc, #56]	@ (200073dc <ui_cmd_joystick+0xa0>)
200073a2:	f7f9 fcdf 	bl	20000d64 <printf>
    	}
    	if((READ_I2C_IO2(0x10) & 16) == 0){
200073a6:	2010      	movs	r0, #16
200073a8:	f7ff ff8c 	bl	200072c4 <READ_I2C_IO2>
200073ac:	4603      	mov	r3, r0
200073ae:	f003 0310 	and.w	r3, r3, #16
200073b2:	2b00      	cmp	r3, #0
200073b4:	d1ca      	bne.n	2000734c <ui_cmd_joystick+0x10>
    		printf("UP\r");
200073b6:	480a      	ldr	r0, [pc, #40]	@ (200073e0 <ui_cmd_joystick+0xa4>)
200073b8:	f7f9 fcd4 	bl	20000d64 <printf>
    	if((READ_I2C_IO2(0x10) & 1) == 0){
200073bc:	e7c6      	b.n	2000734c <ui_cmd_joystick+0x10>
    	}

    }
    printf("joystick end");
200073be:	4809      	ldr	r0, [pc, #36]	@ (200073e4 <ui_cmd_joystick+0xa8>)
200073c0:	f7f9 fcd0 	bl	20000d64 <printf>

    return 0;
200073c4:	2300      	movs	r3, #0
}
200073c6:	4618      	mov	r0, r3
200073c8:	3710      	adds	r7, #16
200073ca:	46bd      	mov	sp, r7
200073cc:	bd80      	pop	{r7, pc}
200073ce:	bf00      	nop
200073d0:	20008e0c 	.word	0x20008e0c
200073d4:	20008e14 	.word	0x20008e14
200073d8:	20008e1c 	.word	0x20008e1c
200073dc:	20008e24 	.word	0x20008e24
200073e0:	20008e2c 	.word	0x20008e2c
200073e4:	20008e30 	.word	0x20008e30

200073e8 <mytest_1>:

void mytest_1(){
200073e8:	b580      	push	{r7, lr}
200073ea:	b082      	sub	sp, #8
200073ec:	af00      	add	r7, sp, #0
	printf("hello");
200073ee:	4807      	ldr	r0, [pc, #28]	@ (2000740c <mytest_1+0x24>)
200073f0:	f7f9 fcb8 	bl	20000d64 <printf>
    // Clear the USART interrupt flag
    //volatile uint32_t *USART1_ICR = (volatile uint32_t *)(0x40013800 + 0x1C);

    // Clear the RXNE interrupt flag
    //volatile uint32_t *USART1_ISR = (volatile uint32_t *)(0x40013800 + 0x1C); // USART_ISR register
    volatile uint32_t USART1_ICR = *(volatile uint32_t *)(0x40013800 + 0x24); // USART_ICR register
200073f4:	4b06      	ldr	r3, [pc, #24]	@ (20007410 <mytest_1+0x28>)
200073f6:	681b      	ldr	r3, [r3, #0]
200073f8:	607b      	str	r3, [r7, #4]

    //printf("%c", USART1_ISR );
    printf("%c", USART1_ICR );
200073fa:	687b      	ldr	r3, [r7, #4]
200073fc:	4619      	mov	r1, r3
200073fe:	4805      	ldr	r0, [pc, #20]	@ (20007414 <mytest_1+0x2c>)
20007400:	f7f9 fcb0 	bl	20000d64 <printf>
	volatile uint32_t *LPUART_ISR = (uint32_t *)(0x40013800 + 0x1C);
	printf("%c", LPUART_ISR);
	*LPUART_ISR = 0xFFFFFFFF;

	*/
}
20007404:	bf00      	nop
20007406:	3708      	adds	r7, #8
20007408:	46bd      	mov	sp, r7
2000740a:	bd80      	pop	{r7, pc}
2000740c:	20008e40 	.word	0x20008e40
20007410:	40013824 	.word	0x40013824
20007414:	20008e48 	.word	0x20008e48

20007418 <SysTick_Init>:

static int SysTick_Init(ui_cmdline_t *cmd, int argc, char *argv[]){
20007418:	b580      	push	{r7, lr}
2000741a:	b088      	sub	sp, #32
2000741c:	af00      	add	r7, sp, #0
2000741e:	60f8      	str	r0, [r7, #12]
20007420:	60b9      	str	r1, [r7, #8]
20007422:	607a      	str	r2, [r7, #4]

	 *(volatile uint32_t *)0xE000ED08 = 0x20000000; // vtor
20007424:	4b0e      	ldr	r3, [pc, #56]	@ (20007460 <SysTick_Init+0x48>)
20007426:	f04f 5200 	mov.w	r2, #536870912	@ 0x20000000
2000742a:	601a      	str	r2, [r3, #0]

    *(volatile uint32_t *)0xE000E010 = 0x7; // 00000111
2000742c:	4b0d      	ldr	r3, [pc, #52]	@ (20007464 <SysTick_Init+0x4c>)
2000742e:	2207      	movs	r2, #7
20007430:	601a      	str	r2, [r3, #0]

    *(volatile uint32_t *)0xE000E014 = 1000000;
20007432:	4b0d      	ldr	r3, [pc, #52]	@ (20007468 <SysTick_Init+0x50>)
20007434:	4a0d      	ldr	r2, [pc, #52]	@ (2000746c <SysTick_Init+0x54>)
20007436:	601a      	str	r2, [r3, #0]

    *(volatile uint32_t *)0xE000E018 = 0;
20007438:	4b0d      	ldr	r3, [pc, #52]	@ (20007470 <SysTick_Init+0x58>)
2000743a:	2200      	movs	r2, #0
2000743c:	601a      	str	r2, [r3, #0]

    *(volatile uint32_t *)0xE000ED20 = 0;
2000743e:	4b0d      	ldr	r3, [pc, #52]	@ (20007474 <SysTick_Init+0x5c>)
20007440:	2200      	movs	r2, #0
20007442:	601a      	str	r2, [r3, #0]
    uint32_t value;




    uint32_t address = 0xE000E018;
20007444:	4b0a      	ldr	r3, [pc, #40]	@ (20007470 <SysTick_Init+0x58>)
20007446:	61fb      	str	r3, [r7, #28]


	while (1) {
	    ptr = (volatile uint32_t *)address;
20007448:	69fb      	ldr	r3, [r7, #28]
2000744a:	61bb      	str	r3, [r7, #24]
	    value = *ptr;
2000744c:	69bb      	ldr	r3, [r7, #24]
2000744e:	681b      	ldr	r3, [r3, #0]
20007450:	617b      	str	r3, [r7, #20]
		printf("0x%08X\n", value);
20007452:	6979      	ldr	r1, [r7, #20]
20007454:	4808      	ldr	r0, [pc, #32]	@ (20007478 <SysTick_Init+0x60>)
20007456:	f7f9 fc85 	bl	20000d64 <printf>
	    ptr = (volatile uint32_t *)address;
2000745a:	bf00      	nop
2000745c:	e7f4      	b.n	20007448 <SysTick_Init+0x30>
2000745e:	bf00      	nop
20007460:	e000ed08 	.word	0xe000ed08
20007464:	e000e010 	.word	0xe000e010
20007468:	e000e014 	.word	0xe000e014
2000746c:	000f4240 	.word	0x000f4240
20007470:	e000e018 	.word	0xe000e018
20007474:	e000ed20 	.word	0xe000ed20
20007478:	20008d30 	.word	0x20008d30

2000747c <Add_Assembly>:


int add_function(int a, int b, int c, int d, int e, int f);


static int Add_Assembly(ui_cmdline_t *cmd, int argc, char *argv[]){
2000747c:	b580      	push	{r7, lr}
2000747e:	b090      	sub	sp, #64	@ 0x40
20007480:	af04      	add	r7, sp, #16
20007482:	60f8      	str	r0, [r7, #12]
20007484:	60b9      	str	r1, [r7, #8]
20007486:	607a      	str	r2, [r7, #4]

	printf(add_num2(1, 2));
20007488:	2102      	movs	r1, #2
2000748a:	2001      	movs	r0, #1
2000748c:	f000 f83e 	bl	2000750c <add_num2>
20007490:	4603      	mov	r3, r0
20007492:	4618      	mov	r0, r3
20007494:	f7f9 fc66 	bl	20000d64 <printf>

	printf(add_num(1, 2, 3, 4, 5, 6));
20007498:	2306      	movs	r3, #6
2000749a:	9301      	str	r3, [sp, #4]
2000749c:	2305      	movs	r3, #5
2000749e:	9300      	str	r3, [sp, #0]
200074a0:	2304      	movs	r3, #4
200074a2:	2203      	movs	r2, #3
200074a4:	2102      	movs	r1, #2
200074a6:	2001      	movs	r0, #1
200074a8:	f000 f83e 	bl	20007528 <add_num>
200074ac:	4603      	mov	r3, r0
200074ae:	4618      	mov	r0, r3
200074b0:	f7f9 fc58 	bl	20000d64 <printf>

	int a = 1;
200074b4:	2301      	movs	r3, #1
200074b6:	62fb      	str	r3, [r7, #44]	@ 0x2c
    int b = 2;
200074b8:	2302      	movs	r3, #2
200074ba:	62bb      	str	r3, [r7, #40]	@ 0x28
    int c = 3;
200074bc:	2303      	movs	r3, #3
200074be:	627b      	str	r3, [r7, #36]	@ 0x24
    int d = 4;
200074c0:	2304      	movs	r3, #4
200074c2:	623b      	str	r3, [r7, #32]
    int e = 5;
200074c4:	2305      	movs	r3, #5
200074c6:	61fb      	str	r3, [r7, #28]
    int f = 6;
200074c8:	2306      	movs	r3, #6
200074ca:	61bb      	str	r3, [r7, #24]
    int result = add_function(a, b, c, d, e, f);
200074cc:	69bb      	ldr	r3, [r7, #24]
200074ce:	9301      	str	r3, [sp, #4]
200074d0:	69fb      	ldr	r3, [r7, #28]
200074d2:	9300      	str	r3, [sp, #0]
200074d4:	6a3b      	ldr	r3, [r7, #32]
200074d6:	6a7a      	ldr	r2, [r7, #36]	@ 0x24
200074d8:	6ab9      	ldr	r1, [r7, #40]	@ 0x28
200074da:	6af8      	ldr	r0, [r7, #44]	@ 0x2c
200074dc:	f7f8 fe26 	bl	2000012c <add_function>
200074e0:	6178      	str	r0, [r7, #20]

    printf("The result of mytest(%d, %d, %d, %d, %d, %d) is %d\n", a, b, c,d,e, f, result);
200074e2:	697b      	ldr	r3, [r7, #20]
200074e4:	9303      	str	r3, [sp, #12]
200074e6:	69bb      	ldr	r3, [r7, #24]
200074e8:	9302      	str	r3, [sp, #8]
200074ea:	69fb      	ldr	r3, [r7, #28]
200074ec:	9301      	str	r3, [sp, #4]
200074ee:	6a3b      	ldr	r3, [r7, #32]
200074f0:	9300      	str	r3, [sp, #0]
200074f2:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
200074f4:	6aba      	ldr	r2, [r7, #40]	@ 0x28
200074f6:	6af9      	ldr	r1, [r7, #44]	@ 0x2c
200074f8:	4803      	ldr	r0, [pc, #12]	@ (20007508 <Add_Assembly+0x8c>)
200074fa:	f7f9 fc33 	bl	20000d64 <printf>


	return 0;
200074fe:	2300      	movs	r3, #0

}
20007500:	4618      	mov	r0, r3
20007502:	3730      	adds	r7, #48	@ 0x30
20007504:	46bd      	mov	sp, r7
20007506:	bd80      	pop	{r7, pc}
20007508:	20008e4c 	.word	0x20008e4c

2000750c <add_num2>:

int add_num2(int a, int b){
2000750c:	b480      	push	{r7}
2000750e:	b083      	sub	sp, #12
20007510:	af00      	add	r7, sp, #0
20007512:	6078      	str	r0, [r7, #4]
20007514:	6039      	str	r1, [r7, #0]
	return(a + b);
20007516:	687a      	ldr	r2, [r7, #4]
20007518:	683b      	ldr	r3, [r7, #0]
2000751a:	4413      	add	r3, r2
}
2000751c:	4618      	mov	r0, r3
2000751e:	370c      	adds	r7, #12
20007520:	46bd      	mov	sp, r7
20007522:	f85d 7b04 	ldr.w	r7, [sp], #4
20007526:	4770      	bx	lr

20007528 <add_num>:

int add_num(int a, int b, int c, int d, int e, int f){
20007528:	b480      	push	{r7}
2000752a:	b087      	sub	sp, #28
2000752c:	af00      	add	r7, sp, #0
2000752e:	60f8      	str	r0, [r7, #12]
20007530:	60b9      	str	r1, [r7, #8]
20007532:	607a      	str	r2, [r7, #4]
20007534:	603b      	str	r3, [r7, #0]
	int ii = 0x1234;
20007536:	f241 2334 	movw	r3, #4660	@ 0x1234
2000753a:	617b      	str	r3, [r7, #20]
	return(a + b + c + d + e + f + ii);
2000753c:	68fa      	ldr	r2, [r7, #12]
2000753e:	68bb      	ldr	r3, [r7, #8]
20007540:	441a      	add	r2, r3
20007542:	687b      	ldr	r3, [r7, #4]
20007544:	441a      	add	r2, r3
20007546:	683b      	ldr	r3, [r7, #0]
20007548:	441a      	add	r2, r3
2000754a:	6a3b      	ldr	r3, [r7, #32]
2000754c:	441a      	add	r2, r3
2000754e:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
20007550:	441a      	add	r2, r3
20007552:	697b      	ldr	r3, [r7, #20]
20007554:	4413      	add	r3, r2
}
20007556:	4618      	mov	r0, r3
20007558:	371c      	adds	r7, #28
2000755a:	46bd      	mov	sp, r7
2000755c:	f85d 7b04 	ldr.w	r7, [sp], #4
20007560:	4770      	bx	lr
	...

20007564 <uart_handler>:





static int uart_handler(ui_cmdline_t *cmd, int argc, char *argv[]){
20007564:	b580      	push	{r7, lr}
20007566:	b084      	sub	sp, #16
20007568:	af00      	add	r7, sp, #0
2000756a:	60f8      	str	r0, [r7, #12]
2000756c:	60b9      	str	r1, [r7, #8]
2000756e:	607a      	str	r2, [r7, #4]

	*(volatile uint32_t *)0xE000ED08 = 0x20000000;
20007570:	4b08      	ldr	r3, [pc, #32]	@ (20007594 <uart_handler+0x30>)
20007572:	f04f 5200 	mov.w	r2, #536870912	@ 0x20000000
20007576:	601a      	str	r2, [r3, #0]

	*(volatile uint32_t *)0xE000E104 = 0x20;
20007578:	4b07      	ldr	r3, [pc, #28]	@ (20007598 <uart_handler+0x34>)
2000757a:	2220      	movs	r2, #32
2000757c:	601a      	str	r2, [r3, #0]
//	(*(volatile uint32_t *)0x40021058)|= (1 << 17); //RCC->APB1ENR1

	//(*(volatile uint32_t *)0x4000440C) = 0xD0;
	(*(volatile uint32_t *)0x40013800) |= 0x2D; //10 1101
2000757e:	4b07      	ldr	r3, [pc, #28]	@ (2000759c <uart_handler+0x38>)
20007580:	681b      	ldr	r3, [r3, #0]
20007582:	4a06      	ldr	r2, [pc, #24]	@ (2000759c <uart_handler+0x38>)
20007584:	f043 032d 	orr.w	r3, r3, #45	@ 0x2d
20007588:	6013      	str	r3, [r2, #0]
//	(*(volatile uint32_t *)0x40004400) |= 0x2D;


	//(*(volatile uint32_t *)0xE000E104) = 0x7;
	while(1){
		printf("hello\n");
2000758a:	4805      	ldr	r0, [pc, #20]	@ (200075a0 <uart_handler+0x3c>)
2000758c:	f7f9 fbea 	bl	20000d64 <printf>
20007590:	e7fb      	b.n	2000758a <uart_handler+0x26>
20007592:	bf00      	nop
20007594:	e000ed08 	.word	0xe000ed08
20007598:	e000e104 	.word	0xe000e104
2000759c:	40013800 	.word	0x40013800
200075a0:	20008e80 	.word	0x20008e80

200075a4 <LED_Init2>:

}



void LED_Init2(void) {
200075a4:	b480      	push	{r7}
200075a6:	b083      	sub	sp, #12
200075a8:	af00      	add	r7, sp, #0

	*(volatile uint32_t *)0x48000400 = 0xf0;
200075aa:	4b0c      	ldr	r3, [pc, #48]	@ (200075dc <LED_Init2+0x38>)
200075ac:	22f0      	movs	r2, #240	@ 0xf0
200075ae:	601a      	str	r2, [r3, #0]
	*(volatile uint32_t *)0x48000404 = 0x0;
200075b0:	4b0b      	ldr	r3, [pc, #44]	@ (200075e0 <LED_Init2+0x3c>)
200075b2:	2200      	movs	r2, #0
200075b4:	601a      	str	r2, [r3, #0]

    volatile uint32_t *RCC_AHB2ENR = (uint32_t *)(0x40021000 + 0x4C);
200075b6:	4b0b      	ldr	r3, [pc, #44]	@ (200075e4 <LED_Init2+0x40>)
200075b8:	607b      	str	r3, [r7, #4]
    *RCC_AHB2ENR = 0xf;//|= (1 << 2);
200075ba:	687b      	ldr	r3, [r7, #4]
200075bc:	220f      	movs	r2, #15
200075be:	601a      	str	r2, [r3, #0]

    volatile uint32_t *GPIOC_MODER = (uint32_t *)(GPIOC_BASE);
200075c0:	4b09      	ldr	r3, [pc, #36]	@ (200075e8 <LED_Init2+0x44>)
200075c2:	603b      	str	r3, [r7, #0]
    //uint32_t initial_value = *GPIOC_MODER;
    //printf("address: 0x%08X, Initial value: 0x%08X\n", (uint32_t)GPIOA_MODER, initial_value);


    //*GPIOC_MODER &= ~(0x2 << 1);
    *GPIOC_MODER |= (1 << 2);
200075c4:	683b      	ldr	r3, [r7, #0]
200075c6:	681b      	ldr	r3, [r3, #0]
200075c8:	f043 0204 	orr.w	r2, r3, #4
200075cc:	683b      	ldr	r3, [r7, #0]
200075ce:	601a      	str	r2, [r3, #0]


    //uint32_t modified_value = *GPIOC_MODER;
    //printf("address: 0x%08X, Modified value: 0x%08X\n", (uint32_t)GPIOA_MODER, modified_value);
}
200075d0:	bf00      	nop
200075d2:	370c      	adds	r7, #12
200075d4:	46bd      	mov	sp, r7
200075d6:	f85d 7b04 	ldr.w	r7, [sp], #4
200075da:	4770      	bx	lr
200075dc:	48000400 	.word	0x48000400
200075e0:	48000404 	.word	0x48000404
200075e4:	4002104c 	.word	0x4002104c
200075e8:	48000800 	.word	0x48000800

200075ec <ui_cmd_LED2>:

static int ui_cmd_LED2(ui_cmdline_t *cmd, int argc, char *argv[])
{
200075ec:	b580      	push	{r7, lr}
200075ee:	b088      	sub	sp, #32
200075f0:	af00      	add	r7, sp, #0
200075f2:	60f8      	str	r0, [r7, #12]
200075f4:	60b9      	str	r1, [r7, #8]
200075f6:	607a      	str	r2, [r7, #4]
    char *state_str;
    int state;

    state_str = cmd_getarg(cmd, 0);
200075f8:	2100      	movs	r1, #0
200075fa:	68f8      	ldr	r0, [r7, #12]
200075fc:	f7fc fd2f 	bl	2000405e <cmd_getarg>
20007600:	61f8      	str	r0, [r7, #28]
    state = atoi(state_str);
20007602:	69f8      	ldr	r0, [r7, #28]
20007604:	f7fa f8b5 	bl	20001772 <lib_atoi>
20007608:	61b8      	str	r0, [r7, #24]

    LED_Init2();
2000760a:	f7ff ffcb 	bl	200075a4 <LED_Init2>
    volatile uint32_t *GPIOC_ODR = (uint32_t *)(GPIOC_BASE + 0x14);
2000760e:	4b0b      	ldr	r3, [pc, #44]	@ (2000763c <ui_cmd_LED2+0x50>)
20007610:	617b      	str	r3, [r7, #20]
    *GPIOA_MODER |= (0x1 << PA5_MODER_BIT_POS);
    uint32_t modified_value = *GPIOA_MODER;
    printf("Modified GPIOA_MODER: 0x%08X\n", modified_value);
    */

    if (state == 1) {
20007612:	69bb      	ldr	r3, [r7, #24]
20007614:	2b01      	cmp	r3, #1
20007616:	d106      	bne.n	20007626 <ui_cmd_LED2+0x3a>
        *GPIOC_ODR |= (1 << 1);
20007618:	697b      	ldr	r3, [r7, #20]
2000761a:	681b      	ldr	r3, [r3, #0]
2000761c:	f043 0202 	orr.w	r2, r3, #2
20007620:	697b      	ldr	r3, [r7, #20]
20007622:	601a      	str	r2, [r3, #0]
20007624:	e005      	b.n	20007632 <ui_cmd_LED2+0x46>
    } else {
        *GPIOC_ODR &= ~(1 << 0);
20007626:	697b      	ldr	r3, [r7, #20]
20007628:	681b      	ldr	r3, [r3, #0]
2000762a:	f023 0201 	bic.w	r2, r3, #1
2000762e:	697b      	ldr	r3, [r7, #20]
20007630:	601a      	str	r2, [r3, #0]
    }

    return 0;
20007632:	2300      	movs	r3, #0
}
20007634:	4618      	mov	r0, r3
20007636:	3720      	adds	r7, #32
20007638:	46bd      	mov	sp, r7
2000763a:	bd80      	pop	{r7, pc}
2000763c:	48000814 	.word	0x48000814

Disassembly of section .init:

20007640 <_init>:
20007640:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
20007642:	bf00      	nop

Disassembly of section .fini:

20007644 <_fini>:
20007644:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
20007646:	bf00      	nop
